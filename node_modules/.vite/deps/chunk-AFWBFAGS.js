import {
  __esm
} from "./chunk-J43GMYXM.js";

// node_modules/ol/dist/ol.js
var ol_exports = {};
var ol;
var init_ol = __esm({
  "node_modules/ol/dist/ol.js"() {
    ol = function() {
      "use strict";
      const t = { 1: "The view center is not defined", 2: "The view resolution is not defined", 3: "The view rotation is not defined", 4: "`image` and `src` cannot be provided at the same time", 5: "`imgSize` must be set when `image` is provided", 7: "`format` must be set when `url` is set", 8: "Unknown `serverType` configured", 9: "`url` must be configured or set using `#setUrl()`", 10: "The default `geometryFunction` can only handle `Point` geometries", 11: "`options.featureTypes` must be an Array", 12: "`options.geometryName` must also be provided when `options.bbox` is set", 13: "Invalid corner", 14: "Invalid color", 15: "Tried to get a value for a key that does not exist in the cache", 16: "Tried to set a value for a key that is used already", 17: "`resolutions` must be sorted in descending order", 18: "Either `origin` or `origins` must be configured, never both", 19: "Number of `tileSizes` and `resolutions` must be equal", 20: "Number of `origins` and `resolutions` must be equal", 22: "Either `tileSize` or `tileSizes` must be configured, never both", 24: "Invalid extent or geometry provided as `geometry`", 25: "Cannot fit empty extent provided as `geometry`", 26: "Features must have an id set", 27: "Features must have an id set", 28: '`renderMode` must be `"hybrid"` or `"vector"`', 30: "The passed `feature` was already added to the source", 31: "Tried to enqueue an `element` that was already added to the queue", 32: "Transformation matrix cannot be inverted", 33: "Invalid units", 34: "Invalid geometry layout", 36: "Unknown SRS type", 37: "Unknown geometry type found", 38: "`styleMapValue` has an unknown type", 39: "Unknown geometry type", 40: "Expected `feature` to have a geometry", 41: "Expected an `ol/style/Style` or an array of `ol/style/Style.js`", 42: "Question unknown, the answer is 42", 43: "Expected `layers` to be an array or a `Collection`", 47: "Expected `controls` to be an array or an `ol/Collection`", 48: "Expected `interactions` to be an array or an `ol/Collection`", 49: "Expected `overlays` to be an array or an `ol/Collection`", 50: "`options.featureTypes` should be an Array", 51: "Either `url` or `tileJSON` options must be provided", 52: "Unknown `serverType` configured", 53: "Unknown `tierSizeCalculation` configured", 55: "The {-y} placeholder requires a tile grid with extent", 56: "mapBrowserEvent must originate from a pointer event", 57: "At least 2 conditions are required", 59: "Invalid command found in the PBF", 60: "Missing or invalid `size`", 61: "Cannot determine IIIF Image API version from provided image information JSON", 62: "A `WebGLArrayBuffer` must either be of type `ELEMENT_ARRAY_BUFFER` or `ARRAY_BUFFER`", 64: "Layer opacity must be a number", 66: "`forEachFeatureAtCoordinate` cannot be used on a WebGL layer if the hit detection logic has not been enabled. This is done by providing adequate shaders using the `hitVertexShader` and `hitFragmentShader` properties of `WebGLPointsLayerRenderer`", 67: "A layer can only be added to the map once. Use either `layer.setMap()` or `map.addLayer()`, not both", 68: "A VectorTile source can only be rendered if it has a projection compatible with the view projection" };
      class e extends Error {
        constructor(e2) {
          const i2 = t[e2];
          super(i2), this.code = e2, this.name = "AssertionError", this.message = i2;
        }
      }
      class i {
        constructor(t2) {
          this.propagationStopped, this.defaultPrevented, this.type = t2, this.target = null;
        }
        preventDefault() {
          this.defaultPrevented = true;
        }
        stopPropagation() {
          this.propagationStopped = true;
        }
      }
      function n(t2) {
        t2.stopPropagation();
      }
      var r = "propertychange";
      class s {
        constructor() {
          this.disposed = false;
        }
        dispose() {
          this.disposed || (this.disposed = true, this.disposeInternal());
        }
        disposeInternal() {
        }
      }
      function o(t2, e2, i2) {
        let n2, r2;
        i2 = i2 || a;
        let s2 = 0, o2 = t2.length, l2 = false;
        for (; s2 < o2; )
          n2 = s2 + (o2 - s2 >> 1), r2 = +i2(t2[n2], e2), r2 < 0 ? s2 = n2 + 1 : (o2 = n2, l2 = !r2);
        return l2 ? s2 : ~s2;
      }
      function a(t2, e2) {
        return t2 > e2 ? 1 : t2 < e2 ? -1 : 0;
      }
      function l(t2, e2, i2) {
        const n2 = t2.length;
        if (t2[0] <= e2)
          return 0;
        if (e2 <= t2[n2 - 1])
          return n2 - 1;
        {
          let r2;
          if (i2 > 0) {
            for (r2 = 1; r2 < n2; ++r2)
              if (t2[r2] < e2)
                return r2 - 1;
          } else if (i2 < 0) {
            for (r2 = 1; r2 < n2; ++r2)
              if (t2[r2] <= e2)
                return r2;
          } else
            for (r2 = 1; r2 < n2; ++r2) {
              if (t2[r2] == e2)
                return r2;
              if (t2[r2] < e2)
                return "function" == typeof i2 ? i2(e2, t2[r2 - 1], t2[r2]) > 0 ? r2 - 1 : r2 : t2[r2 - 1] - e2 < e2 - t2[r2] ? r2 - 1 : r2;
            }
          return n2 - 1;
        }
      }
      function h(t2, e2, i2) {
        for (; e2 < i2; ) {
          const n2 = t2[e2];
          t2[e2] = t2[i2], t2[i2] = n2, ++e2, --i2;
        }
      }
      function c(t2, e2) {
        const i2 = Array.isArray(e2) ? e2 : [e2], n2 = i2.length;
        for (let e3 = 0; e3 < n2; e3++)
          t2[t2.length] = i2[e3];
      }
      function u(t2, e2) {
        const i2 = t2.length;
        if (i2 !== e2.length)
          return false;
        for (let n2 = 0; n2 < i2; n2++)
          if (t2[n2] !== e2[n2])
            return false;
        return true;
      }
      function d(t2, e2, i2) {
        const n2 = e2 || a;
        return t2.every(function(e3, r2) {
          if (0 === r2)
            return true;
          const s2 = n2(t2[r2 - 1], e3);
          return !(s2 > 0 || i2 && 0 === s2);
        });
      }
      function g() {
        return true;
      }
      function f() {
        return false;
      }
      function p() {
      }
      function m(t2) {
        let e2, i2, n2, r2 = false;
        return function() {
          const s2 = Array.prototype.slice.call(arguments);
          return r2 && this === n2 && u(s2, i2) || (r2 = true, n2 = this, i2 = s2, e2 = t2.apply(this, arguments)), e2;
        };
      }
      function _(t2) {
        return function() {
          let e2;
          try {
            e2 = t2();
          } catch (t3) {
            return Promise.reject(t3);
          }
          return e2 instanceof Promise ? e2 : Promise.resolve(e2);
        }();
      }
      function y(t2) {
        for (const e2 in t2)
          delete t2[e2];
      }
      function x(t2) {
        let e2;
        for (e2 in t2)
          return false;
        return !e2;
      }
      class v extends s {
        constructor(t2) {
          super(), this.eventTarget_ = t2, this.pendingRemovals_ = null, this.dispatching_ = null, this.listeners_ = null;
        }
        addEventListener(t2, e2) {
          if (!t2 || !e2)
            return;
          const i2 = this.listeners_ || (this.listeners_ = {}), n2 = i2[t2] || (i2[t2] = []);
          n2.includes(e2) || n2.push(e2);
        }
        dispatchEvent(t2) {
          const e2 = "string" == typeof t2, n2 = e2 ? t2 : t2.type, r2 = this.listeners_ && this.listeners_[n2];
          if (!r2)
            return;
          const s2 = e2 ? new i(t2) : t2;
          s2.target || (s2.target = this.eventTarget_ || this);
          const o2 = this.dispatching_ || (this.dispatching_ = {}), a2 = this.pendingRemovals_ || (this.pendingRemovals_ = {});
          let l2;
          n2 in o2 || (o2[n2] = 0, a2[n2] = 0), ++o2[n2];
          for (let t3 = 0, e3 = r2.length; t3 < e3; ++t3)
            if (l2 = "handleEvent" in r2[t3] ? r2[t3].handleEvent(s2) : r2[t3].call(this, s2), false === l2 || s2.propagationStopped) {
              l2 = false;
              break;
            }
          if (0 == --o2[n2]) {
            let t3 = a2[n2];
            for (delete a2[n2]; t3--; )
              this.removeEventListener(n2, p);
            delete o2[n2];
          }
          return l2;
        }
        disposeInternal() {
          this.listeners_ && y(this.listeners_);
        }
        getListeners(t2) {
          return this.listeners_ && this.listeners_[t2] || void 0;
        }
        hasListener(t2) {
          return !!this.listeners_ && (t2 ? t2 in this.listeners_ : Object.keys(this.listeners_).length > 0);
        }
        removeEventListener(t2, e2) {
          const i2 = this.listeners_ && this.listeners_[t2];
          if (i2) {
            const n2 = i2.indexOf(e2);
            -1 !== n2 && (this.pendingRemovals_ && t2 in this.pendingRemovals_ ? (i2[n2] = p, ++this.pendingRemovals_[t2]) : (i2.splice(n2, 1), 0 === i2.length && delete this.listeners_[t2]));
          }
        }
      }
      var S = "change", w = "error", E = "contextmenu", T = "click", C = "dblclick", b = "dragenter", R = "dragover", P = "drop", I = "keydown", L = "keypress", M = "load", F = "resize", A = "touchmove", O = "wheel";
      function N(t2, e2, i2, n2, r2) {
        if (n2 && n2 !== t2 && (i2 = i2.bind(n2)), r2) {
          const n3 = i2;
          i2 = function() {
            t2.removeEventListener(e2, i2), n3.apply(this, arguments);
          };
        }
        const s2 = { target: t2, type: e2, listener: i2 };
        return t2.addEventListener(e2, i2), s2;
      }
      function D(t2, e2, i2, n2) {
        return N(t2, e2, i2, n2, true);
      }
      function k(t2) {
        t2 && t2.target && (t2.target.removeEventListener(t2.type, t2.listener), y(t2));
      }
      class G extends v {
        constructor() {
          super(), this.on = this.onInternal, this.once = this.onceInternal, this.un = this.unInternal, this.revision_ = 0;
        }
        changed() {
          ++this.revision_, this.dispatchEvent(S);
        }
        getRevision() {
          return this.revision_;
        }
        onInternal(t2, e2) {
          if (Array.isArray(t2)) {
            const i2 = t2.length, n2 = new Array(i2);
            for (let r2 = 0; r2 < i2; ++r2)
              n2[r2] = N(this, t2[r2], e2);
            return n2;
          }
          return N(this, t2, e2);
        }
        onceInternal(t2, e2) {
          let i2;
          if (Array.isArray(t2)) {
            const n2 = t2.length;
            i2 = new Array(n2);
            for (let r2 = 0; r2 < n2; ++r2)
              i2[r2] = D(this, t2[r2], e2);
          } else
            i2 = D(this, t2, e2);
          return e2.ol_key = i2, i2;
        }
        unInternal(t2, e2) {
          const i2 = e2.ol_key;
          if (i2)
            j(i2);
          else if (Array.isArray(t2))
            for (let i3 = 0, n2 = t2.length; i3 < n2; ++i3)
              this.removeEventListener(t2[i3], e2);
          else
            this.removeEventListener(t2, e2);
        }
      }
      function j(t2) {
        if (Array.isArray(t2))
          for (let e2 = 0, i2 = t2.length; e2 < i2; ++e2)
            k(t2[e2]);
        else
          k(t2);
      }
      function B() {
        throw new Error("Unimplemented abstract method.");
      }
      G.prototype.on, G.prototype.once, G.prototype.un;
      let U = 0;
      function z(t2) {
        return t2.ol_uid || (t2.ol_uid = String(++U));
      }
      class X extends i {
        constructor(t2, e2, i2) {
          super(t2), this.key = e2, this.oldValue = i2;
        }
      }
      class V extends G {
        constructor(t2) {
          super(), this.on, this.once, this.un, z(this), this.values_ = null, void 0 !== t2 && this.setProperties(t2);
        }
        get(t2) {
          let e2;
          return this.values_ && this.values_.hasOwnProperty(t2) && (e2 = this.values_[t2]), e2;
        }
        getKeys() {
          return this.values_ && Object.keys(this.values_) || [];
        }
        getProperties() {
          return this.values_ && Object.assign({}, this.values_) || {};
        }
        hasProperties() {
          return !!this.values_;
        }
        notify(t2, e2) {
          let i2;
          i2 = `change:${t2}`, this.hasListener(i2) && this.dispatchEvent(new X(i2, t2, e2)), i2 = r, this.hasListener(i2) && this.dispatchEvent(new X(i2, t2, e2));
        }
        addChangeListener(t2, e2) {
          this.addEventListener(`change:${t2}`, e2);
        }
        removeChangeListener(t2, e2) {
          this.removeEventListener(`change:${t2}`, e2);
        }
        set(t2, e2, i2) {
          const n2 = this.values_ || (this.values_ = {});
          if (i2)
            n2[t2] = e2;
          else {
            const i3 = n2[t2];
            n2[t2] = e2, i3 !== e2 && this.notify(t2, i3);
          }
        }
        setProperties(t2, e2) {
          for (const i2 in t2)
            this.set(i2, t2[i2], e2);
        }
        applyProperties(t2) {
          t2.values_ && Object.assign(this.values_ || (this.values_ = {}), t2.values_);
        }
        unset(t2, e2) {
          if (this.values_ && t2 in this.values_) {
            const i2 = this.values_[t2];
            delete this.values_[t2], x(this.values_) && (this.values_ = null), e2 || this.notify(t2, i2);
          }
        }
      }
      var W = "add", Z = "remove";
      const Y = "length";
      class K extends i {
        constructor(t2, e2, i2) {
          super(t2), this.element = e2, this.index = i2;
        }
      }
      class q extends V {
        constructor(t2, e2) {
          if (super(), this.on, this.once, this.un, e2 = e2 || {}, this.unique_ = !!e2.unique, this.array_ = t2 || [], this.unique_)
            for (let t3 = 0, e3 = this.array_.length; t3 < e3; ++t3)
              this.assertUnique_(this.array_[t3], t3);
          this.updateLength_();
        }
        clear() {
          for (; this.getLength() > 0; )
            this.pop();
        }
        extend(t2) {
          for (let e2 = 0, i2 = t2.length; e2 < i2; ++e2)
            this.push(t2[e2]);
          return this;
        }
        forEach(t2) {
          const e2 = this.array_;
          for (let i2 = 0, n2 = e2.length; i2 < n2; ++i2)
            t2(e2[i2], i2, e2);
        }
        getArray() {
          return this.array_;
        }
        item(t2) {
          return this.array_[t2];
        }
        getLength() {
          return this.get(Y);
        }
        insertAt(t2, e2) {
          if (t2 < 0 || t2 > this.getLength())
            throw new Error("Index out of bounds: " + t2);
          this.unique_ && this.assertUnique_(e2), this.array_.splice(t2, 0, e2), this.updateLength_(), this.dispatchEvent(new K(W, e2, t2));
        }
        pop() {
          return this.removeAt(this.getLength() - 1);
        }
        push(t2) {
          this.unique_ && this.assertUnique_(t2);
          const e2 = this.getLength();
          return this.insertAt(e2, t2), this.getLength();
        }
        remove(t2) {
          const e2 = this.array_;
          for (let i2 = 0, n2 = e2.length; i2 < n2; ++i2)
            if (e2[i2] === t2)
              return this.removeAt(i2);
        }
        removeAt(t2) {
          if (t2 < 0 || t2 >= this.getLength())
            return;
          const e2 = this.array_[t2];
          return this.array_.splice(t2, 1), this.updateLength_(), this.dispatchEvent(new K(Z, e2, t2)), e2;
        }
        setAt(t2, e2) {
          if (t2 >= this.getLength())
            return void this.insertAt(t2, e2);
          if (t2 < 0)
            throw new Error("Index out of bounds: " + t2);
          this.unique_ && this.assertUnique_(e2, t2);
          const i2 = this.array_[t2];
          this.array_[t2] = e2, this.dispatchEvent(new K(Z, i2, t2)), this.dispatchEvent(new K(W, e2, t2));
        }
        updateLength_() {
          this.set(Y, this.array_.length);
        }
        assertUnique_(t2, i2) {
          for (let n2 = 0, r2 = this.array_.length; n2 < r2; ++n2)
            if (this.array_[n2] === t2 && n2 !== i2)
              throw new e(58);
        }
      }
      var H = 0, $ = 1, J = 2, Q = 3, tt = 4;
      function et(t2) {
        return Math.pow(t2, 3);
      }
      function it(t2) {
        return 1 - et(1 - t2);
      }
      function nt(t2) {
        return 3 * t2 * t2 - 2 * t2 * t2 * t2;
      }
      function rt(t2) {
        return t2;
      }
      class st extends v {
        constructor(t2, e2, i2) {
          super(), i2 = i2 || {}, this.tileCoord = t2, this.state = e2, this.interimTile = null, this.key = "", this.transition_ = void 0 === i2.transition ? 250 : i2.transition, this.transitionStarts_ = {}, this.interpolate = !!i2.interpolate;
        }
        changed() {
          this.dispatchEvent(S);
        }
        release() {
          this.state === Q && this.setState(tt);
        }
        getKey() {
          return this.key + "/" + this.tileCoord;
        }
        getInterimTile() {
          if (!this.interimTile)
            return this;
          let t2 = this.interimTile;
          do {
            if (t2.getState() == J)
              return this.transition_ = 0, t2;
            t2 = t2.interimTile;
          } while (t2);
          return this;
        }
        refreshInterimChain() {
          if (!this.interimTile)
            return;
          let t2 = this.interimTile, e2 = this;
          do {
            if (t2.getState() == J) {
              t2.interimTile = null;
              break;
            }
            t2.getState() == $ ? e2 = t2 : t2.getState() == H ? e2.interimTile = t2.interimTile : e2 = t2, t2 = e2.interimTile;
          } while (t2);
        }
        getTileCoord() {
          return this.tileCoord;
        }
        getState() {
          return this.state;
        }
        setState(t2) {
          if (this.state !== Q && this.state > t2)
            throw new Error("Tile load sequence violation");
          this.state = t2, this.changed();
        }
        load() {
          B();
        }
        getAlpha(t2, e2) {
          if (!this.transition_)
            return 1;
          let i2 = this.transitionStarts_[t2];
          if (i2) {
            if (-1 === i2)
              return 1;
          } else
            i2 = e2, this.transitionStarts_[t2] = i2;
          const n2 = e2 - i2 + 1e3 / 60;
          return n2 >= this.transition_ ? 1 : et(n2 / this.transition_);
        }
        inTransition(t2) {
          return !!this.transition_ && -1 !== this.transitionStarts_[t2];
        }
        endTransition(t2) {
          this.transition_ && (this.transitionStarts_[t2] = -1);
        }
      }
      class ot extends st {
        constructor(t2) {
          const e2 = H;
          super(t2.tileCoord, e2, { transition: t2.transition, interpolate: t2.interpolate }), this.loader_ = t2.loader, this.data_ = null, this.error_ = null, this.size_ = t2.size || [256, 256];
        }
        getSize() {
          return this.size_;
        }
        getData() {
          return this.data_;
        }
        getError() {
          return this.error_;
        }
        load() {
          if (this.state !== H && this.state !== Q)
            return;
          this.state = $, this.changed();
          const t2 = this;
          this.loader_().then(function(e2) {
            t2.data_ = e2, t2.state = J, t2.changed();
          }).catch(function(e2) {
            t2.error_ = e2, t2.state = Q, t2.changed();
          });
        }
      }
      function at(t2, i2) {
        if (!t2)
          throw new e(i2);
      }
      class lt extends V {
        constructor(t2) {
          if (super(), this.on, this.once, this.un, this.id_ = void 0, this.geometryName_ = "geometry", this.style_ = null, this.styleFunction_ = void 0, this.geometryChangeKey_ = null, this.addChangeListener(this.geometryName_, this.handleGeometryChanged_), t2)
            if ("function" == typeof t2.getSimplifiedGeometry) {
              const e2 = t2;
              this.setGeometry(e2);
            } else {
              const e2 = t2;
              this.setProperties(e2);
            }
        }
        clone() {
          const t2 = new lt(this.hasProperties() ? this.getProperties() : null);
          t2.setGeometryName(this.getGeometryName());
          const e2 = this.getGeometry();
          e2 && t2.setGeometry(e2.clone());
          const i2 = this.getStyle();
          return i2 && t2.setStyle(i2), t2;
        }
        getGeometry() {
          return this.get(this.geometryName_);
        }
        getId() {
          return this.id_;
        }
        getGeometryName() {
          return this.geometryName_;
        }
        getStyle() {
          return this.style_;
        }
        getStyleFunction() {
          return this.styleFunction_;
        }
        handleGeometryChange_() {
          this.changed();
        }
        handleGeometryChanged_() {
          this.geometryChangeKey_ && (k(this.geometryChangeKey_), this.geometryChangeKey_ = null);
          const t2 = this.getGeometry();
          t2 && (this.geometryChangeKey_ = N(t2, S, this.handleGeometryChange_, this)), this.changed();
        }
        setGeometry(t2) {
          this.set(this.geometryName_, t2);
        }
        setStyle(t2) {
          this.style_ = t2, this.styleFunction_ = t2 ? ht(t2) : void 0, this.changed();
        }
        setId(t2) {
          this.id_ = t2, this.changed();
        }
        setGeometryName(t2) {
          this.removeChangeListener(this.geometryName_, this.handleGeometryChanged_), this.geometryName_ = t2, this.addChangeListener(this.geometryName_, this.handleGeometryChanged_), this.handleGeometryChanged_();
        }
      }
      function ht(t2) {
        if ("function" == typeof t2)
          return t2;
        {
          let e2;
          if (Array.isArray(t2))
            e2 = t2;
          else {
            at("function" == typeof t2.getZIndex, 41);
            e2 = [t2];
          }
          return function() {
            return e2;
          };
        }
      }
      const ct = "undefined" != typeof navigator && void 0 !== navigator.userAgent ? navigator.userAgent.toLowerCase() : "", ut = ct.includes("firefox"), dt = ct.includes("safari") && !ct.includes("chrom"), gt = dt && (ct.includes("version/15.4") || /cpu (os|iphone os) 15_4 like mac os x/.test(ct)), ft = ct.includes("webkit") && !ct.includes("edge"), pt = ct.includes("macintosh"), mt = "undefined" != typeof devicePixelRatio ? devicePixelRatio : 1, _t = "undefined" != typeof WorkerGlobalScope && "undefined" != typeof OffscreenCanvas && self instanceof WorkerGlobalScope, yt = "undefined" != typeof Image && Image.prototype.decode, xt = function() {
        let t2 = false;
        try {
          const e2 = Object.defineProperty({}, "passive", { get: function() {
            t2 = true;
          } });
          window.addEventListener("_", null, e2), window.removeEventListener("_", null, e2);
        } catch (t3) {
        }
        return t2;
      }(), vt = new Array(6);
      function St() {
        return [1, 0, 0, 1, 0, 0];
      }
      function wt(t2) {
        return Tt(t2, 1, 0, 0, 1, 0, 0);
      }
      function Et(t2, e2) {
        const i2 = t2[0], n2 = t2[1], r2 = t2[2], s2 = t2[3], o2 = t2[4], a2 = t2[5], l2 = e2[0], h2 = e2[1], c2 = e2[2], u2 = e2[3], d2 = e2[4], g2 = e2[5];
        return t2[0] = i2 * l2 + r2 * h2, t2[1] = n2 * l2 + s2 * h2, t2[2] = i2 * c2 + r2 * u2, t2[3] = n2 * c2 + s2 * u2, t2[4] = i2 * d2 + r2 * g2 + o2, t2[5] = n2 * d2 + s2 * g2 + a2, t2;
      }
      function Tt(t2, e2, i2, n2, r2, s2, o2) {
        return t2[0] = e2, t2[1] = i2, t2[2] = n2, t2[3] = r2, t2[4] = s2, t2[5] = o2, t2;
      }
      function Ct(t2, e2) {
        return t2[0] = e2[0], t2[1] = e2[1], t2[2] = e2[2], t2[3] = e2[3], t2[4] = e2[4], t2[5] = e2[5], t2;
      }
      function bt(t2, e2) {
        const i2 = e2[0], n2 = e2[1];
        return e2[0] = t2[0] * i2 + t2[2] * n2 + t2[4], e2[1] = t2[1] * i2 + t2[3] * n2 + t2[5], e2;
      }
      function Rt(t2, e2) {
        const i2 = Math.cos(e2), n2 = Math.sin(e2);
        return Et(t2, Tt(vt, i2, n2, -n2, i2, 0, 0));
      }
      function Pt(t2, e2, i2) {
        return Et(t2, Tt(vt, e2, 0, 0, i2, 0, 0));
      }
      function It(t2, e2, i2) {
        return Tt(t2, e2, 0, 0, i2, 0, 0);
      }
      function Lt(t2, e2, i2) {
        return Et(t2, Tt(vt, 1, 0, 0, 1, e2, i2));
      }
      function Mt(t2, e2, i2, n2, r2, s2, o2, a2) {
        const l2 = Math.sin(s2), h2 = Math.cos(s2);
        return t2[0] = n2 * h2, t2[1] = r2 * l2, t2[2] = -n2 * l2, t2[3] = r2 * h2, t2[4] = o2 * n2 * h2 - a2 * n2 * l2 + e2, t2[5] = o2 * r2 * l2 + a2 * r2 * h2 + i2, t2;
      }
      function Ft(t2, e2) {
        const i2 = At(e2);
        at(0 !== i2, 32);
        const n2 = e2[0], r2 = e2[1], s2 = e2[2], o2 = e2[3], a2 = e2[4], l2 = e2[5];
        return t2[0] = o2 / i2, t2[1] = -r2 / i2, t2[2] = -s2 / i2, t2[3] = n2 / i2, t2[4] = (s2 * l2 - o2 * a2) / i2, t2[5] = -(n2 * l2 - r2 * a2) / i2, t2;
      }
      function At(t2) {
        return t2[0] * t2[3] - t2[1] * t2[2];
      }
      let Ot;
      function Nt(t2) {
        const e2 = "matrix(" + t2.join(", ") + ")";
        if (_t)
          return e2;
        const i2 = Ot || (Ot = document.createElement("div"));
        return i2.style.transform = e2, i2.style.transform;
      }
      var Dt = 0, kt = 1, Gt = 2, jt = 4, Bt = 8, Ut = 16;
      function zt(t2) {
        const e2 = Ht();
        for (let i2 = 0, n2 = t2.length; i2 < n2; ++i2)
          re(e2, t2[i2]);
        return e2;
      }
      function Xt(t2, e2, i2) {
        return i2 ? (i2[0] = t2[0] - e2, i2[1] = t2[1] - e2, i2[2] = t2[2] + e2, i2[3] = t2[3] + e2, i2) : [t2[0] - e2, t2[1] - e2, t2[2] + e2, t2[3] + e2];
      }
      function Vt(t2, e2) {
        return e2 ? (e2[0] = t2[0], e2[1] = t2[1], e2[2] = t2[2], e2[3] = t2[3], e2) : t2.slice();
      }
      function Wt(t2, e2, i2) {
        let n2, r2;
        return n2 = e2 < t2[0] ? t2[0] - e2 : t2[2] < e2 ? e2 - t2[2] : 0, r2 = i2 < t2[1] ? t2[1] - i2 : t2[3] < i2 ? i2 - t2[3] : 0, n2 * n2 + r2 * r2;
      }
      function Zt(t2, e2) {
        return Kt(t2, e2[0], e2[1]);
      }
      function Yt(t2, e2) {
        return t2[0] <= e2[0] && e2[2] <= t2[2] && t2[1] <= e2[1] && e2[3] <= t2[3];
      }
      function Kt(t2, e2, i2) {
        return t2[0] <= e2 && e2 <= t2[2] && t2[1] <= i2 && i2 <= t2[3];
      }
      function qt(t2, e2) {
        const i2 = t2[0], n2 = t2[1], r2 = t2[2], s2 = t2[3], o2 = e2[0], a2 = e2[1];
        let l2 = Dt;
        return o2 < i2 ? l2 |= Ut : o2 > r2 && (l2 |= jt), a2 < n2 ? l2 |= Bt : a2 > s2 && (l2 |= Gt), l2 === Dt && (l2 = kt), l2;
      }
      function Ht() {
        return [1 / 0, 1 / 0, -1 / 0, -1 / 0];
      }
      function $t(t2, e2, i2, n2, r2) {
        return r2 ? (r2[0] = t2, r2[1] = e2, r2[2] = i2, r2[3] = n2, r2) : [t2, e2, i2, n2];
      }
      function Jt(t2) {
        return $t(1 / 0, 1 / 0, -1 / 0, -1 / 0, t2);
      }
      function Qt(t2, e2) {
        const i2 = t2[0], n2 = t2[1];
        return $t(i2, n2, i2, n2, e2);
      }
      function te(t2, e2, i2, n2, r2) {
        return oe(Jt(r2), t2, e2, i2, n2);
      }
      function ee(t2, e2) {
        return t2[0] == e2[0] && t2[2] == e2[2] && t2[1] == e2[1] && t2[3] == e2[3];
      }
      function ie(t2, e2, i2) {
        return Math.abs(t2[0] - e2[0]) < i2 && Math.abs(t2[2] - e2[2]) < i2 && Math.abs(t2[1] - e2[1]) < i2 && Math.abs(t2[3] - e2[3]) < i2;
      }
      function ne(t2, e2) {
        return e2[0] < t2[0] && (t2[0] = e2[0]), e2[2] > t2[2] && (t2[2] = e2[2]), e2[1] < t2[1] && (t2[1] = e2[1]), e2[3] > t2[3] && (t2[3] = e2[3]), t2;
      }
      function re(t2, e2) {
        e2[0] < t2[0] && (t2[0] = e2[0]), e2[0] > t2[2] && (t2[2] = e2[0]), e2[1] < t2[1] && (t2[1] = e2[1]), e2[1] > t2[3] && (t2[3] = e2[1]);
      }
      function se(t2, e2) {
        for (let i2 = 0, n2 = e2.length; i2 < n2; ++i2)
          re(t2, e2[i2]);
        return t2;
      }
      function oe(t2, e2, i2, n2, r2) {
        for (; i2 < n2; i2 += r2)
          le(t2, e2[i2], e2[i2 + 1]);
        return t2;
      }
      function ae(t2, e2) {
        for (let i2 = 0, n2 = e2.length; i2 < n2; ++i2)
          se(t2, e2[i2]);
        return t2;
      }
      function le(t2, e2, i2) {
        t2[0] = Math.min(t2[0], e2), t2[1] = Math.min(t2[1], i2), t2[2] = Math.max(t2[2], e2), t2[3] = Math.max(t2[3], i2);
      }
      function he(t2, e2) {
        let i2;
        return i2 = e2(ue(t2)), i2 || (i2 = e2(de(t2)), i2 || (i2 = e2(ve(t2)), i2 || (i2 = e2(xe(t2)), i2 || false)));
      }
      function ce(t2) {
        let e2 = 0;
        return Ee(t2) || (e2 = Se(t2) * _e(t2)), e2;
      }
      function ue(t2) {
        return [t2[0], t2[1]];
      }
      function de(t2) {
        return [t2[2], t2[1]];
      }
      function ge(t2) {
        return [(t2[0] + t2[2]) / 2, (t2[1] + t2[3]) / 2];
      }
      function fe(t2, e2) {
        let i2;
        return "bottom-left" === e2 ? i2 = ue(t2) : "bottom-right" === e2 ? i2 = de(t2) : "top-left" === e2 ? i2 = xe(t2) : "top-right" === e2 ? i2 = ve(t2) : at(false, 13), i2;
      }
      function pe(t2, e2, i2, n2, r2) {
        const [s2, o2, a2, l2, h2, c2, u2, d2] = me(t2, e2, i2, n2);
        return $t(Math.min(s2, a2, h2, u2), Math.min(o2, l2, c2, d2), Math.max(s2, a2, h2, u2), Math.max(o2, l2, c2, d2), r2);
      }
      function me(t2, e2, i2, n2) {
        const r2 = e2 * n2[0] / 2, s2 = e2 * n2[1] / 2, o2 = Math.cos(i2), a2 = Math.sin(i2), l2 = r2 * o2, h2 = r2 * a2, c2 = s2 * o2, u2 = s2 * a2, d2 = t2[0], g2 = t2[1];
        return [d2 - l2 + u2, g2 - h2 - c2, d2 - l2 - u2, g2 - h2 + c2, d2 + l2 - u2, g2 + h2 + c2, d2 + l2 + u2, g2 + h2 - c2, d2 - l2 + u2, g2 - h2 - c2];
      }
      function _e(t2) {
        return t2[3] - t2[1];
      }
      function ye(t2, e2, i2) {
        const n2 = i2 || [1 / 0, 1 / 0, -1 / 0, -1 / 0];
        return we(t2, e2) ? (t2[0] > e2[0] ? n2[0] = t2[0] : n2[0] = e2[0], t2[1] > e2[1] ? n2[1] = t2[1] : n2[1] = e2[1], t2[2] < e2[2] ? n2[2] = t2[2] : n2[2] = e2[2], t2[3] < e2[3] ? n2[3] = t2[3] : n2[3] = e2[3]) : Jt(n2), n2;
      }
      function xe(t2) {
        return [t2[0], t2[3]];
      }
      function ve(t2) {
        return [t2[2], t2[3]];
      }
      function Se(t2) {
        return t2[2] - t2[0];
      }
      function we(t2, e2) {
        return t2[0] <= e2[2] && t2[2] >= e2[0] && t2[1] <= e2[3] && t2[3] >= e2[1];
      }
      function Ee(t2) {
        return t2[2] < t2[0] || t2[3] < t2[1];
      }
      function Te(t2, e2) {
        return e2 ? (e2[0] = t2[0], e2[1] = t2[1], e2[2] = t2[2], e2[3] = t2[3], e2) : t2;
      }
      function Ce(t2, e2) {
        const i2 = (t2[2] - t2[0]) / 2 * (e2 - 1), n2 = (t2[3] - t2[1]) / 2 * (e2 - 1);
        t2[0] -= i2, t2[2] += i2, t2[1] -= n2, t2[3] += n2;
      }
      function be(t2, e2, i2) {
        let n2 = false;
        const r2 = qt(t2, e2), s2 = qt(t2, i2);
        if (r2 === kt || s2 === kt)
          n2 = true;
        else {
          const o2 = t2[0], a2 = t2[1], l2 = t2[2], h2 = t2[3], c2 = e2[0], u2 = e2[1], d2 = i2[0], g2 = i2[1], f2 = (g2 - u2) / (d2 - c2);
          let p2, m2;
          s2 & Gt && !(r2 & Gt) && (p2 = d2 - (g2 - h2) / f2, n2 = p2 >= o2 && p2 <= l2), n2 || !(s2 & jt) || r2 & jt || (m2 = g2 - (d2 - l2) * f2, n2 = m2 >= a2 && m2 <= h2), n2 || !(s2 & Bt) || r2 & Bt || (p2 = d2 - (g2 - a2) / f2, n2 = p2 >= o2 && p2 <= l2), n2 || !(s2 & Ut) || r2 & Ut || (m2 = g2 - (d2 - o2) * f2, n2 = m2 >= a2 && m2 <= h2);
        }
        return n2;
      }
      function Re(t2, e2, i2, n2) {
        let r2 = [];
        if (n2 > 1) {
          const e3 = t2[2] - t2[0], i3 = t2[3] - t2[1];
          for (let s3 = 0; s3 < n2; ++s3)
            r2.push(t2[0] + e3 * s3 / n2, t2[1], t2[2], t2[1] + i3 * s3 / n2, t2[2] - e3 * s3 / n2, t2[3], t2[0], t2[3] - i3 * s3 / n2);
        } else
          r2 = [t2[0], t2[1], t2[2], t2[1], t2[2], t2[3], t2[0], t2[3]];
        e2(r2, r2, 2);
        const s2 = [], o2 = [];
        for (let t3 = 0, e3 = r2.length; t3 < e3; t3 += 2)
          s2.push(r2[t3]), o2.push(r2[t3 + 1]);
        return function(t3, e3, i3) {
          return $t(Math.min.apply(null, t3), Math.min.apply(null, e3), Math.max.apply(null, t3), Math.max.apply(null, e3), i3);
        }(s2, o2, i2);
      }
      function Pe(t2, e2) {
        const i2 = e2.getExtent(), n2 = ge(t2);
        if (e2.canWrapX() && (n2[0] < i2[0] || n2[0] >= i2[2])) {
          const e3 = Se(i2), r2 = Math.floor((n2[0] - i2[0]) / e3) * e3;
          t2[0] -= r2, t2[2] -= r2;
        }
        return t2;
      }
      function Ie(t2, e2) {
        if (e2.canWrapX()) {
          const i2 = e2.getExtent();
          if (!isFinite(t2[0]) || !isFinite(t2[2]))
            return [[i2[0], t2[1], i2[2], t2[3]]];
          Pe(t2, e2);
          const n2 = Se(i2);
          if (Se(t2) > n2)
            return [[i2[0], t2[1], i2[2], t2[3]]];
          if (t2[0] < i2[0])
            return [[t2[0] + n2, t2[1], i2[2], t2[3]], [i2[0], t2[1], t2[2], t2[3]]];
          if (t2[2] > i2[2])
            return [[t2[0], t2[1], i2[2], t2[3]], [i2[0], t2[1], t2[2] - n2, t2[3]]];
        }
        return [t2];
      }
      const Le = { 9001: "m", 9002: "ft", 9003: "us-ft", 9101: "radians", 9102: "degrees" };
      function Me(t2) {
        return Le[t2];
      }
      const Fe = { radians: 6370997 / (2 * Math.PI), degrees: 2 * Math.PI * 6370997 / 360, ft: 0.3048, m: 1, "us-ft": 1200 / 3937 };
      class Ae {
        constructor(t2) {
          this.code_ = t2.code, this.units_ = t2.units, this.extent_ = void 0 !== t2.extent ? t2.extent : null, this.worldExtent_ = void 0 !== t2.worldExtent ? t2.worldExtent : null, this.axisOrientation_ = void 0 !== t2.axisOrientation ? t2.axisOrientation : "enu", this.global_ = void 0 !== t2.global && t2.global, this.canWrapX_ = !(!this.global_ || !this.extent_), this.getPointResolutionFunc_ = t2.getPointResolution, this.defaultTileGrid_ = null, this.metersPerUnit_ = t2.metersPerUnit;
        }
        canWrapX() {
          return this.canWrapX_;
        }
        getCode() {
          return this.code_;
        }
        getExtent() {
          return this.extent_;
        }
        getUnits() {
          return this.units_;
        }
        getMetersPerUnit() {
          return this.metersPerUnit_ || Fe[this.units_];
        }
        getWorldExtent() {
          return this.worldExtent_;
        }
        getAxisOrientation() {
          return this.axisOrientation_;
        }
        isGlobal() {
          return this.global_;
        }
        setGlobal(t2) {
          this.global_ = t2, this.canWrapX_ = !(!t2 || !this.extent_);
        }
        getDefaultTileGrid() {
          return this.defaultTileGrid_;
        }
        setDefaultTileGrid(t2) {
          this.defaultTileGrid_ = t2;
        }
        setExtent(t2) {
          this.extent_ = t2, this.canWrapX_ = !(!this.global_ || !t2);
        }
        setWorldExtent(t2) {
          this.worldExtent_ = t2;
        }
        setGetPointResolution(t2) {
          this.getPointResolutionFunc_ = t2;
        }
        getPointResolutionFunc() {
          return this.getPointResolutionFunc_;
        }
      }
      const Oe = 6378137, Ne = Math.PI * Oe, De = [-Ne, -Ne, Ne, Ne], ke = [-180, -85, 180, 85], Ge = Oe * Math.log(Math.tan(Math.PI / 2));
      class je extends Ae {
        constructor(t2) {
          super({ code: t2, units: "m", extent: De, global: true, worldExtent: ke, getPointResolution: function(t3, e2) {
            return t3 / Math.cosh(e2[1] / Oe);
          } });
        }
      }
      const Be = [new je("EPSG:3857"), new je("EPSG:102100"), new je("EPSG:102113"), new je("EPSG:900913"), new je("http://www.opengis.net/def/crs/EPSG/0/3857"), new je("http://www.opengis.net/gml/srs/epsg.xml#3857")];
      function Ue(t2, e2, i2) {
        const n2 = t2.length;
        i2 = i2 > 1 ? i2 : 2, void 0 === e2 && (e2 = i2 > 2 ? t2.slice() : new Array(n2));
        for (let r2 = 0; r2 < n2; r2 += i2) {
          e2[r2] = Ne * t2[r2] / 180;
          let i3 = Oe * Math.log(Math.tan(Math.PI * (+t2[r2 + 1] + 90) / 360));
          i3 > Ge ? i3 = Ge : i3 < -Ge && (i3 = -Ge), e2[r2 + 1] = i3;
        }
        return e2;
      }
      function ze(t2, e2, i2) {
        const n2 = t2.length;
        i2 = i2 > 1 ? i2 : 2, void 0 === e2 && (e2 = i2 > 2 ? t2.slice() : new Array(n2));
        for (let r2 = 0; r2 < n2; r2 += i2)
          e2[r2] = 180 * t2[r2] / Ne, e2[r2 + 1] = 360 * Math.atan(Math.exp(t2[r2 + 1] / Oe)) / Math.PI - 90;
        return e2;
      }
      const Xe = 6378137, Ve = [-180, -90, 180, 90], We = Math.PI * Xe / 180;
      class Ze extends Ae {
        constructor(t2, e2) {
          super({ code: t2, units: "degrees", extent: Ve, axisOrientation: e2, global: true, metersPerUnit: We, worldExtent: Ve });
        }
      }
      const Ye = [new Ze("CRS:84"), new Ze("EPSG:4326", "neu"), new Ze("urn:ogc:def:crs:OGC:1.3:CRS84"), new Ze("urn:ogc:def:crs:OGC:2:84"), new Ze("http://www.opengis.net/def/crs/OGC/1.3/CRS84"), new Ze("http://www.opengis.net/gml/srs/epsg.xml#4326", "neu"), new Ze("http://www.opengis.net/def/crs/EPSG/0/4326", "neu")];
      let Ke = {};
      function qe() {
        Ke = {};
      }
      function He(t2) {
        return Ke[t2] || Ke[t2.replace(/urn:(x-)?ogc:def:crs:EPSG:(.*:)?(\w+)$/, "EPSG:$3")] || null;
      }
      function $e(t2, e2) {
        Ke[t2] = e2;
      }
      let Je = {};
      function Qe() {
        Je = {};
      }
      function ti(t2, e2, i2) {
        const n2 = t2.getCode(), r2 = e2.getCode();
        n2 in Je || (Je[n2] = {}), Je[n2][r2] = i2;
      }
      function ei(t2, e2) {
        let i2;
        return t2 in Je && e2 in Je[t2] && (i2 = Je[t2][e2]), i2;
      }
      function ii(t2, e2, i2) {
        return Math.min(Math.max(t2, e2), i2);
      }
      function ni(t2, e2, i2, n2, r2, s2) {
        const o2 = r2 - i2, a2 = s2 - n2;
        if (0 !== o2 || 0 !== a2) {
          const l2 = ((t2 - i2) * o2 + (e2 - n2) * a2) / (o2 * o2 + a2 * a2);
          l2 > 1 ? (i2 = r2, n2 = s2) : l2 > 0 && (i2 += o2 * l2, n2 += a2 * l2);
        }
        return ri(t2, e2, i2, n2);
      }
      function ri(t2, e2, i2, n2) {
        const r2 = i2 - t2, s2 = n2 - e2;
        return r2 * r2 + s2 * s2;
      }
      function si(t2) {
        const e2 = t2.length;
        for (let i3 = 0; i3 < e2; i3++) {
          let n2 = i3, r2 = Math.abs(t2[i3][i3]);
          for (let s3 = i3 + 1; s3 < e2; s3++) {
            const e3 = Math.abs(t2[s3][i3]);
            e3 > r2 && (r2 = e3, n2 = s3);
          }
          if (0 === r2)
            return null;
          const s2 = t2[n2];
          t2[n2] = t2[i3], t2[i3] = s2;
          for (let n3 = i3 + 1; n3 < e2; n3++) {
            const r3 = -t2[n3][i3] / t2[i3][i3];
            for (let s3 = i3; s3 < e2 + 1; s3++)
              i3 == s3 ? t2[n3][s3] = 0 : t2[n3][s3] += r3 * t2[i3][s3];
          }
        }
        const i2 = new Array(e2);
        for (let n2 = e2 - 1; n2 >= 0; n2--) {
          i2[n2] = t2[n2][e2] / t2[n2][n2];
          for (let r2 = n2 - 1; r2 >= 0; r2--)
            t2[r2][e2] -= t2[r2][n2] * i2[n2];
        }
        return i2;
      }
      function oi(t2) {
        return 180 * t2 / Math.PI;
      }
      function ai(t2) {
        return t2 * Math.PI / 180;
      }
      function li(t2, e2) {
        const i2 = t2 % e2;
        return i2 * e2 < 0 ? i2 + e2 : i2;
      }
      function hi(t2, e2, i2) {
        return t2 + i2 * (e2 - t2);
      }
      function ci(t2, e2) {
        const i2 = Math.pow(10, e2);
        return Math.round(t2 * i2) / i2;
      }
      function ui(t2, e2) {
        return Math.round(ci(t2, e2));
      }
      function di(t2, e2) {
        return Math.floor(ci(t2, e2));
      }
      function gi(t2, e2) {
        return Math.ceil(ci(t2, e2));
      }
      function fi(t2, e2, i2) {
        const n2 = void 0 !== i2 ? t2.toFixed(i2) : "" + t2;
        let r2 = n2.indexOf(".");
        return r2 = -1 === r2 ? n2.length : r2, r2 > e2 ? n2 : new Array(1 + e2 - r2).join("0") + n2;
      }
      function pi(t2, e2) {
        const i2 = ("" + t2).split("."), n2 = ("" + e2).split(".");
        for (let t3 = 0; t3 < Math.max(i2.length, n2.length); t3++) {
          const e3 = parseInt(i2[t3] || "0", 10), r2 = parseInt(n2[t3] || "0", 10);
          if (e3 > r2)
            return 1;
          if (r2 > e3)
            return -1;
        }
        return 0;
      }
      function mi(t2, e2) {
        return t2[0] += +e2[0], t2[1] += +e2[1], t2;
      }
      function _i(t2, e2) {
        const i2 = e2.getRadius(), n2 = e2.getCenter(), r2 = n2[0], s2 = n2[1];
        let o2 = t2[0] - r2;
        const a2 = t2[1] - s2;
        0 === o2 && 0 === a2 && (o2 = 1);
        const l2 = Math.sqrt(o2 * o2 + a2 * a2);
        return [r2 + i2 * o2 / l2, s2 + i2 * a2 / l2];
      }
      function yi(t2, e2) {
        const i2 = t2[0], n2 = t2[1], r2 = e2[0], s2 = e2[1], o2 = r2[0], a2 = r2[1], l2 = s2[0], h2 = s2[1], c2 = l2 - o2, u2 = h2 - a2, d2 = 0 === c2 && 0 === u2 ? 0 : (c2 * (i2 - o2) + u2 * (n2 - a2)) / (c2 * c2 + u2 * u2 || 0);
        let g2, f2;
        return d2 <= 0 ? (g2 = o2, f2 = a2) : d2 >= 1 ? (g2 = l2, f2 = h2) : (g2 = o2 + d2 * c2, f2 = a2 + d2 * u2), [g2, f2];
      }
      function xi(t2, e2, i2) {
        const n2 = li(e2 + 180, 360) - 180, r2 = Math.abs(3600 * n2), s2 = i2 || 0;
        let o2 = Math.floor(r2 / 3600), a2 = Math.floor((r2 - 3600 * o2) / 60), l2 = ci(r2 - 3600 * o2 - 60 * a2, s2);
        l2 >= 60 && (l2 = 0, a2 += 1), a2 >= 60 && (a2 = 0, o2 += 1);
        let h2 = o2 + "\xB0";
        return 0 === a2 && 0 === l2 || (h2 += " " + fi(a2, 2) + "\u2032"), 0 !== l2 && (h2 += " " + fi(l2, 2, s2) + "\u2033"), 0 !== n2 && (h2 += " " + t2.charAt(n2 < 0 ? 1 : 0)), h2;
      }
      function vi(t2, e2, i2) {
        return t2 ? e2.replace("{x}", t2[0].toFixed(i2)).replace("{y}", t2[1].toFixed(i2)) : "";
      }
      function Si(t2, e2) {
        let i2 = true;
        for (let n2 = t2.length - 1; n2 >= 0; --n2)
          if (t2[n2] != e2[n2]) {
            i2 = false;
            break;
          }
        return i2;
      }
      function wi(t2, e2) {
        const i2 = Math.cos(e2), n2 = Math.sin(e2), r2 = t2[0] * i2 - t2[1] * n2, s2 = t2[1] * i2 + t2[0] * n2;
        return t2[0] = r2, t2[1] = s2, t2;
      }
      function Ei(t2, e2) {
        return t2[0] *= e2, t2[1] *= e2, t2;
      }
      function Ti(t2, e2) {
        const i2 = t2[0] - e2[0], n2 = t2[1] - e2[1];
        return i2 * i2 + n2 * n2;
      }
      function Ci(t2, e2) {
        return Math.sqrt(Ti(t2, e2));
      }
      function bi(t2, e2) {
        return Ti(t2, yi(t2, e2));
      }
      function Ri(t2, e2) {
        return vi(t2, "{x}, {y}", e2);
      }
      function Pi(t2, e2) {
        if (e2.canWrapX()) {
          const i2 = Se(e2.getExtent()), n2 = Ii(t2, e2, i2);
          n2 && (t2[0] -= n2 * i2);
        }
        return t2;
      }
      function Ii(t2, e2, i2) {
        const n2 = e2.getExtent();
        let r2 = 0;
        return e2.canWrapX() && (t2[0] < n2[0] || t2[0] > n2[2]) && (i2 = i2 || Se(n2), r2 = Math.floor((t2[0] - n2[0]) / i2)), r2;
      }
      const Li = 63710088e-1;
      function Mi(t2, e2, i2) {
        i2 = i2 || Li;
        const n2 = ai(t2[1]), r2 = ai(e2[1]), s2 = (r2 - n2) / 2, o2 = ai(e2[0] - t2[0]) / 2, a2 = Math.sin(s2) * Math.sin(s2) + Math.sin(o2) * Math.sin(o2) * Math.cos(n2) * Math.cos(r2);
        return 2 * i2 * Math.atan2(Math.sqrt(a2), Math.sqrt(1 - a2));
      }
      function Fi(t2, e2) {
        let i2 = 0;
        for (let n2 = 0, r2 = t2.length; n2 < r2 - 1; ++n2)
          i2 += Mi(t2[n2], t2[n2 + 1], e2);
        return i2;
      }
      function Ai(t2, e2) {
        let i2 = 0;
        const n2 = t2.length;
        let r2 = t2[n2 - 1][0], s2 = t2[n2 - 1][1];
        for (let e3 = 0; e3 < n2; e3++) {
          const n3 = t2[e3][0], o2 = t2[e3][1];
          i2 += ai(n3 - r2) * (2 + Math.sin(ai(s2)) + Math.sin(ai(o2))), r2 = n3, s2 = o2;
        }
        return i2 * e2 * e2 / 2;
      }
      function Oi(t2, e2, i2, n2) {
        n2 = n2 || Li;
        const r2 = ai(t2[1]), s2 = ai(t2[0]), o2 = e2 / n2, a2 = Math.asin(Math.sin(r2) * Math.cos(o2) + Math.cos(r2) * Math.sin(o2) * Math.cos(i2));
        return [oi(s2 + Math.atan2(Math.sin(i2) * Math.sin(o2) * Math.cos(r2), Math.cos(o2) - Math.sin(r2) * Math.sin(a2))), oi(a2)];
      }
      let Ni = true;
      function Di(t2) {
        Ni = !(void 0 === t2 || t2);
      }
      function ki(t2, e2, i2) {
        if (void 0 !== e2)
          for (let i3 = 0, n2 = t2.length; i3 < n2; ++i3)
            e2[i3] = t2[i3];
        else
          e2 = t2.slice();
        return e2;
      }
      function Gi(t2, e2, i2) {
        if (void 0 !== e2 && t2 !== e2) {
          for (let i3 = 0, n2 = t2.length; i3 < n2; ++i3)
            e2[i3] = t2[i3];
          t2 = e2;
        }
        return t2;
      }
      function ji(t2) {
        $e(t2.getCode(), t2), ti(t2, t2, ki);
      }
      function Bi(t2) {
        t2.forEach(ji);
      }
      function Ui(t2) {
        return "string" == typeof t2 ? He(t2) : t2 || null;
      }
      function zi(t2, e2, i2, n2) {
        let r2;
        const s2 = (t2 = Ui(t2)).getPointResolutionFunc();
        if (s2) {
          if (r2 = s2(e2, i2), n2 && n2 !== t2.getUnits()) {
            const e3 = t2.getMetersPerUnit();
            e3 && (r2 = r2 * e3 / Fe[n2]);
          }
        } else {
          const s3 = t2.getUnits();
          if ("degrees" == s3 && !n2 || "degrees" == n2)
            r2 = e2;
          else {
            const o2 = qi(t2, Ui("EPSG:4326"));
            if (o2 === Gi && "degrees" !== s3)
              r2 = e2 * t2.getMetersPerUnit();
            else {
              let t3 = [i2[0] - e2 / 2, i2[1], i2[0] + e2 / 2, i2[1], i2[0], i2[1] - e2 / 2, i2[0], i2[1] + e2 / 2];
              t3 = o2(t3, t3, 2);
              r2 = (Mi(t3.slice(0, 2), t3.slice(2, 4)) + Mi(t3.slice(4, 6), t3.slice(6, 8))) / 2;
            }
            const a2 = n2 ? Fe[n2] : t2.getMetersPerUnit();
            void 0 !== a2 && (r2 /= a2);
          }
        }
        return r2;
      }
      function Xi(t2) {
        Bi(t2), t2.forEach(function(e2) {
          t2.forEach(function(t3) {
            e2 !== t3 && ti(e2, t3, ki);
          });
        });
      }
      function Vi(t2, e2, i2, n2) {
        t2.forEach(function(t3) {
          e2.forEach(function(e3) {
            ti(t3, e3, i2), ti(e3, t3, n2);
          });
        });
      }
      function Wi(t2, e2) {
        return t2 ? "string" == typeof t2 ? Ui(t2) : t2 : Ui(e2);
      }
      function Zi(t2) {
        return function(e2, i2, n2) {
          const r2 = e2.length;
          n2 = void 0 !== n2 ? n2 : 2, i2 = void 0 !== i2 ? i2 : new Array(r2);
          for (let s2 = 0; s2 < r2; s2 += n2) {
            const r3 = t2(e2.slice(s2, s2 + n2)), o2 = r3.length;
            for (let t3 = 0, a2 = n2; t3 < a2; ++t3)
              i2[s2 + t3] = t3 >= o2 ? e2[s2 + t3] : r3[t3];
          }
          return i2;
        };
      }
      function Yi(t2, e2, i2, n2) {
        const r2 = Ui(t2), s2 = Ui(e2);
        ti(r2, s2, Zi(i2)), ti(s2, r2, Zi(n2));
      }
      function Ki(t2, e2) {
        if (t2 === e2)
          return true;
        const i2 = t2.getUnits() === e2.getUnits();
        if (t2.getCode() === e2.getCode())
          return i2;
        return qi(t2, e2) === ki && i2;
      }
      function qi(t2, e2) {
        let i2 = ei(t2.getCode(), e2.getCode());
        return i2 || (i2 = Gi), i2;
      }
      function Hi(t2, e2) {
        return qi(Ui(t2), Ui(e2));
      }
      function $i(t2, e2, i2) {
        return Hi(e2, i2)(t2, void 0, t2.length);
      }
      function Ji(t2, e2, i2, n2) {
        return Re(t2, Hi(e2, i2), void 0, n2);
      }
      let Qi = null;
      function tn(t2) {
        Qi = Ui(t2);
      }
      function en() {
        return Qi;
      }
      function nn(t2, e2) {
        return Qi ? $i(t2, e2, Qi) : t2;
      }
      function rn(t2, e2) {
        return Qi ? $i(t2, Qi, e2) : (Ni && !Si(t2, [0, 0]) && t2[0] >= -180 && t2[0] <= 180 && t2[1] >= -90 && t2[1] <= 90 && (Ni = false, console.warn("Call useGeographic() from ol/proj once to work with [longitude, latitude] coordinates.")), t2);
      }
      function sn(t2, e2) {
        return Qi ? Ji(t2, e2, Qi) : t2;
      }
      function on(t2, e2) {
        return Qi ? Ji(t2, Qi, e2) : t2;
      }
      function an(t2, e2) {
        if (!Qi)
          return t2;
        const i2 = Ui(e2).getUnits(), n2 = Qi.getUnits();
        return i2 && n2 ? t2 * Fe[i2] / Fe[n2] : t2;
      }
      function ln(t2, e2) {
        if (!Qi)
          return t2;
        const i2 = Ui(e2).getUnits(), n2 = Qi.getUnits();
        return i2 && n2 ? t2 * Fe[n2] / Fe[i2] : t2;
      }
      function hn(t2, e2, i2) {
        return function(n2) {
          let r2, s2;
          if (t2.canWrapX()) {
            const e3 = t2.getExtent(), o2 = Se(e3);
            s2 = Ii(n2 = n2.slice(0), t2, o2), s2 && (n2[0] = n2[0] - s2 * o2), n2[0] = ii(n2[0], e3[0], e3[2]), n2[1] = ii(n2[1], e3[1], e3[3]), r2 = i2(n2);
          } else
            r2 = i2(n2);
          return s2 && e2.canWrapX() && (r2[0] += s2 * Se(e2.getExtent())), r2;
        };
      }
      function cn() {
        Xi(Be), Xi(Ye), Vi(Ye, Be, Ue, ze);
      }
      function un(t2, e2, i2, n2, r2, s2) {
        s2 = s2 || [];
        let o2 = 0;
        for (let a2 = e2; a2 < i2; a2 += n2) {
          const e3 = t2[a2], i3 = t2[a2 + 1];
          s2[o2++] = r2[0] * e3 + r2[2] * i3 + r2[4], s2[o2++] = r2[1] * e3 + r2[3] * i3 + r2[5];
        }
        return s2 && s2.length != o2 && (s2.length = o2), s2;
      }
      function dn(t2, e2, i2, n2, r2, s2, o2) {
        o2 = o2 || [];
        const a2 = Math.cos(r2), l2 = Math.sin(r2), h2 = s2[0], c2 = s2[1];
        let u2 = 0;
        for (let r3 = e2; r3 < i2; r3 += n2) {
          const e3 = t2[r3] - h2, i3 = t2[r3 + 1] - c2;
          o2[u2++] = h2 + e3 * a2 - i3 * l2, o2[u2++] = c2 + e3 * l2 + i3 * a2;
          for (let e4 = r3 + 2; e4 < r3 + n2; ++e4)
            o2[u2++] = t2[e4];
        }
        return o2 && o2.length != u2 && (o2.length = u2), o2;
      }
      function gn(t2, e2, i2, n2, r2, s2, o2, a2) {
        a2 = a2 || [];
        const l2 = o2[0], h2 = o2[1];
        let c2 = 0;
        for (let o3 = e2; o3 < i2; o3 += n2) {
          const e3 = t2[o3] - l2, i3 = t2[o3 + 1] - h2;
          a2[c2++] = l2 + r2 * e3, a2[c2++] = h2 + s2 * i3;
          for (let e4 = o3 + 2; e4 < o3 + n2; ++e4)
            a2[c2++] = t2[e4];
        }
        return a2 && a2.length != c2 && (a2.length = c2), a2;
      }
      function fn(t2, e2, i2, n2, r2, s2, o2) {
        o2 = o2 || [];
        let a2 = 0;
        for (let l2 = e2; l2 < i2; l2 += n2) {
          o2[a2++] = t2[l2] + r2, o2[a2++] = t2[l2 + 1] + s2;
          for (let e3 = l2 + 2; e3 < l2 + n2; ++e3)
            o2[a2++] = t2[e3];
        }
        return o2 && o2.length != a2 && (o2.length = a2), o2;
      }
      cn();
      const pn = [1, 0, 0, 1, 0, 0];
      class mn extends V {
        constructor() {
          super(), this.extent_ = [1 / 0, 1 / 0, -1 / 0, -1 / 0], this.extentRevision_ = -1, this.simplifiedGeometryMaxMinSquaredTolerance = 0, this.simplifiedGeometryRevision = 0, this.simplifyTransformedInternal = m(function(t2, e2, i2) {
            if (!i2)
              return this.getSimplifiedGeometry(e2);
            const n2 = this.clone();
            return n2.applyTransform(i2), n2.getSimplifiedGeometry(e2);
          });
        }
        simplifyTransformed(t2, e2) {
          return this.simplifyTransformedInternal(this.getRevision(), t2, e2);
        }
        clone() {
          return B();
        }
        closestPointXY(t2, e2, i2, n2) {
          return B();
        }
        containsXY(t2, e2) {
          const i2 = this.getClosestPoint([t2, e2]);
          return i2[0] === t2 && i2[1] === e2;
        }
        getClosestPoint(t2, e2) {
          return e2 = e2 || [NaN, NaN], this.closestPointXY(t2[0], t2[1], e2, 1 / 0), e2;
        }
        intersectsCoordinate(t2) {
          return this.containsXY(t2[0], t2[1]);
        }
        computeExtent(t2) {
          return B();
        }
        getExtent(t2) {
          if (this.extentRevision_ != this.getRevision()) {
            const t3 = this.computeExtent(this.extent_);
            (isNaN(t3[0]) || isNaN(t3[1])) && Jt(t3), this.extentRevision_ = this.getRevision();
          }
          return Te(this.extent_, t2);
        }
        rotate(t2, e2) {
          B();
        }
        scale(t2, e2, i2) {
          B();
        }
        simplify(t2) {
          return this.getSimplifiedGeometry(t2 * t2);
        }
        getSimplifiedGeometry(t2) {
          return B();
        }
        getType() {
          return B();
        }
        applyTransform(t2) {
          B();
        }
        intersectsExtent(t2) {
          return B();
        }
        translate(t2, e2) {
          B();
        }
        transform(t2, e2) {
          const i2 = Ui(t2), n2 = "tile-pixels" == i2.getUnits() ? function(t3, n3, r2) {
            const s2 = i2.getExtent(), o2 = i2.getWorldExtent(), a2 = _e(o2) / _e(s2);
            return Mt(pn, o2[0], o2[3], a2, -a2, 0, 0, 0), un(t3, 0, t3.length, r2, pn, n3), Hi(i2, e2)(t3, n3, r2);
          } : Hi(i2, e2);
          return this.applyTransform(n2), this;
        }
      }
      class _n extends mn {
        constructor() {
          super(), this.layout = "XY", this.stride = 2, this.flatCoordinates = null;
        }
        computeExtent(t2) {
          return te(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, t2);
        }
        getCoordinates() {
          return B();
        }
        getFirstCoordinate() {
          return this.flatCoordinates.slice(0, this.stride);
        }
        getFlatCoordinates() {
          return this.flatCoordinates;
        }
        getLastCoordinate() {
          return this.flatCoordinates.slice(this.flatCoordinates.length - this.stride);
        }
        getLayout() {
          return this.layout;
        }
        getSimplifiedGeometry(t2) {
          if (this.simplifiedGeometryRevision !== this.getRevision() && (this.simplifiedGeometryMaxMinSquaredTolerance = 0, this.simplifiedGeometryRevision = this.getRevision()), t2 < 0 || 0 !== this.simplifiedGeometryMaxMinSquaredTolerance && t2 <= this.simplifiedGeometryMaxMinSquaredTolerance)
            return this;
          const e2 = this.getSimplifiedGeometryInternal(t2);
          return e2.getFlatCoordinates().length < this.flatCoordinates.length ? e2 : (this.simplifiedGeometryMaxMinSquaredTolerance = t2, this);
        }
        getSimplifiedGeometryInternal(t2) {
          return this;
        }
        getStride() {
          return this.stride;
        }
        setFlatCoordinates(t2, e2) {
          this.stride = yn(t2), this.layout = t2, this.flatCoordinates = e2;
        }
        setCoordinates(t2, e2) {
          B();
        }
        setLayout(t2, e2, i2) {
          let n2;
          if (t2)
            n2 = yn(t2);
          else {
            for (let t3 = 0; t3 < i2; ++t3) {
              if (0 === e2.length)
                return this.layout = "XY", void (this.stride = 2);
              e2 = e2[0];
            }
            n2 = e2.length, t2 = function(t3) {
              let e3;
              2 == t3 ? e3 = "XY" : 3 == t3 ? e3 = "XYZ" : 4 == t3 && (e3 = "XYZM");
              return e3;
            }(n2);
          }
          this.layout = t2, this.stride = n2;
        }
        applyTransform(t2) {
          this.flatCoordinates && (t2(this.flatCoordinates, this.flatCoordinates, this.stride), this.changed());
        }
        rotate(t2, e2) {
          const i2 = this.getFlatCoordinates();
          if (i2) {
            const n2 = this.getStride();
            dn(i2, 0, i2.length, n2, t2, e2, i2), this.changed();
          }
        }
        scale(t2, e2, i2) {
          void 0 === e2 && (e2 = t2), i2 || (i2 = ge(this.getExtent()));
          const n2 = this.getFlatCoordinates();
          if (n2) {
            const r2 = this.getStride();
            gn(n2, 0, n2.length, r2, t2, e2, i2, n2), this.changed();
          }
        }
        translate(t2, e2) {
          const i2 = this.getFlatCoordinates();
          if (i2) {
            const n2 = this.getStride();
            fn(i2, 0, i2.length, n2, t2, e2, i2), this.changed();
          }
        }
      }
      function yn(t2) {
        let e2;
        return "XY" == t2 ? e2 = 2 : "XYZ" == t2 || "XYM" == t2 ? e2 = 3 : "XYZM" == t2 && (e2 = 4), e2;
      }
      function xn(t2, e2, i2) {
        const n2 = t2.getFlatCoordinates();
        if (n2) {
          const r2 = t2.getStride();
          return un(n2, 0, n2.length, r2, e2, i2);
        }
        return null;
      }
      function vn(t2, e2, i2, n2, r2, s2, o2) {
        const a2 = t2[e2], l2 = t2[e2 + 1], h2 = t2[i2] - a2, c2 = t2[i2 + 1] - l2;
        let u2;
        if (0 === h2 && 0 === c2)
          u2 = e2;
        else {
          const d2 = ((r2 - a2) * h2 + (s2 - l2) * c2) / (h2 * h2 + c2 * c2);
          if (d2 > 1)
            u2 = i2;
          else {
            if (d2 > 0) {
              for (let r3 = 0; r3 < n2; ++r3)
                o2[r3] = hi(t2[e2 + r3], t2[i2 + r3], d2);
              return void (o2.length = n2);
            }
            u2 = e2;
          }
        }
        for (let e3 = 0; e3 < n2; ++e3)
          o2[e3] = t2[u2 + e3];
        o2.length = n2;
      }
      function Sn(t2, e2, i2, n2, r2) {
        let s2 = t2[e2], o2 = t2[e2 + 1];
        for (e2 += n2; e2 < i2; e2 += n2) {
          const i3 = t2[e2], n3 = t2[e2 + 1], a2 = ri(s2, o2, i3, n3);
          a2 > r2 && (r2 = a2), s2 = i3, o2 = n3;
        }
        return r2;
      }
      function wn(t2, e2, i2, n2, r2) {
        for (let s2 = 0, o2 = i2.length; s2 < o2; ++s2) {
          const o3 = i2[s2];
          r2 = Sn(t2, e2, o3, n2, r2), e2 = o3;
        }
        return r2;
      }
      function En(t2, e2, i2, n2, r2) {
        for (let s2 = 0, o2 = i2.length; s2 < o2; ++s2) {
          const o3 = i2[s2];
          r2 = wn(t2, e2, o3, n2, r2), e2 = o3[o3.length - 1];
        }
        return r2;
      }
      function Tn(t2, e2, i2, n2, r2, s2, o2, a2, l2, h2, c2) {
        if (e2 == i2)
          return h2;
        let u2, d2;
        if (0 === r2) {
          if (d2 = ri(o2, a2, t2[e2], t2[e2 + 1]), d2 < h2) {
            for (u2 = 0; u2 < n2; ++u2)
              l2[u2] = t2[e2 + u2];
            return l2.length = n2, d2;
          }
          return h2;
        }
        c2 = c2 || [NaN, NaN];
        let g2 = e2 + n2;
        for (; g2 < i2; )
          if (vn(t2, g2 - n2, g2, n2, o2, a2, c2), d2 = ri(o2, a2, c2[0], c2[1]), d2 < h2) {
            for (h2 = d2, u2 = 0; u2 < n2; ++u2)
              l2[u2] = c2[u2];
            l2.length = n2, g2 += n2;
          } else
            g2 += n2 * Math.max((Math.sqrt(d2) - Math.sqrt(h2)) / r2 | 0, 1);
        if (s2 && (vn(t2, i2 - n2, e2, n2, o2, a2, c2), d2 = ri(o2, a2, c2[0], c2[1]), d2 < h2)) {
          for (h2 = d2, u2 = 0; u2 < n2; ++u2)
            l2[u2] = c2[u2];
          l2.length = n2;
        }
        return h2;
      }
      function Cn(t2, e2, i2, n2, r2, s2, o2, a2, l2, h2, c2) {
        c2 = c2 || [NaN, NaN];
        for (let u2 = 0, d2 = i2.length; u2 < d2; ++u2) {
          const d3 = i2[u2];
          h2 = Tn(t2, e2, d3, n2, r2, s2, o2, a2, l2, h2, c2), e2 = d3;
        }
        return h2;
      }
      function bn(t2, e2, i2, n2, r2, s2, o2, a2, l2, h2, c2) {
        c2 = c2 || [NaN, NaN];
        for (let u2 = 0, d2 = i2.length; u2 < d2; ++u2) {
          const d3 = i2[u2];
          h2 = Cn(t2, e2, d3, n2, r2, s2, o2, a2, l2, h2, c2), e2 = d3[d3.length - 1];
        }
        return h2;
      }
      function Rn(t2, e2, i2, n2) {
        for (let n3 = 0, r2 = i2.length; n3 < r2; ++n3)
          t2[e2++] = i2[n3];
        return e2;
      }
      function Pn(t2, e2, i2, n2) {
        for (let r2 = 0, s2 = i2.length; r2 < s2; ++r2) {
          const s3 = i2[r2];
          for (let i3 = 0; i3 < n2; ++i3)
            t2[e2++] = s3[i3];
        }
        return e2;
      }
      function In(t2, e2, i2, n2, r2) {
        r2 = r2 || [];
        let s2 = 0;
        for (let o2 = 0, a2 = i2.length; o2 < a2; ++o2) {
          const a3 = Pn(t2, e2, i2[o2], n2);
          r2[s2++] = a3, e2 = a3;
        }
        return r2.length = s2, r2;
      }
      function Ln(t2, e2, i2, n2, r2) {
        r2 = r2 || [];
        let s2 = 0;
        for (let o2 = 0, a2 = i2.length; o2 < a2; ++o2) {
          const a3 = In(t2, e2, i2[o2], n2, r2[s2]);
          0 === a3.length && (a3[0] = e2), r2[s2++] = a3, e2 = a3[a3.length - 1];
        }
        return r2.length = s2, r2;
      }
      function Mn(t2, e2, i2, n2, r2, s2, o2) {
        const a2 = (i2 - e2) / n2;
        if (a2 < 3) {
          for (; e2 < i2; e2 += n2)
            s2[o2++] = t2[e2], s2[o2++] = t2[e2 + 1];
          return o2;
        }
        const l2 = new Array(a2);
        l2[0] = 1, l2[a2 - 1] = 1;
        const h2 = [e2, i2 - n2];
        let c2 = 0;
        for (; h2.length > 0; ) {
          const i3 = h2.pop(), s3 = h2.pop();
          let o3 = 0;
          const a3 = t2[s3], u2 = t2[s3 + 1], d2 = t2[i3], g2 = t2[i3 + 1];
          for (let e3 = s3 + n2; e3 < i3; e3 += n2) {
            const i4 = ni(t2[e3], t2[e3 + 1], a3, u2, d2, g2);
            i4 > o3 && (c2 = e3, o3 = i4);
          }
          o3 > r2 && (l2[(c2 - e2) / n2] = 1, s3 + n2 < c2 && h2.push(s3, c2), c2 + n2 < i3 && h2.push(c2, i3));
        }
        for (let i3 = 0; i3 < a2; ++i3)
          l2[i3] && (s2[o2++] = t2[e2 + i3 * n2], s2[o2++] = t2[e2 + i3 * n2 + 1]);
        return o2;
      }
      function Fn(t2, e2, i2, n2, r2, s2, o2, a2) {
        for (let l2 = 0, h2 = i2.length; l2 < h2; ++l2) {
          const h3 = i2[l2];
          o2 = Mn(t2, e2, h3, n2, r2, s2, o2), a2.push(o2), e2 = h3;
        }
        return o2;
      }
      function An(t2, e2, i2, n2, r2, s2, o2) {
        if (i2 <= e2 + n2) {
          for (; e2 < i2; e2 += n2)
            s2[o2++] = t2[e2], s2[o2++] = t2[e2 + 1];
          return o2;
        }
        let a2 = t2[e2], l2 = t2[e2 + 1];
        s2[o2++] = a2, s2[o2++] = l2;
        let h2 = a2, c2 = l2;
        for (e2 += n2; e2 < i2; e2 += n2)
          h2 = t2[e2], c2 = t2[e2 + 1], ri(a2, l2, h2, c2) > r2 && (s2[o2++] = h2, s2[o2++] = c2, a2 = h2, l2 = c2);
        return h2 == a2 && c2 == l2 || (s2[o2++] = h2, s2[o2++] = c2), o2;
      }
      function On(t2, e2) {
        return e2 * Math.round(t2 / e2);
      }
      function Nn(t2, e2, i2, n2, r2, s2, o2) {
        if (e2 == i2)
          return o2;
        let a2, l2, h2 = On(t2[e2], r2), c2 = On(t2[e2 + 1], r2);
        e2 += n2, s2[o2++] = h2, s2[o2++] = c2;
        do {
          if (a2 = On(t2[e2], r2), l2 = On(t2[e2 + 1], r2), (e2 += n2) == i2)
            return s2[o2++] = a2, s2[o2++] = l2, o2;
        } while (a2 == h2 && l2 == c2);
        for (; e2 < i2; ) {
          const i3 = On(t2[e2], r2), u2 = On(t2[e2 + 1], r2);
          if (e2 += n2, i3 == a2 && u2 == l2)
            continue;
          const d2 = a2 - h2, g2 = l2 - c2, f2 = i3 - h2, p2 = u2 - c2;
          d2 * p2 == g2 * f2 && (d2 < 0 && f2 < d2 || d2 == f2 || d2 > 0 && f2 > d2) && (g2 < 0 && p2 < g2 || g2 == p2 || g2 > 0 && p2 > g2) ? (a2 = i3, l2 = u2) : (s2[o2++] = a2, s2[o2++] = l2, h2 = a2, c2 = l2, a2 = i3, l2 = u2);
        }
        return s2[o2++] = a2, s2[o2++] = l2, o2;
      }
      function Dn(t2, e2, i2, n2, r2, s2, o2, a2) {
        for (let l2 = 0, h2 = i2.length; l2 < h2; ++l2) {
          const h3 = i2[l2];
          o2 = Nn(t2, e2, h3, n2, r2, s2, o2), a2.push(o2), e2 = h3;
        }
        return o2;
      }
      function kn(t2, e2, i2, n2, r2, s2, o2, a2) {
        for (let l2 = 0, h2 = i2.length; l2 < h2; ++l2) {
          const h3 = i2[l2], c2 = [];
          o2 = Dn(t2, e2, h3, n2, r2, s2, o2, c2), a2.push(c2), e2 = h3[h3.length - 1];
        }
        return o2;
      }
      function Gn(t2, e2, i2, n2, r2) {
        r2 = void 0 !== r2 ? r2 : [];
        let s2 = 0;
        for (let o2 = e2; o2 < i2; o2 += n2)
          r2[s2++] = t2.slice(o2, o2 + n2);
        return r2.length = s2, r2;
      }
      function jn(t2, e2, i2, n2, r2) {
        r2 = void 0 !== r2 ? r2 : [];
        let s2 = 0;
        for (let o2 = 0, a2 = i2.length; o2 < a2; ++o2) {
          const a3 = i2[o2];
          r2[s2++] = Gn(t2, e2, a3, n2, r2[s2]), e2 = a3;
        }
        return r2.length = s2, r2;
      }
      function Bn(t2, e2, i2, n2, r2) {
        r2 = void 0 !== r2 ? r2 : [];
        let s2 = 0;
        for (let o2 = 0, a2 = i2.length; o2 < a2; ++o2) {
          const a3 = i2[o2];
          r2[s2++] = 1 === a3.length && a3[0] === e2 ? [] : jn(t2, e2, a3, n2, r2[s2]), e2 = a3[a3.length - 1];
        }
        return r2.length = s2, r2;
      }
      function Un(t2, e2, i2, n2) {
        let r2 = 0, s2 = t2[i2 - n2], o2 = t2[i2 - n2 + 1];
        for (; e2 < i2; e2 += n2) {
          const i3 = t2[e2], n3 = t2[e2 + 1];
          r2 += o2 * i3 - s2 * n3, s2 = i3, o2 = n3;
        }
        return r2 / 2;
      }
      function zn(t2, e2, i2, n2) {
        let r2 = 0;
        for (let s2 = 0, o2 = i2.length; s2 < o2; ++s2) {
          const o3 = i2[s2];
          r2 += Un(t2, e2, o3, n2), e2 = o3;
        }
        return r2;
      }
      function Xn(t2, e2, i2, n2) {
        let r2 = 0;
        for (let s2 = 0, o2 = i2.length; s2 < o2; ++s2) {
          const o3 = i2[s2];
          r2 += zn(t2, e2, o3, n2), e2 = o3[o3.length - 1];
        }
        return r2;
      }
      class Vn extends _n {
        constructor(t2, e2) {
          super(), this.maxDelta_ = -1, this.maxDeltaRevision_ = -1, void 0 === e2 || Array.isArray(t2[0]) ? this.setCoordinates(t2, e2) : this.setFlatCoordinates(e2, t2);
        }
        clone() {
          return new Vn(this.flatCoordinates.slice(), this.layout);
        }
        closestPointXY(t2, e2, i2, n2) {
          return n2 < Wt(this.getExtent(), t2, e2) ? n2 : (this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt(Sn(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, 0)), this.maxDeltaRevision_ = this.getRevision()), Tn(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, this.maxDelta_, true, t2, e2, i2, n2));
        }
        getArea() {
          return Un(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
        }
        getCoordinates() {
          return Gn(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
        }
        getSimplifiedGeometryInternal(t2) {
          const e2 = [];
          return e2.length = Mn(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, t2, e2, 0), new Vn(e2, "XY");
        }
        getType() {
          return "LinearRing";
        }
        intersectsExtent(t2) {
          return false;
        }
        setCoordinates(t2, e2) {
          this.setLayout(e2, t2, 1), this.flatCoordinates || (this.flatCoordinates = []), this.flatCoordinates.length = Pn(this.flatCoordinates, 0, t2, this.stride), this.changed();
        }
      }
      class Wn extends _n {
        constructor(t2, e2) {
          super(), this.setCoordinates(t2, e2);
        }
        clone() {
          const t2 = new Wn(this.flatCoordinates.slice(), this.layout);
          return t2.applyProperties(this), t2;
        }
        closestPointXY(t2, e2, i2, n2) {
          const r2 = this.flatCoordinates, s2 = ri(t2, e2, r2[0], r2[1]);
          if (s2 < n2) {
            const t3 = this.stride;
            for (let e3 = 0; e3 < t3; ++e3)
              i2[e3] = r2[e3];
            return i2.length = t3, s2;
          }
          return n2;
        }
        getCoordinates() {
          return this.flatCoordinates ? this.flatCoordinates.slice() : [];
        }
        computeExtent(t2) {
          return Qt(this.flatCoordinates, t2);
        }
        getType() {
          return "Point";
        }
        intersectsExtent(t2) {
          return Kt(t2, this.flatCoordinates[0], this.flatCoordinates[1]);
        }
        setCoordinates(t2, e2) {
          this.setLayout(e2, t2, 0), this.flatCoordinates || (this.flatCoordinates = []), this.flatCoordinates.length = Rn(this.flatCoordinates, 0, t2, this.stride), this.changed();
        }
      }
      function Zn(t2, e2, i2, n2, r2) {
        return !he(r2, function(r3) {
          return !Yn(t2, e2, i2, n2, r3[0], r3[1]);
        });
      }
      function Yn(t2, e2, i2, n2, r2, s2) {
        let o2 = 0, a2 = t2[i2 - n2], l2 = t2[i2 - n2 + 1];
        for (; e2 < i2; e2 += n2) {
          const i3 = t2[e2], n3 = t2[e2 + 1];
          l2 <= s2 ? n3 > s2 && (i3 - a2) * (s2 - l2) - (r2 - a2) * (n3 - l2) > 0 && o2++ : n3 <= s2 && (i3 - a2) * (s2 - l2) - (r2 - a2) * (n3 - l2) < 0 && o2--, a2 = i3, l2 = n3;
        }
        return 0 !== o2;
      }
      function Kn(t2, e2, i2, n2, r2, s2) {
        if (0 === i2.length)
          return false;
        if (!Yn(t2, e2, i2[0], n2, r2, s2))
          return false;
        for (let e3 = 1, o2 = i2.length; e3 < o2; ++e3)
          if (Yn(t2, i2[e3 - 1], i2[e3], n2, r2, s2))
            return false;
        return true;
      }
      function qn(t2, e2, i2, n2, r2, s2) {
        if (0 === i2.length)
          return false;
        for (let o2 = 0, a2 = i2.length; o2 < a2; ++o2) {
          const a3 = i2[o2];
          if (Kn(t2, e2, a3, n2, r2, s2))
            return true;
          e2 = a3[a3.length - 1];
        }
        return false;
      }
      function Hn(t2, e2, i2, n2, r2, s2, o2) {
        let l2, h2, c2, u2, d2, g2, f2;
        const p2 = r2[s2 + 1], m2 = [];
        for (let r3 = 0, s3 = i2.length; r3 < s3; ++r3) {
          const s4 = i2[r3];
          for (u2 = t2[s4 - n2], g2 = t2[s4 - n2 + 1], l2 = e2; l2 < s4; l2 += n2)
            d2 = t2[l2], f2 = t2[l2 + 1], (p2 <= g2 && f2 <= p2 || g2 <= p2 && p2 <= f2) && (c2 = (p2 - g2) / (f2 - g2) * (d2 - u2) + u2, m2.push(c2)), u2 = d2, g2 = f2;
        }
        let _2 = NaN, y2 = -1 / 0;
        for (m2.sort(a), u2 = m2[0], l2 = 1, h2 = m2.length; l2 < h2; ++l2) {
          d2 = m2[l2];
          const r3 = Math.abs(d2 - u2);
          r3 > y2 && (c2 = (u2 + d2) / 2, Kn(t2, e2, i2, n2, c2, p2) && (_2 = c2, y2 = r3)), u2 = d2;
        }
        return isNaN(_2) && (_2 = r2[s2]), o2 ? (o2.push(_2, p2, y2), o2) : [_2, p2, y2];
      }
      function $n(t2, e2, i2, n2, r2) {
        let s2 = [];
        for (let o2 = 0, a2 = i2.length; o2 < a2; ++o2) {
          const a3 = i2[o2];
          s2 = Hn(t2, e2, a3, n2, r2, 2 * o2, s2), e2 = a3[a3.length - 1];
        }
        return s2;
      }
      function Jn(t2, e2, i2, n2, r2) {
        let s2;
        for (e2 += n2; e2 < i2; e2 += n2)
          if (s2 = r2(t2.slice(e2 - n2, e2), t2.slice(e2, e2 + n2)), s2)
            return s2;
        return false;
      }
      function Qn(t2, e2, i2, n2, r2) {
        const s2 = oe([1 / 0, 1 / 0, -1 / 0, -1 / 0], t2, e2, i2, n2);
        return !!we(r2, s2) && (!!Yt(r2, s2) || (s2[0] >= r2[0] && s2[2] <= r2[2] || (s2[1] >= r2[1] && s2[3] <= r2[3] || Jn(t2, e2, i2, n2, function(t3, e3) {
          return be(r2, t3, e3);
        }))));
      }
      function tr(t2, e2, i2, n2, r2) {
        for (let s2 = 0, o2 = i2.length; s2 < o2; ++s2) {
          if (Qn(t2, e2, i2[s2], n2, r2))
            return true;
          e2 = i2[s2];
        }
        return false;
      }
      function er(t2, e2, i2, n2, r2) {
        return !!Qn(t2, e2, i2, n2, r2) || (!!Yn(t2, e2, i2, n2, r2[0], r2[1]) || (!!Yn(t2, e2, i2, n2, r2[0], r2[3]) || (!!Yn(t2, e2, i2, n2, r2[2], r2[1]) || !!Yn(t2, e2, i2, n2, r2[2], r2[3]))));
      }
      function ir(t2, e2, i2, n2, r2) {
        if (!er(t2, e2, i2[0], n2, r2))
          return false;
        if (1 === i2.length)
          return true;
        for (let e3 = 1, s2 = i2.length; e3 < s2; ++e3)
          if (Zn(t2, i2[e3 - 1], i2[e3], n2, r2) && !Qn(t2, i2[e3 - 1], i2[e3], n2, r2))
            return false;
        return true;
      }
      function nr(t2, e2, i2, n2, r2) {
        for (let s2 = 0, o2 = i2.length; s2 < o2; ++s2) {
          const o3 = i2[s2];
          if (ir(t2, e2, o3, n2, r2))
            return true;
          e2 = o3[o3.length - 1];
        }
        return false;
      }
      function rr(t2, e2, i2, n2) {
        for (; e2 < i2 - n2; ) {
          for (let r2 = 0; r2 < n2; ++r2) {
            const s2 = t2[e2 + r2];
            t2[e2 + r2] = t2[i2 - n2 + r2], t2[i2 - n2 + r2] = s2;
          }
          e2 += n2, i2 -= n2;
        }
      }
      function sr(t2, e2, i2, n2) {
        let r2 = 0, s2 = t2[i2 - n2], o2 = t2[i2 - n2 + 1];
        for (; e2 < i2; e2 += n2) {
          const i3 = t2[e2], n3 = t2[e2 + 1];
          r2 += (i3 - s2) * (n3 + o2), s2 = i3, o2 = n3;
        }
        return 0 === r2 ? void 0 : r2 > 0;
      }
      function or(t2, e2, i2, n2, r2) {
        r2 = void 0 !== r2 && r2;
        for (let s2 = 0, o2 = i2.length; s2 < o2; ++s2) {
          const o3 = i2[s2], a2 = sr(t2, e2, o3, n2);
          if (0 === s2) {
            if (r2 && a2 || !r2 && !a2)
              return false;
          } else if (r2 && !a2 || !r2 && a2)
            return false;
          e2 = o3;
        }
        return true;
      }
      function ar(t2, e2, i2, n2, r2) {
        for (let s2 = 0, o2 = i2.length; s2 < o2; ++s2) {
          const o3 = i2[s2];
          if (!or(t2, e2, o3, n2, r2))
            return false;
          o3.length && (e2 = o3[o3.length - 1]);
        }
        return true;
      }
      function lr(t2, e2, i2, n2, r2) {
        r2 = void 0 !== r2 && r2;
        for (let s2 = 0, o2 = i2.length; s2 < o2; ++s2) {
          const o3 = i2[s2], a2 = sr(t2, e2, o3, n2);
          (0 === s2 ? r2 && a2 || !r2 && !a2 : r2 && !a2 || !r2 && a2) && rr(t2, e2, o3, n2), e2 = o3;
        }
        return e2;
      }
      function hr(t2, e2, i2, n2, r2) {
        for (let s2 = 0, o2 = i2.length; s2 < o2; ++s2)
          e2 = lr(t2, e2, i2[s2], n2, r2);
        return e2;
      }
      function cr(t2, e2) {
        const i2 = [];
        let n2 = 0, r2 = 0;
        for (let s2 = 0, o2 = e2.length; s2 < o2; ++s2) {
          const o3 = e2[s2];
          if (sr(t2, n2, o3, 2)) {
            if (0 === i2.length)
              continue;
            i2[i2.length - 1].push(e2[r2]);
          } else
            i2.push(e2.slice(r2, s2 + 1));
          r2 = s2 + 1, n2 = o3;
        }
        return i2;
      }
      class ur extends _n {
        constructor(t2, e2, i2) {
          super(), this.ends_ = [], this.flatInteriorPointRevision_ = -1, this.flatInteriorPoint_ = null, this.maxDelta_ = -1, this.maxDeltaRevision_ = -1, this.orientedRevision_ = -1, this.orientedFlatCoordinates_ = null, void 0 !== e2 && i2 ? (this.setFlatCoordinates(e2, t2), this.ends_ = i2) : this.setCoordinates(t2, e2);
        }
        appendLinearRing(t2) {
          this.flatCoordinates ? c(this.flatCoordinates, t2.getFlatCoordinates()) : this.flatCoordinates = t2.getFlatCoordinates().slice(), this.ends_.push(this.flatCoordinates.length), this.changed();
        }
        clone() {
          const t2 = new ur(this.flatCoordinates.slice(), this.layout, this.ends_.slice());
          return t2.applyProperties(this), t2;
        }
        closestPointXY(t2, e2, i2, n2) {
          return n2 < Wt(this.getExtent(), t2, e2) ? n2 : (this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt(wn(this.flatCoordinates, 0, this.ends_, this.stride, 0)), this.maxDeltaRevision_ = this.getRevision()), Cn(this.flatCoordinates, 0, this.ends_, this.stride, this.maxDelta_, true, t2, e2, i2, n2));
        }
        containsXY(t2, e2) {
          return Kn(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, t2, e2);
        }
        getArea() {
          return zn(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride);
        }
        getCoordinates(t2) {
          let e2;
          return void 0 !== t2 ? (e2 = this.getOrientedFlatCoordinates().slice(), lr(e2, 0, this.ends_, this.stride, t2)) : e2 = this.flatCoordinates, jn(e2, 0, this.ends_, this.stride);
        }
        getEnds() {
          return this.ends_;
        }
        getFlatInteriorPoint() {
          if (this.flatInteriorPointRevision_ != this.getRevision()) {
            const t2 = ge(this.getExtent());
            this.flatInteriorPoint_ = Hn(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, t2, 0), this.flatInteriorPointRevision_ = this.getRevision();
          }
          return this.flatInteriorPoint_;
        }
        getInteriorPoint() {
          return new Wn(this.getFlatInteriorPoint(), "XYM");
        }
        getLinearRingCount() {
          return this.ends_.length;
        }
        getLinearRing(t2) {
          return t2 < 0 || this.ends_.length <= t2 ? null : new Vn(this.flatCoordinates.slice(0 === t2 ? 0 : this.ends_[t2 - 1], this.ends_[t2]), this.layout);
        }
        getLinearRings() {
          const t2 = this.layout, e2 = this.flatCoordinates, i2 = this.ends_, n2 = [];
          let r2 = 0;
          for (let s2 = 0, o2 = i2.length; s2 < o2; ++s2) {
            const o3 = i2[s2], a2 = new Vn(e2.slice(r2, o3), t2);
            n2.push(a2), r2 = o3;
          }
          return n2;
        }
        getOrientedFlatCoordinates() {
          if (this.orientedRevision_ != this.getRevision()) {
            const t2 = this.flatCoordinates;
            or(t2, 0, this.ends_, this.stride) ? this.orientedFlatCoordinates_ = t2 : (this.orientedFlatCoordinates_ = t2.slice(), this.orientedFlatCoordinates_.length = lr(this.orientedFlatCoordinates_, 0, this.ends_, this.stride)), this.orientedRevision_ = this.getRevision();
          }
          return this.orientedFlatCoordinates_;
        }
        getSimplifiedGeometryInternal(t2) {
          const e2 = [], i2 = [];
          return e2.length = Dn(this.flatCoordinates, 0, this.ends_, this.stride, Math.sqrt(t2), e2, 0, i2), new ur(e2, "XY", i2);
        }
        getType() {
          return "Polygon";
        }
        intersectsExtent(t2) {
          return ir(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, t2);
        }
        setCoordinates(t2, e2) {
          this.setLayout(e2, t2, 2), this.flatCoordinates || (this.flatCoordinates = []);
          const i2 = In(this.flatCoordinates, 0, t2, this.stride, this.ends_);
          this.flatCoordinates.length = 0 === i2.length ? 0 : i2[i2.length - 1], this.changed();
        }
      }
      function dr(t2, e2, i2, n2) {
        i2 = i2 || 32;
        const r2 = [];
        for (let s2 = 0; s2 < i2; ++s2)
          c(r2, Oi(t2, e2, 2 * Math.PI * s2 / i2, n2));
        return r2.push(r2[0], r2[1]), new ur(r2, "XY", [r2.length]);
      }
      function gr(t2) {
        const e2 = t2[0], i2 = t2[1], n2 = t2[2], r2 = t2[3], s2 = [e2, i2, e2, r2, n2, r2, n2, i2, e2, i2];
        return new ur(s2, "XY", [s2.length]);
      }
      function fr(t2, e2, i2) {
        e2 = e2 || 32;
        const n2 = t2.getStride(), r2 = t2.getLayout(), s2 = t2.getCenter(), o2 = n2 * (e2 + 1), a2 = new Array(o2);
        for (let t3 = 0; t3 < o2; t3 += n2) {
          a2[t3] = 0, a2[t3 + 1] = 0;
          for (let e3 = 2; e3 < n2; e3++)
            a2[t3 + e3] = s2[e3];
        }
        const l2 = [a2.length], h2 = new ur(a2, r2, l2);
        return pr(h2, s2, t2.getRadius(), i2), h2;
      }
      function pr(t2, e2, i2, n2) {
        const r2 = t2.getFlatCoordinates(), s2 = t2.getStride(), o2 = r2.length / s2 - 1, a2 = n2 || 0;
        for (let t3 = 0; t3 <= o2; ++t3) {
          const n3 = t3 * s2, l2 = a2 + 2 * li(t3, o2) * Math.PI / o2;
          r2[n3] = e2[0] + i2 * Math.cos(l2), r2[n3 + 1] = e2[1] + i2 * Math.sin(l2);
        }
        t2.changed();
      }
      const mr = "accuracy", _r = "accuracyGeometry", yr = "altitude", xr = "altitudeAccuracy", vr = "heading", Sr = "position", wr = "projection", Er = "speed", Tr = "tracking", Cr = "trackingOptions";
      class br extends i {
        constructor(t2) {
          super(w), this.code = t2.code, this.message = t2.message;
        }
      }
      class Rr extends v {
        constructor(t2, e2, i2, n2) {
          super(), this.extent = t2, this.pixelRatio_ = i2, this.resolution = e2, this.state = n2;
        }
        changed() {
          this.dispatchEvent(S);
        }
        getExtent() {
          return this.extent;
        }
        getImage() {
          return B();
        }
        getPixelRatio() {
          return this.pixelRatio_;
        }
        getResolution() {
          return this.resolution;
        }
        getState() {
          return this.state;
        }
        load() {
          B();
        }
      }
      var Pr = 0, Ir = 1, Lr = 2, Mr = 3, Fr = 4;
      class Ar extends Rr {
        constructor(t2, e2, i2, n2, r2, s2) {
          super(t2, e2, i2, Pr), this.src_ = n2, this.image_ = new Image(), null !== r2 && (this.image_.crossOrigin = r2), this.unlisten_ = null, this.state = Pr, this.imageLoadFunction_ = s2;
        }
        getImage() {
          return this.image_;
        }
        handleImageError_() {
          this.state = Mr, this.unlistenImage_(), this.changed();
        }
        handleImageLoad_() {
          void 0 === this.resolution && (this.resolution = _e(this.extent) / this.image_.height), this.state = Lr, this.unlistenImage_(), this.changed();
        }
        load() {
          this.state != Pr && this.state != Mr || (this.state = Ir, this.changed(), this.imageLoadFunction_(this, this.src_), this.unlisten_ = Or(this.image_, this.handleImageLoad_.bind(this), this.handleImageError_.bind(this)));
        }
        setImage(t2) {
          this.image_ = t2, this.resolution = _e(this.extent) / this.image_.height;
        }
        unlistenImage_() {
          this.unlisten_ && (this.unlisten_(), this.unlisten_ = null);
        }
      }
      function Or(t2, e2, i2) {
        const n2 = t2;
        let r2 = true, s2 = false, o2 = false;
        const a2 = [D(n2, M, function() {
          o2 = true, s2 || e2();
        })];
        return n2.src && yt ? (s2 = true, n2.decode().then(function() {
          r2 && e2();
        }).catch(function(t3) {
          r2 && (o2 ? e2() : i2());
        })) : a2.push(D(n2, w, i2)), function() {
          r2 = false, a2.forEach(k);
        };
      }
      class Nr extends Rr {
        constructor(t2, e2, i2, n2, r2) {
          super(t2, e2, i2, void 0 !== r2 ? Pr : Lr), this.loader_ = void 0 !== r2 ? r2 : null, this.canvas_ = n2, this.error_ = null;
        }
        getError() {
          return this.error_;
        }
        handleLoad_(t2) {
          t2 ? (this.error_ = t2, this.state = Mr) : this.state = Lr, this.changed();
        }
        load() {
          this.state == Pr && (this.state = Ir, this.changed(), this.loader_(this.handleLoad_.bind(this)));
        }
        getImage() {
          return this.canvas_;
        }
      }
      function Dr(t2, e2, i2, n2) {
        let r2;
        return r2 = i2 && i2.length ? i2.shift() : _t ? new OffscreenCanvas(t2 || 300, e2 || 300) : document.createElement("canvas"), t2 && (r2.width = t2), e2 && (r2.height = e2), r2.getContext("2d", n2);
      }
      function kr(t2) {
        const e2 = t2.canvas;
        e2.width = 1, e2.height = 1, t2.clearRect(0, 0, 1, 1);
      }
      function Gr(t2) {
        let e2 = t2.offsetWidth;
        const i2 = getComputedStyle(t2);
        return e2 += parseInt(i2.marginLeft, 10) + parseInt(i2.marginRight, 10), e2;
      }
      function jr(t2) {
        let e2 = t2.offsetHeight;
        const i2 = getComputedStyle(t2);
        return e2 += parseInt(i2.marginTop, 10) + parseInt(i2.marginBottom, 10), e2;
      }
      function Br(t2, e2) {
        const i2 = e2.parentNode;
        i2 && i2.replaceChild(t2, e2);
      }
      function Ur(t2) {
        return t2 && t2.parentNode ? t2.parentNode.removeChild(t2) : null;
      }
      function zr(t2) {
        for (; t2.lastChild; )
          t2.removeChild(t2.lastChild);
      }
      function Xr(t2, e2) {
        const i2 = t2.childNodes;
        for (let n2 = 0; ; ++n2) {
          const r2 = i2[n2], s2 = e2[n2];
          if (!r2 && !s2)
            break;
          r2 !== s2 && (r2 ? s2 ? t2.insertBefore(s2, r2) : (t2.removeChild(r2), --n2) : t2.appendChild(s2));
        }
      }
      class Vr extends st {
        constructor(t2, e2, i2, n2, r2, s2) {
          super(t2, e2, s2), this.crossOrigin_ = n2, this.src_ = i2, this.key = i2, this.image_ = new Image(), null !== n2 && (this.image_.crossOrigin = n2), this.unlisten_ = null, this.tileLoadFunction_ = r2;
        }
        getImage() {
          return this.image_;
        }
        setImage(t2) {
          this.image_ = t2, this.state = J, this.unlistenImage_(), this.changed();
        }
        handleImageError_() {
          this.state = Q, this.unlistenImage_(), this.image_ = function() {
            const t2 = Dr(1, 1);
            return t2.fillStyle = "rgba(0,0,0,0)", t2.fillRect(0, 0, 1, 1), t2.canvas;
          }(), this.changed();
        }
        handleImageLoad_() {
          const t2 = this.image_;
          t2.naturalWidth && t2.naturalHeight ? this.state = J : this.state = tt, this.unlistenImage_(), this.changed();
        }
        load() {
          this.state == Q && (this.state = H, this.image_ = new Image(), null !== this.crossOrigin_ && (this.image_.crossOrigin = this.crossOrigin_)), this.state == H && (this.state = $, this.changed(), this.tileLoadFunction_(this, this.src_), this.unlisten_ = Or(this.image_, this.handleImageLoad_.bind(this), this.handleImageError_.bind(this)));
        }
        unlistenImage_() {
          this.unlisten_ && (this.unlisten_(), this.unlisten_ = null);
        }
      }
      class Wr {
        constructor(t2, e2, i2) {
          this.decay_ = t2, this.minVelocity_ = e2, this.delay_ = i2, this.points_ = [], this.angle_ = 0, this.initialVelocity_ = 0;
        }
        begin() {
          this.points_.length = 0, this.angle_ = 0, this.initialVelocity_ = 0;
        }
        update(t2, e2) {
          this.points_.push(t2, e2, Date.now());
        }
        end() {
          if (this.points_.length < 6)
            return false;
          const t2 = Date.now() - this.delay_, e2 = this.points_.length - 3;
          if (this.points_[e2 + 2] < t2)
            return false;
          let i2 = e2 - 3;
          for (; i2 > 0 && this.points_[i2 + 2] > t2; )
            i2 -= 3;
          const n2 = this.points_[e2 + 2] - this.points_[i2 + 2];
          if (n2 < 1e3 / 60)
            return false;
          const r2 = this.points_[e2] - this.points_[i2], s2 = this.points_[e2 + 1] - this.points_[i2 + 1];
          return this.angle_ = Math.atan2(s2, r2), this.initialVelocity_ = Math.sqrt(r2 * r2 + s2 * s2) / n2, this.initialVelocity_ > this.minVelocity_;
        }
        getDistance() {
          return (this.minVelocity_ - this.initialVelocity_) / this.decay_;
        }
        getAngle() {
          return this.angle_;
        }
      }
      const Zr = /^#([a-f0-9]{3}|[a-f0-9]{4}(?:[a-f0-9]{2}){0,2})$/i, Yr = /^([a-z]*)$|^hsla?\(.*\)$/i;
      function Kr(t2) {
        return "string" == typeof t2 ? t2 : Qr(t2);
      }
      function qr(t2) {
        const e2 = document.createElement("div");
        if (e2.style.color = t2, "" !== e2.style.color) {
          document.body.appendChild(e2);
          const t3 = getComputedStyle(e2).color;
          return document.body.removeChild(e2), t3;
        }
        return "";
      }
      const Hr = function() {
        const t2 = {};
        let e2 = 0;
        return function(i2) {
          let n2;
          if (t2.hasOwnProperty(i2))
            n2 = t2[i2];
          else {
            if (e2 >= 1024) {
              let i3 = 0;
              for (const n3 in t2)
                0 == (3 & i3++) && (delete t2[n3], --e2);
            }
            n2 = function(t3) {
              let e3, i3, n3, r2, s2;
              Yr.exec(t3) && (t3 = qr(t3));
              if (Zr.exec(t3)) {
                const o2 = t3.length - 1;
                let a2;
                a2 = o2 <= 4 ? 1 : 2;
                const l2 = 4 === o2 || 8 === o2;
                e3 = parseInt(t3.substr(1 + 0 * a2, a2), 16), i3 = parseInt(t3.substr(1 + 1 * a2, a2), 16), n3 = parseInt(t3.substr(1 + 2 * a2, a2), 16), r2 = l2 ? parseInt(t3.substr(1 + 3 * a2, a2), 16) : 255, 1 == a2 && (e3 = (e3 << 4) + e3, i3 = (i3 << 4) + i3, n3 = (n3 << 4) + n3, l2 && (r2 = (r2 << 4) + r2)), s2 = [e3, i3, n3, r2 / 255];
              } else
                t3.startsWith("rgba(") ? (s2 = t3.slice(5, -1).split(",").map(Number), Jr(s2)) : t3.startsWith("rgb(") ? (s2 = t3.slice(4, -1).split(",").map(Number), s2.push(1), Jr(s2)) : at(false, 14);
              return s2;
            }(i2), t2[i2] = n2, ++e2;
          }
          return n2;
        };
      }();
      function $r(t2) {
        return Array.isArray(t2) ? t2 : Hr(t2);
      }
      function Jr(t2) {
        return t2[0] = ii(t2[0] + 0.5 | 0, 0, 255), t2[1] = ii(t2[1] + 0.5 | 0, 0, 255), t2[2] = ii(t2[2] + 0.5 | 0, 0, 255), t2[3] = ii(t2[3], 0, 1), t2;
      }
      function Qr(t2) {
        let e2 = t2[0];
        e2 != (0 | e2) && (e2 = e2 + 0.5 | 0);
        let i2 = t2[1];
        i2 != (0 | i2) && (i2 = i2 + 0.5 | 0);
        let n2 = t2[2];
        n2 != (0 | n2) && (n2 = n2 + 0.5 | 0);
        return "rgba(" + e2 + "," + i2 + "," + n2 + "," + (void 0 === t2[3] ? 1 : Math.round(100 * t2[3]) / 100) + ")";
      }
      function ts(t2) {
        return Yr.test(t2) && (t2 = qr(t2)), Zr.test(t2) || t2.startsWith("rgba(") || t2.startsWith("rgb(");
      }
      class es {
        constructor() {
          this.cache_ = {}, this.cacheSize_ = 0, this.maxCacheSize_ = 32;
        }
        clear() {
          this.cache_ = {}, this.cacheSize_ = 0;
        }
        canExpireCache() {
          return this.cacheSize_ > this.maxCacheSize_;
        }
        expire() {
          if (this.canExpireCache()) {
            let t2 = 0;
            for (const e2 in this.cache_) {
              const i2 = this.cache_[e2];
              0 != (3 & t2++) || i2.hasListener() || (delete this.cache_[e2], --this.cacheSize_);
            }
          }
        }
        get(t2, e2, i2) {
          const n2 = is(t2, e2, i2);
          return n2 in this.cache_ ? this.cache_[n2] : null;
        }
        set(t2, e2, i2, n2) {
          const r2 = is(t2, e2, i2);
          this.cache_[r2] = n2, ++this.cacheSize_;
        }
        setSize(t2) {
          this.maxCacheSize_ = t2, this.expire();
        }
      }
      function is(t2, e2, i2) {
        return e2 + ":" + t2 + ":" + (i2 ? Kr(i2) : "null");
      }
      const ns = new es();
      var rs = "opacity", ss = "visible", os = "extent", as = "zIndex", ls = "maxResolution", hs = "minResolution", cs = "maxZoom", us = "minZoom", ds = "source", gs = "map";
      class fs extends V {
        constructor(t2) {
          super(), this.on, this.once, this.un, this.background_ = t2.background;
          const e2 = Object.assign({}, t2);
          "object" == typeof t2.properties && (delete e2.properties, Object.assign(e2, t2.properties)), e2[rs] = void 0 !== t2.opacity ? t2.opacity : 1, at("number" == typeof e2[rs], 64), e2[ss] = void 0 === t2.visible || t2.visible, e2[as] = t2.zIndex, e2[ls] = void 0 !== t2.maxResolution ? t2.maxResolution : 1 / 0, e2[hs] = void 0 !== t2.minResolution ? t2.minResolution : 0, e2[us] = void 0 !== t2.minZoom ? t2.minZoom : -1 / 0, e2[cs] = void 0 !== t2.maxZoom ? t2.maxZoom : 1 / 0, this.className_ = void 0 !== e2.className ? e2.className : "ol-layer", delete e2.className, this.setProperties(e2), this.state_ = null;
        }
        getBackground() {
          return this.background_;
        }
        getClassName() {
          return this.className_;
        }
        getLayerState(t2) {
          const e2 = this.state_ || { layer: this, managed: void 0 === t2 || t2 }, i2 = this.getZIndex();
          return e2.opacity = ii(Math.round(100 * this.getOpacity()) / 100, 0, 1), e2.visible = this.getVisible(), e2.extent = this.getExtent(), e2.zIndex = void 0 !== i2 || e2.managed ? i2 : 1 / 0, e2.maxResolution = this.getMaxResolution(), e2.minResolution = Math.max(this.getMinResolution(), 0), e2.minZoom = this.getMinZoom(), e2.maxZoom = this.getMaxZoom(), this.state_ = e2, e2;
        }
        getLayersArray(t2) {
          return B();
        }
        getLayerStatesArray(t2) {
          return B();
        }
        getExtent() {
          return this.get(os);
        }
        getMaxResolution() {
          return this.get(ls);
        }
        getMinResolution() {
          return this.get(hs);
        }
        getMinZoom() {
          return this.get(us);
        }
        getMaxZoom() {
          return this.get(cs);
        }
        getOpacity() {
          return this.get(rs);
        }
        getSourceState() {
          return B();
        }
        getVisible() {
          return this.get(ss);
        }
        getZIndex() {
          return this.get(as);
        }
        setBackground(t2) {
          this.background_ = t2, this.changed();
        }
        setExtent(t2) {
          this.set(os, t2);
        }
        setMaxResolution(t2) {
          this.set(ls, t2);
        }
        setMinResolution(t2) {
          this.set(hs, t2);
        }
        setMaxZoom(t2) {
          this.set(cs, t2);
        }
        setMinZoom(t2) {
          this.set(us, t2);
        }
        setOpacity(t2) {
          at("number" == typeof t2, 64), this.set(rs, t2);
        }
        setVisible(t2) {
          this.set(ss, t2);
        }
        setZIndex(t2) {
          this.set(as, t2);
        }
        disposeInternal() {
          this.state_ && (this.state_.layer = null, this.state_ = null), super.disposeInternal();
        }
      }
      var ps = "prerender", ms = "postrender", _s = "precompose", ys = "postcompose", xs = "rendercomplete";
      class vs extends fs {
        constructor(t2) {
          const e2 = Object.assign({}, t2);
          delete e2.source, super(e2), this.on, this.once, this.un, this.mapPrecomposeKey_ = null, this.mapRenderKey_ = null, this.sourceChangeKey_ = null, this.renderer_ = null, this.rendered = false, t2.render && (this.render = t2.render), t2.map && this.setMap(t2.map), this.addChangeListener(ds, this.handleSourcePropertyChange_);
          const i2 = t2.source ? t2.source : null;
          this.setSource(i2);
        }
        getLayersArray(t2) {
          return (t2 = t2 || []).push(this), t2;
        }
        getLayerStatesArray(t2) {
          return (t2 = t2 || []).push(this.getLayerState()), t2;
        }
        getSource() {
          return this.get(ds) || null;
        }
        getRenderSource() {
          return this.getSource();
        }
        getSourceState() {
          const t2 = this.getSource();
          return t2 ? t2.getState() : "undefined";
        }
        handleSourceChange_() {
          this.changed();
        }
        handleSourcePropertyChange_() {
          this.sourceChangeKey_ && (k(this.sourceChangeKey_), this.sourceChangeKey_ = null);
          const t2 = this.getSource();
          t2 && (this.sourceChangeKey_ = N(t2, S, this.handleSourceChange_, this)), this.changed();
        }
        getFeatures(t2) {
          return this.renderer_ ? this.renderer_.getFeatures(t2) : new Promise((t3) => t3([]));
        }
        getData(t2) {
          return this.renderer_ && this.rendered ? this.renderer_.getData(t2) : null;
        }
        render(t2, e2) {
          const i2 = this.getRenderer();
          if (i2.prepareFrame(t2))
            return this.rendered = true, i2.renderFrame(t2, e2);
        }
        unrender() {
          this.rendered = false;
        }
        setMapInternal(t2) {
          t2 || this.unrender(), this.set(gs, t2);
        }
        getMapInternal() {
          return this.get(gs);
        }
        setMap(t2) {
          this.mapPrecomposeKey_ && (k(this.mapPrecomposeKey_), this.mapPrecomposeKey_ = null), t2 || this.changed(), this.mapRenderKey_ && (k(this.mapRenderKey_), this.mapRenderKey_ = null), t2 && (this.mapPrecomposeKey_ = N(t2, _s, function(t3) {
            const e2 = t3.frameState.layerStatesArray, i2 = this.getLayerState(false);
            at(!e2.some(function(t4) {
              return t4.layer === i2.layer;
            }), 67), e2.push(i2);
          }, this), this.mapRenderKey_ = N(this, S, t2.render, t2), this.changed());
        }
        setSource(t2) {
          this.set(ds, t2);
        }
        getRenderer() {
          return this.renderer_ || (this.renderer_ = this.createRenderer()), this.renderer_;
        }
        hasRenderer() {
          return !!this.renderer_;
        }
        createRenderer() {
          return null;
        }
        disposeInternal() {
          this.renderer_ && (this.renderer_.dispose(), delete this.renderer_), this.setSource(null), super.disposeInternal();
        }
      }
      function Ss(t2, e2) {
        if (!t2.visible)
          return false;
        const i2 = e2.resolution;
        if (i2 < t2.minResolution || i2 >= t2.maxResolution)
          return false;
        const n2 = e2.zoom;
        return n2 > t2.minZoom && n2 <= t2.maxZoom;
      }
      class ws extends s {
        constructor(t2) {
          super(), this.map_ = t2;
        }
        dispatchRenderEvent(t2, e2) {
          B();
        }
        calculateMatrices2D(t2) {
          const e2 = t2.viewState, i2 = t2.coordinateToPixelTransform, n2 = t2.pixelToCoordinateTransform;
          Mt(i2, t2.size[0] / 2, t2.size[1] / 2, 1 / e2.resolution, -1 / e2.resolution, -e2.rotation, -e2.center[0], -e2.center[1]), Ft(n2, i2);
        }
        forEachFeatureAtCoordinate(t2, e2, i2, n2, r2, s2, o2, a2) {
          let l2;
          const h2 = e2.viewState;
          function c2(t3, e3, i3, n3) {
            return r2.call(s2, e3, t3 ? i3 : null, n3);
          }
          const u2 = h2.projection, d2 = Pi(t2.slice(), u2), g2 = [[0, 0]];
          if (u2.canWrapX() && n2) {
            const t3 = Se(u2.getExtent());
            g2.push([-t3, 0], [t3, 0]);
          }
          const f2 = e2.layerStatesArray, p2 = f2.length, m2 = [], _2 = [];
          for (let n3 = 0; n3 < g2.length; n3++)
            for (let r3 = p2 - 1; r3 >= 0; --r3) {
              const s3 = f2[r3], u3 = s3.layer;
              if (u3.hasRenderer() && Ss(s3, h2) && o2.call(a2, u3)) {
                const r4 = u3.getRenderer(), o3 = u3.getSource();
                if (r4 && o3) {
                  const a3 = o3.getWrapX() ? d2 : t2, h3 = c2.bind(null, s3.managed);
                  _2[0] = a3[0] + g2[n3][0], _2[1] = a3[1] + g2[n3][1], l2 = r4.forEachFeatureAtCoordinate(_2, e2, i2, h3, m2);
                }
                if (l2)
                  return l2;
              }
            }
          if (0 === m2.length)
            return;
          const y2 = 1 / m2.length;
          return m2.forEach((t3, e3) => t3.distanceSq += e3 * y2), m2.sort((t3, e3) => t3.distanceSq - e3.distanceSq), m2.some((t3) => l2 = t3.callback(t3.feature, t3.layer, t3.geometry)), l2;
        }
        hasFeatureAtCoordinate(t2, e2, i2, n2, r2, s2) {
          return void 0 !== this.forEachFeatureAtCoordinate(t2, e2, i2, n2, g, this, r2, s2);
        }
        getMap() {
          return this.map_;
        }
        renderFrame(t2) {
          B();
        }
        scheduleExpireIconCache(t2) {
          ns.canExpireCache() && t2.postRenderFunctions.push(Es);
        }
      }
      function Es(t2, e2) {
        ns.expire();
      }
      class Ts extends i {
        constructor(t2, e2, i2, n2) {
          super(t2), this.inversePixelTransform = e2, this.frameState = i2, this.context = n2;
        }
      }
      const Cs = "ol-hidden", bs = "ol-selectable", Rs = "ol-unselectable", Ps = "ol-unsupported", Is = "ol-control", Ls = "ol-collapsed", Ms = new RegExp(["^\\s*(?=(?:(?:[-a-z]+\\s*){0,2}(italic|oblique))?)", "(?=(?:(?:[-a-z]+\\s*){0,2}(small-caps))?)", "(?=(?:(?:[-a-z]+\\s*){0,2}(bold(?:er)?|lighter|[1-9]00 ))?)", "(?:(?:normal|\\1|\\2|\\3)\\s*){0,3}((?:xx?-)?", "(?:small|large)|medium|smaller|larger|[\\.\\d]+(?:\\%|in|[cem]m|ex|p[ctx]))", "(?:\\s*\\/\\s*(normal|[\\.\\d]+(?:\\%|in|[cem]m|ex|p[ctx])?))", `?\\s*([-,\\"\\'\\sa-z]+?)\\s*$`].join(""), "i"), Fs = ["style", "variant", "weight", "size", "lineHeight", "family"], As = function(t2) {
        const e2 = t2.match(Ms);
        if (!e2)
          return null;
        const i2 = { lineHeight: "normal", size: "1.2em", style: "normal", weight: "normal", variant: "normal" };
        for (let t3 = 0, n2 = Fs.length; t3 < n2; ++t3) {
          const n3 = e2[t3 + 1];
          void 0 !== n3 && (i2[Fs[t3]] = n3);
        }
        return i2.families = i2.family.split(/,\s?/), i2;
      }, Os = "10px sans-serif", Ns = "#000", Ds = "round", ks = [], Gs = "round", js = 10, Bs = "#000", Us = "center", zs = "middle", Xs = [0, 0, 0, 0], Vs = new V();
      let Ws, Zs = null;
      const Ys = {}, Ks = function() {
        const t2 = "32px ", e2 = ["monospace", "serif"], i2 = e2.length, n2 = "wmytzilWMYTZIL@#/&?$%10\uF013";
        let r2, s2;
        function o2(r3, o3, a3) {
          let l2 = true;
          for (let h2 = 0; h2 < i2; ++h2) {
            const i3 = e2[h2];
            if (s2 = $s(r3 + " " + o3 + " " + t2 + i3, n2), a3 != i3) {
              const e3 = $s(r3 + " " + o3 + " " + t2 + a3 + "," + i3, n2);
              l2 = l2 && e3 != s2;
            }
          }
          return !!l2;
        }
        function a2() {
          let t3 = true;
          const e3 = Vs.getKeys();
          for (let i3 = 0, n3 = e3.length; i3 < n3; ++i3) {
            const n4 = e3[i3];
            Vs.get(n4) < 100 && (o2.apply(this, n4.split("\n")) ? (y(Ys), Zs = null, Ws = void 0, Vs.set(n4, 100)) : (Vs.set(n4, Vs.get(n4) + 1, true), t3 = false));
          }
          t3 && (clearInterval(r2), r2 = void 0);
        }
        return function(t3) {
          const e3 = As(t3);
          if (!e3)
            return;
          const i3 = e3.families;
          for (let t4 = 0, n3 = i3.length; t4 < n3; ++t4) {
            const n4 = i3[t4], s3 = e3.style + "\n" + e3.weight + "\n" + n4;
            void 0 === Vs.get(s3) && (Vs.set(s3, 100, true), o2(e3.style, e3.weight, n4) || (Vs.set(s3, 0, true), void 0 === r2 && (r2 = setInterval(a2, 32))));
          }
        };
      }(), qs = function() {
        let t2;
        return function(e2) {
          let i2 = Ys[e2];
          if (null == i2) {
            if (_t) {
              const t3 = As(e2), n2 = Hs(e2, "\u017Dg");
              i2 = (isNaN(Number(t3.lineHeight)) ? 1.2 : Number(t3.lineHeight)) * (n2.actualBoundingBoxAscent + n2.actualBoundingBoxDescent);
            } else
              t2 || (t2 = document.createElement("div"), t2.innerHTML = "M", t2.style.minHeight = "0", t2.style.maxHeight = "none", t2.style.height = "auto", t2.style.padding = "0", t2.style.border = "none", t2.style.position = "absolute", t2.style.display = "block", t2.style.left = "-99999px"), t2.style.font = e2, document.body.appendChild(t2), i2 = t2.offsetHeight, document.body.removeChild(t2);
            Ys[e2] = i2;
          }
          return i2;
        };
      }();
      function Hs(t2, e2) {
        return Zs || (Zs = Dr(1, 1)), t2 != Ws && (Zs.font = t2, Ws = Zs.font), Zs.measureText(e2);
      }
      function $s(t2, e2) {
        return Hs(t2, e2).width;
      }
      function Js(t2, e2, i2) {
        if (e2 in i2)
          return i2[e2];
        const n2 = e2.split("\n").reduce((e3, i3) => Math.max(e3, $s(t2, i3)), 0);
        return i2[e2] = n2, n2;
      }
      function Qs(t2, e2) {
        const i2 = [], n2 = [], r2 = [];
        let s2 = 0, o2 = 0, a2 = 0, l2 = 0;
        for (let h2 = 0, c2 = e2.length; h2 <= c2; h2 += 2) {
          const u2 = e2[h2];
          if ("\n" === u2 || h2 === c2) {
            s2 = Math.max(s2, o2), r2.push(o2), o2 = 0, a2 += l2;
            continue;
          }
          const d2 = e2[h2 + 1] || t2.font, g2 = $s(d2, u2);
          i2.push(g2), o2 += g2;
          const f2 = qs(d2);
          n2.push(f2), l2 = Math.max(l2, f2);
        }
        return { width: s2, height: a2, widths: i2, heights: n2, lineWidths: r2 };
      }
      function to(t2, e2, i2, n2, r2, s2, o2, a2, l2, h2, c2) {
        t2.save(), 1 !== i2 && (t2.globalAlpha *= i2), e2 && t2.setTransform.apply(t2, e2), n2.contextInstructions ? (t2.translate(l2, h2), t2.scale(c2[0], c2[1]), function(t3, e3) {
          const i3 = t3.contextInstructions;
          for (let t4 = 0, n3 = i3.length; t4 < n3; t4 += 2)
            Array.isArray(i3[t4 + 1]) ? e3[i3[t4]].apply(e3, i3[t4 + 1]) : e3[i3[t4]] = i3[t4 + 1];
        }(n2, t2)) : c2[0] < 0 || c2[1] < 0 ? (t2.translate(l2, h2), t2.scale(c2[0], c2[1]), t2.drawImage(n2, r2, s2, o2, a2, 0, 0, o2, a2)) : t2.drawImage(n2, r2, s2, o2, a2, l2, h2, o2 * c2[0], a2 * c2[1]), t2.restore();
      }
      class eo extends ws {
        constructor(t2) {
          super(t2), this.fontChangeListenerKey_ = N(Vs, r, t2.redrawText.bind(t2)), this.element_ = document.createElement("div");
          const e2 = this.element_.style;
          e2.position = "absolute", e2.width = "100%", e2.height = "100%", e2.zIndex = "0", this.element_.className = "ol-unselectable ol-layers";
          const i2 = t2.getViewport();
          i2.insertBefore(this.element_, i2.firstChild || null), this.children_ = [], this.renderedVisible_ = true;
        }
        dispatchRenderEvent(t2, e2) {
          const i2 = this.getMap();
          if (i2.hasListener(t2)) {
            const n2 = new Ts(t2, void 0, e2);
            i2.dispatchEvent(n2);
          }
        }
        disposeInternal() {
          k(this.fontChangeListenerKey_), this.element_.parentNode.removeChild(this.element_), super.disposeInternal();
        }
        renderFrame(t2) {
          if (!t2)
            return void (this.renderedVisible_ && (this.element_.style.display = "none", this.renderedVisible_ = false));
          this.calculateMatrices2D(t2), this.dispatchRenderEvent(_s, t2);
          const e2 = t2.layerStatesArray.sort(function(t3, e3) {
            return t3.zIndex - e3.zIndex;
          }), i2 = t2.viewState;
          this.children_.length = 0;
          const n2 = [];
          let r2 = null;
          for (let s2 = 0, o2 = e2.length; s2 < o2; ++s2) {
            const o3 = e2[s2];
            t2.layerIndex = s2;
            const a2 = o3.layer, l2 = a2.getSourceState();
            if (!Ss(o3, i2) || "ready" != l2 && "undefined" != l2) {
              a2.unrender();
              continue;
            }
            const h2 = a2.render(t2, r2);
            h2 && (h2 !== r2 && (this.children_.push(h2), r2 = h2), "getDeclutter" in a2 && n2.push(a2));
          }
          for (let e3 = n2.length - 1; e3 >= 0; --e3)
            n2[e3].renderDeclutter(t2);
          Xr(this.element_, this.children_), this.dispatchRenderEvent(ys, t2), this.renderedVisible_ || (this.element_.style.display = "", this.renderedVisible_ = true), this.scheduleExpireIconCache(t2);
        }
      }
      class io extends i {
        constructor(t2, e2) {
          super(t2), this.layer = e2;
        }
      }
      const no = "layers";
      class ro extends fs {
        constructor(t2) {
          t2 = t2 || {};
          const e2 = Object.assign({}, t2);
          delete e2.layers;
          let i2 = t2.layers;
          super(e2), this.on, this.once, this.un, this.layersListenerKeys_ = [], this.listenerKeys_ = {}, this.addChangeListener(no, this.handleLayersChanged_), i2 ? Array.isArray(i2) ? i2 = new q(i2.slice(), { unique: true }) : at("function" == typeof i2.getArray, 43) : i2 = new q(void 0, { unique: true }), this.setLayers(i2);
        }
        handleLayerChange_() {
          this.changed();
        }
        handleLayersChanged_() {
          this.layersListenerKeys_.forEach(k), this.layersListenerKeys_.length = 0;
          const t2 = this.getLayers();
          this.layersListenerKeys_.push(N(t2, W, this.handleLayersAdd_, this), N(t2, Z, this.handleLayersRemove_, this));
          for (const t3 in this.listenerKeys_)
            this.listenerKeys_[t3].forEach(k);
          y(this.listenerKeys_);
          const e2 = t2.getArray();
          for (let t3 = 0, i2 = e2.length; t3 < i2; t3++) {
            const i3 = e2[t3];
            this.registerLayerListeners_(i3), this.dispatchEvent(new io("addlayer", i3));
          }
          this.changed();
        }
        registerLayerListeners_(t2) {
          const e2 = [N(t2, r, this.handleLayerChange_, this), N(t2, S, this.handleLayerChange_, this)];
          t2 instanceof ro && e2.push(N(t2, "addlayer", this.handleLayerGroupAdd_, this), N(t2, "removelayer", this.handleLayerGroupRemove_, this)), this.listenerKeys_[z(t2)] = e2;
        }
        handleLayerGroupAdd_(t2) {
          this.dispatchEvent(new io("addlayer", t2.layer));
        }
        handleLayerGroupRemove_(t2) {
          this.dispatchEvent(new io("removelayer", t2.layer));
        }
        handleLayersAdd_(t2) {
          const e2 = t2.element;
          this.registerLayerListeners_(e2), this.dispatchEvent(new io("addlayer", e2)), this.changed();
        }
        handleLayersRemove_(t2) {
          const e2 = t2.element, i2 = z(e2);
          this.listenerKeys_[i2].forEach(k), delete this.listenerKeys_[i2], this.dispatchEvent(new io("removelayer", e2)), this.changed();
        }
        getLayers() {
          return this.get(no);
        }
        setLayers(t2) {
          const e2 = this.getLayers();
          if (e2) {
            const t3 = e2.getArray();
            for (let e3 = 0, i2 = t3.length; e3 < i2; ++e3)
              this.dispatchEvent(new io("removelayer", t3[e3]));
          }
          this.set(no, t2);
        }
        getLayersArray(t2) {
          return t2 = void 0 !== t2 ? t2 : [], this.getLayers().forEach(function(e2) {
            e2.getLayersArray(t2);
          }), t2;
        }
        getLayerStatesArray(t2) {
          const e2 = void 0 !== t2 ? t2 : [], i2 = e2.length;
          this.getLayers().forEach(function(t3) {
            t3.getLayerStatesArray(e2);
          });
          const n2 = this.getLayerState();
          let r2 = n2.zIndex;
          t2 || void 0 !== n2.zIndex || (r2 = 0);
          for (let t3 = i2, s2 = e2.length; t3 < s2; t3++) {
            const i3 = e2[t3];
            i3.opacity *= n2.opacity, i3.visible = i3.visible && n2.visible, i3.maxResolution = Math.min(i3.maxResolution, n2.maxResolution), i3.minResolution = Math.max(i3.minResolution, n2.minResolution), i3.minZoom = Math.max(i3.minZoom, n2.minZoom), i3.maxZoom = Math.min(i3.maxZoom, n2.maxZoom), void 0 !== n2.extent && (void 0 !== i3.extent ? i3.extent = ye(i3.extent, n2.extent) : i3.extent = n2.extent), void 0 === i3.zIndex && (i3.zIndex = r2);
          }
          return e2;
        }
        getSourceState() {
          return "ready";
        }
      }
      class so extends i {
        constructor(t2, e2, i2) {
          super(t2), this.map = e2, this.frameState = void 0 !== i2 ? i2 : null;
        }
      }
      class oo extends so {
        constructor(t2, e2, i2, n2, r2, s2) {
          super(t2, e2, r2), this.originalEvent = i2, this.pixel_ = null, this.coordinate_ = null, this.dragging = void 0 !== n2 && n2, this.activePointers = s2;
        }
        get pixel() {
          return this.pixel_ || (this.pixel_ = this.map.getEventPixel(this.originalEvent)), this.pixel_;
        }
        set pixel(t2) {
          this.pixel_ = t2;
        }
        get coordinate() {
          return this.coordinate_ || (this.coordinate_ = this.map.getCoordinateFromPixel(this.pixel)), this.coordinate_;
        }
        set coordinate(t2) {
          this.coordinate_ = t2;
        }
        preventDefault() {
          super.preventDefault(), "preventDefault" in this.originalEvent && this.originalEvent.preventDefault();
        }
        stopPropagation() {
          super.stopPropagation(), "stopPropagation" in this.originalEvent && this.originalEvent.stopPropagation();
        }
      }
      var ao = { SINGLECLICK: "singleclick", CLICK: T, DBLCLICK: C, POINTERDRAG: "pointerdrag", POINTERMOVE: "pointermove", POINTERDOWN: "pointerdown", POINTERUP: "pointerup", POINTEROVER: "pointerover", POINTEROUT: "pointerout", POINTERENTER: "pointerenter", POINTERLEAVE: "pointerleave", POINTERCANCEL: "pointercancel" }, lo = "pointermove", ho = "pointerdown", co = "pointerup", uo = "pointerout";
      class go extends v {
        constructor(t2, e2) {
          super(t2), this.map_ = t2, this.clickTimeoutId_, this.emulateClicks_ = false, this.dragging_ = false, this.dragListenerKeys_ = [], this.moveTolerance_ = void 0 === e2 ? 1 : e2, this.down_ = null;
          const i2 = this.map_.getViewport();
          this.activePointers_ = [], this.trackedTouches_ = {}, this.element_ = i2, this.pointerdownListenerKey_ = N(i2, ho, this.handlePointerDown_, this), this.originalPointerMoveEvent_, this.relayedListenerKey_ = N(i2, lo, this.relayMoveEvent_, this), this.boundHandleTouchMove_ = this.handleTouchMove_.bind(this), this.element_.addEventListener(A, this.boundHandleTouchMove_, !!xt && { passive: false });
        }
        emulateClick_(t2) {
          let e2 = new oo(ao.CLICK, this.map_, t2);
          this.dispatchEvent(e2), void 0 !== this.clickTimeoutId_ ? (clearTimeout(this.clickTimeoutId_), this.clickTimeoutId_ = void 0, e2 = new oo(ao.DBLCLICK, this.map_, t2), this.dispatchEvent(e2)) : this.clickTimeoutId_ = setTimeout(function() {
            this.clickTimeoutId_ = void 0;
            const e3 = new oo(ao.SINGLECLICK, this.map_, t2);
            this.dispatchEvent(e3);
          }.bind(this), 250);
        }
        updateActivePointers_(t2) {
          const e2 = t2, i2 = e2.pointerId;
          if (e2.type == ao.POINTERUP || e2.type == ao.POINTERCANCEL) {
            delete this.trackedTouches_[i2];
            for (const t3 in this.trackedTouches_)
              if (this.trackedTouches_[t3].target !== e2.target) {
                delete this.trackedTouches_[t3];
                break;
              }
          } else
            e2.type != ao.POINTERDOWN && e2.type != ao.POINTERMOVE || (this.trackedTouches_[i2] = e2);
          this.activePointers_ = Object.values(this.trackedTouches_);
        }
        handlePointerUp_(t2) {
          this.updateActivePointers_(t2);
          const e2 = new oo(ao.POINTERUP, this.map_, t2, void 0, void 0, this.activePointers_);
          this.dispatchEvent(e2), this.emulateClicks_ && !e2.defaultPrevented && !this.dragging_ && this.isMouseActionButton_(t2) && this.emulateClick_(this.down_), 0 === this.activePointers_.length && (this.dragListenerKeys_.forEach(k), this.dragListenerKeys_.length = 0, this.dragging_ = false, this.down_ = null);
        }
        isMouseActionButton_(t2) {
          return 0 === t2.button;
        }
        handlePointerDown_(t2) {
          this.emulateClicks_ = 0 === this.activePointers_.length, this.updateActivePointers_(t2);
          const e2 = new oo(ao.POINTERDOWN, this.map_, t2, void 0, void 0, this.activePointers_);
          this.dispatchEvent(e2), this.down_ = {};
          for (const e3 in t2) {
            const i2 = t2[e3];
            this.down_[e3] = "function" == typeof i2 ? p : i2;
          }
          if (0 === this.dragListenerKeys_.length) {
            const t3 = this.map_.getOwnerDocument();
            this.dragListenerKeys_.push(N(t3, ao.POINTERMOVE, this.handlePointerMove_, this), N(t3, ao.POINTERUP, this.handlePointerUp_, this), N(this.element_, ao.POINTERCANCEL, this.handlePointerUp_, this)), this.element_.getRootNode && this.element_.getRootNode() !== t3 && this.dragListenerKeys_.push(N(this.element_.getRootNode(), ao.POINTERUP, this.handlePointerUp_, this));
          }
        }
        handlePointerMove_(t2) {
          if (this.isMoving_(t2)) {
            this.updateActivePointers_(t2), this.dragging_ = true;
            const e2 = new oo(ao.POINTERDRAG, this.map_, t2, this.dragging_, void 0, this.activePointers_);
            this.dispatchEvent(e2);
          }
        }
        relayMoveEvent_(t2) {
          this.originalPointerMoveEvent_ = t2;
          const e2 = !(!this.down_ || !this.isMoving_(t2));
          this.dispatchEvent(new oo(ao.POINTERMOVE, this.map_, t2, e2));
        }
        handleTouchMove_(t2) {
          const e2 = this.originalPointerMoveEvent_;
          e2 && !e2.defaultPrevented || "boolean" == typeof t2.cancelable && true !== t2.cancelable || t2.preventDefault();
        }
        isMoving_(t2) {
          return this.dragging_ || Math.abs(t2.clientX - this.down_.clientX) > this.moveTolerance_ || Math.abs(t2.clientY - this.down_.clientY) > this.moveTolerance_;
        }
        disposeInternal() {
          this.relayedListenerKey_ && (k(this.relayedListenerKey_), this.relayedListenerKey_ = null), this.element_.removeEventListener(A, this.boundHandleTouchMove_), this.pointerdownListenerKey_ && (k(this.pointerdownListenerKey_), this.pointerdownListenerKey_ = null), this.dragListenerKeys_.forEach(k), this.dragListenerKeys_.length = 0, this.element_ = null, super.disposeInternal();
        }
      }
      var fo = "postrender", po = "movestart", mo = "moveend", _o = "loadstart", yo = "loadend", xo = "layergroup", vo = "size", So = "target", wo = "view";
      const Eo = 1 / 0;
      class To {
        constructor(t2, e2) {
          this.priorityFunction_ = t2, this.keyFunction_ = e2, this.elements_ = [], this.priorities_ = [], this.queuedElements_ = {};
        }
        clear() {
          this.elements_.length = 0, this.priorities_.length = 0, y(this.queuedElements_);
        }
        dequeue() {
          const t2 = this.elements_, e2 = this.priorities_, i2 = t2[0];
          1 == t2.length ? (t2.length = 0, e2.length = 0) : (t2[0] = t2.pop(), e2[0] = e2.pop(), this.siftUp_(0));
          const n2 = this.keyFunction_(i2);
          return delete this.queuedElements_[n2], i2;
        }
        enqueue(t2) {
          at(!(this.keyFunction_(t2) in this.queuedElements_), 31);
          const e2 = this.priorityFunction_(t2);
          return e2 != Eo && (this.elements_.push(t2), this.priorities_.push(e2), this.queuedElements_[this.keyFunction_(t2)] = true, this.siftDown_(0, this.elements_.length - 1), true);
        }
        getCount() {
          return this.elements_.length;
        }
        getLeftChildIndex_(t2) {
          return 2 * t2 + 1;
        }
        getRightChildIndex_(t2) {
          return 2 * t2 + 2;
        }
        getParentIndex_(t2) {
          return t2 - 1 >> 1;
        }
        heapify_() {
          let t2;
          for (t2 = (this.elements_.length >> 1) - 1; t2 >= 0; t2--)
            this.siftUp_(t2);
        }
        isEmpty() {
          return 0 === this.elements_.length;
        }
        isKeyQueued(t2) {
          return t2 in this.queuedElements_;
        }
        isQueued(t2) {
          return this.isKeyQueued(this.keyFunction_(t2));
        }
        siftUp_(t2) {
          const e2 = this.elements_, i2 = this.priorities_, n2 = e2.length, r2 = e2[t2], s2 = i2[t2], o2 = t2;
          for (; t2 < n2 >> 1; ) {
            const r3 = this.getLeftChildIndex_(t2), s3 = this.getRightChildIndex_(t2), o3 = s3 < n2 && i2[s3] < i2[r3] ? s3 : r3;
            e2[t2] = e2[o3], i2[t2] = i2[o3], t2 = o3;
          }
          e2[t2] = r2, i2[t2] = s2, this.siftDown_(o2, t2);
        }
        siftDown_(t2, e2) {
          const i2 = this.elements_, n2 = this.priorities_, r2 = i2[e2], s2 = n2[e2];
          for (; e2 > t2; ) {
            const t3 = this.getParentIndex_(e2);
            if (!(n2[t3] > s2))
              break;
            i2[e2] = i2[t3], n2[e2] = n2[t3], e2 = t3;
          }
          i2[e2] = r2, n2[e2] = s2;
        }
        reprioritize() {
          const t2 = this.priorityFunction_, e2 = this.elements_, i2 = this.priorities_;
          let n2 = 0;
          const r2 = e2.length;
          let s2, o2, a2;
          for (o2 = 0; o2 < r2; ++o2)
            s2 = e2[o2], a2 = t2(s2), a2 == Eo ? delete this.queuedElements_[this.keyFunction_(s2)] : (i2[n2] = a2, e2[n2++] = s2);
          e2.length = n2, i2.length = n2, this.heapify_();
        }
      }
      class Co extends To {
        constructor(t2, e2) {
          super(function(e3) {
            return t2.apply(null, e3);
          }, function(t3) {
            return t3[0].getKey();
          }), this.boundHandleTileChange_ = this.handleTileChange.bind(this), this.tileChangeCallback_ = e2, this.tilesLoading_ = 0, this.tilesLoadingKeys_ = {};
        }
        enqueue(t2) {
          const e2 = super.enqueue(t2);
          if (e2) {
            t2[0].addEventListener(S, this.boundHandleTileChange_);
          }
          return e2;
        }
        getTilesLoading() {
          return this.tilesLoading_;
        }
        handleTileChange(t2) {
          const e2 = t2.target, i2 = e2.getState();
          if (i2 === J || i2 === Q || i2 === tt) {
            i2 !== Q && e2.removeEventListener(S, this.boundHandleTileChange_);
            const t3 = e2.getKey();
            t3 in this.tilesLoadingKeys_ && (delete this.tilesLoadingKeys_[t3], --this.tilesLoading_), this.tileChangeCallback_();
          }
        }
        loadMoreTiles(t2, e2) {
          let i2, n2, r2, s2 = 0;
          for (; this.tilesLoading_ < t2 && s2 < e2 && this.getCount() > 0; )
            n2 = this.dequeue()[0], r2 = n2.getKey(), i2 = n2.getState(), i2 !== H || r2 in this.tilesLoadingKeys_ || (this.tilesLoadingKeys_[r2] = true, ++this.tilesLoading_, ++s2, n2.load());
        }
      }
      function bo(t2, e2, i2, n2, r2) {
        if (!t2 || !(i2 in t2.wantedTiles))
          return Eo;
        if (!t2.wantedTiles[i2][e2.getKey()])
          return Eo;
        const s2 = t2.viewState.center, o2 = n2[0] - s2[0], a2 = n2[1] - s2[1];
        return 65536 * Math.log(r2) + Math.sqrt(o2 * o2 + a2 * a2) / r2;
      }
      var Ro = 0, Po = 1, Io = { CENTER: "center", RESOLUTION: "resolution", ROTATION: "rotation" };
      const Lo = 256;
      function Mo(t2, e2, i2) {
        return function(n2, r2, s2, o2, a2) {
          if (!n2)
            return;
          if (!r2 && !e2)
            return n2;
          const l2 = e2 ? 0 : s2[0] * r2, h2 = e2 ? 0 : s2[1] * r2, c2 = a2 ? a2[0] : 0, u2 = a2 ? a2[1] : 0;
          let d2 = t2[0] + l2 / 2 + c2, g2 = t2[2] - l2 / 2 + c2, f2 = t2[1] + h2 / 2 + u2, p2 = t2[3] - h2 / 2 + u2;
          d2 > g2 && (d2 = (g2 + d2) / 2, g2 = d2), f2 > p2 && (f2 = (p2 + f2) / 2, p2 = f2);
          let m2 = ii(n2[0], d2, g2), _2 = ii(n2[1], f2, p2);
          if (o2 && i2 && r2) {
            const t3 = 30 * r2;
            m2 += -t3 * Math.log(1 + Math.max(0, d2 - n2[0]) / t3) + t3 * Math.log(1 + Math.max(0, n2[0] - g2) / t3), _2 += -t3 * Math.log(1 + Math.max(0, f2 - n2[1]) / t3) + t3 * Math.log(1 + Math.max(0, n2[1] - p2) / t3);
          }
          return [m2, _2];
        };
      }
      function Fo(t2) {
        return t2;
      }
      function Ao(t2, e2, i2, n2) {
        const r2 = Se(e2) / i2[0], s2 = _e(e2) / i2[1];
        return n2 ? Math.min(t2, Math.max(r2, s2)) : Math.min(t2, Math.min(r2, s2));
      }
      function Oo(t2, e2, i2) {
        let n2 = Math.min(t2, e2);
        return n2 *= Math.log(1 + 50 * Math.max(0, t2 / e2 - 1)) / 50 + 1, i2 && (n2 = Math.max(n2, i2), n2 /= Math.log(1 + 50 * Math.max(0, i2 / t2 - 1)) / 50 + 1), ii(n2, i2 / 2, 2 * e2);
      }
      function No(t2, e2, i2, n2) {
        return e2 = void 0 === e2 || e2, function(r2, s2, o2, a2) {
          if (void 0 !== r2) {
            const h2 = t2[0], c2 = t2[t2.length - 1], u2 = i2 ? Ao(h2, i2, o2, n2) : h2;
            if (a2)
              return e2 ? Oo(r2, u2, c2) : ii(r2, c2, u2);
            const d2 = Math.min(u2, r2), g2 = Math.floor(l(t2, d2, s2));
            return t2[g2] > u2 && g2 < t2.length - 1 ? t2[g2 + 1] : t2[g2];
          }
        };
      }
      function Do(t2, e2, i2, n2, r2, s2) {
        return n2 = void 0 === n2 || n2, i2 = void 0 !== i2 ? i2 : 0, function(o2, a2, l2, h2) {
          if (void 0 !== o2) {
            const c2 = r2 ? Ao(e2, r2, l2, s2) : e2;
            if (h2)
              return n2 ? Oo(o2, c2, i2) : ii(o2, i2, c2);
            const u2 = 1e-9, d2 = Math.ceil(Math.log(e2 / c2) / Math.log(t2) - u2), g2 = -a2 * (0.5 - u2) + 0.5, f2 = Math.min(c2, o2), p2 = Math.floor(Math.log(e2 / f2) / Math.log(t2) + g2), m2 = Math.max(d2, p2);
            return ii(e2 / Math.pow(t2, m2), i2, c2);
          }
        };
      }
      function ko(t2, e2, i2, n2, r2) {
        return i2 = void 0 === i2 || i2, function(s2, o2, a2, l2) {
          if (void 0 !== s2) {
            const o3 = n2 ? Ao(t2, n2, a2, r2) : t2;
            return i2 && l2 ? Oo(s2, o3, e2) : ii(s2, e2, o3);
          }
        };
      }
      function Go(t2) {
        return void 0 !== t2 ? 0 : void 0;
      }
      function jo(t2) {
        return void 0 !== t2 ? t2 : void 0;
      }
      function Bo(t2) {
        const e2 = 2 * Math.PI / t2;
        return function(t3, i2) {
          return i2 ? t3 : void 0 !== t3 ? t3 = Math.floor(t3 / e2 + 0.5) * e2 : void 0;
        };
      }
      function Uo(t2) {
        return t2 = t2 || ai(5), function(e2, i2) {
          return i2 ? e2 : void 0 !== e2 ? Math.abs(e2) <= t2 ? 0 : e2 : void 0;
        };
      }
      class zo extends V {
        constructor(t2) {
          super(), this.on, this.once, this.un, t2 = Object.assign({}, t2), this.hints_ = [0, 0], this.animations_ = [], this.updateAnimationKey_, this.projection_ = Wi(t2.projection, "EPSG:3857"), this.viewportSize_ = [100, 100], this.targetCenter_ = null, this.targetResolution_, this.targetRotation_, this.nextCenter_ = null, this.nextResolution_, this.nextRotation_, this.cancelAnchor_ = void 0, t2.projection && Di(), t2.center && (t2.center = rn(t2.center, this.projection_)), t2.extent && (t2.extent = on(t2.extent, this.projection_)), this.applyOptions_(t2);
        }
        applyOptions_(t2) {
          const e2 = Object.assign({}, t2);
          for (const t3 in Io)
            delete e2[t3];
          this.setProperties(e2, true);
          const i2 = Wo(t2);
          this.maxResolution_ = i2.maxResolution, this.minResolution_ = i2.minResolution, this.zoomFactor_ = i2.zoomFactor, this.resolutions_ = t2.resolutions, this.padding_ = t2.padding, this.minZoom_ = i2.minZoom;
          const n2 = Vo(t2), r2 = i2.constraint, s2 = Zo(t2);
          this.constraints_ = { center: n2, resolution: r2, rotation: s2 }, this.setRotation(void 0 !== t2.rotation ? t2.rotation : 0), this.setCenterInternal(void 0 !== t2.center ? t2.center : null), void 0 !== t2.resolution ? this.setResolution(t2.resolution) : void 0 !== t2.zoom && this.setZoom(t2.zoom);
        }
        get padding() {
          return this.padding_;
        }
        set padding(t2) {
          let e2 = this.padding_;
          this.padding_ = t2;
          const i2 = this.getCenter();
          if (i2) {
            const n2 = t2 || [0, 0, 0, 0];
            e2 = e2 || [0, 0, 0, 0];
            const r2 = this.getResolution(), s2 = r2 / 2 * (n2[3] - e2[3] + e2[1] - n2[1]), o2 = r2 / 2 * (n2[0] - e2[0] + e2[2] - n2[2]);
            this.setCenterInternal([i2[0] + s2, i2[1] - o2]);
          }
        }
        getUpdatedOptions_(t2) {
          const e2 = this.getProperties();
          return void 0 !== e2.resolution ? e2.resolution = this.getResolution() : e2.zoom = this.getZoom(), e2.center = this.getCenterInternal(), e2.rotation = this.getRotation(), Object.assign({}, e2, t2);
        }
        animate(t2) {
          this.isDef() && !this.getAnimating() && this.resolveConstraints(0);
          const e2 = new Array(arguments.length);
          for (let t3 = 0; t3 < e2.length; ++t3) {
            let i2 = arguments[t3];
            i2.center && (i2 = Object.assign({}, i2), i2.center = rn(i2.center, this.getProjection())), i2.anchor && (i2 = Object.assign({}, i2), i2.anchor = rn(i2.anchor, this.getProjection())), e2[t3] = i2;
          }
          this.animateInternal.apply(this, e2);
        }
        animateInternal(t2) {
          let e2, i2 = arguments.length;
          i2 > 1 && "function" == typeof arguments[i2 - 1] && (e2 = arguments[i2 - 1], --i2);
          let n2 = 0;
          for (; n2 < i2 && !this.isDef(); ++n2) {
            const t3 = arguments[n2];
            t3.center && this.setCenterInternal(t3.center), void 0 !== t3.zoom ? this.setZoom(t3.zoom) : t3.resolution && this.setResolution(t3.resolution), void 0 !== t3.rotation && this.setRotation(t3.rotation);
          }
          if (n2 === i2)
            return void (e2 && Xo(e2, true));
          let r2 = Date.now(), s2 = this.targetCenter_.slice(), o2 = this.targetResolution_, a2 = this.targetRotation_;
          const l2 = [];
          for (; n2 < i2; ++n2) {
            const t3 = arguments[n2], i3 = { start: r2, complete: false, anchor: t3.anchor, duration: void 0 !== t3.duration ? t3.duration : 1e3, easing: t3.easing || nt, callback: e2 };
            if (t3.center && (i3.sourceCenter = s2, i3.targetCenter = t3.center.slice(), s2 = i3.targetCenter), void 0 !== t3.zoom ? (i3.sourceResolution = o2, i3.targetResolution = this.getResolutionForZoom(t3.zoom), o2 = i3.targetResolution) : t3.resolution && (i3.sourceResolution = o2, i3.targetResolution = t3.resolution, o2 = i3.targetResolution), void 0 !== t3.rotation) {
              i3.sourceRotation = a2;
              const e3 = li(t3.rotation - a2 + Math.PI, 2 * Math.PI) - Math.PI;
              i3.targetRotation = a2 + e3, a2 = i3.targetRotation;
            }
            Yo(i3) ? i3.complete = true : r2 += i3.duration, l2.push(i3);
          }
          this.animations_.push(l2), this.setHint(Ro, 1), this.updateAnimations_();
        }
        getAnimating() {
          return this.hints_[Ro] > 0;
        }
        getInteracting() {
          return this.hints_[Po] > 0;
        }
        cancelAnimations() {
          let t2;
          this.setHint(Ro, -this.hints_[Ro]);
          for (let e2 = 0, i2 = this.animations_.length; e2 < i2; ++e2) {
            const i3 = this.animations_[e2];
            if (i3[0].callback && Xo(i3[0].callback, false), !t2)
              for (let e3 = 0, n2 = i3.length; e3 < n2; ++e3) {
                const n3 = i3[e3];
                if (!n3.complete) {
                  t2 = n3.anchor;
                  break;
                }
              }
          }
          this.animations_.length = 0, this.cancelAnchor_ = t2, this.nextCenter_ = null, this.nextResolution_ = NaN, this.nextRotation_ = NaN;
        }
        updateAnimations_() {
          if (void 0 !== this.updateAnimationKey_ && (cancelAnimationFrame(this.updateAnimationKey_), this.updateAnimationKey_ = void 0), !this.getAnimating())
            return;
          const t2 = Date.now();
          let e2 = false;
          for (let i2 = this.animations_.length - 1; i2 >= 0; --i2) {
            const n2 = this.animations_[i2];
            let r2 = true;
            for (let i3 = 0, s2 = n2.length; i3 < s2; ++i3) {
              const s3 = n2[i3];
              if (s3.complete)
                continue;
              const o2 = t2 - s3.start;
              let a2 = s3.duration > 0 ? o2 / s3.duration : 1;
              a2 >= 1 ? (s3.complete = true, a2 = 1) : r2 = false;
              const l2 = s3.easing(a2);
              if (s3.sourceCenter) {
                const t3 = s3.sourceCenter[0], e3 = s3.sourceCenter[1], i4 = s3.targetCenter[0], n3 = s3.targetCenter[1];
                this.nextCenter_ = s3.targetCenter;
                const r3 = t3 + l2 * (i4 - t3), o3 = e3 + l2 * (n3 - e3);
                this.targetCenter_ = [r3, o3];
              }
              if (s3.sourceResolution && s3.targetResolution) {
                const t3 = 1 === l2 ? s3.targetResolution : s3.sourceResolution + l2 * (s3.targetResolution - s3.sourceResolution);
                if (s3.anchor) {
                  const e3 = this.getViewportSize_(this.getRotation()), i4 = this.constraints_.resolution(t3, 0, e3, true);
                  this.targetCenter_ = this.calculateCenterZoom(i4, s3.anchor);
                }
                this.nextResolution_ = s3.targetResolution, this.targetResolution_ = t3, this.applyTargetState_(true);
              }
              if (void 0 !== s3.sourceRotation && void 0 !== s3.targetRotation) {
                const t3 = 1 === l2 ? li(s3.targetRotation + Math.PI, 2 * Math.PI) - Math.PI : s3.sourceRotation + l2 * (s3.targetRotation - s3.sourceRotation);
                if (s3.anchor) {
                  const e3 = this.constraints_.rotation(t3, true);
                  this.targetCenter_ = this.calculateCenterRotate(e3, s3.anchor);
                }
                this.nextRotation_ = s3.targetRotation, this.targetRotation_ = t3;
              }
              if (this.applyTargetState_(true), e2 = true, !s3.complete)
                break;
            }
            if (r2) {
              this.animations_[i2] = null, this.setHint(Ro, -1), this.nextCenter_ = null, this.nextResolution_ = NaN, this.nextRotation_ = NaN;
              const t3 = n2[0].callback;
              t3 && Xo(t3, true);
            }
          }
          this.animations_ = this.animations_.filter(Boolean), e2 && void 0 === this.updateAnimationKey_ && (this.updateAnimationKey_ = requestAnimationFrame(this.updateAnimations_.bind(this)));
        }
        calculateCenterRotate(t2, e2) {
          let i2;
          const n2 = this.getCenterInternal();
          return void 0 !== n2 && (i2 = [n2[0] - e2[0], n2[1] - e2[1]], wi(i2, t2 - this.getRotation()), mi(i2, e2)), i2;
        }
        calculateCenterZoom(t2, e2) {
          let i2;
          const n2 = this.getCenterInternal(), r2 = this.getResolution();
          if (void 0 !== n2 && void 0 !== r2) {
            i2 = [e2[0] - t2 * (e2[0] - n2[0]) / r2, e2[1] - t2 * (e2[1] - n2[1]) / r2];
          }
          return i2;
        }
        getViewportSize_(t2) {
          const e2 = this.viewportSize_;
          if (t2) {
            const i2 = e2[0], n2 = e2[1];
            return [Math.abs(i2 * Math.cos(t2)) + Math.abs(n2 * Math.sin(t2)), Math.abs(i2 * Math.sin(t2)) + Math.abs(n2 * Math.cos(t2))];
          }
          return e2;
        }
        setViewportSize(t2) {
          this.viewportSize_ = Array.isArray(t2) ? t2.slice() : [100, 100], this.getAnimating() || this.resolveConstraints(0);
        }
        getCenter() {
          const t2 = this.getCenterInternal();
          return t2 ? nn(t2, this.getProjection()) : t2;
        }
        getCenterInternal() {
          return this.get(Io.CENTER);
        }
        getConstraints() {
          return this.constraints_;
        }
        getConstrainResolution() {
          return this.get("constrainResolution");
        }
        getHints(t2) {
          return void 0 !== t2 ? (t2[0] = this.hints_[0], t2[1] = this.hints_[1], t2) : this.hints_.slice();
        }
        calculateExtent(t2) {
          return sn(this.calculateExtentInternal(t2), this.getProjection());
        }
        calculateExtentInternal(t2) {
          t2 = t2 || this.getViewportSizeMinusPadding_();
          const e2 = this.getCenterInternal();
          at(e2, 1);
          const i2 = this.getResolution();
          at(void 0 !== i2, 2);
          const n2 = this.getRotation();
          return at(void 0 !== n2, 3), pe(e2, i2, n2, t2);
        }
        getMaxResolution() {
          return this.maxResolution_;
        }
        getMinResolution() {
          return this.minResolution_;
        }
        getMaxZoom() {
          return this.getZoomForResolution(this.minResolution_);
        }
        setMaxZoom(t2) {
          this.applyOptions_(this.getUpdatedOptions_({ maxZoom: t2 }));
        }
        getMinZoom() {
          return this.getZoomForResolution(this.maxResolution_);
        }
        setMinZoom(t2) {
          this.applyOptions_(this.getUpdatedOptions_({ minZoom: t2 }));
        }
        setConstrainResolution(t2) {
          this.applyOptions_(this.getUpdatedOptions_({ constrainResolution: t2 }));
        }
        getProjection() {
          return this.projection_;
        }
        getResolution() {
          return this.get(Io.RESOLUTION);
        }
        getResolutions() {
          return this.resolutions_;
        }
        getResolutionForExtent(t2, e2) {
          return this.getResolutionForExtentInternal(on(t2, this.getProjection()), e2);
        }
        getResolutionForExtentInternal(t2, e2) {
          e2 = e2 || this.getViewportSizeMinusPadding_();
          const i2 = Se(t2) / e2[0], n2 = _e(t2) / e2[1];
          return Math.max(i2, n2);
        }
        getResolutionForValueFunction(t2) {
          t2 = t2 || 2;
          const e2 = this.getConstrainedResolution(this.maxResolution_), i2 = this.minResolution_, n2 = Math.log(e2 / i2) / Math.log(t2);
          return function(i3) {
            return e2 / Math.pow(t2, i3 * n2);
          };
        }
        getRotation() {
          return this.get(Io.ROTATION);
        }
        getValueForResolutionFunction(t2) {
          const e2 = Math.log(t2 || 2), i2 = this.getConstrainedResolution(this.maxResolution_), n2 = this.minResolution_, r2 = Math.log(i2 / n2) / e2;
          return function(t3) {
            return Math.log(i2 / t3) / e2 / r2;
          };
        }
        getViewportSizeMinusPadding_(t2) {
          let e2 = this.getViewportSize_(t2);
          const i2 = this.padding_;
          return i2 && (e2 = [e2[0] - i2[1] - i2[3], e2[1] - i2[0] - i2[2]]), e2;
        }
        getState() {
          const t2 = this.getProjection(), e2 = this.getResolution(), i2 = this.getRotation();
          let n2 = this.getCenterInternal();
          const r2 = this.padding_;
          if (r2) {
            const t3 = this.getViewportSizeMinusPadding_();
            n2 = Ko(n2, this.getViewportSize_(), [t3[0] / 2 + r2[3], t3[1] / 2 + r2[0]], e2, i2);
          }
          return { center: n2.slice(0), projection: void 0 !== t2 ? t2 : null, resolution: e2, nextCenter: this.nextCenter_, nextResolution: this.nextResolution_, nextRotation: this.nextRotation_, rotation: i2, zoom: this.getZoom() };
        }
        getZoom() {
          let t2;
          const e2 = this.getResolution();
          return void 0 !== e2 && (t2 = this.getZoomForResolution(e2)), t2;
        }
        getZoomForResolution(t2) {
          let e2, i2, n2 = this.minZoom_ || 0;
          if (this.resolutions_) {
            const r2 = l(this.resolutions_, t2, 1);
            n2 = r2, e2 = this.resolutions_[r2], i2 = r2 == this.resolutions_.length - 1 ? 2 : e2 / this.resolutions_[r2 + 1];
          } else
            e2 = this.maxResolution_, i2 = this.zoomFactor_;
          return n2 + Math.log(e2 / t2) / Math.log(i2);
        }
        getResolutionForZoom(t2) {
          if (this.resolutions_) {
            if (this.resolutions_.length <= 1)
              return 0;
            const e2 = ii(Math.floor(t2), 0, this.resolutions_.length - 2), i2 = this.resolutions_[e2] / this.resolutions_[e2 + 1];
            return this.resolutions_[e2] / Math.pow(i2, ii(t2 - e2, 0, 1));
          }
          return this.maxResolution_ / Math.pow(this.zoomFactor_, t2 - this.minZoom_);
        }
        fit(t2, e2) {
          let i2;
          if (at(Array.isArray(t2) || "function" == typeof t2.getSimplifiedGeometry, 24), Array.isArray(t2)) {
            at(!Ee(t2), 25);
            i2 = gr(on(t2, this.getProjection()));
          } else if ("Circle" === t2.getType()) {
            const e3 = on(t2.getExtent(), this.getProjection());
            i2 = gr(e3), i2.rotate(this.getRotation(), ge(e3));
          } else {
            const e3 = en();
            i2 = e3 ? t2.clone().transform(e3, this.getProjection()) : t2;
          }
          this.fitInternal(i2, e2);
        }
        rotatedExtentForGeometry(t2) {
          const e2 = this.getRotation(), i2 = Math.cos(e2), n2 = Math.sin(-e2), r2 = t2.getFlatCoordinates(), s2 = t2.getStride();
          let o2 = 1 / 0, a2 = 1 / 0, l2 = -1 / 0, h2 = -1 / 0;
          for (let t3 = 0, e3 = r2.length; t3 < e3; t3 += s2) {
            const e4 = r2[t3] * i2 - r2[t3 + 1] * n2, s3 = r2[t3] * n2 + r2[t3 + 1] * i2;
            o2 = Math.min(o2, e4), a2 = Math.min(a2, s3), l2 = Math.max(l2, e4), h2 = Math.max(h2, s3);
          }
          return [o2, a2, l2, h2];
        }
        fitInternal(t2, e2) {
          let i2 = (e2 = e2 || {}).size;
          i2 || (i2 = this.getViewportSizeMinusPadding_());
          const n2 = void 0 !== e2.padding ? e2.padding : [0, 0, 0, 0], r2 = void 0 !== e2.nearest && e2.nearest;
          let s2;
          s2 = void 0 !== e2.minResolution ? e2.minResolution : void 0 !== e2.maxZoom ? this.getResolutionForZoom(e2.maxZoom) : 0;
          const o2 = this.rotatedExtentForGeometry(t2);
          let a2 = this.getResolutionForExtentInternal(o2, [i2[0] - n2[1] - n2[3], i2[1] - n2[0] - n2[2]]);
          a2 = isNaN(a2) ? s2 : Math.max(a2, s2), a2 = this.getConstrainedResolution(a2, r2 ? 0 : 1);
          const l2 = this.getRotation(), h2 = Math.sin(l2), c2 = Math.cos(l2), u2 = ge(o2);
          u2[0] += (n2[1] - n2[3]) / 2 * a2, u2[1] += (n2[0] - n2[2]) / 2 * a2;
          const d2 = u2[0] * c2 - u2[1] * h2, g2 = u2[1] * c2 + u2[0] * h2, f2 = this.getConstrainedCenter([d2, g2], a2), m2 = e2.callback ? e2.callback : p;
          void 0 !== e2.duration ? this.animateInternal({ resolution: a2, center: f2, duration: e2.duration, easing: e2.easing }, m2) : (this.targetResolution_ = a2, this.targetCenter_ = f2, this.applyTargetState_(false, true), Xo(m2, true));
        }
        centerOn(t2, e2, i2) {
          this.centerOnInternal(rn(t2, this.getProjection()), e2, i2);
        }
        centerOnInternal(t2, e2, i2) {
          this.setCenterInternal(Ko(t2, e2, i2, this.getResolution(), this.getRotation()));
        }
        calculateCenterShift(t2, e2, i2, n2) {
          let r2;
          const s2 = this.padding_;
          if (s2 && t2) {
            const o2 = this.getViewportSizeMinusPadding_(-i2), a2 = Ko(t2, n2, [o2[0] / 2 + s2[3], o2[1] / 2 + s2[0]], e2, i2);
            r2 = [t2[0] - a2[0], t2[1] - a2[1]];
          }
          return r2;
        }
        isDef() {
          return !!this.getCenterInternal() && void 0 !== this.getResolution();
        }
        adjustCenter(t2) {
          const e2 = nn(this.targetCenter_, this.getProjection());
          this.setCenter([e2[0] + t2[0], e2[1] + t2[1]]);
        }
        adjustCenterInternal(t2) {
          const e2 = this.targetCenter_;
          this.setCenterInternal([e2[0] + t2[0], e2[1] + t2[1]]);
        }
        adjustResolution(t2, e2) {
          e2 = e2 && rn(e2, this.getProjection()), this.adjustResolutionInternal(t2, e2);
        }
        adjustResolutionInternal(t2, e2) {
          const i2 = this.getAnimating() || this.getInteracting(), n2 = this.getViewportSize_(this.getRotation()), r2 = this.constraints_.resolution(this.targetResolution_ * t2, 0, n2, i2);
          e2 && (this.targetCenter_ = this.calculateCenterZoom(r2, e2)), this.targetResolution_ *= t2, this.applyTargetState_();
        }
        adjustZoom(t2, e2) {
          this.adjustResolution(Math.pow(this.zoomFactor_, -t2), e2);
        }
        adjustRotation(t2, e2) {
          e2 && (e2 = rn(e2, this.getProjection())), this.adjustRotationInternal(t2, e2);
        }
        adjustRotationInternal(t2, e2) {
          const i2 = this.getAnimating() || this.getInteracting(), n2 = this.constraints_.rotation(this.targetRotation_ + t2, i2);
          e2 && (this.targetCenter_ = this.calculateCenterRotate(n2, e2)), this.targetRotation_ += t2, this.applyTargetState_();
        }
        setCenter(t2) {
          this.setCenterInternal(t2 ? rn(t2, this.getProjection()) : t2);
        }
        setCenterInternal(t2) {
          this.targetCenter_ = t2, this.applyTargetState_();
        }
        setHint(t2, e2) {
          return this.hints_[t2] += e2, this.changed(), this.hints_[t2];
        }
        setResolution(t2) {
          this.targetResolution_ = t2, this.applyTargetState_();
        }
        setRotation(t2) {
          this.targetRotation_ = t2, this.applyTargetState_();
        }
        setZoom(t2) {
          this.setResolution(this.getResolutionForZoom(t2));
        }
        applyTargetState_(t2, e2) {
          const i2 = this.getAnimating() || this.getInteracting() || e2, n2 = this.constraints_.rotation(this.targetRotation_, i2), r2 = this.getViewportSize_(n2), s2 = this.constraints_.resolution(this.targetResolution_, 0, r2, i2), o2 = this.constraints_.center(this.targetCenter_, s2, r2, i2, this.calculateCenterShift(this.targetCenter_, s2, n2, r2));
          this.get(Io.ROTATION) !== n2 && this.set(Io.ROTATION, n2), this.get(Io.RESOLUTION) !== s2 && (this.set(Io.RESOLUTION, s2), this.set("zoom", this.getZoom(), true)), o2 && this.get(Io.CENTER) && Si(this.get(Io.CENTER), o2) || this.set(Io.CENTER, o2), this.getAnimating() && !t2 && this.cancelAnimations(), this.cancelAnchor_ = void 0;
        }
        resolveConstraints(t2, e2, i2) {
          t2 = void 0 !== t2 ? t2 : 200;
          const n2 = e2 || 0, r2 = this.constraints_.rotation(this.targetRotation_), s2 = this.getViewportSize_(r2), o2 = this.constraints_.resolution(this.targetResolution_, n2, s2), a2 = this.constraints_.center(this.targetCenter_, o2, s2, false, this.calculateCenterShift(this.targetCenter_, o2, r2, s2));
          if (0 === t2 && !this.cancelAnchor_)
            return this.targetResolution_ = o2, this.targetRotation_ = r2, this.targetCenter_ = a2, void this.applyTargetState_();
          i2 = i2 || (0 === t2 ? this.cancelAnchor_ : void 0), this.cancelAnchor_ = void 0, this.getResolution() === o2 && this.getRotation() === r2 && this.getCenterInternal() && Si(this.getCenterInternal(), a2) || (this.getAnimating() && this.cancelAnimations(), this.animateInternal({ rotation: r2, center: a2, resolution: o2, duration: t2, easing: it, anchor: i2 }));
        }
        beginInteraction() {
          this.resolveConstraints(0), this.setHint(Po, 1);
        }
        endInteraction(t2, e2, i2) {
          i2 = i2 && rn(i2, this.getProjection()), this.endInteractionInternal(t2, e2, i2);
        }
        endInteractionInternal(t2, e2, i2) {
          this.setHint(Po, -1), this.resolveConstraints(t2, e2, i2);
        }
        getConstrainedCenter(t2, e2) {
          const i2 = this.getViewportSize_(this.getRotation());
          return this.constraints_.center(t2, e2 || this.getResolution(), i2);
        }
        getConstrainedZoom(t2, e2) {
          const i2 = this.getResolutionForZoom(t2);
          return this.getZoomForResolution(this.getConstrainedResolution(i2, e2));
        }
        getConstrainedResolution(t2, e2) {
          e2 = e2 || 0;
          const i2 = this.getViewportSize_(this.getRotation());
          return this.constraints_.resolution(t2, e2, i2);
        }
      }
      function Xo(t2, e2) {
        setTimeout(function() {
          t2(e2);
        }, 0);
      }
      function Vo(t2) {
        if (void 0 !== t2.extent) {
          const e3 = void 0 === t2.smoothExtentConstraint || t2.smoothExtentConstraint;
          return Mo(t2.extent, t2.constrainOnlyCenter, e3);
        }
        const e2 = Wi(t2.projection, "EPSG:3857");
        if (true !== t2.multiWorld && e2.isGlobal()) {
          const t3 = e2.getExtent().slice();
          return t3[0] = -1 / 0, t3[2] = 1 / 0, Mo(t3, false, false);
        }
        return Fo;
      }
      function Wo(t2) {
        let e2, i2, n2;
        let r2 = void 0 !== t2.minZoom ? t2.minZoom : 0, s2 = void 0 !== t2.maxZoom ? t2.maxZoom : 28;
        const o2 = void 0 !== t2.zoomFactor ? t2.zoomFactor : 2, a2 = void 0 !== t2.multiWorld && t2.multiWorld, l2 = void 0 === t2.smoothResolutionConstraint || t2.smoothResolutionConstraint, h2 = void 0 !== t2.showFullExtent && t2.showFullExtent, c2 = Wi(t2.projection, "EPSG:3857"), u2 = c2.getExtent();
        let d2 = t2.constrainOnlyCenter, g2 = t2.extent;
        if (a2 || g2 || !c2.isGlobal() || (d2 = false, g2 = u2), void 0 !== t2.resolutions) {
          const o3 = t2.resolutions;
          i2 = o3[r2], n2 = void 0 !== o3[s2] ? o3[s2] : o3[o3.length - 1], e2 = t2.constrainResolution ? No(o3, l2, !d2 && g2, h2) : ko(i2, n2, l2, !d2 && g2, h2);
        } else {
          const a3 = (u2 ? Math.max(Se(u2), _e(u2)) : 360 * Fe.degrees / c2.getMetersPerUnit()) / Lo / Math.pow(2, 0), f2 = a3 / Math.pow(2, 28);
          i2 = t2.maxResolution, void 0 !== i2 ? r2 = 0 : i2 = a3 / Math.pow(o2, r2), n2 = t2.minResolution, void 0 === n2 && (n2 = void 0 !== t2.maxZoom ? void 0 !== t2.maxResolution ? i2 / Math.pow(o2, s2) : a3 / Math.pow(o2, s2) : f2), s2 = r2 + Math.floor(Math.log(i2 / n2) / Math.log(o2)), n2 = i2 / Math.pow(o2, s2 - r2), e2 = t2.constrainResolution ? Do(o2, i2, n2, l2, !d2 && g2, h2) : ko(i2, n2, l2, !d2 && g2, h2);
        }
        return { constraint: e2, maxResolution: i2, minResolution: n2, minZoom: r2, zoomFactor: o2 };
      }
      function Zo(t2) {
        if (void 0 === t2.enableRotation || t2.enableRotation) {
          const e2 = t2.constrainRotation;
          return void 0 === e2 || true === e2 ? Uo() : false === e2 ? jo : "number" == typeof e2 ? Bo(e2) : jo;
        }
        return Go;
      }
      function Yo(t2) {
        return !(t2.sourceCenter && t2.targetCenter && !Si(t2.sourceCenter, t2.targetCenter)) && (t2.sourceResolution === t2.targetResolution && t2.sourceRotation === t2.targetRotation);
      }
      function Ko(t2, e2, i2, n2, r2) {
        const s2 = Math.cos(-r2);
        let o2 = Math.sin(-r2), a2 = t2[0] * s2 - t2[1] * o2, l2 = t2[1] * s2 + t2[0] * o2;
        a2 += (e2[0] / 2 - i2[0]) * n2, l2 += (i2[1] - e2[1] / 2) * n2, o2 = -o2;
        return [a2 * s2 - l2 * o2, l2 * s2 + a2 * o2];
      }
      class qo extends V {
        constructor(t2) {
          super();
          const e2 = t2.element;
          !e2 || t2.target || e2.style.pointerEvents || (e2.style.pointerEvents = "auto"), this.element = e2 || null, this.target_ = null, this.map_ = null, this.listenerKeys = [], t2.render && (this.render = t2.render), t2.target && this.setTarget(t2.target);
        }
        disposeInternal() {
          Ur(this.element), super.disposeInternal();
        }
        getMap() {
          return this.map_;
        }
        setMap(t2) {
          this.map_ && Ur(this.element);
          for (let t3 = 0, e2 = this.listenerKeys.length; t3 < e2; ++t3)
            k(this.listenerKeys[t3]);
          if (this.listenerKeys.length = 0, this.map_ = t2, t2) {
            (this.target_ ? this.target_ : t2.getOverlayContainerStopEvent()).appendChild(this.element), this.render !== p && this.listenerKeys.push(N(t2, fo, this.render, this)), t2.render();
          }
        }
        render(t2) {
        }
        setTarget(t2) {
          this.target_ = "string" == typeof t2 ? document.getElementById(t2) : t2;
        }
      }
      class Ho extends qo {
        constructor(t2) {
          t2 = t2 || {}, super({ element: document.createElement("div"), render: t2.render, target: t2.target }), this.ulElement_ = document.createElement("ul"), this.collapsed_ = void 0 === t2.collapsed || t2.collapsed, this.userCollapsed_ = this.collapsed_, this.overrideCollapsible_ = void 0 !== t2.collapsible, this.collapsible_ = void 0 === t2.collapsible || t2.collapsible, this.collapsible_ || (this.collapsed_ = false);
          const e2 = void 0 !== t2.className ? t2.className : "ol-attribution", i2 = void 0 !== t2.tipLabel ? t2.tipLabel : "Attributions", n2 = void 0 !== t2.expandClassName ? t2.expandClassName : e2 + "-expand", r2 = void 0 !== t2.collapseLabel ? t2.collapseLabel : "\u203A", s2 = void 0 !== t2.collapseClassName ? t2.collapseClassName : e2 + "-collapse";
          "string" == typeof r2 ? (this.collapseLabel_ = document.createElement("span"), this.collapseLabel_.textContent = r2, this.collapseLabel_.className = s2) : this.collapseLabel_ = r2;
          const o2 = void 0 !== t2.label ? t2.label : "i";
          "string" == typeof o2 ? (this.label_ = document.createElement("span"), this.label_.textContent = o2, this.label_.className = n2) : this.label_ = o2;
          const a2 = this.collapsible_ && !this.collapsed_ ? this.collapseLabel_ : this.label_;
          this.toggleButton_ = document.createElement("button"), this.toggleButton_.setAttribute("type", "button"), this.toggleButton_.setAttribute("aria-expanded", String(!this.collapsed_)), this.toggleButton_.title = i2, this.toggleButton_.appendChild(a2), this.toggleButton_.addEventListener(T, this.handleClick_.bind(this), false);
          const l2 = e2 + " ol-unselectable " + Is + (this.collapsed_ && this.collapsible_ ? " ol-collapsed" : "") + (this.collapsible_ ? "" : " ol-uncollapsible"), h2 = this.element;
          h2.className = l2, h2.appendChild(this.toggleButton_), h2.appendChild(this.ulElement_), this.renderedAttributions_ = [], this.renderedVisible_ = true;
        }
        collectSourceAttributions_(t2) {
          const e2 = {}, i2 = [];
          let n2 = true;
          const r2 = t2.layerStatesArray;
          for (let s2 = 0, o2 = r2.length; s2 < o2; ++s2) {
            const o3 = r2[s2];
            if (!Ss(o3, t2.viewState))
              continue;
            const a2 = o3.layer.getSource();
            if (!a2)
              continue;
            const l2 = a2.getAttributions();
            if (!l2)
              continue;
            const h2 = l2(t2);
            if (h2)
              if (n2 = n2 && false !== a2.getAttributionsCollapsible(), Array.isArray(h2))
                for (let t3 = 0, n3 = h2.length; t3 < n3; ++t3)
                  h2[t3] in e2 || (i2.push(h2[t3]), e2[h2[t3]] = true);
              else
                h2 in e2 || (i2.push(h2), e2[h2] = true);
          }
          return this.overrideCollapsible_ || this.setCollapsible(n2), i2;
        }
        updateElement_(t2) {
          if (!t2)
            return void (this.renderedVisible_ && (this.element.style.display = "none", this.renderedVisible_ = false));
          const e2 = this.collectSourceAttributions_(t2), i2 = e2.length > 0;
          if (this.renderedVisible_ != i2 && (this.element.style.display = i2 ? "" : "none", this.renderedVisible_ = i2), !u(e2, this.renderedAttributions_)) {
            zr(this.ulElement_);
            for (let t3 = 0, i3 = e2.length; t3 < i3; ++t3) {
              const i4 = document.createElement("li");
              i4.innerHTML = e2[t3], this.ulElement_.appendChild(i4);
            }
            this.renderedAttributions_ = e2;
          }
        }
        handleClick_(t2) {
          t2.preventDefault(), this.handleToggle_(), this.userCollapsed_ = this.collapsed_;
        }
        handleToggle_() {
          this.element.classList.toggle(Ls), this.collapsed_ ? Br(this.collapseLabel_, this.label_) : Br(this.label_, this.collapseLabel_), this.collapsed_ = !this.collapsed_, this.toggleButton_.setAttribute("aria-expanded", String(!this.collapsed_));
        }
        getCollapsible() {
          return this.collapsible_;
        }
        setCollapsible(t2) {
          this.collapsible_ !== t2 && (this.collapsible_ = t2, this.element.classList.toggle("ol-uncollapsible"), this.userCollapsed_ && this.handleToggle_());
        }
        setCollapsed(t2) {
          this.userCollapsed_ = t2, this.collapsible_ && this.collapsed_ !== t2 && this.handleToggle_();
        }
        getCollapsed() {
          return this.collapsed_;
        }
        render(t2) {
          this.updateElement_(t2.frameState);
        }
      }
      class $o extends qo {
        constructor(t2) {
          t2 = t2 || {}, super({ element: document.createElement("div"), render: t2.render, target: t2.target });
          const e2 = void 0 !== t2.className ? t2.className : "ol-rotate", i2 = void 0 !== t2.label ? t2.label : "\u21E7", n2 = void 0 !== t2.compassClassName ? t2.compassClassName : "ol-compass";
          this.label_ = null, "string" == typeof i2 ? (this.label_ = document.createElement("span"), this.label_.className = n2, this.label_.textContent = i2) : (this.label_ = i2, this.label_.classList.add(n2));
          const r2 = t2.tipLabel ? t2.tipLabel : "Reset rotation", s2 = document.createElement("button");
          s2.className = e2 + "-reset", s2.setAttribute("type", "button"), s2.title = r2, s2.appendChild(this.label_), s2.addEventListener(T, this.handleClick_.bind(this), false);
          const o2 = e2 + " ol-unselectable " + Is, a2 = this.element;
          a2.className = o2, a2.appendChild(s2), this.callResetNorth_ = t2.resetNorth ? t2.resetNorth : void 0, this.duration_ = void 0 !== t2.duration ? t2.duration : 250, this.autoHide_ = void 0 === t2.autoHide || t2.autoHide, this.rotation_ = void 0, this.autoHide_ && this.element.classList.add(Cs);
        }
        handleClick_(t2) {
          t2.preventDefault(), void 0 !== this.callResetNorth_ ? this.callResetNorth_() : this.resetNorth_();
        }
        resetNorth_() {
          const t2 = this.getMap().getView();
          if (!t2)
            return;
          const e2 = t2.getRotation();
          void 0 !== e2 && (this.duration_ > 0 && e2 % (2 * Math.PI) != 0 ? t2.animate({ rotation: 0, duration: this.duration_, easing: it }) : t2.setRotation(0));
        }
        render(t2) {
          const e2 = t2.frameState;
          if (!e2)
            return;
          const i2 = e2.viewState.rotation;
          if (i2 != this.rotation_) {
            const t3 = "rotate(" + i2 + "rad)";
            if (this.autoHide_) {
              const t4 = this.element.classList.contains(Cs);
              t4 || 0 !== i2 ? t4 && 0 !== i2 && this.element.classList.remove(Cs) : this.element.classList.add(Cs);
            }
            this.label_.style.transform = t3;
          }
          this.rotation_ = i2;
        }
      }
      class Jo extends qo {
        constructor(t2) {
          t2 = t2 || {}, super({ element: document.createElement("div"), target: t2.target });
          const e2 = void 0 !== t2.className ? t2.className : "ol-zoom", i2 = void 0 !== t2.delta ? t2.delta : 1, n2 = void 0 !== t2.zoomInClassName ? t2.zoomInClassName : e2 + "-in", r2 = void 0 !== t2.zoomOutClassName ? t2.zoomOutClassName : e2 + "-out", s2 = void 0 !== t2.zoomInLabel ? t2.zoomInLabel : "+", o2 = void 0 !== t2.zoomOutLabel ? t2.zoomOutLabel : "\u2013", a2 = void 0 !== t2.zoomInTipLabel ? t2.zoomInTipLabel : "Zoom in", l2 = void 0 !== t2.zoomOutTipLabel ? t2.zoomOutTipLabel : "Zoom out", h2 = document.createElement("button");
          h2.className = n2, h2.setAttribute("type", "button"), h2.title = a2, h2.appendChild("string" == typeof s2 ? document.createTextNode(s2) : s2), h2.addEventListener(T, this.handleClick_.bind(this, i2), false);
          const c2 = document.createElement("button");
          c2.className = r2, c2.setAttribute("type", "button"), c2.title = l2, c2.appendChild("string" == typeof o2 ? document.createTextNode(o2) : o2), c2.addEventListener(T, this.handleClick_.bind(this, -i2), false);
          const u2 = e2 + " ol-unselectable " + Is, d2 = this.element;
          d2.className = u2, d2.appendChild(h2), d2.appendChild(c2), this.duration_ = void 0 !== t2.duration ? t2.duration : 250;
        }
        handleClick_(t2, e2) {
          e2.preventDefault(), this.zoomByDelta_(t2);
        }
        zoomByDelta_(t2) {
          const e2 = this.getMap().getView();
          if (!e2)
            return;
          const i2 = e2.getZoom();
          if (void 0 !== i2) {
            const n2 = e2.getConstrainedZoom(i2 + t2);
            this.duration_ > 0 ? (e2.getAnimating() && e2.cancelAnimations(), e2.animate({ zoom: n2, duration: this.duration_, easing: it })) : e2.setZoom(n2);
          }
        }
      }
      function Qo(t2) {
        t2 = t2 || {};
        const e2 = new q();
        (void 0 === t2.zoom || t2.zoom) && e2.push(new Jo(t2.zoomOptions));
        (void 0 === t2.rotate || t2.rotate) && e2.push(new $o(t2.rotateOptions));
        return (void 0 === t2.attribution || t2.attribution) && e2.push(new Ho(t2.attributionOptions)), e2;
      }
      var ta = "active";
      class ea extends V {
        constructor(t2) {
          super(), this.on, this.once, this.un, t2 && t2.handleEvent && (this.handleEvent = t2.handleEvent), this.map_ = null, this.setActive(true);
        }
        getActive() {
          return this.get(ta);
        }
        getMap() {
          return this.map_;
        }
        handleEvent(t2) {
          return true;
        }
        setActive(t2) {
          this.set(ta, t2);
        }
        setMap(t2) {
          this.map_ = t2;
        }
      }
      function ia(t2, e2, i2) {
        const n2 = t2.getCenterInternal();
        if (n2) {
          const r2 = [n2[0] + e2[0], n2[1] + e2[1]];
          t2.animateInternal({ duration: void 0 !== i2 ? i2 : 250, easing: rt, center: t2.getConstrainedCenter(r2) });
        }
      }
      function na(t2, e2, i2, n2) {
        const r2 = t2.getZoom();
        if (void 0 === r2)
          return;
        const s2 = t2.getConstrainedZoom(r2 + e2), o2 = t2.getResolutionForZoom(s2);
        t2.getAnimating() && t2.cancelAnimations(), t2.animate({ resolution: o2, anchor: i2, duration: void 0 !== n2 ? n2 : 250, easing: it });
      }
      class ra extends ea {
        constructor(t2) {
          super(), t2 = t2 || {}, this.delta_ = t2.delta ? t2.delta : 1, this.duration_ = void 0 !== t2.duration ? t2.duration : 250;
        }
        handleEvent(t2) {
          let e2 = false;
          if (t2.type == ao.DBLCLICK) {
            const i2 = t2.originalEvent, n2 = t2.map, r2 = t2.coordinate, s2 = i2.shiftKey ? -this.delta_ : this.delta_;
            na(n2.getView(), s2, r2, this.duration_), i2.preventDefault(), e2 = true;
          }
          return !e2;
        }
      }
      class sa extends ea {
        constructor(t2) {
          super(t2 = t2 || {}), t2.handleDownEvent && (this.handleDownEvent = t2.handleDownEvent), t2.handleDragEvent && (this.handleDragEvent = t2.handleDragEvent), t2.handleMoveEvent && (this.handleMoveEvent = t2.handleMoveEvent), t2.handleUpEvent && (this.handleUpEvent = t2.handleUpEvent), t2.stopDown && (this.stopDown = t2.stopDown), this.handlingDownUpSequence = false, this.targetPointers = [];
        }
        getPointerCount() {
          return this.targetPointers.length;
        }
        handleDownEvent(t2) {
          return false;
        }
        handleDragEvent(t2) {
        }
        handleEvent(t2) {
          if (!t2.originalEvent)
            return true;
          let e2 = false;
          if (this.updateTrackedPointers_(t2), this.handlingDownUpSequence) {
            if (t2.type == ao.POINTERDRAG)
              this.handleDragEvent(t2), t2.originalEvent.preventDefault();
            else if (t2.type == ao.POINTERUP) {
              const e3 = this.handleUpEvent(t2);
              this.handlingDownUpSequence = e3 && this.targetPointers.length > 0;
            }
          } else if (t2.type == ao.POINTERDOWN) {
            const i2 = this.handleDownEvent(t2);
            this.handlingDownUpSequence = i2, e2 = this.stopDown(i2);
          } else
            t2.type == ao.POINTERMOVE && this.handleMoveEvent(t2);
          return !e2;
        }
        handleMoveEvent(t2) {
        }
        handleUpEvent(t2) {
          return false;
        }
        stopDown(t2) {
          return t2;
        }
        updateTrackedPointers_(t2) {
          t2.activePointers && (this.targetPointers = t2.activePointers);
        }
      }
      function oa(t2) {
        const e2 = t2.length;
        let i2 = 0, n2 = 0;
        for (let r2 = 0; r2 < e2; r2++)
          i2 += t2[r2].clientX, n2 += t2[r2].clientY;
        return [i2 / e2, n2 / e2];
      }
      function aa(t2) {
        const e2 = arguments;
        return function(t3) {
          let i2 = true;
          for (let n2 = 0, r2 = e2.length; n2 < r2 && (i2 = i2 && e2[n2](t3), i2); ++n2)
            ;
          return i2;
        };
      }
      const la = function(t2) {
        const e2 = t2.originalEvent;
        return e2.altKey && !(e2.metaKey || e2.ctrlKey) && !e2.shiftKey;
      }, ha = function(t2) {
        const e2 = t2.originalEvent;
        return e2.altKey && !(e2.metaKey || e2.ctrlKey) && e2.shiftKey;
      }, ca = function(t2) {
        const e2 = t2.map.getTargetElement(), i2 = t2.map.getOwnerDocument().activeElement;
        return e2.contains(i2);
      }, ua = function(t2) {
        return !t2.map.getTargetElement().hasAttribute("tabindex") || ca(t2);
      }, da = g, ga = function(t2) {
        const e2 = t2.originalEvent;
        return 0 == e2.button && !(ft && pt && e2.ctrlKey);
      }, fa = f, pa = function(t2) {
        return t2.type == ao.SINGLECLICK;
      }, ma = function(t2) {
        const e2 = t2.originalEvent;
        return !e2.altKey && !(e2.metaKey || e2.ctrlKey) && !e2.shiftKey;
      }, _a = function(t2) {
        const e2 = t2.originalEvent;
        return !e2.altKey && !(e2.metaKey || e2.ctrlKey) && e2.shiftKey;
      }, ya = function(t2) {
        const e2 = t2.originalEvent, i2 = e2.target.tagName;
        return "INPUT" !== i2 && "SELECT" !== i2 && "TEXTAREA" !== i2 && !e2.target.isContentEditable;
      }, xa = function(t2) {
        const e2 = t2.originalEvent;
        return at(void 0 !== e2, 56), "mouse" == e2.pointerType;
      }, va = function(t2) {
        const e2 = t2.originalEvent;
        return at(void 0 !== e2, 56), e2.isPrimary && 0 === e2.button;
      };
      class Sa extends sa {
        constructor(t2) {
          super({ stopDown: f }), t2 = t2 || {}, this.kinetic_ = t2.kinetic, this.lastCentroid = null, this.lastPointersCount_, this.panning_ = false;
          const e2 = t2.condition ? t2.condition : aa(ma, va);
          this.condition_ = t2.onFocusOnly ? aa(ua, e2) : e2, this.noKinetic_ = false;
        }
        handleDragEvent(t2) {
          this.panning_ || (this.panning_ = true, this.getMap().getView().beginInteraction());
          const e2 = this.targetPointers, i2 = oa(e2);
          if (e2.length == this.lastPointersCount_) {
            if (this.kinetic_ && this.kinetic_.update(i2[0], i2[1]), this.lastCentroid) {
              const e3 = [this.lastCentroid[0] - i2[0], i2[1] - this.lastCentroid[1]], n2 = t2.map.getView();
              Ei(e3, n2.getResolution()), wi(e3, n2.getRotation()), n2.adjustCenterInternal(e3);
            }
          } else
            this.kinetic_ && this.kinetic_.begin();
          this.lastCentroid = i2, this.lastPointersCount_ = e2.length, t2.originalEvent.preventDefault();
        }
        handleUpEvent(t2) {
          const e2 = t2.map, i2 = e2.getView();
          if (0 === this.targetPointers.length) {
            if (!this.noKinetic_ && this.kinetic_ && this.kinetic_.end()) {
              const t3 = this.kinetic_.getDistance(), n2 = this.kinetic_.getAngle(), r2 = i2.getCenterInternal(), s2 = e2.getPixelFromCoordinateInternal(r2), o2 = e2.getCoordinateFromPixelInternal([s2[0] - t3 * Math.cos(n2), s2[1] - t3 * Math.sin(n2)]);
              i2.animateInternal({ center: i2.getConstrainedCenter(o2), duration: 500, easing: it });
            }
            return this.panning_ && (this.panning_ = false, i2.endInteraction()), false;
          }
          return this.kinetic_ && this.kinetic_.begin(), this.lastCentroid = null, true;
        }
        handleDownEvent(t2) {
          if (this.targetPointers.length > 0 && this.condition_(t2)) {
            const e2 = t2.map.getView();
            return this.lastCentroid = null, e2.getAnimating() && e2.cancelAnimations(), this.kinetic_ && this.kinetic_.begin(), this.noKinetic_ = this.targetPointers.length > 1, true;
          }
          return false;
        }
      }
      class wa extends sa {
        constructor(t2) {
          t2 = t2 || {}, super({ stopDown: f }), this.condition_ = t2.condition ? t2.condition : ha, this.lastAngle_ = void 0, this.duration_ = void 0 !== t2.duration ? t2.duration : 250;
        }
        handleDragEvent(t2) {
          if (!xa(t2))
            return;
          const e2 = t2.map, i2 = e2.getView();
          if (i2.getConstraints().rotation === Go)
            return;
          const n2 = e2.getSize(), r2 = t2.pixel, s2 = Math.atan2(n2[1] / 2 - r2[1], r2[0] - n2[0] / 2);
          if (void 0 !== this.lastAngle_) {
            const t3 = s2 - this.lastAngle_;
            i2.adjustRotationInternal(-t3);
          }
          this.lastAngle_ = s2;
        }
        handleUpEvent(t2) {
          if (!xa(t2))
            return true;
          return t2.map.getView().endInteraction(this.duration_), false;
        }
        handleDownEvent(t2) {
          if (!xa(t2))
            return false;
          if (ga(t2) && this.condition_(t2)) {
            return t2.map.getView().beginInteraction(), this.lastAngle_ = void 0, true;
          }
          return false;
        }
      }
      class Ea extends s {
        constructor(t2) {
          super(), this.geometry_ = null, this.element_ = document.createElement("div"), this.element_.style.position = "absolute", this.element_.style.pointerEvents = "auto", this.element_.className = "ol-box " + t2, this.map_ = null, this.startPixel_ = null, this.endPixel_ = null;
        }
        disposeInternal() {
          this.setMap(null);
        }
        render_() {
          const t2 = this.startPixel_, e2 = this.endPixel_, i2 = "px", n2 = this.element_.style;
          n2.left = Math.min(t2[0], e2[0]) + i2, n2.top = Math.min(t2[1], e2[1]) + i2, n2.width = Math.abs(e2[0] - t2[0]) + i2, n2.height = Math.abs(e2[1] - t2[1]) + i2;
        }
        setMap(t2) {
          if (this.map_) {
            this.map_.getOverlayContainer().removeChild(this.element_);
            const t3 = this.element_.style;
            t3.left = "inherit", t3.top = "inherit", t3.width = "inherit", t3.height = "inherit";
          }
          this.map_ = t2, this.map_ && this.map_.getOverlayContainer().appendChild(this.element_);
        }
        setPixels(t2, e2) {
          this.startPixel_ = t2, this.endPixel_ = e2, this.createOrUpdateGeometry(), this.render_();
        }
        createOrUpdateGeometry() {
          const t2 = this.startPixel_, e2 = this.endPixel_, i2 = [t2, [t2[0], e2[1]], e2, [e2[0], t2[1]]].map(this.map_.getCoordinateFromPixelInternal, this.map_);
          i2[4] = i2[0].slice(), this.geometry_ ? this.geometry_.setCoordinates([i2]) : this.geometry_ = new ur([i2]);
        }
        getGeometry() {
          return this.geometry_;
        }
      }
      const Ta = "boxstart", Ca = "boxdrag", ba = "boxend", Ra = "boxcancel";
      class Pa extends i {
        constructor(t2, e2, i2) {
          super(t2), this.coordinate = e2, this.mapBrowserEvent = i2;
        }
      }
      class Ia extends sa {
        constructor(t2) {
          super(), this.on, this.once, this.un, t2 = t2 || {}, this.box_ = new Ea(t2.className || "ol-dragbox"), this.minArea_ = void 0 !== t2.minArea ? t2.minArea : 64, t2.onBoxEnd && (this.onBoxEnd = t2.onBoxEnd), this.startPixel_ = null, this.condition_ = t2.condition ? t2.condition : ga, this.boxEndCondition_ = t2.boxEndCondition ? t2.boxEndCondition : this.defaultBoxEndCondition;
        }
        defaultBoxEndCondition(t2, e2, i2) {
          const n2 = i2[0] - e2[0], r2 = i2[1] - e2[1];
          return n2 * n2 + r2 * r2 >= this.minArea_;
        }
        getGeometry() {
          return this.box_.getGeometry();
        }
        handleDragEvent(t2) {
          this.box_.setPixels(this.startPixel_, t2.pixel), this.dispatchEvent(new Pa(Ca, t2.coordinate, t2));
        }
        handleUpEvent(t2) {
          this.box_.setMap(null);
          const e2 = this.boxEndCondition_(t2, this.startPixel_, t2.pixel);
          return e2 && this.onBoxEnd(t2), this.dispatchEvent(new Pa(e2 ? ba : Ra, t2.coordinate, t2)), false;
        }
        handleDownEvent(t2) {
          return !!this.condition_(t2) && (this.startPixel_ = t2.pixel, this.box_.setMap(t2.map), this.box_.setPixels(this.startPixel_, this.startPixel_), this.dispatchEvent(new Pa(Ta, t2.coordinate, t2)), true);
        }
        onBoxEnd(t2) {
        }
      }
      class La extends Ia {
        constructor(t2) {
          super({ condition: (t2 = t2 || {}).condition ? t2.condition : _a, className: t2.className || "ol-dragzoom", minArea: t2.minArea }), this.duration_ = void 0 !== t2.duration ? t2.duration : 200, this.out_ = void 0 !== t2.out && t2.out;
        }
        onBoxEnd(t2) {
          const e2 = this.getMap().getView();
          let i2 = this.getGeometry();
          if (this.out_) {
            const t3 = e2.rotatedExtentForGeometry(i2), n2 = e2.getResolutionForExtentInternal(t3), r2 = e2.getResolution() / n2;
            i2 = i2.clone(), i2.scale(r2 * r2);
          }
          e2.fitInternal(i2, { duration: this.duration_, easing: it });
        }
      }
      var Ma = 37, Fa = 38, Aa = 39, Oa = 40;
      class Na extends ea {
        constructor(t2) {
          super(), t2 = t2 || {}, this.defaultCondition_ = function(t3) {
            return ma(t3) && ya(t3);
          }, this.condition_ = void 0 !== t2.condition ? t2.condition : this.defaultCondition_, this.duration_ = void 0 !== t2.duration ? t2.duration : 100, this.pixelDelta_ = void 0 !== t2.pixelDelta ? t2.pixelDelta : 128;
        }
        handleEvent(t2) {
          let e2 = false;
          if (t2.type == I) {
            const i2 = t2.originalEvent, n2 = i2.keyCode;
            if (this.condition_(t2) && (n2 == Oa || n2 == Ma || n2 == Aa || n2 == Fa)) {
              const r2 = t2.map.getView(), s2 = r2.getResolution() * this.pixelDelta_;
              let o2 = 0, a2 = 0;
              n2 == Oa ? a2 = -s2 : n2 == Ma ? o2 = -s2 : n2 == Aa ? o2 = s2 : a2 = s2;
              const l2 = [o2, a2];
              wi(l2, r2.getRotation()), ia(r2, l2, this.duration_), i2.preventDefault(), e2 = true;
            }
          }
          return !e2;
        }
      }
      class Da extends ea {
        constructor(t2) {
          super(), t2 = t2 || {}, this.condition_ = t2.condition ? t2.condition : ya, this.delta_ = t2.delta ? t2.delta : 1, this.duration_ = void 0 !== t2.duration ? t2.duration : 100;
        }
        handleEvent(t2) {
          let e2 = false;
          if (t2.type == I || t2.type == L) {
            const i2 = t2.originalEvent, n2 = i2.charCode;
            if (this.condition_(t2) && (n2 == "+".charCodeAt(0) || n2 == "-".charCodeAt(0))) {
              const r2 = t2.map, s2 = n2 == "+".charCodeAt(0) ? this.delta_ : -this.delta_;
              na(r2.getView(), s2, void 0, this.duration_), i2.preventDefault(), e2 = true;
            }
          }
          return !e2;
        }
      }
      class ka extends ea {
        constructor(t2) {
          super(t2 = t2 || {}), this.totalDelta_ = 0, this.lastDelta_ = 0, this.maxDelta_ = void 0 !== t2.maxDelta ? t2.maxDelta : 1, this.duration_ = void 0 !== t2.duration ? t2.duration : 250, this.timeout_ = void 0 !== t2.timeout ? t2.timeout : 80, this.useAnchor_ = void 0 === t2.useAnchor || t2.useAnchor, this.constrainResolution_ = void 0 !== t2.constrainResolution && t2.constrainResolution;
          const e2 = t2.condition ? t2.condition : da;
          this.condition_ = t2.onFocusOnly ? aa(ua, e2) : e2, this.lastAnchor_ = null, this.startTime_ = void 0, this.timeoutId_, this.mode_ = void 0, this.trackpadEventGap_ = 400, this.trackpadTimeoutId_, this.deltaPerZoom_ = 300;
        }
        endInteraction_() {
          this.trackpadTimeoutId_ = void 0;
          const t2 = this.getMap();
          if (!t2)
            return;
          t2.getView().endInteraction(void 0, this.lastDelta_ ? this.lastDelta_ > 0 ? 1 : -1 : 0, this.lastAnchor_);
        }
        handleEvent(t2) {
          if (!this.condition_(t2))
            return true;
          if (t2.type !== O)
            return true;
          const e2 = t2.map, i2 = t2.originalEvent;
          let n2;
          if (i2.preventDefault(), this.useAnchor_ && (this.lastAnchor_ = t2.coordinate), t2.type == O && (n2 = i2.deltaY, ut && i2.deltaMode === WheelEvent.DOM_DELTA_PIXEL && (n2 /= mt), i2.deltaMode === WheelEvent.DOM_DELTA_LINE && (n2 *= 40)), 0 === n2)
            return false;
          this.lastDelta_ = n2;
          const r2 = Date.now();
          void 0 === this.startTime_ && (this.startTime_ = r2), (!this.mode_ || r2 - this.startTime_ > this.trackpadEventGap_) && (this.mode_ = Math.abs(n2) < 4 ? "trackpad" : "wheel");
          const s2 = e2.getView();
          if ("trackpad" === this.mode_ && !s2.getConstrainResolution() && !this.constrainResolution_)
            return this.trackpadTimeoutId_ ? clearTimeout(this.trackpadTimeoutId_) : (s2.getAnimating() && s2.cancelAnimations(), s2.beginInteraction()), this.trackpadTimeoutId_ = setTimeout(this.endInteraction_.bind(this), this.timeout_), s2.adjustZoom(-n2 / this.deltaPerZoom_, this.lastAnchor_), this.startTime_ = r2, false;
          this.totalDelta_ += n2;
          const o2 = Math.max(this.timeout_ - (r2 - this.startTime_), 0);
          return clearTimeout(this.timeoutId_), this.timeoutId_ = setTimeout(this.handleWheelZoom_.bind(this, e2), o2), false;
        }
        handleWheelZoom_(t2) {
          const e2 = t2.getView();
          e2.getAnimating() && e2.cancelAnimations();
          let i2 = -ii(this.totalDelta_, -this.maxDelta_ * this.deltaPerZoom_, this.maxDelta_ * this.deltaPerZoom_) / this.deltaPerZoom_;
          (e2.getConstrainResolution() || this.constrainResolution_) && (i2 = i2 ? i2 > 0 ? 1 : -1 : 0), na(e2, i2, this.lastAnchor_, this.duration_), this.mode_ = void 0, this.totalDelta_ = 0, this.lastAnchor_ = null, this.startTime_ = void 0, this.timeoutId_ = void 0;
        }
        setMouseAnchor(t2) {
          this.useAnchor_ = t2, t2 || (this.lastAnchor_ = null);
        }
      }
      class Ga extends sa {
        constructor(t2) {
          const e2 = t2 = t2 || {};
          e2.stopDown || (e2.stopDown = f), super(e2), this.anchor_ = null, this.lastAngle_ = void 0, this.rotating_ = false, this.rotationDelta_ = 0, this.threshold_ = void 0 !== t2.threshold ? t2.threshold : 0.3, this.duration_ = void 0 !== t2.duration ? t2.duration : 250;
        }
        handleDragEvent(t2) {
          let e2 = 0;
          const i2 = this.targetPointers[0], n2 = this.targetPointers[1], r2 = Math.atan2(n2.clientY - i2.clientY, n2.clientX - i2.clientX);
          if (void 0 !== this.lastAngle_) {
            const t3 = r2 - this.lastAngle_;
            this.rotationDelta_ += t3, !this.rotating_ && Math.abs(this.rotationDelta_) > this.threshold_ && (this.rotating_ = true), e2 = t3;
          }
          this.lastAngle_ = r2;
          const s2 = t2.map, o2 = s2.getView();
          if (o2.getConstraints().rotation === Go)
            return;
          const a2 = s2.getViewport().getBoundingClientRect(), l2 = oa(this.targetPointers);
          l2[0] -= a2.left, l2[1] -= a2.top, this.anchor_ = s2.getCoordinateFromPixelInternal(l2), this.rotating_ && (s2.render(), o2.adjustRotationInternal(e2, this.anchor_));
        }
        handleUpEvent(t2) {
          if (this.targetPointers.length < 2) {
            return t2.map.getView().endInteraction(this.duration_), false;
          }
          return true;
        }
        handleDownEvent(t2) {
          if (this.targetPointers.length >= 2) {
            const e2 = t2.map;
            return this.anchor_ = null, this.lastAngle_ = void 0, this.rotating_ = false, this.rotationDelta_ = 0, this.handlingDownUpSequence || e2.getView().beginInteraction(), true;
          }
          return false;
        }
      }
      class ja extends sa {
        constructor(t2) {
          const e2 = t2 = t2 || {};
          e2.stopDown || (e2.stopDown = f), super(e2), this.anchor_ = null, this.duration_ = void 0 !== t2.duration ? t2.duration : 400, this.lastDistance_ = void 0, this.lastScaleDelta_ = 1;
        }
        handleDragEvent(t2) {
          let e2 = 1;
          const i2 = this.targetPointers[0], n2 = this.targetPointers[1], r2 = i2.clientX - n2.clientX, s2 = i2.clientY - n2.clientY, o2 = Math.sqrt(r2 * r2 + s2 * s2);
          void 0 !== this.lastDistance_ && (e2 = this.lastDistance_ / o2), this.lastDistance_ = o2;
          const a2 = t2.map, l2 = a2.getView();
          1 != e2 && (this.lastScaleDelta_ = e2);
          const h2 = a2.getViewport().getBoundingClientRect(), c2 = oa(this.targetPointers);
          c2[0] -= h2.left, c2[1] -= h2.top, this.anchor_ = a2.getCoordinateFromPixelInternal(c2), a2.render(), l2.adjustResolutionInternal(e2, this.anchor_);
        }
        handleUpEvent(t2) {
          if (this.targetPointers.length < 2) {
            const e2 = t2.map.getView(), i2 = this.lastScaleDelta_ > 1 ? 1 : -1;
            return e2.endInteraction(this.duration_, i2), false;
          }
          return true;
        }
        handleDownEvent(t2) {
          if (this.targetPointers.length >= 2) {
            const e2 = t2.map;
            return this.anchor_ = null, this.lastDistance_ = void 0, this.lastScaleDelta_ = 1, this.handlingDownUpSequence || e2.getView().beginInteraction(), true;
          }
          return false;
        }
      }
      function Ba(t2) {
        t2 = t2 || {};
        const e2 = new q(), i2 = new Wr(-5e-3, 0.05, 100);
        (void 0 === t2.altShiftDragRotate || t2.altShiftDragRotate) && e2.push(new wa());
        (void 0 === t2.doubleClickZoom || t2.doubleClickZoom) && e2.push(new ra({ delta: t2.zoomDelta, duration: t2.zoomDuration }));
        (void 0 === t2.dragPan || t2.dragPan) && e2.push(new Sa({ onFocusOnly: t2.onFocusOnly, kinetic: i2 }));
        (void 0 === t2.pinchRotate || t2.pinchRotate) && e2.push(new Ga());
        (void 0 === t2.pinchZoom || t2.pinchZoom) && e2.push(new ja({ duration: t2.zoomDuration }));
        (void 0 === t2.keyboard || t2.keyboard) && (e2.push(new Na()), e2.push(new Da({ delta: t2.zoomDelta, duration: t2.zoomDuration })));
        (void 0 === t2.mouseWheelZoom || t2.mouseWheelZoom) && e2.push(new ka({ onFocusOnly: t2.onFocusOnly, duration: t2.zoomDuration }));
        return (void 0 === t2.shiftDragZoom || t2.shiftDragZoom) && e2.push(new La({ duration: t2.zoomDuration })), e2;
      }
      function Ua(t2, e2, i2) {
        return void 0 === i2 && (i2 = [0, 0]), i2[0] = t2[0] + 2 * e2, i2[1] = t2[1] + 2 * e2, i2;
      }
      function za(t2) {
        return t2[0] > 0 && t2[1] > 0;
      }
      function Xa(t2, e2, i2) {
        return void 0 === i2 && (i2 = [0, 0]), i2[0] = t2[0] * e2 + 0.5 | 0, i2[1] = t2[1] * e2 + 0.5 | 0, i2;
      }
      function Va(t2, e2) {
        return Array.isArray(t2) ? t2 : (void 0 === e2 ? e2 = [t2, t2] : (e2[0] = t2, e2[1] = t2), e2);
      }
      function Wa(t2) {
        t2 instanceof vs ? t2.setMapInternal(null) : t2 instanceof ro && t2.getLayers().forEach(Wa);
      }
      function Za(t2, e2) {
        if (t2 instanceof vs)
          t2.setMapInternal(e2);
        else if (t2 instanceof ro) {
          const i2 = t2.getLayers().getArray();
          for (let t3 = 0, n2 = i2.length; t3 < n2; ++t3)
            Za(i2[t3], e2);
        }
      }
      class Ya extends V {
        constructor(t2) {
          super(), t2 = t2 || {}, this.on, this.once, this.un;
          const e2 = function(t3) {
            let e3 = null;
            void 0 !== t3.keyboardEventTarget && (e3 = "string" == typeof t3.keyboardEventTarget ? document.getElementById(t3.keyboardEventTarget) : t3.keyboardEventTarget);
            const i3 = {}, n2 = t3.layers && "function" == typeof t3.layers.getLayers ? t3.layers : new ro({ layers: t3.layers });
            let r2, s2, o2;
            i3[xo] = n2, i3[So] = t3.target, i3[wo] = t3.view instanceof zo ? t3.view : new zo(), void 0 !== t3.controls && (Array.isArray(t3.controls) ? r2 = new q(t3.controls.slice()) : (at("function" == typeof t3.controls.getArray, 47), r2 = t3.controls));
            void 0 !== t3.interactions && (Array.isArray(t3.interactions) ? s2 = new q(t3.interactions.slice()) : (at("function" == typeof t3.interactions.getArray, 48), s2 = t3.interactions));
            void 0 !== t3.overlays ? Array.isArray(t3.overlays) ? o2 = new q(t3.overlays.slice()) : (at("function" == typeof t3.overlays.getArray, 49), o2 = t3.overlays) : o2 = new q();
            return { controls: r2, interactions: s2, keyboardEventTarget: e3, overlays: o2, values: i3 };
          }(t2);
          this.renderComplete_, this.loaded_ = true, this.boundHandleBrowserEvent_ = this.handleBrowserEvent.bind(this), this.maxTilesLoading_ = void 0 !== t2.maxTilesLoading ? t2.maxTilesLoading : 16, this.pixelRatio_ = void 0 !== t2.pixelRatio ? t2.pixelRatio : mt, this.postRenderTimeoutHandle_, this.animationDelayKey_, this.animationDelay_ = this.animationDelay_.bind(this), this.coordinateToPixelTransform_ = [1, 0, 0, 1, 0, 0], this.pixelToCoordinateTransform_ = [1, 0, 0, 1, 0, 0], this.frameIndex_ = 0, this.frameState_ = null, this.previousExtent_ = null, this.viewPropertyListenerKey_ = null, this.viewChangeListenerKey_ = null, this.layerGroupPropertyListenerKeys_ = null, this.viewport_ = document.createElement("div"), this.viewport_.className = "ol-viewport" + ("ontouchstart" in window ? " ol-touch" : ""), this.viewport_.style.position = "relative", this.viewport_.style.overflow = "hidden", this.viewport_.style.width = "100%", this.viewport_.style.height = "100%", this.overlayContainer_ = document.createElement("div"), this.overlayContainer_.style.position = "absolute", this.overlayContainer_.style.zIndex = "0", this.overlayContainer_.style.width = "100%", this.overlayContainer_.style.height = "100%", this.overlayContainer_.style.pointerEvents = "none", this.overlayContainer_.className = "ol-overlaycontainer", this.viewport_.appendChild(this.overlayContainer_), this.overlayContainerStopEvent_ = document.createElement("div"), this.overlayContainerStopEvent_.style.position = "absolute", this.overlayContainerStopEvent_.style.zIndex = "0", this.overlayContainerStopEvent_.style.width = "100%", this.overlayContainerStopEvent_.style.height = "100%", this.overlayContainerStopEvent_.style.pointerEvents = "none", this.overlayContainerStopEvent_.className = "ol-overlaycontainer-stopevent", this.viewport_.appendChild(this.overlayContainerStopEvent_), this.mapBrowserEventHandler_ = null, this.moveTolerance_ = t2.moveTolerance, this.keyboardEventTarget_ = e2.keyboardEventTarget, this.targetChangeHandlerKeys_ = null, this.controls = e2.controls || Qo(), this.interactions = e2.interactions || Ba({ onFocusOnly: true }), this.overlays_ = e2.overlays, this.overlayIdIndex_ = {}, this.renderer_ = null, this.postRenderFunctions_ = [], this.tileQueue_ = new Co(this.getTilePriority.bind(this), this.handleTileChange_.bind(this)), this.addChangeListener(xo, this.handleLayerGroupChanged_), this.addChangeListener(wo, this.handleViewChanged_), this.addChangeListener(vo, this.handleSizeChanged_), this.addChangeListener(So, this.handleTargetChanged_), this.setProperties(e2.values);
          const i2 = this;
          !t2.view || t2.view instanceof zo || t2.view.then(function(t3) {
            i2.setView(new zo(t3));
          }), this.controls.addEventListener(W, function(t3) {
            t3.element.setMap(this);
          }.bind(this)), this.controls.addEventListener(Z, function(t3) {
            t3.element.setMap(null);
          }.bind(this)), this.interactions.addEventListener(W, function(t3) {
            t3.element.setMap(this);
          }.bind(this)), this.interactions.addEventListener(Z, function(t3) {
            t3.element.setMap(null);
          }.bind(this)), this.overlays_.addEventListener(W, function(t3) {
            this.addOverlayInternal_(t3.element);
          }.bind(this)), this.overlays_.addEventListener(Z, function(t3) {
            const e3 = t3.element.getId();
            void 0 !== e3 && delete this.overlayIdIndex_[e3.toString()], t3.element.setMap(null);
          }.bind(this)), this.controls.forEach(function(t3) {
            t3.setMap(this);
          }.bind(this)), this.interactions.forEach(function(t3) {
            t3.setMap(this);
          }.bind(this)), this.overlays_.forEach(this.addOverlayInternal_.bind(this));
        }
        addControl(t2) {
          this.getControls().push(t2);
        }
        addInteraction(t2) {
          this.getInteractions().push(t2);
        }
        addLayer(t2) {
          this.getLayerGroup().getLayers().push(t2);
        }
        handleLayerAdd_(t2) {
          Za(t2.layer, this);
        }
        addOverlay(t2) {
          this.getOverlays().push(t2);
        }
        addOverlayInternal_(t2) {
          const e2 = t2.getId();
          void 0 !== e2 && (this.overlayIdIndex_[e2.toString()] = t2), t2.setMap(this);
        }
        disposeInternal() {
          this.controls.clear(), this.interactions.clear(), this.overlays_.clear(), this.setTarget(null), super.disposeInternal();
        }
        forEachFeatureAtPixel(t2, e2, i2) {
          if (!this.frameState_ || !this.renderer_)
            return;
          const n2 = this.getCoordinateFromPixelInternal(t2), r2 = void 0 !== (i2 = void 0 !== i2 ? i2 : {}).hitTolerance ? i2.hitTolerance : 0, s2 = void 0 !== i2.layerFilter ? i2.layerFilter : g, o2 = false !== i2.checkWrapped;
          return this.renderer_.forEachFeatureAtCoordinate(n2, this.frameState_, r2, o2, e2, null, s2, null);
        }
        getFeaturesAtPixel(t2, e2) {
          const i2 = [];
          return this.forEachFeatureAtPixel(t2, function(t3) {
            i2.push(t3);
          }, e2), i2;
        }
        getAllLayers() {
          const t2 = [];
          return function e2(i2) {
            i2.forEach(function(i3) {
              i3 instanceof ro ? e2(i3.getLayers()) : t2.push(i3);
            });
          }(this.getLayers()), t2;
        }
        hasFeatureAtPixel(t2, e2) {
          if (!this.frameState_ || !this.renderer_)
            return false;
          const i2 = this.getCoordinateFromPixelInternal(t2), n2 = void 0 !== (e2 = void 0 !== e2 ? e2 : {}).layerFilter ? e2.layerFilter : g, r2 = void 0 !== e2.hitTolerance ? e2.hitTolerance : 0, s2 = false !== e2.checkWrapped;
          return this.renderer_.hasFeatureAtCoordinate(i2, this.frameState_, r2, s2, n2, null);
        }
        getEventCoordinate(t2) {
          return this.getCoordinateFromPixel(this.getEventPixel(t2));
        }
        getEventCoordinateInternal(t2) {
          return this.getCoordinateFromPixelInternal(this.getEventPixel(t2));
        }
        getEventPixel(t2) {
          const e2 = this.viewport_.getBoundingClientRect(), i2 = "changedTouches" in t2 ? t2.changedTouches[0] : t2;
          return [i2.clientX - e2.left, i2.clientY - e2.top];
        }
        getTarget() {
          return this.get(So);
        }
        getTargetElement() {
          const t2 = this.getTarget();
          return void 0 !== t2 ? "string" == typeof t2 ? document.getElementById(t2) : t2 : null;
        }
        getCoordinateFromPixel(t2) {
          return nn(this.getCoordinateFromPixelInternal(t2), this.getView().getProjection());
        }
        getCoordinateFromPixelInternal(t2) {
          const e2 = this.frameState_;
          return e2 ? bt(e2.pixelToCoordinateTransform, t2.slice()) : null;
        }
        getControls() {
          return this.controls;
        }
        getOverlays() {
          return this.overlays_;
        }
        getOverlayById(t2) {
          const e2 = this.overlayIdIndex_[t2.toString()];
          return void 0 !== e2 ? e2 : null;
        }
        getInteractions() {
          return this.interactions;
        }
        getLayerGroup() {
          return this.get(xo);
        }
        setLayers(t2) {
          const e2 = this.getLayerGroup();
          if (t2 instanceof q)
            return void e2.setLayers(t2);
          const i2 = e2.getLayers();
          i2.clear(), i2.extend(t2);
        }
        getLayers() {
          return this.getLayerGroup().getLayers();
        }
        getLoadingOrNotReady() {
          const t2 = this.getLayerGroup().getLayerStatesArray();
          for (let e2 = 0, i2 = t2.length; e2 < i2; ++e2) {
            const i3 = t2[e2];
            if (!i3.visible)
              continue;
            const n2 = i3.layer.getRenderer();
            if (n2 && !n2.ready)
              return true;
            const r2 = i3.layer.getSource();
            if (r2 && r2.loading)
              return true;
          }
          return false;
        }
        getPixelFromCoordinate(t2) {
          const e2 = rn(t2, this.getView().getProjection());
          return this.getPixelFromCoordinateInternal(e2);
        }
        getPixelFromCoordinateInternal(t2) {
          const e2 = this.frameState_;
          return e2 ? bt(e2.coordinateToPixelTransform, t2.slice(0, 2)) : null;
        }
        getRenderer() {
          return this.renderer_;
        }
        getSize() {
          return this.get(vo);
        }
        getView() {
          return this.get(wo);
        }
        getViewport() {
          return this.viewport_;
        }
        getOverlayContainer() {
          return this.overlayContainer_;
        }
        getOverlayContainerStopEvent() {
          return this.overlayContainerStopEvent_;
        }
        getOwnerDocument() {
          const t2 = this.getTargetElement();
          return t2 ? t2.ownerDocument : document;
        }
        getTilePriority(t2, e2, i2, n2) {
          return bo(this.frameState_, t2, e2, i2, n2);
        }
        handleBrowserEvent(t2, e2) {
          e2 = e2 || t2.type;
          const i2 = new oo(e2, this, t2);
          this.handleMapBrowserEvent(i2);
        }
        handleMapBrowserEvent(t2) {
          if (!this.frameState_)
            return;
          const e2 = t2.originalEvent, i2 = e2.type;
          if (i2 === ho || i2 === O || i2 === I) {
            const t3 = this.getOwnerDocument(), i3 = this.viewport_.getRootNode ? this.viewport_.getRootNode() : t3, n2 = e2.target;
            if (this.overlayContainerStopEvent_.contains(n2) || !(i3 === t3 ? t3.documentElement : i3).contains(n2))
              return;
          }
          if (t2.frameState = this.frameState_, false !== this.dispatchEvent(t2)) {
            const e3 = this.getInteractions().getArray().slice();
            for (let i3 = e3.length - 1; i3 >= 0; i3--) {
              const n2 = e3[i3];
              if (n2.getMap() !== this || !n2.getActive() || !this.getTargetElement())
                continue;
              if (!n2.handleEvent(t2) || t2.propagationStopped)
                break;
            }
          }
        }
        handlePostRender() {
          const t2 = this.frameState_, e2 = this.tileQueue_;
          if (!e2.isEmpty()) {
            let i3 = this.maxTilesLoading_, n2 = i3;
            if (t2) {
              const e3 = t2.viewHints;
              if (e3[Ro] || e3[Po]) {
                const e4 = Date.now() - t2.time > 8;
                i3 = e4 ? 0 : 8, n2 = e4 ? 0 : 2;
              }
            }
            e2.getTilesLoading() < i3 && (e2.reprioritize(), e2.loadMoreTiles(i3, n2));
          }
          t2 && this.renderer_ && !t2.animate && (true === this.renderComplete_ ? (this.hasListener(xs) && this.renderer_.dispatchRenderEvent(xs, t2), false === this.loaded_ && (this.loaded_ = true, this.dispatchEvent(new so(yo, this, t2)))) : true === this.loaded_ && (this.loaded_ = false, this.dispatchEvent(new so(_o, this, t2))));
          const i2 = this.postRenderFunctions_;
          for (let e3 = 0, n2 = i2.length; e3 < n2; ++e3)
            i2[e3](this, t2);
          i2.length = 0;
        }
        handleSizeChanged_() {
          this.getView() && !this.getView().getAnimating() && this.getView().resolveConstraints(0), this.render();
        }
        handleTargetChanged_() {
          if (this.mapBrowserEventHandler_) {
            for (let t3 = 0, e2 = this.targetChangeHandlerKeys_.length; t3 < e2; ++t3)
              k(this.targetChangeHandlerKeys_[t3]);
            this.targetChangeHandlerKeys_ = null, this.viewport_.removeEventListener(E, this.boundHandleBrowserEvent_), this.viewport_.removeEventListener(O, this.boundHandleBrowserEvent_), this.mapBrowserEventHandler_.dispose(), this.mapBrowserEventHandler_ = null, Ur(this.viewport_);
          }
          const t2 = this.getTargetElement();
          if (t2) {
            t2.appendChild(this.viewport_), this.renderer_ || (this.renderer_ = new eo(this)), this.mapBrowserEventHandler_ = new go(this, this.moveTolerance_);
            for (const t3 in ao)
              this.mapBrowserEventHandler_.addEventListener(ao[t3], this.handleMapBrowserEvent.bind(this));
            this.viewport_.addEventListener(E, this.boundHandleBrowserEvent_, false), this.viewport_.addEventListener(O, this.boundHandleBrowserEvent_, !!xt && { passive: false });
            const e2 = this.getOwnerDocument().defaultView, i2 = this.keyboardEventTarget_ ? this.keyboardEventTarget_ : t2;
            this.targetChangeHandlerKeys_ = [N(i2, I, this.handleBrowserEvent, this), N(i2, L, this.handleBrowserEvent, this), N(e2, F, this.updateSize, this)];
          } else
            this.renderer_ && (clearTimeout(this.postRenderTimeoutHandle_), this.postRenderTimeoutHandle_ = void 0, this.postRenderFunctions_.length = 0, this.renderer_.dispose(), this.renderer_ = null), this.animationDelayKey_ && (cancelAnimationFrame(this.animationDelayKey_), this.animationDelayKey_ = void 0);
          this.updateSize();
        }
        handleTileChange_() {
          this.render();
        }
        handleViewPropertyChanged_() {
          this.render();
        }
        handleViewChanged_() {
          this.viewPropertyListenerKey_ && (k(this.viewPropertyListenerKey_), this.viewPropertyListenerKey_ = null), this.viewChangeListenerKey_ && (k(this.viewChangeListenerKey_), this.viewChangeListenerKey_ = null);
          const t2 = this.getView();
          t2 && (this.updateViewportSize_(), this.viewPropertyListenerKey_ = N(t2, r, this.handleViewPropertyChanged_, this), this.viewChangeListenerKey_ = N(t2, S, this.handleViewPropertyChanged_, this), t2.resolveConstraints(0)), this.render();
        }
        handleLayerGroupChanged_() {
          this.layerGroupPropertyListenerKeys_ && (this.layerGroupPropertyListenerKeys_.forEach(k), this.layerGroupPropertyListenerKeys_ = null);
          const t2 = this.getLayerGroup();
          t2 && (this.handleLayerAdd_(new io("addlayer", t2)), this.layerGroupPropertyListenerKeys_ = [N(t2, r, this.render, this), N(t2, S, this.render, this), N(t2, "addlayer", this.handleLayerAdd_, this), N(t2, "removelayer", this.handleLayerRemove_, this)]), this.render();
        }
        isRendered() {
          return !!this.frameState_;
        }
        animationDelay_() {
          this.animationDelayKey_ = void 0, this.renderFrame_(Date.now());
        }
        renderSync() {
          this.animationDelayKey_ && cancelAnimationFrame(this.animationDelayKey_), this.animationDelay_();
        }
        redrawText() {
          const t2 = this.getLayerGroup().getLayerStatesArray();
          for (let e2 = 0, i2 = t2.length; e2 < i2; ++e2) {
            const i3 = t2[e2].layer;
            i3.hasRenderer() && i3.getRenderer().handleFontsChanged();
          }
        }
        render() {
          this.renderer_ && void 0 === this.animationDelayKey_ && (this.animationDelayKey_ = requestAnimationFrame(this.animationDelay_));
        }
        removeControl(t2) {
          return this.getControls().remove(t2);
        }
        removeInteraction(t2) {
          return this.getInteractions().remove(t2);
        }
        removeLayer(t2) {
          return this.getLayerGroup().getLayers().remove(t2);
        }
        handleLayerRemove_(t2) {
          Wa(t2.layer);
        }
        removeOverlay(t2) {
          return this.getOverlays().remove(t2);
        }
        renderFrame_(t2) {
          const e2 = this.getSize(), i2 = this.getView(), n2 = this.frameState_;
          let r2 = null;
          if (void 0 !== e2 && za(e2) && i2 && i2.isDef()) {
            const n3 = i2.getHints(this.frameState_ ? this.frameState_.viewHints : void 0), s2 = i2.getState();
            if (r2 = { animate: false, coordinateToPixelTransform: this.coordinateToPixelTransform_, declutterTree: null, extent: pe(s2.center, s2.resolution, s2.rotation, e2), index: this.frameIndex_++, layerIndex: 0, layerStatesArray: this.getLayerGroup().getLayerStatesArray(), pixelRatio: this.pixelRatio_, pixelToCoordinateTransform: this.pixelToCoordinateTransform_, postRenderFunctions: [], size: e2, tileQueue: this.tileQueue_, time: t2, usedTiles: {}, viewState: s2, viewHints: n3, wantedTiles: {}, mapId: z(this), renderTargets: {} }, s2.nextCenter && s2.nextResolution) {
              const t3 = isNaN(s2.nextRotation) ? s2.rotation : s2.nextRotation;
              r2.nextExtent = pe(s2.nextCenter, s2.nextResolution, t3, e2);
            }
          }
          if (this.frameState_ = r2, this.renderer_.renderFrame(r2), r2) {
            if (r2.animate && this.render(), Array.prototype.push.apply(this.postRenderFunctions_, r2.postRenderFunctions), n2) {
              (!this.previousExtent_ || !Ee(this.previousExtent_) && !ee(r2.extent, this.previousExtent_)) && (this.dispatchEvent(new so(po, this, n2)), this.previousExtent_ = Jt(this.previousExtent_));
            }
            this.previousExtent_ && !r2.viewHints[Ro] && !r2.viewHints[Po] && !ee(r2.extent, this.previousExtent_) && (this.dispatchEvent(new so(mo, this, r2)), Vt(r2.extent, this.previousExtent_));
          }
          this.dispatchEvent(new so(fo, this, r2)), this.renderComplete_ = this.hasListener(_o) || this.hasListener(yo) || this.hasListener(xs) ? !this.tileQueue_.getTilesLoading() && !this.tileQueue_.getCount() && !this.getLoadingOrNotReady() : void 0, this.postRenderTimeoutHandle_ || (this.postRenderTimeoutHandle_ = setTimeout(() => {
            this.postRenderTimeoutHandle_ = void 0, this.handlePostRender();
          }, 0));
        }
        setLayerGroup(t2) {
          const e2 = this.getLayerGroup();
          e2 && this.handleLayerRemove_(new io("removelayer", e2)), this.set(xo, t2);
        }
        setSize(t2) {
          this.set(vo, t2);
        }
        setTarget(t2) {
          this.set(So, t2);
        }
        setView(t2) {
          if (!t2 || t2 instanceof zo)
            return void this.set(wo, t2);
          this.set(wo, new zo());
          const e2 = this;
          t2.then(function(t3) {
            e2.setView(new zo(t3));
          });
        }
        updateSize() {
          const t2 = this.getTargetElement();
          let e2;
          if (t2) {
            const i2 = getComputedStyle(t2), n2 = t2.offsetWidth - parseFloat(i2.borderLeftWidth) - parseFloat(i2.paddingLeft) - parseFloat(i2.paddingRight) - parseFloat(i2.borderRightWidth), r2 = t2.offsetHeight - parseFloat(i2.borderTopWidth) - parseFloat(i2.paddingTop) - parseFloat(i2.paddingBottom) - parseFloat(i2.borderBottomWidth);
            isNaN(n2) || isNaN(r2) || (e2 = [n2, r2], !za(e2) && (t2.offsetWidth || t2.offsetHeight || t2.getClientRects().length) && console.warn("No map visible because the map container's width or height are 0."));
          }
          this.setSize(e2), this.updateViewportSize_();
        }
        updateViewportSize_() {
          const t2 = this.getView();
          if (t2) {
            let e2;
            const i2 = getComputedStyle(this.viewport_);
            i2.width && i2.height && (e2 = [parseInt(i2.width, 10), parseInt(i2.height, 10)]), t2.setViewportSize(e2);
          }
        }
      }
      const Ka = "element", qa = "map", Ha = "offset", $a = "position", Ja = "positioning";
      class Qa extends V {
        constructor(t2) {
          super(), this.on, this.once, this.un, this.options = t2, this.id = t2.id, this.insertFirst = void 0 === t2.insertFirst || t2.insertFirst, this.stopEvent = void 0 === t2.stopEvent || t2.stopEvent, this.element = document.createElement("div"), this.element.className = void 0 !== t2.className ? t2.className : "ol-overlay-container ol-selectable", this.element.style.position = "absolute", this.element.style.pointerEvents = "auto", this.autoPan = true === t2.autoPan ? {} : t2.autoPan || void 0, this.rendered = { transform_: "", visible: true }, this.mapPostrenderListenerKey = null, this.addChangeListener(Ka, this.handleElementChanged), this.addChangeListener(qa, this.handleMapChanged), this.addChangeListener(Ha, this.handleOffsetChanged), this.addChangeListener($a, this.handlePositionChanged), this.addChangeListener(Ja, this.handlePositioningChanged), void 0 !== t2.element && this.setElement(t2.element), this.setOffset(void 0 !== t2.offset ? t2.offset : [0, 0]), this.setPositioning(t2.positioning || "top-left"), void 0 !== t2.position && this.setPosition(t2.position);
        }
        getElement() {
          return this.get(Ka);
        }
        getId() {
          return this.id;
        }
        getMap() {
          return this.get(qa) || null;
        }
        getOffset() {
          return this.get(Ha);
        }
        getPosition() {
          return this.get($a);
        }
        getPositioning() {
          return this.get(Ja);
        }
        handleElementChanged() {
          zr(this.element);
          const t2 = this.getElement();
          t2 && this.element.appendChild(t2);
        }
        handleMapChanged() {
          this.mapPostrenderListenerKey && (Ur(this.element), k(this.mapPostrenderListenerKey), this.mapPostrenderListenerKey = null);
          const t2 = this.getMap();
          if (t2) {
            this.mapPostrenderListenerKey = N(t2, fo, this.render, this), this.updatePixelPosition();
            const e2 = this.stopEvent ? t2.getOverlayContainerStopEvent() : t2.getOverlayContainer();
            this.insertFirst ? e2.insertBefore(this.element, e2.childNodes[0] || null) : e2.appendChild(this.element), this.performAutoPan();
          }
        }
        render() {
          this.updatePixelPosition();
        }
        handleOffsetChanged() {
          this.updatePixelPosition();
        }
        handlePositionChanged() {
          this.updatePixelPosition(), this.performAutoPan();
        }
        handlePositioningChanged() {
          this.updatePixelPosition();
        }
        setElement(t2) {
          this.set(Ka, t2);
        }
        setMap(t2) {
          this.set(qa, t2);
        }
        setOffset(t2) {
          this.set(Ha, t2);
        }
        setPosition(t2) {
          this.set($a, t2);
        }
        performAutoPan() {
          this.autoPan && this.panIntoView(this.autoPan);
        }
        panIntoView(t2) {
          const e2 = this.getMap();
          if (!e2 || !e2.getTargetElement() || !this.get($a))
            return;
          const i2 = this.getRect(e2.getTargetElement(), e2.getSize()), n2 = this.getElement(), r2 = this.getRect(n2, [Gr(n2), jr(n2)]), s2 = void 0 === (t2 = t2 || {}).margin ? 20 : t2.margin;
          if (!Yt(i2, r2)) {
            const n3 = r2[0] - i2[0], o2 = i2[2] - r2[2], a2 = r2[1] - i2[1], l2 = i2[3] - r2[3], h2 = [0, 0];
            if (n3 < 0 ? h2[0] = n3 - s2 : o2 < 0 && (h2[0] = Math.abs(o2) + s2), a2 < 0 ? h2[1] = a2 - s2 : l2 < 0 && (h2[1] = Math.abs(l2) + s2), 0 !== h2[0] || 0 !== h2[1]) {
              const i3 = e2.getView().getCenterInternal(), n4 = e2.getPixelFromCoordinateInternal(i3);
              if (!n4)
                return;
              const r3 = [n4[0] + h2[0], n4[1] + h2[1]], s3 = t2.animation || {};
              e2.getView().animateInternal({ center: e2.getCoordinateFromPixelInternal(r3), duration: s3.duration, easing: s3.easing });
            }
          }
        }
        getRect(t2, e2) {
          const i2 = t2.getBoundingClientRect(), n2 = i2.left + window.pageXOffset, r2 = i2.top + window.pageYOffset;
          return [n2, r2, n2 + e2[0], r2 + e2[1]];
        }
        setPositioning(t2) {
          this.set(Ja, t2);
        }
        setVisible(t2) {
          this.rendered.visible !== t2 && (this.element.style.display = t2 ? "" : "none", this.rendered.visible = t2);
        }
        updatePixelPosition() {
          const t2 = this.getMap(), e2 = this.getPosition();
          if (!t2 || !t2.isRendered() || !e2)
            return void this.setVisible(false);
          const i2 = t2.getPixelFromCoordinate(e2), n2 = t2.getSize();
          this.updateRenderedPosition(i2, n2);
        }
        updateRenderedPosition(t2, e2) {
          const i2 = this.element.style, n2 = this.getOffset(), r2 = this.getPositioning();
          this.setVisible(true);
          let s2 = "0%", o2 = "0%";
          "bottom-right" == r2 || "center-right" == r2 || "top-right" == r2 ? s2 = "-100%" : "bottom-center" != r2 && "center-center" != r2 && "top-center" != r2 || (s2 = "-50%"), "bottom-left" == r2 || "bottom-center" == r2 || "bottom-right" == r2 ? o2 = "-100%" : "center-left" != r2 && "center-center" != r2 && "center-right" != r2 || (o2 = "-50%");
          const a2 = `translate(${s2}, ${o2}) translate(${Math.round(t2[0] + n2[0]) + "px"}, ${Math.round(t2[1] + n2[1]) + "px"})`;
          this.rendered.transform_ != a2 && (this.rendered.transform_ = a2, i2.transform = a2);
        }
        getOptions() {
          return this.options;
        }
      }
      class tl {
        constructor(t2) {
          this.highWaterMark = void 0 !== t2 ? t2 : 2048, this.count_ = 0, this.entries_ = {}, this.oldest_ = null, this.newest_ = null;
        }
        canExpireCache() {
          return this.highWaterMark > 0 && this.getCount() > this.highWaterMark;
        }
        expireCache(t2) {
          for (; this.canExpireCache(); )
            this.pop();
        }
        clear() {
          this.count_ = 0, this.entries_ = {}, this.oldest_ = null, this.newest_ = null;
        }
        containsKey(t2) {
          return this.entries_.hasOwnProperty(t2);
        }
        forEach(t2) {
          let e2 = this.oldest_;
          for (; e2; )
            t2(e2.value_, e2.key_, this), e2 = e2.newer;
        }
        get(t2, e2) {
          const i2 = this.entries_[t2];
          return at(void 0 !== i2, 15), i2 === this.newest_ || (i2 === this.oldest_ ? (this.oldest_ = this.oldest_.newer, this.oldest_.older = null) : (i2.newer.older = i2.older, i2.older.newer = i2.newer), i2.newer = null, i2.older = this.newest_, this.newest_.newer = i2, this.newest_ = i2), i2.value_;
        }
        remove(t2) {
          const e2 = this.entries_[t2];
          return at(void 0 !== e2, 15), e2 === this.newest_ ? (this.newest_ = e2.older, this.newest_ && (this.newest_.newer = null)) : e2 === this.oldest_ ? (this.oldest_ = e2.newer, this.oldest_ && (this.oldest_.older = null)) : (e2.newer.older = e2.older, e2.older.newer = e2.newer), delete this.entries_[t2], --this.count_, e2.value_;
        }
        getCount() {
          return this.count_;
        }
        getKeys() {
          const t2 = new Array(this.count_);
          let e2, i2 = 0;
          for (e2 = this.newest_; e2; e2 = e2.older)
            t2[i2++] = e2.key_;
          return t2;
        }
        getValues() {
          const t2 = new Array(this.count_);
          let e2, i2 = 0;
          for (e2 = this.newest_; e2; e2 = e2.older)
            t2[i2++] = e2.value_;
          return t2;
        }
        peekLast() {
          return this.oldest_.value_;
        }
        peekLastKey() {
          return this.oldest_.key_;
        }
        peekFirstKey() {
          return this.newest_.key_;
        }
        peek(t2) {
          if (this.containsKey(t2))
            return this.entries_[t2].value_;
        }
        pop() {
          const t2 = this.oldest_;
          return delete this.entries_[t2.key_], t2.newer && (t2.newer.older = null), this.oldest_ = t2.newer, this.oldest_ || (this.newest_ = null), --this.count_, t2.value_;
        }
        replace(t2, e2) {
          this.get(t2), this.entries_[t2].value_ = e2;
        }
        set(t2, e2) {
          at(!(t2 in this.entries_), 16);
          const i2 = { key_: t2, newer: null, older: this.newest_, value_: e2 };
          this.newest_ ? this.newest_.newer = i2 : this.oldest_ = i2, this.newest_ = i2, this.entries_[t2] = i2, ++this.count_;
        }
        setSize(t2) {
          this.highWaterMark = t2;
        }
      }
      function el(t2, e2, i2, n2) {
        return void 0 !== n2 ? (n2[0] = t2, n2[1] = e2, n2[2] = i2, n2) : [t2, e2, i2];
      }
      function il(t2, e2, i2) {
        return t2 + "/" + e2 + "/" + i2;
      }
      function nl(t2) {
        return il(t2[0], t2[1], t2[2]);
      }
      function rl(t2) {
        const [e2, i2, n2] = t2.substring(t2.lastIndexOf("/") + 1, t2.length).split(",").map(Number);
        return il(e2, i2, n2);
      }
      function sl(t2) {
        return t2.split("/").map(Number);
      }
      function ol2(t2) {
        return (t2[1] << t2[0]) + t2[2];
      }
      function al(t2, e2) {
        const i2 = t2[0], n2 = t2[1], r2 = t2[2];
        if (e2.getMinZoom() > i2 || i2 > e2.getMaxZoom())
          return false;
        const s2 = e2.getFullTileRange(i2);
        return !s2 || s2.containsXY(n2, r2);
      }
      class ll extends tl {
        clear() {
          for (; this.getCount() > 0; )
            this.pop().release();
          super.clear();
        }
        expireCache(t2) {
          for (; this.canExpireCache(); ) {
            if (this.peekLast().getKey() in t2)
              break;
            this.pop().release();
          }
        }
        pruneExceptNewestZ() {
          if (0 === this.getCount())
            return;
          const t2 = sl(this.peekFirstKey())[0];
          this.forEach(function(e2) {
            e2.tileCoord[0] !== t2 && (this.remove(nl(e2.tileCoord)), e2.release());
          }.bind(this));
        }
      }
      class hl {
        constructor(t2, e2, i2, n2) {
          this.minX = t2, this.maxX = e2, this.minY = i2, this.maxY = n2;
        }
        contains(t2) {
          return this.containsXY(t2[1], t2[2]);
        }
        containsTileRange(t2) {
          return this.minX <= t2.minX && t2.maxX <= this.maxX && this.minY <= t2.minY && t2.maxY <= this.maxY;
        }
        containsXY(t2, e2) {
          return this.minX <= t2 && t2 <= this.maxX && this.minY <= e2 && e2 <= this.maxY;
        }
        equals(t2) {
          return this.minX == t2.minX && this.minY == t2.minY && this.maxX == t2.maxX && this.maxY == t2.maxY;
        }
        extend(t2) {
          t2.minX < this.minX && (this.minX = t2.minX), t2.maxX > this.maxX && (this.maxX = t2.maxX), t2.minY < this.minY && (this.minY = t2.minY), t2.maxY > this.maxY && (this.maxY = t2.maxY);
        }
        getHeight() {
          return this.maxY - this.minY + 1;
        }
        getSize() {
          return [this.getWidth(), this.getHeight()];
        }
        getWidth() {
          return this.maxX - this.minX + 1;
        }
        intersects(t2) {
          return this.minX <= t2.maxX && this.maxX >= t2.minX && this.minY <= t2.maxY && this.maxY >= t2.minY;
        }
      }
      function cl(t2, e2, i2, n2, r2) {
        return void 0 !== r2 ? (r2.minX = t2, r2.maxX = e2, r2.minY = i2, r2.maxY = n2, r2) : new hl(t2, e2, i2, n2);
      }
      const ul = [];
      class dl extends st {
        constructor(t2, e2, i2, n2) {
          super(t2, e2, { transition: 0 }), this.context_ = {}, this.executorGroups = {}, this.declutterExecutorGroups = {}, this.loadingSourceTiles = 0, this.hitDetectionImageData = {}, this.replayState_ = {}, this.sourceTiles = [], this.errorTileKeys = {}, this.wantedResolution, this.getSourceTiles = n2.bind(void 0, this), this.wrappedTileCoord = i2;
        }
        getContext(t2) {
          const e2 = z(t2);
          return e2 in this.context_ || (this.context_[e2] = Dr(1, 1, ul)), this.context_[e2];
        }
        hasContext(t2) {
          return z(t2) in this.context_;
        }
        getImage(t2) {
          return this.hasContext(t2) ? this.getContext(t2).canvas : null;
        }
        getReplayState(t2) {
          const e2 = z(t2);
          return e2 in this.replayState_ || (this.replayState_[e2] = { dirty: false, renderedRenderOrder: null, renderedResolution: NaN, renderedRevision: -1, renderedTileResolution: NaN, renderedTileRevision: -1, renderedTileZ: -1 }), this.replayState_[e2];
        }
        load() {
          this.getSourceTiles();
        }
        release() {
          for (const t2 in this.context_) {
            const e2 = this.context_[t2];
            kr(e2), ul.push(e2.canvas), delete this.context_[t2];
          }
          super.release();
        }
      }
      class gl extends st {
        constructor(t2, e2, i2, n2, r2, s2) {
          super(t2, e2, s2), this.extent = null, this.format_ = n2, this.features_ = null, this.loader_, this.projection = null, this.resolution, this.tileLoadFunction_ = r2, this.url_ = i2, this.key = i2;
        }
        getFormat() {
          return this.format_;
        }
        getFeatures() {
          return this.features_;
        }
        load() {
          this.state == H && (this.setState($), this.tileLoadFunction_(this, this.url_), this.loader_ && this.loader_(this.extent, this.resolution, this.projection));
        }
        onLoad(t2, e2) {
          this.setFeatures(t2);
        }
        onError() {
          this.setState(Q);
        }
        setFeatures(t2) {
          this.features_ = t2, this.setState(J);
        }
        setLoader(t2) {
          this.loader_ = t2;
        }
      }
      function fl(t2) {
        return Array.isArray(t2) ? Qr(t2) : t2;
      }
      let pl, ml = false;
      function _l(t2, e2, i2, n2, r2, s2, o2) {
        const a2 = new XMLHttpRequest();
        a2.open("GET", "function" == typeof t2 ? t2(i2, n2, r2) : t2, true), "arraybuffer" == e2.getType() && (a2.responseType = "arraybuffer"), a2.withCredentials = ml, a2.onload = function(t3) {
          if (!a2.status || a2.status >= 200 && a2.status < 300) {
            const t4 = e2.getType();
            let n3;
            "json" == t4 || "text" == t4 ? n3 = a2.responseText : "xml" == t4 ? (n3 = a2.responseXML, n3 || (n3 = new DOMParser().parseFromString(a2.responseText, "application/xml"))) : "arraybuffer" == t4 && (n3 = a2.response), n3 ? s2(e2.readFeatures(n3, { extent: i2, featureProjection: r2 }), e2.readProjection(n3)) : o2();
          } else
            o2();
        }, a2.onerror = o2, a2.send();
      }
      function yl(t2, e2) {
        return function(i2, n2, r2, s2, o2) {
          const a2 = this;
          _l(t2, e2, i2, n2, r2, function(t3, e3) {
            a2.addFeatures(t3), void 0 !== s2 && s2(t3);
          }, o2 || p);
        };
      }
      function xl(t2, e2) {
        return [[-1 / 0, -1 / 0, 1 / 0, 1 / 0]];
      }
      function vl(t2, e2, i2, n2) {
        const r2 = document.createElement("script"), s2 = "olc_" + z(e2);
        function o2() {
          delete window[s2], r2.parentNode.removeChild(r2);
        }
        r2.async = true, r2.src = t2 + (t2.includes("?") ? "&" : "?") + (n2 || "callback") + "=" + s2;
        const a2 = setTimeout(function() {
          o2(), i2 && i2();
        }, 1e4);
        window[s2] = function(t3) {
          clearTimeout(a2), o2(), e2(t3);
        }, document.head.appendChild(r2);
      }
      class Sl extends Error {
        constructor(t2) {
          super("Unexpected response status: " + t2.status), this.name = "ResponseError", this.response = t2;
        }
      }
      class wl extends Error {
        constructor(t2) {
          super("Failed to issue request"), this.name = "ClientError", this.client = t2;
        }
      }
      function El(t2) {
        return new Promise(function(e2, i2) {
          const n2 = new XMLHttpRequest();
          n2.addEventListener("load", function(t3) {
            const n3 = t3.target;
            if (!n3.status || n3.status >= 200 && n3.status < 300) {
              let t4;
              try {
                t4 = JSON.parse(n3.responseText);
              } catch (t5) {
                const e3 = "Error parsing response text as JSON: " + t5.message;
                return void i2(new Error(e3));
              }
              e2(t4);
            } else
              i2(new Sl(n3));
          }), n2.addEventListener("error", function(t3) {
            i2(new wl(t3.target));
          }), n2.open("GET", t2), n2.setRequestHeader("Accept", "application/json"), n2.send();
        });
      }
      function Tl(t2, e2) {
        return e2.includes("://") ? e2 : new URL(e2, t2).href;
      }
      class Cl {
        drawCustom(t2, e2, i2, n2) {
        }
        drawGeometry(t2) {
        }
        setStyle(t2) {
        }
        drawCircle(t2, e2) {
        }
        drawFeature(t2, e2) {
        }
        drawGeometryCollection(t2, e2) {
        }
        drawLineString(t2, e2) {
        }
        drawMultiLineString(t2, e2) {
        }
        drawMultiPoint(t2, e2) {
        }
        drawMultiPolygon(t2, e2) {
        }
        drawPoint(t2, e2) {
        }
        drawPolygon(t2, e2) {
        }
        drawText(t2, e2) {
        }
        setFillStrokeStyle(t2, e2) {
        }
        setImageStyle(t2, e2) {
        }
        setTextStyle(t2, e2) {
        }
      }
      class bl extends Cl {
        constructor(t2, e2, i2, n2, r2, s2, o2) {
          super(), this.context_ = t2, this.pixelRatio_ = e2, this.extent_ = i2, this.transform_ = n2, this.viewRotation_ = r2, this.squaredTolerance_ = s2, this.userTransform_ = o2, this.contextFillState_ = null, this.contextStrokeState_ = null, this.contextTextState_ = null, this.fillState_ = null, this.strokeState_ = null, this.image_ = null, this.imageAnchorX_ = 0, this.imageAnchorY_ = 0, this.imageHeight_ = 0, this.imageOpacity_ = 0, this.imageOriginX_ = 0, this.imageOriginY_ = 0, this.imageRotateWithView_ = false, this.imageRotation_ = 0, this.imageScale_ = [0, 0], this.imageWidth_ = 0, this.text_ = "", this.textOffsetX_ = 0, this.textOffsetY_ = 0, this.textRotateWithView_ = false, this.textRotation_ = 0, this.textScale_ = [0, 0], this.textFillState_ = null, this.textStrokeState_ = null, this.textState_ = null, this.pixelCoordinates_ = [], this.tmpLocalTransform_ = [1, 0, 0, 1, 0, 0];
        }
        drawImages_(t2, e2, i2, n2) {
          if (!this.image_)
            return;
          const r2 = un(t2, e2, i2, n2, this.transform_, this.pixelCoordinates_), s2 = this.context_, o2 = this.tmpLocalTransform_, a2 = s2.globalAlpha;
          1 != this.imageOpacity_ && (s2.globalAlpha = a2 * this.imageOpacity_);
          let l2 = this.imageRotation_;
          this.imageRotateWithView_ && (l2 += this.viewRotation_);
          for (let t3 = 0, e3 = r2.length; t3 < e3; t3 += 2) {
            const e4 = r2[t3] - this.imageAnchorX_, i3 = r2[t3 + 1] - this.imageAnchorY_;
            if (0 !== l2 || 1 != this.imageScale_[0] || 1 != this.imageScale_[1]) {
              const t4 = e4 + this.imageAnchorX_, n3 = i3 + this.imageAnchorY_;
              Mt(o2, t4, n3, 1, 1, l2, -t4, -n3), s2.setTransform.apply(s2, o2), s2.translate(t4, n3), s2.scale(this.imageScale_[0], this.imageScale_[1]), s2.drawImage(this.image_, this.imageOriginX_, this.imageOriginY_, this.imageWidth_, this.imageHeight_, -this.imageAnchorX_, -this.imageAnchorY_, this.imageWidth_, this.imageHeight_), s2.setTransform(1, 0, 0, 1, 0, 0);
            } else
              s2.drawImage(this.image_, this.imageOriginX_, this.imageOriginY_, this.imageWidth_, this.imageHeight_, e4, i3, this.imageWidth_, this.imageHeight_);
          }
          1 != this.imageOpacity_ && (s2.globalAlpha = a2);
        }
        drawText_(t2, e2, i2, n2) {
          if (!this.textState_ || "" === this.text_)
            return;
          this.textFillState_ && this.setContextFillState_(this.textFillState_), this.textStrokeState_ && this.setContextStrokeState_(this.textStrokeState_), this.setContextTextState_(this.textState_);
          const r2 = un(t2, e2, i2, n2, this.transform_, this.pixelCoordinates_), s2 = this.context_;
          let o2 = this.textRotation_;
          for (this.textRotateWithView_ && (o2 += this.viewRotation_); e2 < i2; e2 += n2) {
            const t3 = r2[e2] + this.textOffsetX_, i3 = r2[e2 + 1] + this.textOffsetY_;
            0 !== o2 || 1 != this.textScale_[0] || 1 != this.textScale_[1] ? (s2.translate(t3 - this.textOffsetX_, i3 - this.textOffsetY_), s2.rotate(o2), s2.translate(this.textOffsetX_, this.textOffsetY_), s2.scale(this.textScale_[0], this.textScale_[1]), this.textStrokeState_ && s2.strokeText(this.text_, 0, 0), this.textFillState_ && s2.fillText(this.text_, 0, 0), s2.setTransform(1, 0, 0, 1, 0, 0)) : (this.textStrokeState_ && s2.strokeText(this.text_, t3, i3), this.textFillState_ && s2.fillText(this.text_, t3, i3));
          }
        }
        moveToLineTo_(t2, e2, i2, n2, r2) {
          const s2 = this.context_, o2 = un(t2, e2, i2, n2, this.transform_, this.pixelCoordinates_);
          s2.moveTo(o2[0], o2[1]);
          let a2 = o2.length;
          r2 && (a2 -= 2);
          for (let t3 = 2; t3 < a2; t3 += 2)
            s2.lineTo(o2[t3], o2[t3 + 1]);
          return r2 && s2.closePath(), i2;
        }
        drawRings_(t2, e2, i2, n2) {
          for (let r2 = 0, s2 = i2.length; r2 < s2; ++r2)
            e2 = this.moveToLineTo_(t2, e2, i2[r2], n2, true);
          return e2;
        }
        drawCircle(t2) {
          if (we(this.extent_, t2.getExtent())) {
            if (this.fillState_ || this.strokeState_) {
              this.fillState_ && this.setContextFillState_(this.fillState_), this.strokeState_ && this.setContextStrokeState_(this.strokeState_);
              const e2 = xn(t2, this.transform_, this.pixelCoordinates_), i2 = e2[2] - e2[0], n2 = e2[3] - e2[1], r2 = Math.sqrt(i2 * i2 + n2 * n2), s2 = this.context_;
              s2.beginPath(), s2.arc(e2[0], e2[1], r2, 0, 2 * Math.PI), this.fillState_ && s2.fill(), this.strokeState_ && s2.stroke();
            }
            "" !== this.text_ && this.drawText_(t2.getCenter(), 0, 2, 2);
          }
        }
        setStyle(t2) {
          this.setFillStrokeStyle(t2.getFill(), t2.getStroke()), this.setImageStyle(t2.getImage()), this.setTextStyle(t2.getText());
        }
        setTransform(t2) {
          this.transform_ = t2;
        }
        drawGeometry(t2) {
          switch (t2.getType()) {
            case "Point":
              this.drawPoint(t2);
              break;
            case "LineString":
              this.drawLineString(t2);
              break;
            case "Polygon":
              this.drawPolygon(t2);
              break;
            case "MultiPoint":
              this.drawMultiPoint(t2);
              break;
            case "MultiLineString":
              this.drawMultiLineString(t2);
              break;
            case "MultiPolygon":
              this.drawMultiPolygon(t2);
              break;
            case "GeometryCollection":
              this.drawGeometryCollection(t2);
              break;
            case "Circle":
              this.drawCircle(t2);
          }
        }
        drawFeature(t2, e2) {
          const i2 = e2.getGeometryFunction()(t2);
          i2 && we(this.extent_, i2.getExtent()) && (this.setStyle(e2), this.drawGeometry(i2));
        }
        drawGeometryCollection(t2) {
          const e2 = t2.getGeometriesArray();
          for (let t3 = 0, i2 = e2.length; t3 < i2; ++t3)
            this.drawGeometry(e2[t3]);
        }
        drawPoint(t2) {
          this.squaredTolerance_ && (t2 = t2.simplifyTransformed(this.squaredTolerance_, this.userTransform_));
          const e2 = t2.getFlatCoordinates(), i2 = t2.getStride();
          this.image_ && this.drawImages_(e2, 0, e2.length, i2), "" !== this.text_ && this.drawText_(e2, 0, e2.length, i2);
        }
        drawMultiPoint(t2) {
          this.squaredTolerance_ && (t2 = t2.simplifyTransformed(this.squaredTolerance_, this.userTransform_));
          const e2 = t2.getFlatCoordinates(), i2 = t2.getStride();
          this.image_ && this.drawImages_(e2, 0, e2.length, i2), "" !== this.text_ && this.drawText_(e2, 0, e2.length, i2);
        }
        drawLineString(t2) {
          if (this.squaredTolerance_ && (t2 = t2.simplifyTransformed(this.squaredTolerance_, this.userTransform_)), we(this.extent_, t2.getExtent())) {
            if (this.strokeState_) {
              this.setContextStrokeState_(this.strokeState_);
              const e2 = this.context_, i2 = t2.getFlatCoordinates();
              e2.beginPath(), this.moveToLineTo_(i2, 0, i2.length, t2.getStride(), false), e2.stroke();
            }
            if ("" !== this.text_) {
              const e2 = t2.getFlatMidpoint();
              this.drawText_(e2, 0, 2, 2);
            }
          }
        }
        drawMultiLineString(t2) {
          this.squaredTolerance_ && (t2 = t2.simplifyTransformed(this.squaredTolerance_, this.userTransform_));
          const e2 = t2.getExtent();
          if (we(this.extent_, e2)) {
            if (this.strokeState_) {
              this.setContextStrokeState_(this.strokeState_);
              const e3 = this.context_, i2 = t2.getFlatCoordinates();
              let n2 = 0;
              const r2 = t2.getEnds(), s2 = t2.getStride();
              e3.beginPath();
              for (let t3 = 0, e4 = r2.length; t3 < e4; ++t3)
                n2 = this.moveToLineTo_(i2, n2, r2[t3], s2, false);
              e3.stroke();
            }
            if ("" !== this.text_) {
              const e3 = t2.getFlatMidpoints();
              this.drawText_(e3, 0, e3.length, 2);
            }
          }
        }
        drawPolygon(t2) {
          if (this.squaredTolerance_ && (t2 = t2.simplifyTransformed(this.squaredTolerance_, this.userTransform_)), we(this.extent_, t2.getExtent())) {
            if (this.strokeState_ || this.fillState_) {
              this.fillState_ && this.setContextFillState_(this.fillState_), this.strokeState_ && this.setContextStrokeState_(this.strokeState_);
              const e2 = this.context_;
              e2.beginPath(), this.drawRings_(t2.getOrientedFlatCoordinates(), 0, t2.getEnds(), t2.getStride()), this.fillState_ && e2.fill(), this.strokeState_ && e2.stroke();
            }
            if ("" !== this.text_) {
              const e2 = t2.getFlatInteriorPoint();
              this.drawText_(e2, 0, 2, 2);
            }
          }
        }
        drawMultiPolygon(t2) {
          if (this.squaredTolerance_ && (t2 = t2.simplifyTransformed(this.squaredTolerance_, this.userTransform_)), we(this.extent_, t2.getExtent())) {
            if (this.strokeState_ || this.fillState_) {
              this.fillState_ && this.setContextFillState_(this.fillState_), this.strokeState_ && this.setContextStrokeState_(this.strokeState_);
              const e2 = this.context_, i2 = t2.getOrientedFlatCoordinates();
              let n2 = 0;
              const r2 = t2.getEndss(), s2 = t2.getStride();
              e2.beginPath();
              for (let t3 = 0, e3 = r2.length; t3 < e3; ++t3) {
                const e4 = r2[t3];
                n2 = this.drawRings_(i2, n2, e4, s2);
              }
              this.fillState_ && e2.fill(), this.strokeState_ && e2.stroke();
            }
            if ("" !== this.text_) {
              const e2 = t2.getFlatInteriorPoints();
              this.drawText_(e2, 0, e2.length, 2);
            }
          }
        }
        setContextFillState_(t2) {
          const e2 = this.context_, i2 = this.contextFillState_;
          i2 ? i2.fillStyle != t2.fillStyle && (i2.fillStyle = t2.fillStyle, e2.fillStyle = t2.fillStyle) : (e2.fillStyle = t2.fillStyle, this.contextFillState_ = { fillStyle: t2.fillStyle });
        }
        setContextStrokeState_(t2) {
          const e2 = this.context_, i2 = this.contextStrokeState_;
          i2 ? (i2.lineCap != t2.lineCap && (i2.lineCap = t2.lineCap, e2.lineCap = t2.lineCap), u(i2.lineDash, t2.lineDash) || e2.setLineDash(i2.lineDash = t2.lineDash), i2.lineDashOffset != t2.lineDashOffset && (i2.lineDashOffset = t2.lineDashOffset, e2.lineDashOffset = t2.lineDashOffset), i2.lineJoin != t2.lineJoin && (i2.lineJoin = t2.lineJoin, e2.lineJoin = t2.lineJoin), i2.lineWidth != t2.lineWidth && (i2.lineWidth = t2.lineWidth, e2.lineWidth = t2.lineWidth), i2.miterLimit != t2.miterLimit && (i2.miterLimit = t2.miterLimit, e2.miterLimit = t2.miterLimit), i2.strokeStyle != t2.strokeStyle && (i2.strokeStyle = t2.strokeStyle, e2.strokeStyle = t2.strokeStyle)) : (e2.lineCap = t2.lineCap, e2.setLineDash(t2.lineDash), e2.lineDashOffset = t2.lineDashOffset, e2.lineJoin = t2.lineJoin, e2.lineWidth = t2.lineWidth, e2.miterLimit = t2.miterLimit, e2.strokeStyle = t2.strokeStyle, this.contextStrokeState_ = { lineCap: t2.lineCap, lineDash: t2.lineDash, lineDashOffset: t2.lineDashOffset, lineJoin: t2.lineJoin, lineWidth: t2.lineWidth, miterLimit: t2.miterLimit, strokeStyle: t2.strokeStyle });
        }
        setContextTextState_(t2) {
          const e2 = this.context_, i2 = this.contextTextState_, n2 = t2.textAlign ? t2.textAlign : Us;
          i2 ? (i2.font != t2.font && (i2.font = t2.font, e2.font = t2.font), i2.textAlign != n2 && (i2.textAlign = n2, e2.textAlign = n2), i2.textBaseline != t2.textBaseline && (i2.textBaseline = t2.textBaseline, e2.textBaseline = t2.textBaseline)) : (e2.font = t2.font, e2.textAlign = n2, e2.textBaseline = t2.textBaseline, this.contextTextState_ = { font: t2.font, textAlign: n2, textBaseline: t2.textBaseline });
        }
        setFillStrokeStyle(t2, e2) {
          if (t2) {
            const e3 = t2.getColor();
            this.fillState_ = { fillStyle: fl(e3 || Ns) };
          } else
            this.fillState_ = null;
          if (e2) {
            const t3 = e2.getColor(), i2 = e2.getLineCap(), n2 = e2.getLineDash(), r2 = e2.getLineDashOffset(), s2 = e2.getLineJoin(), o2 = e2.getWidth(), a2 = e2.getMiterLimit(), l2 = n2 || ks;
            this.strokeState_ = { lineCap: void 0 !== i2 ? i2 : Ds, lineDash: 1 === this.pixelRatio_ ? l2 : l2.map((t4) => t4 * this.pixelRatio_), lineDashOffset: (r2 || 0) * this.pixelRatio_, lineJoin: void 0 !== s2 ? s2 : Gs, lineWidth: (void 0 !== o2 ? o2 : 1) * this.pixelRatio_, miterLimit: void 0 !== a2 ? a2 : js, strokeStyle: fl(t3 || Bs) };
          } else
            this.strokeState_ = null;
        }
        setImageStyle(t2) {
          let e2;
          if (!t2 || !(e2 = t2.getSize()))
            return void (this.image_ = null);
          const i2 = t2.getPixelRatio(this.pixelRatio_), n2 = t2.getAnchor(), r2 = t2.getOrigin();
          this.image_ = t2.getImage(this.pixelRatio_), this.imageAnchorX_ = n2[0] * i2, this.imageAnchorY_ = n2[1] * i2, this.imageHeight_ = e2[1] * i2, this.imageOpacity_ = t2.getOpacity(), this.imageOriginX_ = r2[0], this.imageOriginY_ = r2[1], this.imageRotateWithView_ = t2.getRotateWithView(), this.imageRotation_ = t2.getRotation();
          const s2 = t2.getScaleArray();
          this.imageScale_ = [s2[0] * this.pixelRatio_ / i2, s2[1] * this.pixelRatio_ / i2], this.imageWidth_ = e2[0] * i2;
        }
        setTextStyle(t2) {
          if (t2) {
            const e2 = t2.getFill();
            if (e2) {
              const t3 = e2.getColor();
              this.textFillState_ = { fillStyle: fl(t3 || Ns) };
            } else
              this.textFillState_ = null;
            const i2 = t2.getStroke();
            if (i2) {
              const t3 = i2.getColor(), e3 = i2.getLineCap(), n3 = i2.getLineDash(), r3 = i2.getLineDashOffset(), s3 = i2.getLineJoin(), o3 = i2.getWidth(), a3 = i2.getMiterLimit();
              this.textStrokeState_ = { lineCap: void 0 !== e3 ? e3 : Ds, lineDash: n3 || ks, lineDashOffset: r3 || 0, lineJoin: void 0 !== s3 ? s3 : Gs, lineWidth: void 0 !== o3 ? o3 : 1, miterLimit: void 0 !== a3 ? a3 : js, strokeStyle: fl(t3 || Bs) };
            } else
              this.textStrokeState_ = null;
            const n2 = t2.getFont(), r2 = t2.getOffsetX(), s2 = t2.getOffsetY(), o2 = t2.getRotateWithView(), a2 = t2.getRotation(), l2 = t2.getScaleArray(), h2 = t2.getText(), c2 = t2.getTextAlign(), u2 = t2.getTextBaseline();
            this.textState_ = { font: void 0 !== n2 ? n2 : Os, textAlign: void 0 !== c2 ? c2 : Us, textBaseline: void 0 !== u2 ? u2 : zs }, this.text_ = void 0 !== h2 ? Array.isArray(h2) ? h2.reduce((t3, e3, i3) => t3 + (i3 % 2 ? " " : e3), "") : h2 : "", this.textOffsetX_ = void 0 !== r2 ? this.pixelRatio_ * r2 : 0, this.textOffsetY_ = void 0 !== s2 ? this.pixelRatio_ * s2 : 0, this.textRotateWithView_ = void 0 !== o2 && o2, this.textRotation_ = void 0 !== a2 ? a2 : 0, this.textScale_ = [this.pixelRatio_ * l2[0], this.pixelRatio_ * l2[1]];
          } else
            this.text_ = "";
        }
      }
      const Rl = { Point: function(t2, e2, i2, n2, r2) {
        const s2 = i2.getImage(), o2 = i2.getText();
        let a2;
        if (s2) {
          if (s2.getImageState() != Lr)
            return;
          let l2 = t2;
          if (r2) {
            const h3 = s2.getDeclutterMode();
            if ("none" !== h3)
              if (l2 = r2, "obstacle" === h3) {
                const r3 = t2.getBuilder(i2.getZIndex(), "Image");
                r3.setImageStyle(s2, a2), r3.drawPoint(e2, n2);
              } else
                o2 && o2.getText() && (a2 = {});
          }
          const h2 = l2.getBuilder(i2.getZIndex(), "Image");
          h2.setImageStyle(s2, a2), h2.drawPoint(e2, n2);
        }
        if (o2 && o2.getText()) {
          let s3 = t2;
          r2 && (s3 = r2);
          const l2 = s3.getBuilder(i2.getZIndex(), "Text");
          l2.setTextStyle(o2, a2), l2.drawText(e2, n2);
        }
      }, LineString: function(t2, e2, i2, n2, r2) {
        const s2 = i2.getStroke();
        if (s2) {
          const r3 = t2.getBuilder(i2.getZIndex(), "LineString");
          r3.setFillStrokeStyle(null, s2), r3.drawLineString(e2, n2);
        }
        const o2 = i2.getText();
        if (o2 && o2.getText()) {
          const s3 = (r2 || t2).getBuilder(i2.getZIndex(), "Text");
          s3.setTextStyle(o2), s3.drawText(e2, n2);
        }
      }, Polygon: function(t2, e2, i2, n2, r2) {
        const s2 = i2.getFill(), o2 = i2.getStroke();
        if (s2 || o2) {
          const r3 = t2.getBuilder(i2.getZIndex(), "Polygon");
          r3.setFillStrokeStyle(s2, o2), r3.drawPolygon(e2, n2);
        }
        const a2 = i2.getText();
        if (a2 && a2.getText()) {
          const s3 = (r2 || t2).getBuilder(i2.getZIndex(), "Text");
          s3.setTextStyle(a2), s3.drawText(e2, n2);
        }
      }, MultiPoint: function(t2, e2, i2, n2, r2) {
        const s2 = i2.getImage(), o2 = i2.getText();
        let a2;
        if (s2) {
          if (s2.getImageState() != Lr)
            return;
          let l2 = t2;
          if (r2) {
            const h3 = s2.getDeclutterMode();
            if ("none" !== h3)
              if (l2 = r2, "obstacle" === h3) {
                const r3 = t2.getBuilder(i2.getZIndex(), "Image");
                r3.setImageStyle(s2, a2), r3.drawMultiPoint(e2, n2);
              } else
                o2 && o2.getText() && (a2 = {});
          }
          const h2 = l2.getBuilder(i2.getZIndex(), "Image");
          h2.setImageStyle(s2, a2), h2.drawMultiPoint(e2, n2);
        }
        if (o2 && o2.getText()) {
          let s3 = t2;
          r2 && (s3 = r2);
          const l2 = s3.getBuilder(i2.getZIndex(), "Text");
          l2.setTextStyle(o2, a2), l2.drawText(e2, n2);
        }
      }, MultiLineString: function(t2, e2, i2, n2, r2) {
        const s2 = i2.getStroke();
        if (s2) {
          const r3 = t2.getBuilder(i2.getZIndex(), "LineString");
          r3.setFillStrokeStyle(null, s2), r3.drawMultiLineString(e2, n2);
        }
        const o2 = i2.getText();
        if (o2 && o2.getText()) {
          const s3 = (r2 || t2).getBuilder(i2.getZIndex(), "Text");
          s3.setTextStyle(o2), s3.drawText(e2, n2);
        }
      }, MultiPolygon: function(t2, e2, i2, n2, r2) {
        const s2 = i2.getFill(), o2 = i2.getStroke();
        if (o2 || s2) {
          const r3 = t2.getBuilder(i2.getZIndex(), "Polygon");
          r3.setFillStrokeStyle(s2, o2), r3.drawMultiPolygon(e2, n2);
        }
        const a2 = i2.getText();
        if (a2 && a2.getText()) {
          const s3 = (r2 || t2).getBuilder(i2.getZIndex(), "Text");
          s3.setTextStyle(a2), s3.drawText(e2, n2);
        }
      }, GeometryCollection: function(t2, e2, i2, n2, r2) {
        const s2 = e2.getGeometriesArray();
        let o2, a2;
        for (o2 = 0, a2 = s2.length; o2 < a2; ++o2) {
          (0, Rl[s2[o2].getType()])(t2, s2[o2], i2, n2, r2);
        }
      }, Circle: function(t2, e2, i2, n2, r2) {
        const s2 = i2.getFill(), o2 = i2.getStroke();
        if (s2 || o2) {
          const r3 = t2.getBuilder(i2.getZIndex(), "Circle");
          r3.setFillStrokeStyle(s2, o2), r3.drawCircle(e2, n2);
        }
        const a2 = i2.getText();
        if (a2 && a2.getText()) {
          const s3 = (r2 || t2).getBuilder(i2.getZIndex(), "Text");
          s3.setTextStyle(a2), s3.drawText(e2, n2);
        }
      } };
      function Pl(t2, e2) {
        return parseInt(z(t2), 10) - parseInt(z(e2), 10);
      }
      function Il(t2, e2) {
        const i2 = Ll(t2, e2);
        return i2 * i2;
      }
      function Ll(t2, e2) {
        return 0.5 * t2 / e2;
      }
      function Ml(t2, e2, i2, n2, r2, s2, o2) {
        let a2 = false;
        const l2 = i2.getImage();
        if (l2) {
          const t3 = l2.getImageState();
          t3 == Lr || t3 == Mr ? l2.unlistenImageChange(r2) : (t3 == Pr && l2.load(), l2.listenImageChange(r2), a2 = true);
        }
        return function(t3, e3, i3, n3, r3, s3) {
          const o3 = i3.getGeometryFunction()(e3);
          if (!o3)
            return;
          const a3 = o3.simplifyTransformed(n3, r3);
          if (i3.getRenderer())
            Fl(t3, a3, i3, e3);
          else {
            (0, Rl[a3.getType()])(t3, a3, i3, e3, s3);
          }
        }(t2, e2, i2, n2, s2, o2), a2;
      }
      function Fl(t2, e2, i2, n2) {
        if ("GeometryCollection" == e2.getType()) {
          const r2 = e2.getGeometries();
          for (let e3 = 0, s2 = r2.length; e3 < s2; ++e3)
            Fl(t2, r2[e3], i2, n2);
          return;
        }
        t2.getBuilder(i2.getZIndex(), "Default").drawCustom(e2, n2, i2.getRenderer(), i2.getHitDetectionRenderer());
      }
      function Al(t2) {
        if (!(t2.context instanceof CanvasRenderingContext2D))
          throw new Error("Only works for render events from Canvas 2D layers");
        const e2 = t2.inversePixelTransform[0], i2 = t2.frameState, n2 = Et(t2.inversePixelTransform.slice(), i2.coordinateToPixelTransform), r2 = Il(i2.viewState.resolution, e2);
        let s2;
        const o2 = en();
        return o2 && (s2 = qi(o2, i2.viewState.projection)), new bl(t2.context, e2, i2.extent, n2, i2.viewState.rotation, r2, s2);
      }
      let Ol;
      const Nl = [];
      function Dl(t2, e2, i2, n2, r2) {
        t2.beginPath(), t2.moveTo(0, 0), t2.lineTo(e2, i2), t2.lineTo(n2, r2), t2.closePath(), t2.save(), t2.clip(), t2.fillRect(0, 0, Math.max(e2, n2) + 1, Math.max(i2, r2)), t2.restore();
      }
      function kl(t2, e2) {
        return Math.abs(t2[4 * e2] - 210) > 2 || Math.abs(t2[4 * e2 + 3] - 191.25) > 2;
      }
      function Gl(t2, e2, i2, n2) {
        const r2 = $i(i2, e2, t2);
        let s2 = zi(e2, n2, i2);
        const o2 = e2.getMetersPerUnit();
        void 0 !== o2 && (s2 *= o2);
        const a2 = t2.getMetersPerUnit();
        void 0 !== a2 && (s2 /= a2);
        const l2 = t2.getExtent();
        if (!l2 || Zt(l2, r2)) {
          const e3 = zi(t2, s2, r2) / s2;
          isFinite(e3) && e3 > 0 && (s2 /= e3);
        }
        return s2;
      }
      function jl(t2, e2, i2, n2) {
        const r2 = ge(i2);
        let s2 = Gl(t2, e2, r2, n2);
        return (!isFinite(s2) || s2 <= 0) && he(i2, function(i3) {
          return s2 = Gl(t2, e2, i3, n2), isFinite(s2) && s2 > 0;
        }), s2;
      }
      function Bl(t2, e2, i2, n2, r2, s2, o2, a2, l2, h2, c2, u2) {
        const d2 = Dr(Math.round(i2 * t2), Math.round(i2 * e2), Nl);
        if (u2 || (d2.imageSmoothingEnabled = false), 0 === l2.length)
          return d2.canvas;
        function g2(t3) {
          return Math.round(t3 * i2) / i2;
        }
        d2.scale(i2, i2), d2.globalCompositeOperation = "lighter";
        const f2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
        l2.forEach(function(t3, e3, i3) {
          ne(f2, t3.extent);
        });
        const p2 = Se(f2), m2 = _e(f2), _2 = Dr(Math.round(i2 * p2 / n2), Math.round(i2 * m2 / n2));
        u2 || (_2.imageSmoothingEnabled = false);
        const y2 = i2 / n2;
        l2.forEach(function(t3, e3, i3) {
          const n3 = t3.extent[0] - f2[0], r3 = -(t3.extent[3] - f2[3]), s3 = Se(t3.extent), o3 = _e(t3.extent);
          t3.image.width > 0 && t3.image.height > 0 && _2.drawImage(t3.image, h2, h2, t3.image.width - 2 * h2, t3.image.height - 2 * h2, n3 * y2, r3 * y2, s3 * y2, o3 * y2);
        });
        const x2 = xe(o2);
        return a2.getTriangles().forEach(function(t3, e3, r3) {
          const o3 = t3.source, a3 = t3.target;
          let l3 = o3[0][0], h3 = o3[0][1], c3 = o3[1][0], p3 = o3[1][1], m3 = o3[2][0], y3 = o3[2][1];
          const v2 = g2((a3[0][0] - x2[0]) / s2), S2 = g2(-(a3[0][1] - x2[1]) / s2), w2 = g2((a3[1][0] - x2[0]) / s2), E2 = g2(-(a3[1][1] - x2[1]) / s2), T2 = g2((a3[2][0] - x2[0]) / s2), C2 = g2(-(a3[2][1] - x2[1]) / s2), b2 = l3, R2 = h3;
          l3 = 0, h3 = 0, c3 -= b2, p3 -= R2, m3 -= b2, y3 -= R2;
          const P2 = si([[c3, p3, 0, 0, w2 - v2], [m3, y3, 0, 0, T2 - v2], [0, 0, c3, p3, E2 - S2], [0, 0, m3, y3, C2 - S2]]);
          if (P2) {
            if (d2.save(), d2.beginPath(), function() {
              if (void 0 === Ol) {
                const t4 = document.createElement("canvas").getContext("2d");
                t4.globalCompositeOperation = "lighter", t4.fillStyle = "rgba(210, 0, 0, 0.75)", Dl(t4, 4, 5, 4, 0), Dl(t4, 4, 5, 0, 5);
                const e4 = t4.getImageData(0, 0, 3, 3).data;
                Ol = kl(e4, 0) || kl(e4, 4) || kl(e4, 8);
              }
              return Ol;
            }() || !u2) {
              d2.moveTo(w2, E2);
              const t4 = 4, e4 = v2 - w2, i3 = S2 - E2;
              for (let n3 = 0; n3 < t4; n3++)
                d2.lineTo(w2 + g2((n3 + 1) * e4 / t4), E2 + g2(n3 * i3 / (t4 - 1))), n3 != t4 - 1 && d2.lineTo(w2 + g2((n3 + 1) * e4 / t4), E2 + g2((n3 + 1) * i3 / (t4 - 1)));
              d2.lineTo(T2, C2);
            } else
              d2.moveTo(w2, E2), d2.lineTo(v2, S2), d2.lineTo(T2, C2);
            d2.clip(), d2.transform(P2[0], P2[2], P2[1], P2[3], v2, S2), d2.translate(f2[0] - b2, f2[3] - R2), d2.scale(n2 / i2, -n2 / i2), d2.drawImage(_2.canvas, 0, 0), d2.restore();
          }
        }), c2 && (d2.save(), d2.globalCompositeOperation = "source-over", d2.strokeStyle = "black", d2.lineWidth = 1, a2.getTriangles().forEach(function(t3, e3, i3) {
          const n3 = t3.target, r3 = (n3[0][0] - x2[0]) / s2, o3 = -(n3[0][1] - x2[1]) / s2, a3 = (n3[1][0] - x2[0]) / s2, l3 = -(n3[1][1] - x2[1]) / s2, h3 = (n3[2][0] - x2[0]) / s2, c3 = -(n3[2][1] - x2[1]) / s2;
          d2.beginPath(), d2.moveTo(a3, l3), d2.lineTo(r3, o3), d2.lineTo(h3, c3), d2.closePath(), d2.stroke();
        }), d2.restore()), d2.canvas;
      }
      class Ul {
        constructor(t2, e2, i2, n2, r2, s2) {
          this.sourceProj_ = t2, this.targetProj_ = e2;
          let o2 = {};
          const a2 = Hi(this.targetProj_, this.sourceProj_);
          this.transformInv_ = function(t3) {
            const e3 = t3[0] + "/" + t3[1];
            return o2[e3] || (o2[e3] = a2(t3)), o2[e3];
          }, this.maxSourceExtent_ = n2, this.errorThresholdSquared_ = r2 * r2, this.triangles_ = [], this.wrapsXInSource_ = false, this.canWrapXInSource_ = this.sourceProj_.canWrapX() && !!n2 && !!this.sourceProj_.getExtent() && Se(n2) == Se(this.sourceProj_.getExtent()), this.sourceWorldWidth_ = this.sourceProj_.getExtent() ? Se(this.sourceProj_.getExtent()) : null, this.targetWorldWidth_ = this.targetProj_.getExtent() ? Se(this.targetProj_.getExtent()) : null;
          const l2 = xe(i2), h2 = ve(i2), c2 = de(i2), u2 = ue(i2), d2 = this.transformInv_(l2), g2 = this.transformInv_(h2), f2 = this.transformInv_(c2), p2 = this.transformInv_(u2), m2 = 10 + (s2 ? Math.max(0, Math.ceil(Math.log2(ce(i2) / (s2 * s2 * 256 * 256)))) : 0);
          if (this.addQuad_(l2, h2, c2, u2, d2, g2, f2, p2, m2), this.wrapsXInSource_) {
            let t3 = 1 / 0;
            this.triangles_.forEach(function(e3, i3, n3) {
              t3 = Math.min(t3, e3.source[0][0], e3.source[1][0], e3.source[2][0]);
            }), this.triangles_.forEach(function(e3) {
              if (Math.max(e3.source[0][0], e3.source[1][0], e3.source[2][0]) - t3 > this.sourceWorldWidth_ / 2) {
                const i3 = [[e3.source[0][0], e3.source[0][1]], [e3.source[1][0], e3.source[1][1]], [e3.source[2][0], e3.source[2][1]]];
                i3[0][0] - t3 > this.sourceWorldWidth_ / 2 && (i3[0][0] -= this.sourceWorldWidth_), i3[1][0] - t3 > this.sourceWorldWidth_ / 2 && (i3[1][0] -= this.sourceWorldWidth_), i3[2][0] - t3 > this.sourceWorldWidth_ / 2 && (i3[2][0] -= this.sourceWorldWidth_);
                const n3 = Math.min(i3[0][0], i3[1][0], i3[2][0]);
                Math.max(i3[0][0], i3[1][0], i3[2][0]) - n3 < this.sourceWorldWidth_ / 2 && (e3.source = i3);
              }
            }.bind(this));
          }
          o2 = {};
        }
        addTriangle_(t2, e2, i2, n2, r2, s2) {
          this.triangles_.push({ source: [n2, r2, s2], target: [t2, e2, i2] });
        }
        addQuad_(t2, e2, i2, n2, r2, s2, o2, a2, l2) {
          const h2 = zt([r2, s2, o2, a2]), c2 = this.sourceWorldWidth_ ? Se(h2) / this.sourceWorldWidth_ : null, u2 = this.sourceWorldWidth_, d2 = this.sourceProj_.canWrapX() && c2 > 0.5 && c2 < 1;
          let g2 = false;
          if (l2 > 0) {
            if (this.targetProj_.isGlobal() && this.targetWorldWidth_) {
              g2 = Se(zt([t2, e2, i2, n2])) / this.targetWorldWidth_ > 0.25 || g2;
            }
            !d2 && this.sourceProj_.isGlobal() && c2 && (g2 = c2 > 0.25 || g2);
          }
          if (!g2 && this.maxSourceExtent_ && isFinite(h2[0]) && isFinite(h2[1]) && isFinite(h2[2]) && isFinite(h2[3]) && !we(h2, this.maxSourceExtent_))
            return;
          let f2 = 0;
          if (!(g2 || isFinite(r2[0]) && isFinite(r2[1]) && isFinite(s2[0]) && isFinite(s2[1]) && isFinite(o2[0]) && isFinite(o2[1]) && isFinite(a2[0]) && isFinite(a2[1]))) {
            if (l2 > 0)
              g2 = true;
            else if (f2 = (isFinite(r2[0]) && isFinite(r2[1]) ? 0 : 8) + (isFinite(s2[0]) && isFinite(s2[1]) ? 0 : 4) + (isFinite(o2[0]) && isFinite(o2[1]) ? 0 : 2) + (isFinite(a2[0]) && isFinite(a2[1]) ? 0 : 1), 1 != f2 && 2 != f2 && 4 != f2 && 8 != f2)
              return;
          }
          if (l2 > 0) {
            if (!g2) {
              const e3 = [(t2[0] + i2[0]) / 2, (t2[1] + i2[1]) / 2], n3 = this.transformInv_(e3);
              let s3;
              if (d2) {
                s3 = (li(r2[0], u2) + li(o2[0], u2)) / 2 - li(n3[0], u2);
              } else
                s3 = (r2[0] + o2[0]) / 2 - n3[0];
              const a3 = (r2[1] + o2[1]) / 2 - n3[1];
              g2 = s3 * s3 + a3 * a3 > this.errorThresholdSquared_;
            }
            if (g2) {
              if (Math.abs(t2[0] - i2[0]) <= Math.abs(t2[1] - i2[1])) {
                const h3 = [(e2[0] + i2[0]) / 2, (e2[1] + i2[1]) / 2], c3 = this.transformInv_(h3), u3 = [(n2[0] + t2[0]) / 2, (n2[1] + t2[1]) / 2], d3 = this.transformInv_(u3);
                this.addQuad_(t2, e2, h3, u3, r2, s2, c3, d3, l2 - 1), this.addQuad_(u3, h3, i2, n2, d3, c3, o2, a2, l2 - 1);
              } else {
                const h3 = [(t2[0] + e2[0]) / 2, (t2[1] + e2[1]) / 2], c3 = this.transformInv_(h3), u3 = [(i2[0] + n2[0]) / 2, (i2[1] + n2[1]) / 2], d3 = this.transformInv_(u3);
                this.addQuad_(t2, h3, u3, n2, r2, c3, d3, a2, l2 - 1), this.addQuad_(h3, e2, i2, u3, c3, s2, o2, d3, l2 - 1);
              }
              return;
            }
          }
          if (d2) {
            if (!this.canWrapXInSource_)
              return;
            this.wrapsXInSource_ = true;
          }
          0 == (11 & f2) && this.addTriangle_(t2, i2, n2, r2, o2, a2), 0 == (14 & f2) && this.addTriangle_(t2, i2, e2, r2, o2, s2), f2 && (0 == (13 & f2) && this.addTriangle_(e2, n2, t2, s2, a2, r2), 0 == (7 & f2) && this.addTriangle_(e2, n2, i2, s2, a2, o2));
        }
        calculateSourceExtent() {
          const t2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
          return this.triangles_.forEach(function(e2, i2, n2) {
            const r2 = e2.source;
            re(t2, r2[0]), re(t2, r2[1]), re(t2, r2[2]);
          }), t2;
        }
        getTriangles() {
          return this.triangles_;
        }
      }
      class zl extends st {
        constructor(t2, e2, i2, n2, r2, s2, o2, a2, l2, h2, c2, u2) {
          super(r2, H, { interpolate: !!u2 }), this.renderEdges_ = void 0 !== c2 && c2, this.pixelRatio_ = o2, this.gutter_ = a2, this.canvas_ = null, this.sourceTileGrid_ = e2, this.targetTileGrid_ = n2, this.wrappedTileCoord_ = s2 || r2, this.sourceTiles_ = [], this.sourcesListenerKeys_ = null, this.sourceZ_ = 0;
          const d2 = n2.getTileCoordExtent(this.wrappedTileCoord_), g2 = this.targetTileGrid_.getExtent();
          let f2 = this.sourceTileGrid_.getExtent();
          const p2 = g2 ? ye(d2, g2) : d2;
          if (0 === ce(p2))
            return void (this.state = tt);
          const m2 = t2.getExtent();
          m2 && (f2 = f2 ? ye(f2, m2) : m2);
          const _2 = n2.getResolution(this.wrappedTileCoord_[0]), y2 = jl(t2, i2, p2, _2);
          if (!isFinite(y2) || y2 <= 0)
            return void (this.state = tt);
          const x2 = void 0 !== h2 ? h2 : 0.5;
          if (this.triangulation_ = new Ul(t2, i2, p2, f2, y2 * x2, _2), 0 === this.triangulation_.getTriangles().length)
            return void (this.state = tt);
          this.sourceZ_ = e2.getZForResolution(y2);
          let v2 = this.triangulation_.calculateSourceExtent();
          if (f2 && (t2.canWrapX() ? (v2[1] = ii(v2[1], f2[1], f2[3]), v2[3] = ii(v2[3], f2[1], f2[3])) : v2 = ye(v2, f2)), ce(v2)) {
            const t3 = e2.getTileRangeForExtentAndZ(v2, this.sourceZ_);
            for (let e3 = t3.minX; e3 <= t3.maxX; e3++)
              for (let i3 = t3.minY; i3 <= t3.maxY; i3++) {
                const t4 = l2(this.sourceZ_, e3, i3, o2);
                t4 && this.sourceTiles_.push(t4);
              }
            0 === this.sourceTiles_.length && (this.state = tt);
          } else
            this.state = tt;
        }
        getImage() {
          return this.canvas_;
        }
        reproject_() {
          const t2 = [];
          if (this.sourceTiles_.forEach(function(e2, i2, n2) {
            e2 && e2.getState() == J && t2.push({ extent: this.sourceTileGrid_.getTileCoordExtent(e2.tileCoord), image: e2.getImage() });
          }.bind(this)), this.sourceTiles_.length = 0, 0 === t2.length)
            this.state = Q;
          else {
            const e2 = this.wrappedTileCoord_[0], i2 = this.targetTileGrid_.getTileSize(e2), n2 = "number" == typeof i2 ? i2 : i2[0], r2 = "number" == typeof i2 ? i2 : i2[1], s2 = this.targetTileGrid_.getResolution(e2), o2 = this.sourceTileGrid_.getResolution(this.sourceZ_), a2 = this.targetTileGrid_.getTileCoordExtent(this.wrappedTileCoord_);
            this.canvas_ = Bl(n2, r2, this.pixelRatio_, o2, this.sourceTileGrid_.getExtent(), s2, a2, this.triangulation_, t2, this.gutter_, this.renderEdges_, this.interpolate), this.state = J;
          }
          this.changed();
        }
        load() {
          if (this.state == H) {
            this.state = $, this.changed();
            let t2 = 0;
            this.sourcesListenerKeys_ = [], this.sourceTiles_.forEach(function(e2, i2, n2) {
              const r2 = e2.getState();
              if (r2 == H || r2 == $) {
                t2++;
                const i3 = N(e2, S, function(n3) {
                  const r3 = e2.getState();
                  r3 != J && r3 != Q && r3 != tt || (k(i3), t2--, 0 === t2 && (this.unlistenSources_(), this.reproject_()));
                }, this);
                this.sourcesListenerKeys_.push(i3);
              }
            }.bind(this)), 0 === t2 ? setTimeout(this.reproject_.bind(this), 0) : this.sourceTiles_.forEach(function(t3, e2, i2) {
              t3.getState() == H && t3.load();
            });
          }
        }
        unlistenSources_() {
          this.sourcesListenerKeys_.forEach(k), this.sourcesListenerKeys_ = null;
        }
        release() {
          this.canvas_ && (kr(this.canvas_.getContext("2d")), Nl.push(this.canvas_), this.canvas_ = null), super.release();
        }
      }
      var Xl = "tileloadstart", Vl = "tileloadend", Wl = "tileloaderror";
      class Zl extends V {
        constructor(t2) {
          super(), this.projection = Ui(t2.projection), this.attributions_ = Yl(t2.attributions), this.attributionsCollapsible_ = void 0 === t2.attributionsCollapsible || t2.attributionsCollapsible, this.loading = false, this.state_ = void 0 !== t2.state ? t2.state : "ready", this.wrapX_ = void 0 !== t2.wrapX && t2.wrapX, this.interpolate_ = !!t2.interpolate, this.viewResolver = null, this.viewRejector = null;
          const e2 = this;
          this.viewPromise_ = new Promise(function(t3, i2) {
            e2.viewResolver = t3, e2.viewRejector = i2;
          });
        }
        getAttributions() {
          return this.attributions_;
        }
        getAttributionsCollapsible() {
          return this.attributionsCollapsible_;
        }
        getProjection() {
          return this.projection;
        }
        getResolutions() {
          return B();
        }
        getView() {
          return this.viewPromise_;
        }
        getState() {
          return this.state_;
        }
        getWrapX() {
          return this.wrapX_;
        }
        getInterpolate() {
          return this.interpolate_;
        }
        refresh() {
          this.changed();
        }
        setAttributions(t2) {
          this.attributions_ = Yl(t2), this.changed();
        }
        setState(t2) {
          this.state_ = t2, this.changed();
        }
      }
      function Yl(t2) {
        return t2 ? Array.isArray(t2) ? function(e2) {
          return t2;
        } : "function" == typeof t2 ? t2 : function(e2) {
          return [t2];
        } : null;
      }
      const Kl = [0, 0, 0];
      class ql {
        constructor(t2) {
          let e2;
          if (this.minZoom = void 0 !== t2.minZoom ? t2.minZoom : 0, this.resolutions_ = t2.resolutions, at(d(this.resolutions_, function(t3, e3) {
            return e3 - t3;
          }, true), 17), !t2.origins)
            for (let t3 = 0, i3 = this.resolutions_.length - 1; t3 < i3; ++t3)
              if (e2) {
                if (this.resolutions_[t3] / this.resolutions_[t3 + 1] !== e2) {
                  e2 = void 0;
                  break;
                }
              } else
                e2 = this.resolutions_[t3] / this.resolutions_[t3 + 1];
          this.zoomFactor_ = e2, this.maxZoom = this.resolutions_.length - 1, this.origin_ = void 0 !== t2.origin ? t2.origin : null, this.origins_ = null, void 0 !== t2.origins && (this.origins_ = t2.origins, at(this.origins_.length == this.resolutions_.length, 20));
          const i2 = t2.extent;
          void 0 === i2 || this.origin_ || this.origins_ || (this.origin_ = xe(i2)), at(!this.origin_ && this.origins_ || this.origin_ && !this.origins_, 18), this.tileSizes_ = null, void 0 !== t2.tileSizes && (this.tileSizes_ = t2.tileSizes, at(this.tileSizes_.length == this.resolutions_.length, 19)), this.tileSize_ = void 0 !== t2.tileSize ? t2.tileSize : this.tileSizes_ ? null : Lo, at(!this.tileSize_ && this.tileSizes_ || this.tileSize_ && !this.tileSizes_, 22), this.extent_ = void 0 !== i2 ? i2 : null, this.fullTileRanges_ = null, this.tmpSize_ = [0, 0], this.tmpExtent_ = [0, 0, 0, 0], void 0 !== t2.sizes ? this.fullTileRanges_ = t2.sizes.map(function(t3, e3) {
            const n2 = new hl(Math.min(0, t3[0]), Math.max(t3[0] - 1, -1), Math.min(0, t3[1]), Math.max(t3[1] - 1, -1));
            if (i2) {
              const t4 = this.getTileRangeForExtentAndZ(i2, e3);
              n2.minX = Math.max(t4.minX, n2.minX), n2.maxX = Math.min(t4.maxX, n2.maxX), n2.minY = Math.max(t4.minY, n2.minY), n2.maxY = Math.min(t4.maxY, n2.maxY);
            }
            return n2;
          }, this) : i2 && this.calculateTileRanges_(i2);
        }
        forEachTileCoord(t2, e2, i2) {
          const n2 = this.getTileRangeForExtentAndZ(t2, e2);
          for (let t3 = n2.minX, r2 = n2.maxX; t3 <= r2; ++t3)
            for (let r3 = n2.minY, s2 = n2.maxY; r3 <= s2; ++r3)
              i2([e2, t3, r3]);
        }
        forEachTileCoordParentTileRange(t2, e2, i2, n2) {
          let r2, s2, o2, a2 = null, l2 = t2[0] - 1;
          for (2 === this.zoomFactor_ ? (s2 = t2[1], o2 = t2[2]) : a2 = this.getTileCoordExtent(t2, n2); l2 >= this.minZoom; ) {
            if (2 === this.zoomFactor_ ? (s2 = Math.floor(s2 / 2), o2 = Math.floor(o2 / 2), r2 = cl(s2, s2, o2, o2, i2)) : r2 = this.getTileRangeForExtentAndZ(a2, l2, i2), e2(l2, r2))
              return true;
            --l2;
          }
          return false;
        }
        getExtent() {
          return this.extent_;
        }
        getMaxZoom() {
          return this.maxZoom;
        }
        getMinZoom() {
          return this.minZoom;
        }
        getOrigin(t2) {
          return this.origin_ ? this.origin_ : this.origins_[t2];
        }
        getResolution(t2) {
          return this.resolutions_[t2];
        }
        getResolutions() {
          return this.resolutions_;
        }
        getTileCoordChildTileRange(t2, e2, i2) {
          if (t2[0] < this.maxZoom) {
            if (2 === this.zoomFactor_) {
              const i3 = 2 * t2[1], n3 = 2 * t2[2];
              return cl(i3, i3 + 1, n3, n3 + 1, e2);
            }
            const n2 = this.getTileCoordExtent(t2, i2 || this.tmpExtent_);
            return this.getTileRangeForExtentAndZ(n2, t2[0] + 1, e2);
          }
          return null;
        }
        getTileRangeForTileCoordAndZ(t2, e2, i2) {
          if (e2 > this.maxZoom || e2 < this.minZoom)
            return null;
          const n2 = t2[0], r2 = t2[1], s2 = t2[2];
          if (e2 === n2)
            return cl(r2, s2, r2, s2, i2);
          if (this.zoomFactor_) {
            const t3 = Math.pow(this.zoomFactor_, e2 - n2), o3 = Math.floor(r2 * t3), a2 = Math.floor(s2 * t3);
            if (e2 < n2)
              return cl(o3, o3, a2, a2, i2);
            return cl(o3, Math.floor(t3 * (r2 + 1)) - 1, a2, Math.floor(t3 * (s2 + 1)) - 1, i2);
          }
          const o2 = this.getTileCoordExtent(t2, this.tmpExtent_);
          return this.getTileRangeForExtentAndZ(o2, e2, i2);
        }
        getTileRangeExtent(t2, e2, i2) {
          const n2 = this.getOrigin(t2), r2 = this.getResolution(t2), s2 = Va(this.getTileSize(t2), this.tmpSize_), o2 = n2[0] + e2.minX * s2[0] * r2, a2 = n2[0] + (e2.maxX + 1) * s2[0] * r2;
          return $t(o2, n2[1] + e2.minY * s2[1] * r2, a2, n2[1] + (e2.maxY + 1) * s2[1] * r2, i2);
        }
        getTileRangeForExtentAndZ(t2, e2, i2) {
          const n2 = Kl;
          this.getTileCoordForXYAndZ_(t2[0], t2[3], e2, false, n2);
          const r2 = n2[1], s2 = n2[2];
          return this.getTileCoordForXYAndZ_(t2[2], t2[1], e2, true, n2), cl(r2, n2[1], s2, n2[2], i2);
        }
        getTileCoordCenter(t2) {
          const e2 = this.getOrigin(t2[0]), i2 = this.getResolution(t2[0]), n2 = Va(this.getTileSize(t2[0]), this.tmpSize_);
          return [e2[0] + (t2[1] + 0.5) * n2[0] * i2, e2[1] - (t2[2] + 0.5) * n2[1] * i2];
        }
        getTileCoordExtent(t2, e2) {
          const i2 = this.getOrigin(t2[0]), n2 = this.getResolution(t2[0]), r2 = Va(this.getTileSize(t2[0]), this.tmpSize_), s2 = i2[0] + t2[1] * r2[0] * n2, o2 = i2[1] - (t2[2] + 1) * r2[1] * n2;
          return $t(s2, o2, s2 + r2[0] * n2, o2 + r2[1] * n2, e2);
        }
        getTileCoordForCoordAndResolution(t2, e2, i2) {
          return this.getTileCoordForXYAndResolution_(t2[0], t2[1], e2, false, i2);
        }
        getTileCoordForXYAndResolution_(t2, e2, i2, n2, r2) {
          const s2 = this.getZForResolution(i2), o2 = i2 / this.getResolution(s2), a2 = this.getOrigin(s2), l2 = Va(this.getTileSize(s2), this.tmpSize_);
          let h2 = o2 * (t2 - a2[0]) / i2 / l2[0], c2 = o2 * (a2[1] - e2) / i2 / l2[1];
          return n2 ? (h2 = gi(h2, 5) - 1, c2 = gi(c2, 5) - 1) : (h2 = di(h2, 5), c2 = di(c2, 5)), el(s2, h2, c2, r2);
        }
        getTileCoordForXYAndZ_(t2, e2, i2, n2, r2) {
          const s2 = this.getOrigin(i2), o2 = this.getResolution(i2), a2 = Va(this.getTileSize(i2), this.tmpSize_);
          let l2 = (t2 - s2[0]) / o2 / a2[0], h2 = (s2[1] - e2) / o2 / a2[1];
          return n2 ? (l2 = gi(l2, 5) - 1, h2 = gi(h2, 5) - 1) : (l2 = di(l2, 5), h2 = di(h2, 5)), el(i2, l2, h2, r2);
        }
        getTileCoordForCoordAndZ(t2, e2, i2) {
          return this.getTileCoordForXYAndZ_(t2[0], t2[1], e2, false, i2);
        }
        getTileCoordResolution(t2) {
          return this.resolutions_[t2[0]];
        }
        getTileSize(t2) {
          return this.tileSize_ ? this.tileSize_ : this.tileSizes_[t2];
        }
        getFullTileRange(t2) {
          return this.fullTileRanges_ ? this.fullTileRanges_[t2] : this.extent_ ? this.getTileRangeForExtentAndZ(this.extent_, t2) : null;
        }
        getZForResolution(t2, e2) {
          return ii(l(this.resolutions_, t2, e2 || 0), this.minZoom, this.maxZoom);
        }
        tileCoordIntersectsViewport(t2, e2) {
          return er(e2, 0, e2.length, 2, this.getTileCoordExtent(t2));
        }
        calculateTileRanges_(t2) {
          const e2 = this.resolutions_.length, i2 = new Array(e2);
          for (let n2 = this.minZoom; n2 < e2; ++n2)
            i2[n2] = this.getTileRangeForExtentAndZ(t2, n2);
          this.fullTileRanges_ = i2;
        }
      }
      function Hl(t2) {
        let e2 = t2.getDefaultTileGrid();
        return e2 || (e2 = eh(t2), t2.setDefaultTileGrid(e2)), e2;
      }
      function $l(t2, e2, i2) {
        const n2 = e2[0], r2 = t2.getTileCoordCenter(e2), s2 = ih(i2);
        if (Zt(s2, r2))
          return e2;
        {
          const e3 = Se(s2), i3 = Math.ceil((s2[0] - r2[0]) / e3);
          return r2[0] += e3 * i3, t2.getTileCoordForCoordAndZ(r2, n2);
        }
      }
      function Jl(t2, e2, i2, n2) {
        n2 = void 0 !== n2 ? n2 : "top-left";
        const r2 = th(t2, e2, i2);
        return new ql({ extent: t2, origin: fe(t2, n2), resolutions: r2, tileSize: i2 });
      }
      function Ql(t2) {
        const e2 = t2 || {}, i2 = e2.extent || Ui("EPSG:3857").getExtent(), n2 = { extent: i2, minZoom: e2.minZoom, tileSize: e2.tileSize, resolutions: th(i2, e2.maxZoom, e2.tileSize, e2.maxResolution) };
        return new ql(n2);
      }
      function th(t2, e2, i2, n2) {
        e2 = void 0 !== e2 ? e2 : 42, i2 = Va(void 0 !== i2 ? i2 : Lo);
        const r2 = _e(t2), s2 = Se(t2);
        n2 = n2 > 0 ? n2 : Math.max(s2 / i2[0], r2 / i2[1]);
        const o2 = e2 + 1, a2 = new Array(o2);
        for (let t3 = 0; t3 < o2; ++t3)
          a2[t3] = n2 / Math.pow(2, t3);
        return a2;
      }
      function eh(t2, e2, i2, n2) {
        return Jl(ih(t2), e2, i2, n2);
      }
      function ih(t2) {
        let e2 = (t2 = Ui(t2)).getExtent();
        if (!e2) {
          const i2 = 180 * Fe.degrees / t2.getMetersPerUnit();
          e2 = $t(-i2, -i2, i2, i2);
        }
        return e2;
      }
      class nh extends Zl {
        constructor(t2) {
          super({ attributions: t2.attributions, attributionsCollapsible: t2.attributionsCollapsible, projection: t2.projection, state: t2.state, wrapX: t2.wrapX, interpolate: t2.interpolate }), this.on, this.once, this.un, this.opaque_ = void 0 !== t2.opaque && t2.opaque, this.tilePixelRatio_ = void 0 !== t2.tilePixelRatio ? t2.tilePixelRatio : 1, this.tileGrid = void 0 !== t2.tileGrid ? t2.tileGrid : null;
          const e2 = [256, 256];
          this.tileGrid && Va(this.tileGrid.getTileSize(this.tileGrid.getMinZoom()), e2), this.tileCache = new ll(t2.cacheSize || 0), this.tmpSize = [0, 0], this.key_ = t2.key || "", this.tileOptions = { transition: t2.transition, interpolate: t2.interpolate }, this.zDirection = t2.zDirection ? t2.zDirection : 0;
        }
        canExpireCache() {
          return this.tileCache.canExpireCache();
        }
        expireCache(t2, e2) {
          const i2 = this.getTileCacheForProjection(t2);
          i2 && i2.expireCache(e2);
        }
        forEachLoadedTile(t2, e2, i2, n2) {
          const r2 = this.getTileCacheForProjection(t2);
          if (!r2)
            return false;
          let s2, o2, a2, l2 = true;
          for (let t3 = i2.minX; t3 <= i2.maxX; ++t3)
            for (let h2 = i2.minY; h2 <= i2.maxY; ++h2)
              o2 = il(e2, t3, h2), a2 = false, r2.containsKey(o2) && (s2 = r2.get(o2), a2 = s2.getState() === J, a2 && (a2 = false !== n2(s2))), a2 || (l2 = false);
          return l2;
        }
        getGutterForProjection(t2) {
          return 0;
        }
        getKey() {
          return this.key_;
        }
        setKey(t2) {
          this.key_ !== t2 && (this.key_ = t2, this.changed());
        }
        getOpaque(t2) {
          return this.opaque_;
        }
        getResolutions() {
          return this.tileGrid ? this.tileGrid.getResolutions() : null;
        }
        getTile(t2, e2, i2, n2, r2) {
          return B();
        }
        getTileGrid() {
          return this.tileGrid;
        }
        getTileGridForProjection(t2) {
          return this.tileGrid ? this.tileGrid : Hl(t2);
        }
        getTileCacheForProjection(t2) {
          const e2 = this.getProjection();
          return at(null === e2 || Ki(e2, t2), 68), this.tileCache;
        }
        getTilePixelRatio(t2) {
          return this.tilePixelRatio_;
        }
        getTilePixelSize(t2, e2, i2) {
          const n2 = this.getTileGridForProjection(i2), r2 = this.getTilePixelRatio(e2), s2 = Va(n2.getTileSize(t2), this.tmpSize);
          return 1 == r2 ? s2 : Xa(s2, r2, this.tmpSize);
        }
        getTileCoordForTileUrlFunction(t2, e2) {
          e2 = void 0 !== e2 ? e2 : this.getProjection();
          const i2 = this.getTileGridForProjection(e2);
          return this.getWrapX() && e2.isGlobal() && (t2 = $l(i2, t2, e2)), al(t2, i2) ? t2 : null;
        }
        clear() {
          this.tileCache.clear();
        }
        refresh() {
          this.clear(), super.refresh();
        }
        updateCacheSize(t2, e2) {
          const i2 = this.getTileCacheForProjection(e2);
          t2 > i2.highWaterMark && (i2.highWaterMark = t2);
        }
        useTile(t2, e2, i2, n2) {
        }
      }
      class rh extends i {
        constructor(t2, e2) {
          super(t2), this.tile = e2;
        }
      }
      function sh(t2, e2) {
        const i2 = /\{z\}/g, n2 = /\{x\}/g, r2 = /\{y\}/g, s2 = /\{-y\}/g;
        return function(o2, a2, l2) {
          return o2 ? t2.replace(i2, o2[0].toString()).replace(n2, o2[1].toString()).replace(r2, o2[2].toString()).replace(s2, function() {
            const t3 = o2[0], i3 = e2.getFullTileRange(t3);
            at(i3, 55);
            return (i3.getHeight() - o2[2] - 1).toString();
          }) : void 0;
        };
      }
      function oh(t2, e2) {
        const i2 = t2.length, n2 = new Array(i2);
        for (let r2 = 0; r2 < i2; ++r2)
          n2[r2] = sh(t2[r2], e2);
        return ah(n2);
      }
      function ah(t2) {
        return 1 === t2.length ? t2[0] : function(e2, i2, n2) {
          if (e2) {
            const r2 = li(ol2(e2), t2.length);
            return t2[r2](e2, i2, n2);
          }
        };
      }
      function lh(t2, e2, i2) {
      }
      function hh(t2) {
        const e2 = [];
        let i2 = /\{([a-z])-([a-z])\}/.exec(t2);
        if (i2) {
          const n2 = i2[1].charCodeAt(0), r2 = i2[2].charCodeAt(0);
          let s2;
          for (s2 = n2; s2 <= r2; ++s2)
            e2.push(t2.replace(i2[0], String.fromCharCode(s2)));
          return e2;
        }
        if (i2 = /\{(\d+)-(\d+)\}/.exec(t2), i2) {
          const n2 = parseInt(i2[2], 10);
          for (let r2 = parseInt(i2[1], 10); r2 <= n2; r2++)
            e2.push(t2.replace(i2[0], r2.toString()));
          return e2;
        }
        return e2.push(t2), e2;
      }
      class ch extends nh {
        constructor(t2) {
          super({ attributions: t2.attributions, cacheSize: t2.cacheSize, opaque: t2.opaque, projection: t2.projection, state: t2.state, tileGrid: t2.tileGrid, tilePixelRatio: t2.tilePixelRatio, wrapX: t2.wrapX, transition: t2.transition, interpolate: t2.interpolate, key: t2.key, attributionsCollapsible: t2.attributionsCollapsible, zDirection: t2.zDirection }), this.generateTileUrlFunction_ = this.tileUrlFunction === ch.prototype.tileUrlFunction, this.tileLoadFunction = t2.tileLoadFunction, t2.tileUrlFunction && (this.tileUrlFunction = t2.tileUrlFunction), this.urls = null, t2.urls ? this.setUrls(t2.urls) : t2.url && this.setUrl(t2.url), this.tileLoadingKeys_ = {};
        }
        getTileLoadFunction() {
          return this.tileLoadFunction;
        }
        getTileUrlFunction() {
          return Object.getPrototypeOf(this).tileUrlFunction === this.tileUrlFunction ? this.tileUrlFunction.bind(this) : this.tileUrlFunction;
        }
        getUrls() {
          return this.urls;
        }
        handleTileChange(t2) {
          const e2 = t2.target, i2 = z(e2), n2 = e2.getState();
          let r2;
          n2 == $ ? (this.tileLoadingKeys_[i2] = true, r2 = Xl) : i2 in this.tileLoadingKeys_ && (delete this.tileLoadingKeys_[i2], r2 = n2 == Q ? Wl : n2 == J ? Vl : void 0), null != r2 && this.dispatchEvent(new rh(r2, e2));
        }
        setTileLoadFunction(t2) {
          this.tileCache.clear(), this.tileLoadFunction = t2, this.changed();
        }
        setTileUrlFunction(t2, e2) {
          this.tileUrlFunction = t2, this.tileCache.pruneExceptNewestZ(), void 0 !== e2 ? this.setKey(e2) : this.changed();
        }
        setUrl(t2) {
          const e2 = hh(t2);
          this.urls = e2, this.setUrls(e2);
        }
        setUrls(t2) {
          this.urls = t2;
          const e2 = t2.join("\n");
          this.generateTileUrlFunction_ ? this.setTileUrlFunction(oh(t2, this.tileGrid), e2) : this.setKey(e2);
        }
        tileUrlFunction(t2, e2, i2) {
        }
        useTile(t2, e2, i2) {
          const n2 = il(t2, e2, i2);
          this.tileCache.containsKey(n2) && this.tileCache.get(n2);
        }
      }
      class uh extends ch {
        constructor(t2) {
          super({ attributions: t2.attributions, cacheSize: t2.cacheSize, opaque: t2.opaque, projection: t2.projection, state: t2.state, tileGrid: t2.tileGrid, tileLoadFunction: t2.tileLoadFunction ? t2.tileLoadFunction : dh, tilePixelRatio: t2.tilePixelRatio, tileUrlFunction: t2.tileUrlFunction, url: t2.url, urls: t2.urls, wrapX: t2.wrapX, transition: t2.transition, interpolate: void 0 === t2.interpolate || t2.interpolate, key: t2.key, attributionsCollapsible: t2.attributionsCollapsible, zDirection: t2.zDirection }), this.crossOrigin = void 0 !== t2.crossOrigin ? t2.crossOrigin : null, this.tileClass = void 0 !== t2.tileClass ? t2.tileClass : Vr, this.tileCacheForProjection = {}, this.tileGridForProjection = {}, this.reprojectionErrorThreshold_ = t2.reprojectionErrorThreshold, this.renderReprojectionEdges_ = false;
        }
        canExpireCache() {
          if (this.tileCache.canExpireCache())
            return true;
          for (const t2 in this.tileCacheForProjection)
            if (this.tileCacheForProjection[t2].canExpireCache())
              return true;
          return false;
        }
        expireCache(t2, e2) {
          const i2 = this.getTileCacheForProjection(t2);
          this.tileCache.expireCache(this.tileCache == i2 ? e2 : {});
          for (const t3 in this.tileCacheForProjection) {
            const n2 = this.tileCacheForProjection[t3];
            n2.expireCache(n2 == i2 ? e2 : {});
          }
        }
        getGutterForProjection(t2) {
          return this.getProjection() && t2 && !Ki(this.getProjection(), t2) ? 0 : this.getGutter();
        }
        getGutter() {
          return 0;
        }
        getKey() {
          let t2 = super.getKey();
          return this.getInterpolate() || (t2 += ":disable-interpolation"), t2;
        }
        getOpaque(t2) {
          return !(this.getProjection() && t2 && !Ki(this.getProjection(), t2)) && super.getOpaque(t2);
        }
        getTileGridForProjection(t2) {
          const e2 = this.getProjection();
          if (!this.tileGrid || e2 && !Ki(e2, t2)) {
            const e3 = z(t2);
            return e3 in this.tileGridForProjection || (this.tileGridForProjection[e3] = Hl(t2)), this.tileGridForProjection[e3];
          }
          return this.tileGrid;
        }
        getTileCacheForProjection(t2) {
          const e2 = this.getProjection();
          if (!e2 || Ki(e2, t2))
            return this.tileCache;
          {
            const e3 = z(t2);
            return e3 in this.tileCacheForProjection || (this.tileCacheForProjection[e3] = new ll(this.tileCache.highWaterMark)), this.tileCacheForProjection[e3];
          }
        }
        createTile_(t2, e2, i2, n2, r2, s2) {
          const o2 = [t2, e2, i2], a2 = this.getTileCoordForTileUrlFunction(o2, r2), l2 = a2 ? this.tileUrlFunction(a2, n2, r2) : void 0, h2 = new this.tileClass(o2, void 0 !== l2 ? H : tt, void 0 !== l2 ? l2 : "", this.crossOrigin, this.tileLoadFunction, this.tileOptions);
          return h2.key = s2, h2.addEventListener(S, this.handleTileChange.bind(this)), h2;
        }
        getTile(t2, e2, i2, n2, r2) {
          const s2 = this.getProjection();
          if (s2 && r2 && !Ki(s2, r2)) {
            const o2 = this.getTileCacheForProjection(r2), a2 = [t2, e2, i2];
            let l2;
            const h2 = nl(a2);
            o2.containsKey(h2) && (l2 = o2.get(h2));
            const c2 = this.getKey();
            if (l2 && l2.key == c2)
              return l2;
            {
              const t3 = this.getTileGridForProjection(s2), e3 = this.getTileGridForProjection(r2), i3 = this.getTileCoordForTileUrlFunction(a2, r2), u2 = new zl(s2, t3, r2, e3, a2, i3, this.getTilePixelRatio(n2), this.getGutter(), function(t4, e4, i4, n3) {
                return this.getTileInternal(t4, e4, i4, n3, s2);
              }.bind(this), this.reprojectionErrorThreshold_, this.renderReprojectionEdges_, this.getInterpolate());
              return u2.key = c2, l2 ? (u2.interimTile = l2, u2.refreshInterimChain(), o2.replace(h2, u2)) : o2.set(h2, u2), u2;
            }
          }
          return this.getTileInternal(t2, e2, i2, n2, s2 || r2);
        }
        getTileInternal(t2, e2, i2, n2, r2) {
          let s2 = null;
          const o2 = il(t2, e2, i2), a2 = this.getKey();
          if (this.tileCache.containsKey(o2)) {
            if (s2 = this.tileCache.get(o2), s2.key != a2) {
              const l2 = s2;
              s2 = this.createTile_(t2, e2, i2, n2, r2, a2), l2.getState() == H ? s2.interimTile = l2.interimTile : s2.interimTile = l2, s2.refreshInterimChain(), this.tileCache.replace(o2, s2);
            }
          } else
            s2 = this.createTile_(t2, e2, i2, n2, r2, a2), this.tileCache.set(o2, s2);
          return s2;
        }
        setRenderReprojectionEdges(t2) {
          if (this.renderReprojectionEdges_ != t2) {
            this.renderReprojectionEdges_ = t2;
            for (const t3 in this.tileCacheForProjection)
              this.tileCacheForProjection[t3].clear();
            this.changed();
          }
        }
        setTileGridForProjection(t2, e2) {
          const i2 = Ui(t2);
          if (i2) {
            const t3 = z(i2);
            t3 in this.tileGridForProjection || (this.tileGridForProjection[t3] = e2);
          }
        }
        clear() {
          super.clear();
          for (const t2 in this.tileCacheForProjection)
            this.tileCacheForProjection[t2].clear();
        }
      }
      function dh(t2, e2) {
        t2.getImage().src = e2;
      }
      function gh(t2) {
        const e2 = t2[0], i2 = new Array(e2);
        let n2, r2, s2 = 1 << e2 - 1;
        for (n2 = 0; n2 < e2; ++n2)
          r2 = 48, t2[1] & s2 && (r2 += 1), t2[2] & s2 && (r2 += 2), i2[n2] = String.fromCharCode(r2), s2 >>= 1;
        return i2.join("");
      }
      class fh extends uh {
        constructor(t2) {
          const e2 = void 0 !== (t2 = t2 || {}).projection ? t2.projection : "EPSG:3857", i2 = void 0 !== t2.tileGrid ? t2.tileGrid : Ql({ extent: ih(e2), maxResolution: t2.maxResolution, maxZoom: t2.maxZoom, minZoom: t2.minZoom, tileSize: t2.tileSize });
          super({ attributions: t2.attributions, cacheSize: t2.cacheSize, crossOrigin: t2.crossOrigin, interpolate: t2.interpolate, opaque: t2.opaque, projection: e2, reprojectionErrorThreshold: t2.reprojectionErrorThreshold, tileGrid: i2, tileLoadFunction: t2.tileLoadFunction, tilePixelRatio: t2.tilePixelRatio, tileUrlFunction: t2.tileUrlFunction, url: t2.url, urls: t2.urls, wrapX: void 0 === t2.wrapX || t2.wrapX, transition: t2.transition, attributionsCollapsible: t2.attributionsCollapsible, zDirection: t2.zDirection }), this.gutter_ = void 0 !== t2.gutter ? t2.gutter : 0;
        }
        getGutter() {
          return this.gutter_;
        }
      }
      function ph(t2, e2, i2, n2, r2) {
        mh(t2, e2, i2 || 0, n2 || t2.length - 1, r2 || yh);
      }
      function mh(t2, e2, i2, n2, r2) {
        for (; n2 > i2; ) {
          if (n2 - i2 > 600) {
            var s2 = n2 - i2 + 1, o2 = e2 - i2 + 1, a2 = Math.log(s2), l2 = 0.5 * Math.exp(2 * a2 / 3), h2 = 0.5 * Math.sqrt(a2 * l2 * (s2 - l2) / s2) * (o2 - s2 / 2 < 0 ? -1 : 1);
            mh(t2, e2, Math.max(i2, Math.floor(e2 - o2 * l2 / s2 + h2)), Math.min(n2, Math.floor(e2 + (s2 - o2) * l2 / s2 + h2)), r2);
          }
          var c2 = t2[e2], u2 = i2, d2 = n2;
          for (_h(t2, i2, e2), r2(t2[n2], c2) > 0 && _h(t2, i2, n2); u2 < d2; ) {
            for (_h(t2, u2, d2), u2++, d2--; r2(t2[u2], c2) < 0; )
              u2++;
            for (; r2(t2[d2], c2) > 0; )
              d2--;
          }
          0 === r2(t2[i2], c2) ? _h(t2, i2, d2) : _h(t2, ++d2, n2), d2 <= e2 && (i2 = d2 + 1), e2 <= d2 && (n2 = d2 - 1);
        }
      }
      function _h(t2, e2, i2) {
        var n2 = t2[e2];
        t2[e2] = t2[i2], t2[i2] = n2;
      }
      function yh(t2, e2) {
        return t2 < e2 ? -1 : t2 > e2 ? 1 : 0;
      }
      class xh {
        constructor(t2 = 9) {
          this._maxEntries = Math.max(4, t2), this._minEntries = Math.max(2, Math.ceil(0.4 * this._maxEntries)), this.clear();
        }
        all() {
          return this._all(this.data, []);
        }
        search(t2) {
          let e2 = this.data;
          const i2 = [];
          if (!Lh(t2, e2))
            return i2;
          const n2 = this.toBBox, r2 = [];
          for (; e2; ) {
            for (let s2 = 0; s2 < e2.children.length; s2++) {
              const o2 = e2.children[s2], a2 = e2.leaf ? n2(o2) : o2;
              Lh(t2, a2) && (e2.leaf ? i2.push(o2) : Ih(t2, a2) ? this._all(o2, i2) : r2.push(o2));
            }
            e2 = r2.pop();
          }
          return i2;
        }
        collides(t2) {
          let e2 = this.data;
          if (!Lh(t2, e2))
            return false;
          const i2 = [];
          for (; e2; ) {
            for (let n2 = 0; n2 < e2.children.length; n2++) {
              const r2 = e2.children[n2], s2 = e2.leaf ? this.toBBox(r2) : r2;
              if (Lh(t2, s2)) {
                if (e2.leaf || Ih(t2, s2))
                  return true;
                i2.push(r2);
              }
            }
            e2 = i2.pop();
          }
          return false;
        }
        load(t2) {
          if (!t2 || !t2.length)
            return this;
          if (t2.length < this._minEntries) {
            for (let e3 = 0; e3 < t2.length; e3++)
              this.insert(t2[e3]);
            return this;
          }
          let e2 = this._build(t2.slice(), 0, t2.length - 1, 0);
          if (this.data.children.length)
            if (this.data.height === e2.height)
              this._splitRoot(this.data, e2);
            else {
              if (this.data.height < e2.height) {
                const t3 = this.data;
                this.data = e2, e2 = t3;
              }
              this._insert(e2, this.data.height - e2.height - 1, true);
            }
          else
            this.data = e2;
          return this;
        }
        insert(t2) {
          return t2 && this._insert(t2, this.data.height - 1), this;
        }
        clear() {
          return this.data = Mh([]), this;
        }
        remove(t2, e2) {
          if (!t2)
            return this;
          let i2 = this.data;
          const n2 = this.toBBox(t2), r2 = [], s2 = [];
          let o2, a2, l2;
          for (; i2 || r2.length; ) {
            if (i2 || (i2 = r2.pop(), a2 = r2[r2.length - 1], o2 = s2.pop(), l2 = true), i2.leaf) {
              const n3 = vh(t2, i2.children, e2);
              if (-1 !== n3)
                return i2.children.splice(n3, 1), r2.push(i2), this._condense(r2), this;
            }
            l2 || i2.leaf || !Ih(i2, n2) ? a2 ? (o2++, i2 = a2.children[o2], l2 = false) : i2 = null : (r2.push(i2), s2.push(o2), o2 = 0, a2 = i2, i2 = i2.children[0]);
          }
          return this;
        }
        toBBox(t2) {
          return t2;
        }
        compareMinX(t2, e2) {
          return t2.minX - e2.minX;
        }
        compareMinY(t2, e2) {
          return t2.minY - e2.minY;
        }
        toJSON() {
          return this.data;
        }
        fromJSON(t2) {
          return this.data = t2, this;
        }
        _all(t2, e2) {
          const i2 = [];
          for (; t2; )
            t2.leaf ? e2.push(...t2.children) : i2.push(...t2.children), t2 = i2.pop();
          return e2;
        }
        _build(t2, e2, i2, n2) {
          const r2 = i2 - e2 + 1;
          let s2, o2 = this._maxEntries;
          if (r2 <= o2)
            return s2 = Mh(t2.slice(e2, i2 + 1)), Sh(s2, this.toBBox), s2;
          n2 || (n2 = Math.ceil(Math.log(r2) / Math.log(o2)), o2 = Math.ceil(r2 / Math.pow(o2, n2 - 1))), s2 = Mh([]), s2.leaf = false, s2.height = n2;
          const a2 = Math.ceil(r2 / o2), l2 = a2 * Math.ceil(Math.sqrt(o2));
          Fh(t2, e2, i2, l2, this.compareMinX);
          for (let r3 = e2; r3 <= i2; r3 += l2) {
            const e3 = Math.min(r3 + l2 - 1, i2);
            Fh(t2, r3, e3, a2, this.compareMinY);
            for (let i3 = r3; i3 <= e3; i3 += a2) {
              const r4 = Math.min(i3 + a2 - 1, e3);
              s2.children.push(this._build(t2, i3, r4, n2 - 1));
            }
          }
          return Sh(s2, this.toBBox), s2;
        }
        _chooseSubtree(t2, e2, i2, n2) {
          for (; n2.push(e2), !e2.leaf && n2.length - 1 !== i2; ) {
            let i3, n3 = 1 / 0, o2 = 1 / 0;
            for (let a2 = 0; a2 < e2.children.length; a2++) {
              const l2 = e2.children[a2], h2 = bh(l2), c2 = (r2 = t2, s2 = l2, (Math.max(s2.maxX, r2.maxX) - Math.min(s2.minX, r2.minX)) * (Math.max(s2.maxY, r2.maxY) - Math.min(s2.minY, r2.minY)) - h2);
              c2 < o2 ? (o2 = c2, n3 = h2 < n3 ? h2 : n3, i3 = l2) : c2 === o2 && h2 < n3 && (n3 = h2, i3 = l2);
            }
            e2 = i3 || e2.children[0];
          }
          var r2, s2;
          return e2;
        }
        _insert(t2, e2, i2) {
          const n2 = i2 ? t2 : this.toBBox(t2), r2 = [], s2 = this._chooseSubtree(n2, this.data, e2, r2);
          for (s2.children.push(t2), Eh(s2, n2); e2 >= 0 && r2[e2].children.length > this._maxEntries; )
            this._split(r2, e2), e2--;
          this._adjustParentBBoxes(n2, r2, e2);
        }
        _split(t2, e2) {
          const i2 = t2[e2], n2 = i2.children.length, r2 = this._minEntries;
          this._chooseSplitAxis(i2, r2, n2);
          const s2 = this._chooseSplitIndex(i2, r2, n2), o2 = Mh(i2.children.splice(s2, i2.children.length - s2));
          o2.height = i2.height, o2.leaf = i2.leaf, Sh(i2, this.toBBox), Sh(o2, this.toBBox), e2 ? t2[e2 - 1].children.push(o2) : this._splitRoot(i2, o2);
        }
        _splitRoot(t2, e2) {
          this.data = Mh([t2, e2]), this.data.height = t2.height + 1, this.data.leaf = false, Sh(this.data, this.toBBox);
        }
        _chooseSplitIndex(t2, e2, i2) {
          let n2, r2 = 1 / 0, s2 = 1 / 0;
          for (let o2 = e2; o2 <= i2 - e2; o2++) {
            const e3 = wh(t2, 0, o2, this.toBBox), a2 = wh(t2, o2, i2, this.toBBox), l2 = Ph(e3, a2), h2 = bh(e3) + bh(a2);
            l2 < r2 ? (r2 = l2, n2 = o2, s2 = h2 < s2 ? h2 : s2) : l2 === r2 && h2 < s2 && (s2 = h2, n2 = o2);
          }
          return n2 || i2 - e2;
        }
        _chooseSplitAxis(t2, e2, i2) {
          const n2 = t2.leaf ? this.compareMinX : Th, r2 = t2.leaf ? this.compareMinY : Ch;
          this._allDistMargin(t2, e2, i2, n2) < this._allDistMargin(t2, e2, i2, r2) && t2.children.sort(n2);
        }
        _allDistMargin(t2, e2, i2, n2) {
          t2.children.sort(n2);
          const r2 = this.toBBox, s2 = wh(t2, 0, e2, r2), o2 = wh(t2, i2 - e2, i2, r2);
          let a2 = Rh(s2) + Rh(o2);
          for (let n3 = e2; n3 < i2 - e2; n3++) {
            const e3 = t2.children[n3];
            Eh(s2, t2.leaf ? r2(e3) : e3), a2 += Rh(s2);
          }
          for (let n3 = i2 - e2 - 1; n3 >= e2; n3--) {
            const e3 = t2.children[n3];
            Eh(o2, t2.leaf ? r2(e3) : e3), a2 += Rh(o2);
          }
          return a2;
        }
        _adjustParentBBoxes(t2, e2, i2) {
          for (let n2 = i2; n2 >= 0; n2--)
            Eh(e2[n2], t2);
        }
        _condense(t2) {
          for (let e2, i2 = t2.length - 1; i2 >= 0; i2--)
            0 === t2[i2].children.length ? i2 > 0 ? (e2 = t2[i2 - 1].children, e2.splice(e2.indexOf(t2[i2]), 1)) : this.clear() : Sh(t2[i2], this.toBBox);
        }
      }
      function vh(t2, e2, i2) {
        if (!i2)
          return e2.indexOf(t2);
        for (let n2 = 0; n2 < e2.length; n2++)
          if (i2(t2, e2[n2]))
            return n2;
        return -1;
      }
      function Sh(t2, e2) {
        wh(t2, 0, t2.children.length, e2, t2);
      }
      function wh(t2, e2, i2, n2, r2) {
        r2 || (r2 = Mh(null)), r2.minX = 1 / 0, r2.minY = 1 / 0, r2.maxX = -1 / 0, r2.maxY = -1 / 0;
        for (let s2 = e2; s2 < i2; s2++) {
          const e3 = t2.children[s2];
          Eh(r2, t2.leaf ? n2(e3) : e3);
        }
        return r2;
      }
      function Eh(t2, e2) {
        return t2.minX = Math.min(t2.minX, e2.minX), t2.minY = Math.min(t2.minY, e2.minY), t2.maxX = Math.max(t2.maxX, e2.maxX), t2.maxY = Math.max(t2.maxY, e2.maxY), t2;
      }
      function Th(t2, e2) {
        return t2.minX - e2.minX;
      }
      function Ch(t2, e2) {
        return t2.minY - e2.minY;
      }
      function bh(t2) {
        return (t2.maxX - t2.minX) * (t2.maxY - t2.minY);
      }
      function Rh(t2) {
        return t2.maxX - t2.minX + (t2.maxY - t2.minY);
      }
      function Ph(t2, e2) {
        const i2 = Math.max(t2.minX, e2.minX), n2 = Math.max(t2.minY, e2.minY), r2 = Math.min(t2.maxX, e2.maxX), s2 = Math.min(t2.maxY, e2.maxY);
        return Math.max(0, r2 - i2) * Math.max(0, s2 - n2);
      }
      function Ih(t2, e2) {
        return t2.minX <= e2.minX && t2.minY <= e2.minY && e2.maxX <= t2.maxX && e2.maxY <= t2.maxY;
      }
      function Lh(t2, e2) {
        return e2.minX <= t2.maxX && e2.minY <= t2.maxY && e2.maxX >= t2.minX && e2.maxY >= t2.minY;
      }
      function Mh(t2) {
        return { children: t2, height: 1, leaf: true, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
      }
      function Fh(t2, e2, i2, n2, r2) {
        const s2 = [e2, i2];
        for (; s2.length; ) {
          if ((i2 = s2.pop()) - (e2 = s2.pop()) <= n2)
            continue;
          const o2 = e2 + Math.ceil((i2 - e2) / n2 / 2) * n2;
          ph(t2, o2, e2, i2, r2), s2.push(e2, o2, o2, i2);
        }
      }
      class Ah {
        constructor(t2) {
          this.rbush_ = new xh(t2), this.items_ = {};
        }
        insert(t2, e2) {
          const i2 = { minX: t2[0], minY: t2[1], maxX: t2[2], maxY: t2[3], value: e2 };
          this.rbush_.insert(i2), this.items_[z(e2)] = i2;
        }
        load(t2, e2) {
          const i2 = new Array(e2.length);
          for (let n2 = 0, r2 = e2.length; n2 < r2; n2++) {
            const r3 = t2[n2], s2 = e2[n2], o2 = { minX: r3[0], minY: r3[1], maxX: r3[2], maxY: r3[3], value: s2 };
            i2[n2] = o2, this.items_[z(s2)] = o2;
          }
          this.rbush_.load(i2);
        }
        remove(t2) {
          const e2 = z(t2), i2 = this.items_[e2];
          return delete this.items_[e2], null !== this.rbush_.remove(i2);
        }
        update(t2, e2) {
          const i2 = this.items_[z(e2)];
          ee([i2.minX, i2.minY, i2.maxX, i2.maxY], t2) || (this.remove(e2), this.insert(t2, e2));
        }
        getAll() {
          return this.rbush_.all().map(function(t2) {
            return t2.value;
          });
        }
        getInExtent(t2) {
          const e2 = { minX: t2[0], minY: t2[1], maxX: t2[2], maxY: t2[3] };
          return this.rbush_.search(e2).map(function(t3) {
            return t3.value;
          });
        }
        forEach(t2) {
          return this.forEach_(this.getAll(), t2);
        }
        forEachInExtent(t2, e2) {
          return this.forEach_(this.getInExtent(t2), e2);
        }
        forEach_(t2, e2) {
          let i2;
          for (let n2 = 0, r2 = t2.length; n2 < r2; n2++)
            if (i2 = e2(t2[n2]), i2)
              return i2;
          return i2;
        }
        isEmpty() {
          return x(this.items_);
        }
        clear() {
          this.rbush_.clear(), this.items_ = {};
        }
        getExtent(t2) {
          const e2 = this.rbush_.toJSON();
          return $t(e2.minX, e2.minY, e2.maxX, e2.maxY, t2);
        }
        concat(t2) {
          this.rbush_.load(t2.rbush_.all());
          for (const e2 in t2.items_)
            this.items_[e2] = t2.items_[e2];
        }
      }
      var Oh = "addfeature", Nh = "changefeature", Dh = "clear", kh = "removefeature", Gh = "featuresloadstart", jh = "featuresloadend", Bh = "featuresloaderror";
      class Uh extends i {
        constructor(t2, e2, i2) {
          super(t2), this.feature = e2, this.features = i2;
        }
      }
      class zh extends Zl {
        constructor(t2) {
          super({ attributions: (t2 = t2 || {}).attributions, interpolate: true, projection: void 0, state: "ready", wrapX: void 0 === t2.wrapX || t2.wrapX }), this.on, this.once, this.un, this.loader_ = p, this.format_ = t2.format, this.overlaps_ = void 0 === t2.overlaps || t2.overlaps, this.url_ = t2.url, void 0 !== t2.loader ? this.loader_ = t2.loader : void 0 !== this.url_ && (at(this.format_, 7), this.loader_ = yl(this.url_, this.format_)), this.strategy_ = void 0 !== t2.strategy ? t2.strategy : xl;
          const e2 = void 0 === t2.useSpatialIndex || t2.useSpatialIndex;
          let i2, n2;
          this.featuresRtree_ = e2 ? new Ah() : null, this.loadedExtentsRtree_ = new Ah(), this.loadingExtentsCount_ = 0, this.nullGeometryFeatures_ = {}, this.idIndex_ = {}, this.uidIndex_ = {}, this.featureChangeKeys_ = {}, this.featuresCollection_ = null, Array.isArray(t2.features) ? n2 = t2.features : t2.features && (i2 = t2.features, n2 = i2.getArray()), e2 || void 0 !== i2 || (i2 = new q(n2)), void 0 !== n2 && this.addFeaturesInternal(n2), void 0 !== i2 && this.bindFeaturesCollection_(i2);
        }
        addFeature(t2) {
          this.addFeatureInternal(t2), this.changed();
        }
        addFeatureInternal(t2) {
          const e2 = z(t2);
          if (!this.addToIndex_(e2, t2))
            return void (this.featuresCollection_ && this.featuresCollection_.remove(t2));
          this.setupChangeEvents_(e2, t2);
          const i2 = t2.getGeometry();
          if (i2) {
            const e3 = i2.getExtent();
            this.featuresRtree_ && this.featuresRtree_.insert(e3, t2);
          } else
            this.nullGeometryFeatures_[e2] = t2;
          this.dispatchEvent(new Uh(Oh, t2));
        }
        setupChangeEvents_(t2, e2) {
          this.featureChangeKeys_[t2] = [N(e2, S, this.handleFeatureChange_, this), N(e2, r, this.handleFeatureChange_, this)];
        }
        addToIndex_(t2, e2) {
          let i2 = true;
          const n2 = e2.getId();
          return void 0 !== n2 && (n2.toString() in this.idIndex_ ? i2 = false : this.idIndex_[n2.toString()] = e2), i2 && (at(!(t2 in this.uidIndex_), 30), this.uidIndex_[t2] = e2), i2;
        }
        addFeatures(t2) {
          this.addFeaturesInternal(t2), this.changed();
        }
        addFeaturesInternal(t2) {
          const e2 = [], i2 = [], n2 = [];
          for (let e3 = 0, n3 = t2.length; e3 < n3; e3++) {
            const n4 = t2[e3], r2 = z(n4);
            this.addToIndex_(r2, n4) && i2.push(n4);
          }
          for (let t3 = 0, r2 = i2.length; t3 < r2; t3++) {
            const r3 = i2[t3], s2 = z(r3);
            this.setupChangeEvents_(s2, r3);
            const o2 = r3.getGeometry();
            if (o2) {
              const t4 = o2.getExtent();
              e2.push(t4), n2.push(r3);
            } else
              this.nullGeometryFeatures_[s2] = r3;
          }
          if (this.featuresRtree_ && this.featuresRtree_.load(e2, n2), this.hasListener(Oh))
            for (let t3 = 0, e3 = i2.length; t3 < e3; t3++)
              this.dispatchEvent(new Uh(Oh, i2[t3]));
        }
        bindFeaturesCollection_(t2) {
          let e2 = false;
          this.addEventListener(Oh, function(i2) {
            e2 || (e2 = true, t2.push(i2.feature), e2 = false);
          }), this.addEventListener(kh, function(i2) {
            e2 || (e2 = true, t2.remove(i2.feature), e2 = false);
          }), t2.addEventListener(W, function(t3) {
            e2 || (e2 = true, this.addFeature(t3.element), e2 = false);
          }.bind(this)), t2.addEventListener(Z, function(t3) {
            e2 || (e2 = true, this.removeFeature(t3.element), e2 = false);
          }.bind(this)), this.featuresCollection_ = t2;
        }
        clear(t2) {
          if (t2) {
            for (const t3 in this.featureChangeKeys_) {
              this.featureChangeKeys_[t3].forEach(k);
            }
            this.featuresCollection_ || (this.featureChangeKeys_ = {}, this.idIndex_ = {}, this.uidIndex_ = {});
          } else if (this.featuresRtree_) {
            const t3 = function(t4) {
              this.removeFeatureInternal(t4);
            }.bind(this);
            this.featuresRtree_.forEach(t3);
            for (const t4 in this.nullGeometryFeatures_)
              this.removeFeatureInternal(this.nullGeometryFeatures_[t4]);
          }
          this.featuresCollection_ && this.featuresCollection_.clear(), this.featuresRtree_ && this.featuresRtree_.clear(), this.nullGeometryFeatures_ = {};
          const e2 = new Uh(Dh);
          this.dispatchEvent(e2), this.changed();
        }
        forEachFeature(t2) {
          if (this.featuresRtree_)
            return this.featuresRtree_.forEach(t2);
          this.featuresCollection_ && this.featuresCollection_.forEach(t2);
        }
        forEachFeatureAtCoordinateDirect(t2, e2) {
          const i2 = [t2[0], t2[1], t2[0], t2[1]];
          return this.forEachFeatureInExtent(i2, function(i3) {
            return i3.getGeometry().intersectsCoordinate(t2) ? e2(i3) : void 0;
          });
        }
        forEachFeatureInExtent(t2, e2) {
          if (this.featuresRtree_)
            return this.featuresRtree_.forEachInExtent(t2, e2);
          this.featuresCollection_ && this.featuresCollection_.forEach(e2);
        }
        forEachFeatureIntersectingExtent(t2, e2) {
          return this.forEachFeatureInExtent(t2, function(i2) {
            if (i2.getGeometry().intersectsExtent(t2)) {
              const t3 = e2(i2);
              if (t3)
                return t3;
            }
          });
        }
        getFeaturesCollection() {
          return this.featuresCollection_;
        }
        getFeatures() {
          let t2;
          return this.featuresCollection_ ? t2 = this.featuresCollection_.getArray().slice(0) : this.featuresRtree_ && (t2 = this.featuresRtree_.getAll(), x(this.nullGeometryFeatures_) || c(t2, Object.values(this.nullGeometryFeatures_))), t2;
        }
        getFeaturesAtCoordinate(t2) {
          const e2 = [];
          return this.forEachFeatureAtCoordinateDirect(t2, function(t3) {
            e2.push(t3);
          }), e2;
        }
        getFeaturesInExtent(t2, e2) {
          if (this.featuresRtree_) {
            if (!(e2 && e2.canWrapX() && this.getWrapX()))
              return this.featuresRtree_.getInExtent(t2);
            const i2 = Ie(t2, e2);
            return [].concat(...i2.map((t3) => this.featuresRtree_.getInExtent(t3)));
          }
          return this.featuresCollection_ ? this.featuresCollection_.getArray().slice(0) : [];
        }
        getClosestFeatureToCoordinate(t2, e2) {
          const i2 = t2[0], n2 = t2[1];
          let r2 = null;
          const s2 = [NaN, NaN];
          let o2 = 1 / 0;
          const a2 = [-1 / 0, -1 / 0, 1 / 0, 1 / 0];
          return e2 = e2 || g, this.featuresRtree_.forEachInExtent(a2, function(t3) {
            if (e2(t3)) {
              const e3 = t3.getGeometry(), l2 = o2;
              if (o2 = e3.closestPointXY(i2, n2, s2, o2), o2 < l2) {
                r2 = t3;
                const e4 = Math.sqrt(o2);
                a2[0] = i2 - e4, a2[1] = n2 - e4, a2[2] = i2 + e4, a2[3] = n2 + e4;
              }
            }
          }), r2;
        }
        getExtent(t2) {
          return this.featuresRtree_.getExtent(t2);
        }
        getFeatureById(t2) {
          const e2 = this.idIndex_[t2.toString()];
          return void 0 !== e2 ? e2 : null;
        }
        getFeatureByUid(t2) {
          const e2 = this.uidIndex_[t2];
          return void 0 !== e2 ? e2 : null;
        }
        getFormat() {
          return this.format_;
        }
        getOverlaps() {
          return this.overlaps_;
        }
        getUrl() {
          return this.url_;
        }
        handleFeatureChange_(t2) {
          const e2 = t2.target, i2 = z(e2), n2 = e2.getGeometry();
          if (n2) {
            const t3 = n2.getExtent();
            i2 in this.nullGeometryFeatures_ ? (delete this.nullGeometryFeatures_[i2], this.featuresRtree_ && this.featuresRtree_.insert(t3, e2)) : this.featuresRtree_ && this.featuresRtree_.update(t3, e2);
          } else
            i2 in this.nullGeometryFeatures_ || (this.featuresRtree_ && this.featuresRtree_.remove(e2), this.nullGeometryFeatures_[i2] = e2);
          const r2 = e2.getId();
          if (void 0 !== r2) {
            const t3 = r2.toString();
            this.idIndex_[t3] !== e2 && (this.removeFromIdIndex_(e2), this.idIndex_[t3] = e2);
          } else
            this.removeFromIdIndex_(e2), this.uidIndex_[i2] = e2;
          this.changed(), this.dispatchEvent(new Uh(Nh, e2));
        }
        hasFeature(t2) {
          const e2 = t2.getId();
          return void 0 !== e2 ? e2 in this.idIndex_ : z(t2) in this.uidIndex_;
        }
        isEmpty() {
          return this.featuresRtree_ ? this.featuresRtree_.isEmpty() && x(this.nullGeometryFeatures_) : !this.featuresCollection_ || 0 === this.featuresCollection_.getLength();
        }
        loadFeatures(t2, e2, i2) {
          const n2 = this.loadedExtentsRtree_, r2 = this.strategy_(t2, e2, i2);
          for (let t3 = 0, s2 = r2.length; t3 < s2; ++t3) {
            const s3 = r2[t3];
            n2.forEachInExtent(s3, function(t4) {
              return Yt(t4.extent, s3);
            }) || (++this.loadingExtentsCount_, this.dispatchEvent(new Uh(Gh)), this.loader_.call(this, s3, e2, i2, function(t4) {
              --this.loadingExtentsCount_, this.dispatchEvent(new Uh(jh, void 0, t4));
            }.bind(this), function() {
              --this.loadingExtentsCount_, this.dispatchEvent(new Uh(Bh));
            }.bind(this)), n2.insert(s3, { extent: s3.slice() }));
          }
          this.loading = !(this.loader_.length < 4) && this.loadingExtentsCount_ > 0;
        }
        refresh() {
          this.clear(true), this.loadedExtentsRtree_.clear(), super.refresh();
        }
        removeLoadedExtent(t2) {
          const e2 = this.loadedExtentsRtree_;
          let i2;
          e2.forEachInExtent(t2, function(e3) {
            if (ee(e3.extent, t2))
              return i2 = e3, true;
          }), i2 && e2.remove(i2);
        }
        removeFeature(t2) {
          if (!t2)
            return;
          const e2 = z(t2);
          e2 in this.nullGeometryFeatures_ ? delete this.nullGeometryFeatures_[e2] : this.featuresRtree_ && this.featuresRtree_.remove(t2);
          this.removeFeatureInternal(t2) && this.changed();
        }
        removeFeatureInternal(t2) {
          const e2 = z(t2), i2 = this.featureChangeKeys_[e2];
          if (!i2)
            return;
          i2.forEach(k), delete this.featureChangeKeys_[e2];
          const n2 = t2.getId();
          return void 0 !== n2 && delete this.idIndex_[n2.toString()], delete this.uidIndex_[e2], this.dispatchEvent(new Uh(kh, t2)), t2;
        }
        removeFromIdIndex_(t2) {
          let e2 = false;
          for (const i2 in this.idIndex_)
            if (this.idIndex_[i2] === t2) {
              delete this.idIndex_[i2], e2 = true;
              break;
            }
          return e2;
        }
        setLoader(t2) {
          this.loader_ = t2;
        }
        setUrl(t2) {
          at(this.format_, 7), this.url_ = t2, this.setLoader(yl(t2, this.format_));
        }
      }
      class Xh extends nh {
        constructor(t2) {
          const e2 = void 0 === t2.projection ? "EPSG:3857" : t2.projection;
          let i2 = t2.tileGrid;
          void 0 === i2 && e2 && (i2 = Ql({ extent: ih(e2), maxResolution: t2.maxResolution, maxZoom: t2.maxZoom, minZoom: t2.minZoom, tileSize: t2.tileSize })), super({ cacheSize: 0.1, attributions: t2.attributions, attributionsCollapsible: t2.attributionsCollapsible, projection: e2, tileGrid: i2, opaque: t2.opaque, state: t2.state, wrapX: t2.wrapX, transition: t2.transition, interpolate: t2.interpolate }), this.gutter_ = void 0 !== t2.gutter ? t2.gutter : 0, this.tileSize_ = t2.tileSize ? Va(t2.tileSize) : null, this.tileSizes_ = null, this.tileLoadingKeys_ = {}, this.loader_ = t2.loader, this.handleTileChange_ = this.handleTileChange_.bind(this), this.bandCount = void 0 === t2.bandCount ? 4 : t2.bandCount;
        }
        setTileSizes(t2) {
          this.tileSizes_ = t2;
        }
        getTileSize(t2) {
          if (this.tileSizes_)
            return this.tileSizes_[t2];
          if (this.tileSize_)
            return this.tileSize_;
          const e2 = this.getTileGrid();
          return e2 ? Va(e2.getTileSize(t2)) : [256, 256];
        }
        getGutterForProjection(t2) {
          return this.gutter_;
        }
        setLoader(t2) {
          this.loader_ = t2;
        }
        getTile(t2, e2, i2, n2, r2) {
          const s2 = this.getTileSize(t2), o2 = il(t2, e2, i2);
          if (this.tileCache.containsKey(o2))
            return this.tileCache.get(o2);
          const a2 = this.loader_;
          const l2 = Object.assign({ tileCoord: [t2, e2, i2], loader: function() {
            return _(function() {
              return a2(t2, e2, i2);
            });
          }, size: s2 }, this.tileOptions), h2 = new ot(l2);
          return h2.key = this.getKey(), h2.addEventListener(S, this.handleTileChange_), this.tileCache.set(o2, h2), h2;
        }
        handleTileChange_(t2) {
          const e2 = t2.target, i2 = z(e2), n2 = e2.getState();
          let r2;
          n2 == $ ? (this.tileLoadingKeys_[i2] = true, r2 = Xl) : i2 in this.tileLoadingKeys_ && (delete this.tileLoadingKeys_[i2], r2 = n2 == Q ? Wl : n2 == J ? Vl : void 0), r2 && this.dispatchEvent(new rh(r2, e2));
        }
      }
      function Vh(t2, e2) {
        if (!t2)
          return false;
        if (true === t2)
          return true;
        if (3 !== e2.getSamplesPerPixel())
          return false;
        const i2 = e2.fileDirectory.PhotometricInterpretation, n2 = GeoTIFF.globals.photometricInterpretations;
        return i2 === n2.CMYK || i2 === n2.YCbCr || i2 === n2.CIELab || i2 === n2.ICCLab;
      }
      const Wh = "STATISTICS_MAXIMUM", Zh = "STATISTICS_MINIMUM";
      let Yh;
      function Kh(t2) {
        try {
          return t2.getBoundingBox();
        } catch (e2) {
          const i2 = t2.fileDirectory;
          return [0, 0, i2.ImageWidth, i2.ImageLength];
        }
      }
      function qh(t2) {
        try {
          return t2.getOrigin().slice(0, 2);
        } catch (e2) {
          return [0, t2.fileDirectory.ImageLength];
        }
      }
      function Hh(t2, e2) {
        try {
          return t2.getResolution(e2);
        } catch (i2) {
          return [e2.fileDirectory.ImageWidth / t2.fileDirectory.ImageWidth, e2.fileDirectory.ImageHeight / t2.fileDirectory.ImageHeight];
        }
      }
      function $h(t2) {
        const e2 = t2.geoKeys;
        if (!e2)
          return null;
        if (e2.ProjectedCSTypeGeoKey) {
          const t3 = "EPSG:" + e2.ProjectedCSTypeGeoKey;
          let i2 = Ui(t3);
          if (!i2) {
            const n2 = Me(e2.ProjLinearUnitsGeoKey);
            n2 && (i2 = new Ae({ code: t3, units: n2 }));
          }
          return i2;
        }
        if (e2.GeographicTypeGeoKey) {
          const t3 = "EPSG:" + e2.GeographicTypeGeoKey;
          let i2 = Ui(t3);
          if (!i2) {
            const n2 = Me(e2.GeogAngularUnitsGeoKey);
            n2 && (i2 = new Ae({ code: t3, units: n2 }));
          }
          return i2;
        }
        return null;
      }
      function Jh(t2) {
        return t2.getImageCount().then(function(e2) {
          const i2 = new Array(e2);
          for (let n2 = 0; n2 < e2; ++n2)
            i2[n2] = t2.getImage(n2);
          return Promise.all(i2);
        });
      }
      function Qh(t2, e2) {
        let i2;
        return i2 = t2.blob ? GeoTIFF.fromBlob(t2.blob) : t2.overviews ? GeoTIFF.fromUrls(t2.url, t2.overviews, e2) : GeoTIFF.fromUrl(t2.url, e2), i2.then(Jh);
      }
      function tc(t2, e2, i2, n2, r2) {
        if (Array.isArray(t2)) {
          const s2 = t2.length;
          if (!Array.isArray(e2) || s2 != e2.length) {
            const t3 = new Error(n2);
            throw r2(t3), t3;
          }
          for (let o2 = 0; o2 < s2; ++o2)
            tc(t2[o2], e2[o2], i2, n2, r2);
        } else if (Math.abs(t2 - e2) > i2 * t2)
          throw new Error(n2);
      }
      function ec(t2) {
        return t2 instanceof Int8Array ? 127 : t2 instanceof Uint8Array || t2 instanceof Uint8ClampedArray ? 255 : t2 instanceof Int16Array ? 32767 : t2 instanceof Uint16Array ? 65535 : t2 instanceof Int32Array ? 2147483647 : t2 instanceof Uint32Array ? 4294967295 : t2 instanceof Float32Array ? 34e37 : 255;
      }
      class ic extends Xh {
        constructor(t2) {
          super({ state: "loading", tileGrid: null, projection: null, opaque: t2.opaque, transition: t2.transition, interpolate: false !== t2.interpolate, wrapX: t2.wrapX }), this.sourceInfo_ = t2.sources;
          const e2 = this.sourceInfo_.length;
          this.sourceOptions_ = t2.sourceOptions, this.sourceImagery_ = new Array(e2), this.sourceMasks_ = new Array(e2), this.resolutionFactors_ = new Array(e2), this.samplesPerPixel_, this.nodataValues_, this.metadata_, this.normalize_ = false !== t2.normalize, this.addAlpha_ = false, this.error_ = null, this.convertToRGB_ = t2.convertToRGB || false, this.setKey(this.sourceInfo_.map((t3) => t3.url).join(","));
          const i2 = this, n2 = new Array(e2);
          for (let t3 = 0; t3 < e2; ++t3)
            n2[t3] = Qh(this.sourceInfo_[t3], this.sourceOptions_);
          Promise.all(n2).then(function(t3) {
            i2.configure_(t3);
          }).catch(function(t3) {
            console.error(t3), i2.error_ = t3, i2.setState("error");
          });
        }
        getError() {
          return this.error_;
        }
        configure_(t2) {
          let e2, i2, n2, r2, s2;
          const o2 = new Array(t2.length), a2 = new Array(t2.length), l2 = new Array(t2.length);
          let h2 = 0;
          const c2 = t2.length;
          for (let u3 = 0; u3 < c2; ++u3) {
            const c3 = [], d3 = [];
            t2[u3].forEach((t3) => {
              4 == (4 & (t3.fileDirectory.NewSubfileType || 0)) ? d3.push(t3) : c3.push(t3);
            });
            const g3 = c3.length;
            if (d3.length > 0 && d3.length !== g3)
              throw new Error(`Expected one mask per image found ${d3.length} masks and ${g3} images`);
            let f2, p2;
            const m2 = new Array(g3), _2 = new Array(g3), y2 = new Array(g3);
            a2[u3] = new Array(g3), l2[u3] = new Array(g3);
            for (let t3 = 0; t3 < g3; ++t3) {
              const e3 = c3[t3], i3 = e3.getGDALNoData();
              l2[u3][t3] = e3.getGDALMetadata(0), a2[u3][t3] = i3;
              const n3 = this.sourceInfo_[u3].bands;
              o2[u3] = n3 ? n3.length : e3.getSamplesPerPixel();
              const r3 = g3 - (t3 + 1);
              f2 || (f2 = Kh(e3)), p2 || (p2 = qh(e3));
              const s3 = Hh(e3, c3[0]);
              y2[r3] = s3[0];
              const h3 = [e3.getTileWidth(), e3.getTileHeight()];
              m2[r3] = h3;
              const d4 = s3[0] / Math.abs(s3[1]);
              _2[r3] = [h3[0], h3[1] / d4];
            }
            if (e2 ? ye(e2, f2, e2) : e2 = f2, i2) {
              tc(i2, p2, 0, `Origin mismatch for source ${u3}, got [${p2}] but expected [${i2}]`, this.viewRejector);
            } else
              i2 = p2;
            if (s2) {
              s2.length - h2 > y2.length && (h2 = s2.length - y2.length);
              const t3 = s2[s2.length - 1] / y2[y2.length - 1];
              this.resolutionFactors_[u3] = t3;
              const e3 = y2.map((e4) => e4 * t3), i3 = `Resolution mismatch for source ${u3}, got [${e3}] but expected [${s2}]`;
              tc(s2.slice(h2, s2.length), e3, 0.02, i3, this.viewRejector);
            } else
              s2 = y2, this.resolutionFactors_[u3] = 1;
            n2 ? tc(n2.slice(h2, n2.length), _2, 0.01, `Tile size mismatch for source ${u3}`, this.viewRejector) : n2 = _2, r2 ? tc(r2.slice(h2, r2.length), m2, 0, `Tile size mismatch for source ${u3}`, this.viewRejector) : r2 = m2, this.sourceImagery_[u3] = c3.reverse(), this.sourceMasks_[u3] = d3.reverse();
          }
          for (let t3 = 0, e3 = this.sourceImagery_.length; t3 < e3; ++t3) {
            const e4 = this.sourceImagery_[t3];
            for (; e4.length < s2.length; )
              e4.unshift(void 0);
          }
          if (!this.getProjection()) {
            const e3 = t2[0];
            for (let t3 = e3.length - 1; t3 >= 0; --t3) {
              const i3 = $h(e3[t3]);
              if (i3) {
                this.projection = i3;
                break;
              }
            }
          }
          this.samplesPerPixel_ = o2, this.nodataValues_ = a2, this.metadata_ = l2;
          t:
            for (let t3 = 0; t3 < c2; ++t3) {
              if (void 0 !== this.sourceInfo_[t3].nodata) {
                this.addAlpha_ = true;
                break;
              }
              if (this.sourceMasks_[t3].length) {
                this.addAlpha_ = true;
                break;
              }
              const e3 = a2[t3], i3 = this.sourceInfo_[t3].bands;
              if (i3) {
                for (let t4 = 0; t4 < i3.length; ++t4)
                  if (null !== e3[i3[t4] - 1]) {
                    this.addAlpha_ = true;
                    break t;
                  }
              } else
                for (let t4 = 0; t4 < e3.length; ++t4)
                  if (null !== e3[t4]) {
                    this.addAlpha_ = true;
                    break t;
                  }
            }
          let u2 = this.addAlpha_ ? 1 : 0;
          for (let t3 = 0; t3 < c2; ++t3)
            u2 += o2[t3];
          this.bandCount = u2;
          const d2 = new ql({ extent: e2, minZoom: h2, origin: i2, resolutions: s2, tileSizes: n2 });
          this.tileGrid = d2, this.setTileSizes(r2), this.setLoader(this.loadTile_.bind(this)), this.setState("ready");
          let g2 = 0;
          1 === s2.length && (s2 = [2 * s2[0], s2[0]], g2 = 1), this.viewResolver({ showFullExtent: true, projection: this.projection, resolutions: s2, center: nn(ge(e2), this.projection), extent: sn(e2, this.projection), zoom: g2 });
        }
        loadTile_(t2, e2, i2) {
          const n2 = this.getTileSize(t2), r2 = this.sourceImagery_.length, s2 = new Array(2 * r2), o2 = this.nodataValues_, a2 = this.sourceInfo_, l2 = (Yh || (Yh = new GeoTIFF.Pool()), Yh);
          for (let h2 = 0; h2 < r2; ++h2) {
            const c2 = a2[h2], u2 = this.resolutionFactors_[h2], d2 = [Math.round(e2 * (n2[0] * u2)), Math.round(i2 * (n2[1] * u2)), Math.round((e2 + 1) * (n2[0] * u2)), Math.round((i2 + 1) * (n2[1] * u2))], g2 = this.sourceImagery_[h2][t2];
            let f2, p2;
            c2.bands && (f2 = c2.bands.map(function(t3) {
              return t3 - 1;
            })), p2 = "nodata" in c2 && null !== c2.nodata ? c2.nodata : f2 ? f2.map(function(t3) {
              return o2[h2][t3];
            }) : o2[h2];
            const m2 = { window: d2, width: n2[0], height: n2[1], samples: f2, fillValue: p2, pool: l2, interleave: false };
            Vh(this.convertToRGB_, g2) ? s2[h2] = g2.readRGB(m2) : s2[h2] = g2.readRasters(m2);
            const _2 = r2 + h2, y2 = this.sourceMasks_[h2][t2];
            y2 ? s2[_2] = y2.readRasters({ window: d2, width: n2[0], height: n2[1], samples: [0], pool: l2, interleave: false }) : s2[_2] = Promise.resolve(null);
          }
          return Promise.all(s2).then(this.composeTile_.bind(this, n2)).catch(function(t3) {
            throw console.error(t3), t3;
          });
        }
        composeTile_(t2, e2) {
          const i2 = this.metadata_, n2 = this.sourceInfo_, r2 = this.sourceImagery_.length, s2 = this.bandCount, o2 = this.samplesPerPixel_, a2 = this.nodataValues_, l2 = this.normalize_, h2 = this.addAlpha_, c2 = t2[0] * t2[1], u2 = c2 * s2;
          let d2;
          d2 = l2 ? new Uint8Array(u2) : new Float32Array(u2);
          let g2 = 0;
          for (let t3 = 0; t3 < c2; ++t3) {
            let s3 = h2;
            for (let c3 = 0; c3 < r2; ++c3) {
              const u3 = n2[c3];
              let p2, m2, _2 = u3.min, y2 = u3.max;
              if (l2) {
                const t4 = i2[c3][0];
                void 0 === _2 && (_2 = t4 && Zh in t4 ? parseFloat(t4.STATISTICS_MINIMUM) : (f2 = e2[c3][0]) instanceof Int8Array ? -128 : f2 instanceof Int16Array ? -32768 : f2 instanceof Int32Array ? -2147483648 : f2 instanceof Float32Array ? 12e-39 : 0), void 0 === y2 && (y2 = t4 && Wh in t4 ? parseFloat(t4.STATISTICS_MAXIMUM) : ec(e2[c3][0])), p2 = 255 / (y2 - _2), m2 = -_2 * p2;
              }
              for (let i3 = 0; i3 < o2[c3]; ++i3) {
                const n3 = e2[c3][i3][t3];
                let r3;
                if (r3 = l2 ? ii(p2 * n3 + m2, 0, 255) : n3, h2) {
                  let t4 = u3.nodata;
                  if (void 0 === t4) {
                    let e4;
                    e4 = u3.bands ? u3.bands[i3] - 1 : i3, t4 = a2[c3][e4];
                  }
                  const e3 = isNaN(t4);
                  (!e3 && n3 !== t4 || e3 && !isNaN(n3)) && (s3 = false, d2[g2] = r3);
                } else
                  d2[g2] = r3;
                g2++;
              }
              if (!s3) {
                const i3 = e2[r2 + c3];
                i3 && !i3[0][t3] && (s3 = true);
              }
            }
            h2 && (s3 || (d2[g2] = 255), g2++);
          }
          var f2;
          return d2;
        }
      }
      ic.prototype.getView;
      class nc extends Vr {
        constructor(t2, e2, i2, n2, r2, s2, o2) {
          super(e2, i2, n2, r2, s2, o2), this.zoomifyImage_ = null, this.tileSize_ = t2;
        }
        getImage() {
          if (this.zoomifyImage_)
            return this.zoomifyImage_;
          const t2 = super.getImage();
          if (this.state == J) {
            const e2 = this.tileSize_;
            if (t2.width == e2[0] && t2.height == e2[1])
              return this.zoomifyImage_ = t2, t2;
            {
              const i2 = Dr(e2[0], e2[1]);
              return i2.drawImage(t2, 0, 0), this.zoomifyImage_ = i2.canvas, i2.canvas;
            }
          }
          return t2;
        }
      }
      const rc = "version1", sc = "version2", oc = "version3", ac = {};
      ac[rc] = { level0: { supports: [], formats: [], qualities: ["native"] }, level1: { supports: ["regionByPx", "sizeByW", "sizeByH", "sizeByPct"], formats: ["jpg"], qualities: ["native"] }, level2: { supports: ["regionByPx", "regionByPct", "sizeByW", "sizeByH", "sizeByPct", "sizeByConfinedWh", "sizeByWh"], formats: ["jpg", "png"], qualities: ["native", "color", "grey", "bitonal"] } }, ac[sc] = { level0: { supports: [], formats: ["jpg"], qualities: ["default"] }, level1: { supports: ["regionByPx", "sizeByW", "sizeByH", "sizeByPct"], formats: ["jpg"], qualities: ["default"] }, level2: { supports: ["regionByPx", "regionByPct", "sizeByW", "sizeByH", "sizeByPct", "sizeByConfinedWh", "sizeByDistortedWh", "sizeByWh"], formats: ["jpg", "png"], qualities: ["default", "bitonal"] } }, ac[oc] = { level0: { supports: [], formats: ["jpg"], qualities: ["default"] }, level1: { supports: ["regionByPx", "regionSquare", "sizeByW", "sizeByH", "sizeByWh"], formats: ["jpg"], qualities: ["default"] }, level2: { supports: ["regionByPx", "regionSquare", "regionByPct", "sizeByW", "sizeByH", "sizeByPct", "sizeByConfinedWh", "sizeByWh"], formats: ["jpg", "png"], qualities: ["default"] } }, ac.none = { none: { supports: [], formats: [], qualities: [] } };
      const lc = /^https?:\/\/library\.stanford\.edu\/iiif\/image-api\/(?:1\.1\/)?compliance\.html#level[0-2]$/, hc = /^https?:\/\/iiif\.io\/api\/image\/2\/level[0-2](?:\.json)?$/, cc = /(^https?:\/\/iiif\.io\/api\/image\/3\/level[0-2](?:\.json)?$)|(^level[0-2]$)/;
      const uc = {};
      uc[rc] = function(t2) {
        let e2 = t2.getComplianceLevelSupportedFeatures();
        return void 0 === e2 && (e2 = ac[rc].level0), { url: void 0 === t2.imageInfo["@id"] ? void 0 : t2.imageInfo["@id"].replace(/\/?(?:info\.json)?$/g, ""), supports: e2.supports, formats: [...e2.formats, void 0 === t2.imageInfo.formats ? [] : t2.imageInfo.formats], qualities: [...e2.qualities, void 0 === t2.imageInfo.qualities ? [] : t2.imageInfo.qualities], resolutions: t2.imageInfo.scale_factors, tileSize: void 0 !== t2.imageInfo.tile_width ? void 0 !== t2.imageInfo.tile_height ? [t2.imageInfo.tile_width, t2.imageInfo.tile_height] : [t2.imageInfo.tile_width, t2.imageInfo.tile_width] : null != t2.imageInfo.tile_height ? [t2.imageInfo.tile_height, t2.imageInfo.tile_height] : void 0 };
      }, uc[sc] = function(t2) {
        const e2 = t2.getComplianceLevelSupportedFeatures(), i2 = Array.isArray(t2.imageInfo.profile) && t2.imageInfo.profile.length > 1, n2 = i2 && t2.imageInfo.profile[1].supports ? t2.imageInfo.profile[1].supports : [], r2 = i2 && t2.imageInfo.profile[1].formats ? t2.imageInfo.profile[1].formats : [], s2 = i2 && t2.imageInfo.profile[1].qualities ? t2.imageInfo.profile[1].qualities : [];
        return { url: t2.imageInfo["@id"].replace(/\/?(?:info\.json)?$/g, ""), sizes: void 0 === t2.imageInfo.sizes ? void 0 : t2.imageInfo.sizes.map(function(t3) {
          return [t3.width, t3.height];
        }), tileSize: void 0 === t2.imageInfo.tiles ? void 0 : [t2.imageInfo.tiles.map(function(t3) {
          return t3.width;
        })[0], t2.imageInfo.tiles.map(function(t3) {
          return void 0 === t3.height ? t3.width : t3.height;
        })[0]], resolutions: void 0 === t2.imageInfo.tiles ? void 0 : t2.imageInfo.tiles.map(function(t3) {
          return t3.scaleFactors;
        })[0], supports: [...e2.supports, ...n2], formats: [...e2.formats, ...r2], qualities: [...e2.qualities, ...s2] };
      }, uc[oc] = function(t2) {
        const e2 = t2.getComplianceLevelSupportedFeatures(), i2 = void 0 === t2.imageInfo.extraFormats ? e2.formats : [...e2.formats, ...t2.imageInfo.extraFormats], n2 = void 0 !== t2.imageInfo.preferredFormats && Array.isArray(t2.imageInfo.preferredFormats) && t2.imageInfo.preferredFormats.length > 0 ? t2.imageInfo.preferredFormats.filter(function(t3) {
          return ["jpg", "png", "gif"].includes(t3);
        }).reduce(function(t3, e3) {
          return void 0 === t3 && i2.includes(e3) ? e3 : t3;
        }, void 0) : void 0;
        return { url: t2.imageInfo.id, sizes: void 0 === t2.imageInfo.sizes ? void 0 : t2.imageInfo.sizes.map(function(t3) {
          return [t3.width, t3.height];
        }), tileSize: void 0 === t2.imageInfo.tiles ? void 0 : [t2.imageInfo.tiles.map(function(t3) {
          return t3.width;
        })[0], t2.imageInfo.tiles.map(function(t3) {
          return t3.height;
        })[0]], resolutions: void 0 === t2.imageInfo.tiles ? void 0 : t2.imageInfo.tiles.map(function(t3) {
          return t3.scaleFactors;
        })[0], supports: void 0 === t2.imageInfo.extraFeatures ? e2.supports : [...e2.supports, ...t2.imageInfo.extraFeatures], formats: i2, qualities: void 0 === t2.imageInfo.extraQualities ? e2.qualities : [...e2.qualities, ...t2.imageInfo.extraQualities], preferredFormat: n2 };
      };
      function dc(t2) {
        return t2.toLocaleString("en", { maximumFractionDigits: 10 });
      }
      class gc extends Rr {
        constructor(t2, e2, i2, n2, r2, s2, o2) {
          const a2 = t2.getExtent(), l2 = e2.getExtent(), h2 = l2 ? ye(i2, l2) : i2, c2 = Gl(t2, e2, ge(h2), n2), u2 = new Ul(t2, e2, h2, a2, 0.5 * c2, n2), d2 = s2(u2.calculateSourceExtent(), c2, r2), g2 = d2 ? Pr : Fr, f2 = d2 ? d2.getPixelRatio() : 1;
          super(i2, n2, f2, g2), this.targetProj_ = e2, this.maxSourceExtent_ = a2, this.triangulation_ = u2, this.targetResolution_ = n2, this.targetExtent_ = i2, this.sourceImage_ = d2, this.sourcePixelRatio_ = f2, this.interpolate_ = o2, this.canvas_ = null, this.sourceListenerKey_ = null;
        }
        disposeInternal() {
          this.state == Ir && this.unlistenSource_(), super.disposeInternal();
        }
        getImage() {
          return this.canvas_;
        }
        getProjection() {
          return this.targetProj_;
        }
        reproject_() {
          const t2 = this.sourceImage_.getState();
          if (t2 == Lr) {
            const t3 = Se(this.targetExtent_) / this.targetResolution_, e2 = _e(this.targetExtent_) / this.targetResolution_;
            this.canvas_ = Bl(t3, e2, this.sourcePixelRatio_, this.sourceImage_.getResolution(), this.maxSourceExtent_, this.targetResolution_, this.targetExtent_, this.triangulation_, [{ extent: this.sourceImage_.getExtent(), image: this.sourceImage_.getImage() }], 0, void 0, this.interpolate_);
          }
          this.state = t2, this.changed();
        }
        load() {
          if (this.state == Pr) {
            this.state = Ir, this.changed();
            const t2 = this.sourceImage_.getState();
            t2 == Lr || t2 == Mr ? this.reproject_() : (this.sourceListenerKey_ = N(this.sourceImage_, S, function(t3) {
              const e2 = this.sourceImage_.getState();
              e2 != Lr && e2 != Mr || (this.unlistenSource_(), this.reproject_());
            }, this), this.sourceImage_.load());
          }
        }
        unlistenSource_() {
          k(this.sourceListenerKey_), this.sourceListenerKey_ = null;
        }
      }
      const fc = "imageloadstart", pc = "imageloadend", mc = "imageloaderror";
      class _c extends i {
        constructor(t2, e2) {
          super(t2), this.image = e2;
        }
      }
      class yc extends Zl {
        constructor(t2) {
          super({ attributions: t2.attributions, projection: t2.projection, state: t2.state, interpolate: void 0 === t2.interpolate || t2.interpolate }), this.on, this.once, this.un, this.resolutions_ = void 0 !== t2.resolutions ? t2.resolutions : null, this.reprojectedImage_ = null, this.reprojectedRevision_ = 0;
        }
        getResolutions() {
          return this.resolutions_;
        }
        findNearestResolution(t2) {
          if (this.resolutions_) {
            const e2 = l(this.resolutions_, t2, 0);
            t2 = this.resolutions_[e2];
          }
          return t2;
        }
        getImage(t2, e2, i2, n2) {
          const r2 = this.getProjection();
          if (r2 && n2 && !Ki(r2, n2)) {
            if (this.reprojectedImage_) {
              if (this.reprojectedRevision_ == this.getRevision() && Ki(this.reprojectedImage_.getProjection(), n2) && this.reprojectedImage_.getResolution() == e2 && ee(this.reprojectedImage_.getExtent(), t2))
                return this.reprojectedImage_;
              this.reprojectedImage_.dispose(), this.reprojectedImage_ = null;
            }
            return this.reprojectedImage_ = new gc(r2, n2, t2, e2, i2, function(t3, e3, i3) {
              return this.getImageInternal(t3, e3, i3, r2);
            }.bind(this), this.getInterpolate()), this.reprojectedRevision_ = this.getRevision(), this.reprojectedImage_;
          }
          return r2 && (n2 = r2), this.getImageInternal(t2, e2, i2, n2);
        }
        getImageInternal(t2, e2, i2, n2) {
          return B();
        }
        handleImageChange(t2) {
          const e2 = t2.target;
          let i2;
          switch (e2.getState()) {
            case Ir:
              this.loading = true, i2 = fc;
              break;
            case Lr:
              this.loading = false, i2 = pc;
              break;
            case Mr:
              this.loading = false, i2 = mc;
              break;
            default:
              return;
          }
          this.hasListener(i2) && this.dispatchEvent(new _c(i2, e2));
        }
      }
      function xc(t2, e2) {
        t2.getImage().src = e2;
      }
      function vc(t2, e2) {
        const i2 = [];
        Object.keys(e2).forEach(function(t3) {
          null !== e2[t3] && void 0 !== e2[t3] && i2.push(t3 + "=" + encodeURIComponent(e2[t3]));
        });
        const n2 = i2.join("&");
        return t2 = t2.replace(/[?&]$/, ""), (t2 += t2.includes("?") ? "&" : "?") + n2;
      }
      const Sc = "1.3.0", wc = [101, 101];
      const Ec = '&#169; <a href="https://www.openstreetmap.org/copyright" target="_blank">OpenStreetMap</a> contributors.';
      class Tc extends vs {
        constructor(t2) {
          super(t2 = t2 || {});
        }
      }
      class Cc extends G {
        constructor(t2) {
          super(), this.ready = true, this.boundHandleImageChange_ = this.handleImageChange_.bind(this), this.layer_ = t2, this.declutterExecutorGroup = null;
        }
        getFeatures(t2) {
          return B();
        }
        getData(t2) {
          return null;
        }
        prepareFrame(t2) {
          return B();
        }
        renderFrame(t2, e2) {
          return B();
        }
        loadedTileCallback(t2, e2, i2) {
          t2[e2] || (t2[e2] = {}), t2[e2][i2.tileCoord.toString()] = i2;
        }
        createLoadedTileFinder(t2, e2, i2) {
          return function(n2, r2) {
            const s2 = this.loadedTileCallback.bind(this, i2, n2);
            return t2.forEachLoadedTile(e2, n2, r2, s2);
          }.bind(this);
        }
        forEachFeatureAtCoordinate(t2, e2, i2, n2, r2) {
        }
        getLayer() {
          return this.layer_;
        }
        handleFontsChanged() {
        }
        handleImageChange_(t2) {
          t2.target.getState() === Lr && this.renderIfReadyAndVisible();
        }
        loadImage(t2) {
          let e2 = t2.getState();
          return e2 != Lr && e2 != Mr && t2.addEventListener(S, this.boundHandleImageChange_), e2 == Pr && (t2.load(), e2 = t2.getState()), e2 == Lr;
        }
        renderIfReadyAndVisible() {
          const t2 = this.getLayer();
          t2 && t2.getVisible() && "ready" === t2.getSourceState() && t2.changed();
        }
        disposeInternal() {
          delete this.layer_, super.disposeInternal();
        }
      }
      const bc = [];
      let Rc = null;
      class Pc extends Cc {
        constructor(t2) {
          super(t2), this.container = null, this.renderedResolution, this.tempTransform = [1, 0, 0, 1, 0, 0], this.pixelTransform = [1, 0, 0, 1, 0, 0], this.inversePixelTransform = [1, 0, 0, 1, 0, 0], this.context = null, this.containerReused = false, this.pixelContext_ = null, this.frameState = null;
        }
        getImageData(t2, e2, i2) {
          let n2;
          Rc || function() {
            const t3 = document.createElement("canvas");
            t3.width = 1, t3.height = 1, Rc = t3.getContext("2d");
          }(), Rc.clearRect(0, 0, 1, 1);
          try {
            Rc.drawImage(t2, e2, i2, 1, 1, 0, 0, 1, 1), n2 = Rc.getImageData(0, 0, 1, 1).data;
          } catch (t3) {
            return Rc = null, null;
          }
          return n2;
        }
        getBackground(t2) {
          let e2 = this.getLayer().getBackground();
          return "function" == typeof e2 && (e2 = e2(t2.viewState.resolution)), e2 || void 0;
        }
        useContainer(t2, e2, i2) {
          const n2 = this.getLayer().getClassName();
          let r2, s2;
          if (t2 && t2.className === n2 && (!i2 || t2 && t2.style.backgroundColor && u($r(t2.style.backgroundColor), $r(i2)))) {
            const e3 = t2.firstElementChild;
            e3 instanceof HTMLCanvasElement && (s2 = e3.getContext("2d"));
          }
          if (s2 && s2.canvas.style.transform === e2 ? (this.container = t2, this.context = s2, this.containerReused = true) : this.containerReused && (this.container = null, this.context = null, this.containerReused = false), !this.container) {
            r2 = document.createElement("div"), r2.className = n2;
            let t3 = r2.style;
            t3.position = "absolute", t3.width = "100%", t3.height = "100%", s2 = Dr();
            const e3 = s2.canvas;
            r2.appendChild(e3), t3 = e3.style, t3.position = "absolute", t3.left = "0", t3.transformOrigin = "top left", this.container = r2, this.context = s2;
          }
          this.containerReused || !i2 || this.container.style.backgroundColor || (this.container.style.backgroundColor = i2);
        }
        clipUnrotated(t2, e2, i2) {
          const n2 = xe(i2), r2 = ve(i2), s2 = de(i2), o2 = ue(i2);
          bt(e2.coordinateToPixelTransform, n2), bt(e2.coordinateToPixelTransform, r2), bt(e2.coordinateToPixelTransform, s2), bt(e2.coordinateToPixelTransform, o2);
          const a2 = this.inversePixelTransform;
          bt(a2, n2), bt(a2, r2), bt(a2, s2), bt(a2, o2), t2.save(), t2.beginPath(), t2.moveTo(Math.round(n2[0]), Math.round(n2[1])), t2.lineTo(Math.round(r2[0]), Math.round(r2[1])), t2.lineTo(Math.round(s2[0]), Math.round(s2[1])), t2.lineTo(Math.round(o2[0]), Math.round(o2[1])), t2.clip();
        }
        dispatchRenderEvent_(t2, e2, i2) {
          const n2 = this.getLayer();
          if (n2.hasListener(t2)) {
            const r2 = new Ts(t2, this.inversePixelTransform, i2, e2);
            n2.dispatchEvent(r2);
          }
        }
        preRender(t2, e2) {
          this.frameState = e2, this.dispatchRenderEvent_(ps, t2, e2);
        }
        postRender(t2, e2) {
          this.dispatchRenderEvent_(ms, t2, e2);
        }
        getRenderTransform(t2, e2, i2, n2, r2, s2, o2) {
          const a2 = r2 / 2, l2 = s2 / 2, h2 = n2 / e2, c2 = -h2, u2 = -t2[0] + o2, d2 = -t2[1];
          return Mt(this.tempTransform, a2, l2, h2, c2, -i2, u2, d2);
        }
        disposeInternal() {
          delete this.frameState, super.disposeInternal();
        }
      }
      class Ic extends Pc {
        constructor(t2) {
          super(t2), this.image_ = null;
        }
        getImage() {
          return this.image_ ? this.image_.getImage() : null;
        }
        prepareFrame(t2) {
          const e2 = t2.layerStatesArray[t2.layerIndex], i2 = t2.pixelRatio, n2 = t2.viewState, r2 = n2.resolution, s2 = this.getLayer().getSource(), o2 = t2.viewHints;
          let a2 = t2.extent;
          if (void 0 !== e2.extent && (a2 = ye(a2, on(e2.extent, n2.projection))), !o2[Ro] && !o2[Po] && !Ee(a2))
            if (s2) {
              const t3 = n2.projection, e3 = s2.getImage(a2, r2, i2, t3);
              e3 && (this.loadImage(e3) ? this.image_ = e3 : e3.getState() === Fr && (this.image_ = null));
            } else
              this.image_ = null;
          return !!this.image_;
        }
        getData(t2) {
          const e2 = this.frameState;
          if (!e2)
            return null;
          const i2 = this.getLayer(), n2 = bt(e2.pixelToCoordinateTransform, t2.slice()), r2 = i2.getExtent();
          if (r2 && !Zt(r2, n2))
            return null;
          const s2 = this.image_.getExtent(), o2 = this.image_.getImage(), a2 = Se(s2), l2 = Math.floor(o2.width * ((n2[0] - s2[0]) / a2));
          if (l2 < 0 || l2 >= o2.width)
            return null;
          const h2 = _e(s2), c2 = Math.floor(o2.height * ((s2[3] - n2[1]) / h2));
          return c2 < 0 || c2 >= o2.height ? null : this.getImageData(o2, l2, c2);
        }
        renderFrame(t2, e2) {
          const i2 = this.image_, n2 = i2.getExtent(), r2 = i2.getResolution(), s2 = i2.getPixelRatio(), o2 = t2.layerStatesArray[t2.layerIndex], a2 = t2.pixelRatio, l2 = t2.viewState, h2 = l2.center, c2 = a2 * r2 / (l2.resolution * s2), u2 = t2.extent, d2 = l2.resolution, g2 = l2.rotation, f2 = Math.round(Se(u2) / d2 * a2), p2 = Math.round(_e(u2) / d2 * a2);
          Mt(this.pixelTransform, t2.size[0] / 2, t2.size[1] / 2, 1 / a2, 1 / a2, g2, -f2 / 2, -p2 / 2), Ft(this.inversePixelTransform, this.pixelTransform);
          const m2 = Nt(this.pixelTransform);
          this.useContainer(e2, m2, this.getBackground(t2));
          const _2 = this.context, y2 = _2.canvas;
          y2.width != f2 || y2.height != p2 ? (y2.width = f2, y2.height = p2) : this.containerReused || _2.clearRect(0, 0, f2, p2);
          let x2 = false, v2 = true;
          if (o2.extent) {
            const e3 = on(o2.extent, l2.projection);
            v2 = we(e3, t2.extent), x2 = v2 && !Yt(e3, t2.extent), x2 && this.clipUnrotated(_2, t2, e3);
          }
          const S2 = i2.getImage(), w2 = Mt(this.tempTransform, f2 / 2, p2 / 2, c2, c2, 0, s2 * (n2[0] - h2[0]) / r2, s2 * (h2[1] - n2[3]) / r2);
          this.renderedResolution = r2 * a2 / s2;
          const E2 = S2.width * w2[0], T2 = S2.height * w2[3];
          if (this.getLayer().getSource().getInterpolate() || (_2.imageSmoothingEnabled = false), this.preRender(_2, t2), v2 && E2 >= 0.5 && T2 >= 0.5) {
            const t3 = w2[4], e3 = w2[5], i3 = o2.opacity;
            let n3;
            1 !== i3 && (n3 = _2.globalAlpha, _2.globalAlpha = i3), _2.drawImage(S2, 0, 0, +S2.width, +S2.height, t3, e3, E2, T2), 1 !== i3 && (_2.globalAlpha = n3);
          }
          return this.postRender(_2, t2), x2 && _2.restore(), _2.imageSmoothingEnabled = true, m2 !== y2.style.transform && (y2.style.transform = m2), this.container;
        }
      }
      class Lc extends Tc {
        constructor(t2) {
          super(t2);
        }
        createRenderer() {
          return new Ic(this);
        }
        getData(t2) {
          return super.getData(t2);
        }
      }
      var Mc = "preload", Fc = "useInterimTilesOnError";
      class Ac extends vs {
        constructor(t2) {
          t2 = t2 || {};
          const e2 = Object.assign({}, t2);
          delete e2.preload, delete e2.useInterimTilesOnError, super(e2), this.on, this.once, this.un, this.setPreload(void 0 !== t2.preload ? t2.preload : 0), this.setUseInterimTilesOnError(void 0 === t2.useInterimTilesOnError || t2.useInterimTilesOnError);
        }
        getPreload() {
          return this.get(Mc);
        }
        setPreload(t2) {
          this.set(Mc, t2);
        }
        getUseInterimTilesOnError() {
          return this.get(Fc);
        }
        setUseInterimTilesOnError(t2) {
          this.set(Fc, t2);
        }
        getData(t2) {
          return super.getData(t2);
        }
      }
      class Oc extends Pc {
        constructor(t2) {
          super(t2), this.extentChanged = true, this.renderedExtent_ = null, this.renderedPixelRatio, this.renderedProjection = null, this.renderedRevision, this.renderedTiles = [], this.newTiles_ = false, this.tmpExtent = [1 / 0, 1 / 0, -1 / 0, -1 / 0], this.tmpTileRange_ = new hl(0, 0, 0, 0);
        }
        isDrawableTile(t2) {
          const e2 = this.getLayer(), i2 = t2.getState(), n2 = e2.getUseInterimTilesOnError();
          return i2 == J || i2 == tt || i2 == Q && !n2;
        }
        getTile(t2, e2, i2, n2) {
          const r2 = n2.pixelRatio, s2 = n2.viewState.projection, o2 = this.getLayer();
          let a2 = o2.getSource().getTile(t2, e2, i2, r2, s2);
          return a2.getState() == Q && o2.getUseInterimTilesOnError() && o2.getPreload() > 0 && (this.newTiles_ = true), this.isDrawableTile(a2) || (a2 = a2.getInterimTile()), a2;
        }
        getData(t2) {
          const e2 = this.frameState;
          if (!e2)
            return null;
          const i2 = this.getLayer(), n2 = bt(e2.pixelToCoordinateTransform, t2.slice()), r2 = i2.getExtent();
          if (r2 && !Zt(r2, n2))
            return null;
          const s2 = e2.pixelRatio, o2 = e2.viewState.projection, a2 = e2.viewState, l2 = i2.getRenderSource(), h2 = l2.getTileGridForProjection(a2.projection), c2 = l2.getTilePixelRatio(e2.pixelRatio);
          for (let t3 = h2.getZForResolution(a2.resolution); t3 >= h2.getMinZoom(); --t3) {
            const e3 = h2.getTileCoordForCoordAndZ(n2, t3), i3 = l2.getTile(t3, e3[1], e3[2], s2, o2);
            if (!(i3 instanceof Vr || i3 instanceof zl) || i3 instanceof zl && i3.getState() === tt)
              return null;
            if (i3.getState() !== J)
              continue;
            const r3 = h2.getOrigin(t3), u2 = Va(h2.getTileSize(t3)), d2 = h2.getResolution(t3), g2 = Math.floor(c2 * ((n2[0] - r3[0]) / d2 - e3[1] * u2[0])), f2 = Math.floor(c2 * ((r3[1] - n2[1]) / d2 - e3[2] * u2[1])), p2 = Math.round(c2 * l2.getGutterForProjection(a2.projection));
            return this.getImageData(i3.getImage(), g2 + p2, f2 + p2);
          }
          return null;
        }
        loadedTileCallback(t2, e2, i2) {
          return !!this.isDrawableTile(i2) && super.loadedTileCallback(t2, e2, i2);
        }
        prepareFrame(t2) {
          return !!this.getLayer().getSource();
        }
        renderFrame(t2, e2) {
          const i2 = t2.layerStatesArray[t2.layerIndex], n2 = t2.viewState, r2 = n2.projection, s2 = n2.resolution, o2 = n2.center, l2 = n2.rotation, h2 = t2.pixelRatio, c2 = this.getLayer(), u2 = c2.getSource(), d2 = u2.getRevision(), g2 = u2.getTileGridForProjection(r2), f2 = g2.getZForResolution(s2, u2.zDirection), p2 = g2.getResolution(f2);
          let m2 = t2.extent;
          const _2 = t2.viewState.resolution, y2 = u2.getTilePixelRatio(h2), x2 = Math.round(Se(m2) / _2 * h2), v2 = Math.round(_e(m2) / _2 * h2), S2 = i2.extent && on(i2.extent, r2);
          S2 && (m2 = ye(m2, on(i2.extent, r2)));
          const w2 = p2 * x2 / 2 / y2, E2 = p2 * v2 / 2 / y2, T2 = [o2[0] - w2, o2[1] - E2, o2[0] + w2, o2[1] + E2], C2 = g2.getTileRangeForExtentAndZ(m2, f2), b2 = {};
          b2[f2] = {};
          const R2 = this.createLoadedTileFinder(u2, r2, b2), P2 = this.tmpExtent, I2 = this.tmpTileRange_;
          this.newTiles_ = false;
          const L2 = l2 ? me(n2.center, _2, l2, t2.size) : void 0;
          for (let e3 = C2.minX; e3 <= C2.maxX; ++e3)
            for (let n3 = C2.minY; n3 <= C2.maxY; ++n3) {
              if (l2 && !g2.tileCoordIntersectsViewport([f2, e3, n3], L2))
                continue;
              const r3 = this.getTile(f2, e3, n3, t2);
              if (this.isDrawableTile(r3)) {
                const e4 = z(this);
                if (r3.getState() == J) {
                  b2[f2][r3.tileCoord.toString()] = r3;
                  let t3 = r3.inTransition(e4);
                  t3 && 1 !== i2.opacity && (r3.endTransition(e4), t3 = false), this.newTiles_ || !t3 && this.renderedTiles.includes(r3) || (this.newTiles_ = true);
                }
                if (1 === r3.getAlpha(e4, t2.time))
                  continue;
              }
              const s3 = g2.getTileCoordChildTileRange(r3.tileCoord, I2, P2);
              let o3 = false;
              s3 && (o3 = R2(f2 + 1, s3)), o3 || g2.forEachTileCoordParentTileRange(r3.tileCoord, R2, I2, P2);
            }
          const M2 = p2 / s2 * h2 / y2;
          Mt(this.pixelTransform, t2.size[0] / 2, t2.size[1] / 2, 1 / h2, 1 / h2, l2, -x2 / 2, -v2 / 2);
          const F2 = Nt(this.pixelTransform);
          this.useContainer(e2, F2, this.getBackground(t2));
          const A2 = this.context, O2 = A2.canvas;
          Ft(this.inversePixelTransform, this.pixelTransform), Mt(this.tempTransform, x2 / 2, v2 / 2, M2, M2, 0, -x2 / 2, -v2 / 2), O2.width != x2 || O2.height != v2 ? (O2.width = x2, O2.height = v2) : this.containerReused || A2.clearRect(0, 0, x2, v2), S2 && this.clipUnrotated(A2, t2, S2), u2.getInterpolate() || (A2.imageSmoothingEnabled = false), this.preRender(A2, t2), this.renderedTiles.length = 0;
          let N2, D2, k2, G2 = Object.keys(b2).map(Number);
          G2.sort(a), 1 !== i2.opacity || this.containerReused && !u2.getOpaque(t2.viewState.projection) ? (N2 = [], D2 = []) : G2 = G2.reverse();
          for (let e3 = G2.length - 1; e3 >= 0; --e3) {
            const i3 = G2[e3], n3 = u2.getTilePixelSize(i3, h2, r2), s3 = g2.getResolution(i3) / p2, o3 = n3[0] * s3 * M2, a2 = n3[1] * s3 * M2, l3 = g2.getTileCoordForCoordAndZ(xe(T2), i3), c3 = g2.getTileCoordExtent(l3), d3 = bt(this.tempTransform, [y2 * (c3[0] - T2[0]) / p2, y2 * (T2[3] - c3[3]) / p2]), m3 = y2 * u2.getGutterForProjection(r2), _3 = b2[i3];
            for (const e4 in _3) {
              const n4 = _3[e4], r3 = n4.tileCoord, s4 = l3[1] - r3[1], h3 = Math.round(d3[0] - (s4 - 1) * o3), c4 = l3[2] - r3[2], g3 = Math.round(d3[1] - (c4 - 1) * a2), p3 = Math.round(d3[0] - s4 * o3), y3 = Math.round(d3[1] - c4 * a2), x3 = h3 - p3, v3 = g3 - y3, S3 = f2 === i3, w3 = S3 && 1 !== n4.getAlpha(z(this), t2.time);
              let E3 = false;
              if (!w3)
                if (N2) {
                  k2 = [p3, y3, p3 + x3, y3, p3 + x3, y3 + v3, p3, y3 + v3];
                  for (let t3 = 0, e5 = N2.length; t3 < e5; ++t3)
                    if (f2 !== i3 && i3 < D2[t3]) {
                      const e6 = N2[t3];
                      we([p3, y3, p3 + x3, y3 + v3], [e6[0], e6[3], e6[4], e6[7]]) && (E3 || (A2.save(), E3 = true), A2.beginPath(), A2.moveTo(k2[0], k2[1]), A2.lineTo(k2[2], k2[3]), A2.lineTo(k2[4], k2[5]), A2.lineTo(k2[6], k2[7]), A2.moveTo(e6[6], e6[7]), A2.lineTo(e6[4], e6[5]), A2.lineTo(e6[2], e6[3]), A2.lineTo(e6[0], e6[1]), A2.clip());
                    }
                  N2.push(k2), D2.push(i3);
                } else
                  A2.clearRect(p3, y3, x3, v3);
              this.drawTileImage(n4, t2, p3, y3, x3, v3, m3, S3), N2 && !w3 ? (E3 && A2.restore(), this.renderedTiles.unshift(n4)) : this.renderedTiles.push(n4), this.updateUsedTiles(t2.usedTiles, u2, n4);
            }
          }
          return this.renderedRevision = d2, this.renderedResolution = p2, this.extentChanged = !this.renderedExtent_ || !ee(this.renderedExtent_, T2), this.renderedExtent_ = T2, this.renderedPixelRatio = h2, this.renderedProjection = r2, this.manageTilePyramid(t2, u2, g2, h2, r2, m2, f2, c2.getPreload()), this.scheduleExpireCache(t2, u2), this.postRender(A2, t2), i2.extent && A2.restore(), A2.imageSmoothingEnabled = true, F2 !== O2.style.transform && (O2.style.transform = F2), this.container;
        }
        drawTileImage(t2, e2, i2, n2, r2, s2, o2, a2) {
          const l2 = this.getTileImage(t2);
          if (!l2)
            return;
          const h2 = z(this), c2 = e2.layerStatesArray[e2.layerIndex], u2 = c2.opacity * (a2 ? t2.getAlpha(h2, e2.time) : 1), d2 = u2 !== this.context.globalAlpha;
          d2 && (this.context.save(), this.context.globalAlpha = u2), this.context.drawImage(l2, o2, o2, l2.width - 2 * o2, l2.height - 2 * o2, i2, n2, r2, s2), d2 && this.context.restore(), u2 !== c2.opacity ? e2.animate = true : a2 && t2.endTransition(h2);
        }
        getImage() {
          const t2 = this.context;
          return t2 ? t2.canvas : null;
        }
        getTileImage(t2) {
          return t2.getImage();
        }
        scheduleExpireCache(t2, e2) {
          if (e2.canExpireCache()) {
            const i2 = function(t3, e3, i3) {
              const n2 = z(t3);
              n2 in i3.usedTiles && t3.expireCache(i3.viewState.projection, i3.usedTiles[n2]);
            }.bind(null, e2);
            t2.postRenderFunctions.push(i2);
          }
        }
        updateUsedTiles(t2, e2, i2) {
          const n2 = z(e2);
          n2 in t2 || (t2[n2] = {}), t2[n2][i2.getKey()] = true;
        }
        manageTilePyramid(t2, e2, i2, n2, r2, s2, o2, a2, l2) {
          const h2 = z(e2);
          h2 in t2.wantedTiles || (t2.wantedTiles[h2] = {});
          const c2 = t2.wantedTiles[h2], u2 = t2.tileQueue, d2 = i2.getMinZoom(), g2 = t2.viewState.rotation, f2 = g2 ? me(t2.viewState.center, t2.viewState.resolution, g2, t2.size) : void 0;
          let p2, m2, _2, y2, x2, v2, S2 = 0;
          for (v2 = d2; v2 <= o2; ++v2)
            for (m2 = i2.getTileRangeForExtentAndZ(s2, v2, m2), _2 = i2.getResolution(v2), y2 = m2.minX; y2 <= m2.maxX; ++y2)
              for (x2 = m2.minY; x2 <= m2.maxY; ++x2)
                g2 && !i2.tileCoordIntersectsViewport([v2, y2, x2], f2) || (o2 - v2 <= a2 ? (++S2, p2 = e2.getTile(v2, y2, x2, n2, r2), p2.getState() == H && (c2[p2.getKey()] = true, u2.isKeyQueued(p2.getKey()) || u2.enqueue([p2, h2, i2.getTileCoordCenter(p2.tileCoord), _2])), void 0 !== l2 && l2(p2)) : e2.useTile(v2, y2, x2, r2));
          e2.updateCacheSize(S2, r2);
        }
      }
      class Nc extends Ac {
        constructor(t2) {
          super(t2);
        }
        createRenderer() {
          return new Oc(this);
        }
      }
      let Dc, kc = true;
      try {
        new ImageData(10, 10);
      } catch (t2) {
        kc = false;
      }
      function Gc(t2, e2, i2) {
        if (kc)
          return new ImageData(t2, e2, i2);
        Dc || (Dc = document.createElement("canvas").getContext("2d"));
        const n2 = Dc.createImageData(e2, i2);
        return n2.data.set(t2), n2;
      }
      function jc(t2) {
        let e2 = true;
        try {
          new ImageData(10, 10);
        } catch (t3) {
          e2 = false;
        }
        function i2(t3, i3, n2) {
          return e2 ? new ImageData(t3, i3, n2) : { data: t3, width: i3, height: n2 };
        }
        return function(e3) {
          const n2 = e3.buffers, r2 = e3.meta, s2 = e3.imageOps, o2 = e3.width, a2 = e3.height, l2 = n2.length, h2 = n2[0].byteLength;
          if (s2) {
            const e4 = new Array(l2);
            for (let t3 = 0; t3 < l2; ++t3)
              e4[t3] = i2(new Uint8ClampedArray(n2[t3]), o2, a2);
            return t2(e4, r2).data.buffer;
          }
          const c2 = new Uint8ClampedArray(h2), u2 = new Array(l2), d2 = new Array(l2);
          for (let t3 = 0; t3 < l2; ++t3)
            u2[t3] = new Uint8ClampedArray(n2[t3]), d2[t3] = [0, 0, 0, 0];
          for (let e4 = 0; e4 < h2; e4 += 4) {
            for (let t3 = 0; t3 < l2; ++t3) {
              const i4 = u2[t3];
              d2[t3][0] = i4[e4], d2[t3][1] = i4[e4 + 1], d2[t3][2] = i4[e4 + 2], d2[t3][3] = i4[e4 + 3];
            }
            const i3 = t2(d2, r2);
            c2[e4] = i3[0], c2[e4 + 1] = i3[1], c2[e4 + 2] = i3[2], c2[e4 + 3] = i3[3];
          }
          return c2.buffer;
        };
      }
      function Bc(t2, e2) {
        const i2 = Object.keys(t2.lib || {}).map(function(e3) {
          return "const " + e3 + " = " + t2.lib[e3].toString() + ";";
        }).concat(["const __minion__ = (" + jc.toString() + ")(", t2.operation.toString(), ");", 'self.addEventListener("message", function(event) {', "  const buffer = __minion__(event.data);", "  self.postMessage({buffer: buffer, meta: event.data.meta}, [buffer]);", "});"]), n2 = new Worker("undefined" == typeof Blob ? "data:text/javascript;base64," + Buffer.from(i2.join("\n"), "binary").toString("base64") : URL.createObjectURL(new Blob(i2, { type: "text/javascript" })));
        return n2.addEventListener("message", e2), n2;
      }
      class Uc extends s {
        constructor(t2) {
          let e2;
          super(), this._imageOps = !!t2.imageOps, e2 = 0 === t2.threads ? 0 : this._imageOps ? 1 : t2.threads || 1;
          const i2 = new Array(e2);
          if (e2)
            for (let n2 = 0; n2 < e2; ++n2)
              i2[n2] = Bc(t2, this._onWorkerMessage.bind(this, n2));
          else
            i2[0] = function(t3, e3) {
              const i3 = jc(t3.operation);
              let n2 = false;
              return { postMessage: function(t4) {
                setTimeout(function() {
                  n2 || e3({ data: { buffer: i3(t4), meta: t4.meta } });
                }, 0);
              }, terminate: function() {
                n2 = true;
              } };
            }(t2, this._onWorkerMessage.bind(this, 0));
          this._workers = i2, this._queue = [], this._maxQueueLength = t2.queue || 1 / 0, this._running = 0, this._dataLookup = {}, this._job = null;
        }
        process(t2, e2, i2) {
          this._enqueue({ inputs: t2, meta: e2, callback: i2 }), this._dispatch();
        }
        _enqueue(t2) {
          for (this._queue.push(t2); this._queue.length > this._maxQueueLength; )
            this._queue.shift().callback(null, null);
        }
        _dispatch() {
          if (this._running || 0 === this._queue.length)
            return;
          const t2 = this._queue.shift();
          this._job = t2;
          const e2 = t2.inputs[0].width, i2 = t2.inputs[0].height, n2 = t2.inputs.map(function(t3) {
            return t3.data.buffer;
          }), r2 = this._workers.length;
          if (this._running = r2, 1 === r2)
            return void this._workers[0].postMessage({ buffers: n2, meta: t2.meta, imageOps: this._imageOps, width: e2, height: i2 }, n2);
          const s2 = t2.inputs[0].data.length, o2 = 4 * Math.ceil(s2 / 4 / r2);
          for (let s3 = 0; s3 < r2; ++s3) {
            const r3 = s3 * o2, a2 = [];
            for (let t3 = 0, e3 = n2.length; t3 < e3; ++t3)
              a2.push(n2[t3].slice(r3, r3 + o2));
            this._workers[s3].postMessage({ buffers: a2, meta: t2.meta, imageOps: this._imageOps, width: e2, height: i2 }, a2);
          }
        }
        _onWorkerMessage(t2, e2) {
          this.disposed || (this._dataLookup[t2] = e2.data, --this._running, 0 === this._running && this._resolveJob());
        }
        _resolveJob() {
          const t2 = this._job, e2 = this._workers.length;
          let i2, n2;
          if (1 === e2)
            i2 = new Uint8ClampedArray(this._dataLookup[0].buffer), n2 = this._dataLookup[0].meta;
          else {
            const r2 = t2.inputs[0].data.length;
            i2 = new Uint8ClampedArray(r2), n2 = new Array(e2);
            const s2 = 4 * Math.ceil(r2 / 4 / e2);
            for (let t3 = 0; t3 < e2; ++t3) {
              const e3 = this._dataLookup[t3].buffer, r3 = t3 * s2;
              i2.set(new Uint8ClampedArray(e3), r3), n2[t3] = this._dataLookup[t3].meta;
            }
          }
          this._job = null, this._dataLookup = {}, t2.callback(null, Gc(i2, t2.inputs[0].width, t2.inputs[0].height), n2), this._dispatch();
        }
        disposeInternal() {
          for (let t2 = 0; t2 < this._workers.length; ++t2)
            this._workers[t2].terminate();
          this._workers.length = 0;
        }
      }
      const zc = "beforeoperations", Xc = "afteroperations";
      class Vc extends i {
        constructor(t2, e2, i2) {
          super(t2), this.extent = e2.extent, this.resolution = e2.viewState.resolution / e2.pixelRatio, this.data = i2;
        }
      }
      class Wc extends yc {
        constructor(t2) {
          super({ projection: null }), this.on, this.once, this.un, this.processor_ = null, this.operationType_ = void 0 !== t2.operationType ? t2.operationType : "pixel", this.threads_ = void 0 !== t2.threads ? t2.threads : 1, this.layers_ = function(t3) {
            const e3 = t3.length, i3 = new Array(e3);
            for (let n2 = 0; n2 < e3; ++n2)
              i3[n2] = Kc(t3[n2]);
            return i3;
          }(t2.sources);
          const e2 = this.changed.bind(this);
          for (let t3 = 0, i3 = this.layers_.length; t3 < i3; ++t3)
            this.layers_[t3].addEventListener(S, e2);
          var i2;
          this.tileQueue_ = new Co(function() {
            return 1;
          }, this.changed.bind(this)), this.requestedFrameState_, this.renderedImageCanvas_ = null, this.renderedRevision_, this.frameState_ = { animate: false, coordinateToPixelTransform: [1, 0, 0, 1, 0, 0], declutterTree: null, extent: null, index: 0, layerIndex: 0, layerStatesArray: (i2 = this.layers_, i2.map(function(t3) {
            return t3.getLayerState();
          })), pixelRatio: 1, pixelToCoordinateTransform: [1, 0, 0, 1, 0, 0], postRenderFunctions: [], size: [0, 0], tileQueue: this.tileQueue_, time: Date.now(), usedTiles: {}, viewState: { rotation: 0 }, viewHints: [], wantedTiles: {}, mapId: z(this), renderTargets: {} }, this.setAttributions(function(e3) {
            const i3 = [];
            for (let n2 = 0, r2 = t2.sources.length; n2 < r2; ++n2) {
              const r3 = t2.sources[n2], s2 = (r3 instanceof Zl ? r3 : r3.getSource()).getAttributions();
              if ("function" == typeof s2) {
                const t3 = s2(e3);
                i3.push.apply(i3, t3);
              }
            }
            return 0 !== i3.length ? i3 : null;
          }), void 0 !== t2.operation && this.setOperation(t2.operation, t2.lib);
        }
        setOperation(t2, e2) {
          this.processor_ && this.processor_.dispose(), this.processor_ = new Uc({ operation: t2, imageOps: "image" === this.operationType_, queue: 1, lib: e2, threads: this.threads_ }), this.changed();
        }
        updateFrameState_(t2, e2, i2) {
          const n2 = Object.assign({}, this.frameState_);
          n2.viewState = Object.assign({}, n2.viewState);
          const r2 = ge(t2);
          n2.extent = t2.slice(), n2.size[0] = Math.round(Se(t2) / e2), n2.size[1] = Math.round(_e(t2) / e2), n2.time = Date.now();
          const s2 = n2.viewState;
          return s2.center = r2, s2.projection = i2, s2.resolution = e2, n2;
        }
        allSourcesReady_() {
          let t2, e2 = true;
          for (let i2 = 0, n2 = this.layers_.length; i2 < n2; ++i2)
            if (t2 = this.layers_[i2].getSource(), "ready" !== t2.getState()) {
              e2 = false;
              break;
            }
          return e2;
        }
        getImage(t2, e2, i2, n2) {
          if (!this.allSourcesReady_())
            return null;
          const r2 = this.updateFrameState_(t2, e2, n2);
          if (this.requestedFrameState_ = r2, this.renderedImageCanvas_) {
            const i3 = this.renderedImageCanvas_.getResolution(), n3 = this.renderedImageCanvas_.getExtent();
            e2 === i3 && ee(t2, n3) || (this.renderedImageCanvas_ = null);
          }
          return this.renderedImageCanvas_ && this.getRevision() === this.renderedRevision_ || this.processSources_(), r2.tileQueue.loadMoreTiles(16, 16), r2.animate && requestAnimationFrame(this.changed.bind(this)), this.renderedImageCanvas_;
        }
        processSources_() {
          const t2 = this.requestedFrameState_, e2 = this.layers_.length, i2 = new Array(e2);
          for (let n3 = 0; n3 < e2; ++n3) {
            t2.layerIndex = n3;
            const e3 = Yc(this.layers_[n3], t2);
            if (!e3)
              return;
            i2[n3] = e3;
          }
          const n2 = {};
          this.dispatchEvent(new Vc(zc, t2, n2)), this.processor_.process(i2, n2, this.onWorkerComplete_.bind(this, t2));
        }
        onWorkerComplete_(t2, e2, i2, n2) {
          if (e2 || !i2)
            return;
          const r2 = t2.extent, s2 = t2.viewState.resolution;
          if (s2 !== this.requestedFrameState_.viewState.resolution || !ee(r2, this.requestedFrameState_.extent))
            return;
          let o2;
          if (this.renderedImageCanvas_)
            o2 = this.renderedImageCanvas_.getImage().getContext("2d");
          else {
            o2 = Dr(Math.round(Se(r2) / s2), Math.round(_e(r2) / s2)), this.renderedImageCanvas_ = new Nr(r2, s2, 1, o2.canvas);
          }
          o2.putImageData(i2, 0, 0), this.changed(), this.renderedRevision_ = this.getRevision(), this.dispatchEvent(new Vc(Xc, t2, n2)), t2.animate && requestAnimationFrame(this.changed.bind(this));
        }
        disposeInternal() {
          this.processor_ && this.processor_.dispose(), super.disposeInternal();
        }
      }
      Wc.prototype.dispose;
      let Zc = null;
      function Yc(t2, e2) {
        const i2 = t2.getRenderer();
        if (!i2)
          throw new Error("Unsupported layer type: " + t2);
        if (!i2.prepareFrame(e2))
          return null;
        const n2 = e2.size[0], r2 = e2.size[1];
        if (0 === n2 || 0 === r2)
          return null;
        const s2 = i2.renderFrame(e2, null);
        let o2;
        if (s2 instanceof HTMLCanvasElement)
          o2 = s2;
        else {
          if (s2 && (o2 = s2.firstElementChild), !(o2 instanceof HTMLCanvasElement))
            throw new Error("Unsupported rendered element: " + o2);
          if (o2.width === n2 && o2.height === r2) {
            return o2.getContext("2d").getImageData(0, 0, n2, r2);
          }
        }
        if (Zc) {
          const t3 = Zc.canvas;
          t3.width !== n2 || t3.height !== r2 ? Zc = Dr(n2, r2) : Zc.clearRect(0, 0, n2, r2);
        } else
          Zc = Dr(n2, r2);
        return Zc.drawImage(o2, 0, 0, n2, r2), Zc.getImageData(0, 0, n2, r2);
      }
      function Kc(t2) {
        let e2;
        return t2 instanceof Zl ? t2 instanceof nh ? e2 = new Nc({ source: t2 }) : t2 instanceof yc && (e2 = new Lc({ source: t2 })) : e2 = t2, e2;
      }
      const qc = ['Map tiles by <a href="https://stamen.com/" target="_blank">Stamen Design</a>, under <a href="https://creativecommons.org/licenses/by/3.0/" target="_blank">CC BY 3.0</a>.', Ec], Hc = { terrain: { extension: "jpg", opaque: true }, "terrain-background": { extension: "jpg", opaque: true }, "terrain-labels": { extension: "png", opaque: false }, "terrain-lines": { extension: "png", opaque: false }, "toner-background": { extension: "png", opaque: true }, toner: { extension: "png", opaque: true }, "toner-hybrid": { extension: "png", opaque: false }, "toner-labels": { extension: "png", opaque: false }, "toner-lines": { extension: "png", opaque: false }, "toner-lite": { extension: "png", opaque: true }, watercolor: { extension: "jpg", opaque: true } }, $c = { terrain: { minZoom: 0, maxZoom: 18 }, toner: { minZoom: 0, maxZoom: 20 }, watercolor: { minZoom: 0, maxZoom: 18 } };
      class Jc extends st {
        constructor(t2, e2, i2, n2, r2, s2) {
          super(t2, e2), this.src_ = i2, this.extent_ = n2, this.preemptive_ = r2, this.grid_ = null, this.keys_ = null, this.data_ = null, this.jsonp_ = s2;
        }
        getImage() {
          return null;
        }
        getData(t2) {
          if (!this.grid_ || !this.keys_)
            return null;
          const e2 = (t2[0] - this.extent_[0]) / (this.extent_[2] - this.extent_[0]), i2 = (t2[1] - this.extent_[1]) / (this.extent_[3] - this.extent_[1]), n2 = this.grid_[Math.floor((1 - i2) * this.grid_.length)];
          if ("string" != typeof n2)
            return null;
          let r2 = n2.charCodeAt(Math.floor(e2 * n2.length));
          r2 >= 93 && r2--, r2 >= 35 && r2--, r2 -= 32;
          let s2 = null;
          if (r2 in this.keys_) {
            const t3 = this.keys_[r2];
            s2 = this.data_ && t3 in this.data_ ? this.data_[t3] : t3;
          }
          return s2;
        }
        forDataAtCoordinate(t2, e2, i2) {
          this.state == tt && true === i2 ? (this.state = H, D(this, S, function(i3) {
            e2(this.getData(t2));
          }, this), this.loadInternal_()) : true === i2 ? setTimeout(function() {
            e2(this.getData(t2));
          }.bind(this), 0) : e2(this.getData(t2));
        }
        getKey() {
          return this.src_;
        }
        handleError_() {
          this.state = Q, this.changed();
        }
        handleLoad_(t2) {
          this.grid_ = t2.grid, this.keys_ = t2.keys, this.data_ = t2.data, this.state = J, this.changed();
        }
        loadInternal_() {
          if (this.state == H)
            if (this.state = $, this.jsonp_)
              vl(this.src_, this.handleLoad_.bind(this), this.handleError_.bind(this));
            else {
              const t2 = new XMLHttpRequest();
              t2.addEventListener("load", this.onXHRLoad_.bind(this)), t2.addEventListener("error", this.onXHRError_.bind(this)), t2.open("GET", this.src_), t2.send();
            }
        }
        onXHRLoad_(t2) {
          const e2 = t2.target;
          if (!e2.status || e2.status >= 200 && e2.status < 300) {
            let t3;
            try {
              t3 = JSON.parse(e2.responseText);
            } catch (t4) {
              return void this.handleError_();
            }
            this.handleLoad_(t3);
          } else
            this.handleError_();
        }
        onXHRError_(t2) {
          this.handleError_();
        }
        load() {
          this.preemptive_ ? this.loadInternal_() : this.setState(tt);
        }
      }
      class Qc extends ch {
        constructor(t2) {
          const e2 = t2.projection || "EPSG:3857", i2 = t2.extent || ih(e2), n2 = t2.tileGrid || Ql({ extent: i2, maxResolution: t2.maxResolution, maxZoom: void 0 !== t2.maxZoom ? t2.maxZoom : 22, minZoom: t2.minZoom, tileSize: t2.tileSize || 512 });
          super({ attributions: t2.attributions, attributionsCollapsible: t2.attributionsCollapsible, cacheSize: t2.cacheSize, interpolate: true, opaque: false, projection: e2, state: t2.state, tileGrid: n2, tileLoadFunction: t2.tileLoadFunction ? t2.tileLoadFunction : tu, tileUrlFunction: t2.tileUrlFunction, url: t2.url, urls: t2.urls, wrapX: void 0 === t2.wrapX || t2.wrapX, transition: t2.transition, zDirection: void 0 === t2.zDirection ? 1 : t2.zDirection }), this.format_ = t2.format ? t2.format : null, this.sourceTileCache = new ll(this.tileCache.highWaterMark), this.overlaps_ = null == t2.overlaps || t2.overlaps, this.tileClass = t2.tileClass ? t2.tileClass : gl, this.tileGrids_ = {};
        }
        getFeaturesInExtent(t2) {
          const e2 = [], i2 = this.tileCache;
          if (0 === i2.getCount())
            return e2;
          const n2 = sl(i2.peekFirstKey())[0], r2 = this.tileGrid;
          return i2.forEach(function(i3) {
            if (i3.tileCoord[0] !== n2 || i3.getState() !== J)
              return;
            const s2 = i3.getSourceTiles();
            for (let i4 = 0, n3 = s2.length; i4 < n3; ++i4) {
              const n4 = s2[i4], o2 = n4.tileCoord;
              if (we(t2, r2.getTileCoordExtent(o2))) {
                const i5 = n4.getFeatures();
                if (i5)
                  for (let n5 = 0, r3 = i5.length; n5 < r3; ++n5) {
                    const r4 = i5[n5], s3 = r4.getGeometry();
                    we(t2, s3.getExtent()) && e2.push(r4);
                  }
              }
            }
          }), e2;
        }
        getOverlaps() {
          return this.overlaps_;
        }
        clear() {
          this.tileCache.clear(), this.sourceTileCache.clear();
        }
        expireCache(t2, e2) {
          const i2 = this.getTileCacheForProjection(t2), n2 = Object.keys(e2).reduce((t3, e3) => {
            const n3 = rl(e3), r2 = i2.peek(n3);
            if (r2) {
              const e4 = r2.sourceTiles;
              for (let i3 = 0, n4 = e4.length; i3 < n4; ++i3)
                t3[e4[i3].getKey()] = true;
            }
            return t3;
          }, {});
          super.expireCache(t2, e2), this.sourceTileCache.expireCache(n2);
        }
        getSourceTiles(t2, e2, i2) {
          if (i2.getState() === H) {
            i2.setState($);
            const n2 = i2.wrappedTileCoord, r2 = this.getTileGridForProjection(e2), s2 = r2.getTileCoordExtent(n2), o2 = n2[0], a2 = r2.getResolution(o2);
            Xt(s2, -a2, s2);
            const l2 = this.tileGrid, h2 = l2.getExtent();
            h2 && ye(s2, h2, s2);
            const c2 = l2.getZForResolution(a2, this.zDirection);
            l2.forEachTileCoord(s2, c2, (n3) => {
              const r3 = this.tileUrlFunction(n3, t2, e2), s3 = this.sourceTileCache.containsKey(r3) ? this.sourceTileCache.get(r3) : new this.tileClass(n3, r3 ? H : tt, r3, this.format_, this.tileLoadFunction);
              i2.sourceTiles.push(s3);
              const o3 = s3.getState();
              if (o3 < J) {
                const t3 = (e3) => {
                  this.handleTileChange(e3);
                  const n4 = s3.getState();
                  if (n4 === J || n4 === Q) {
                    const e4 = s3.getKey();
                    e4 in i2.errorTileKeys ? s3.getState() === J && delete i2.errorTileKeys[e4] : i2.loadingSourceTiles--, n4 === Q ? i2.errorTileKeys[e4] = true : s3.removeEventListener(S, t3), 0 === i2.loadingSourceTiles && i2.setState(x(i2.errorTileKeys) ? J : Q);
                  }
                };
                s3.addEventListener(S, t3), i2.loadingSourceTiles++;
              }
              o3 === H && (s3.extent = l2.getTileCoordExtent(n3), s3.projection = e2, s3.resolution = l2.getResolution(n3[0]), this.sourceTileCache.set(r3, s3), s3.load());
            }), i2.loadingSourceTiles || i2.setState(i2.sourceTiles.some((t3) => t3.getState() === Q) ? Q : J);
          }
          return i2.sourceTiles;
        }
        getTile(t2, e2, i2, n2, r2) {
          const s2 = il(t2, e2, i2), o2 = this.getKey();
          let a2;
          if (this.tileCache.containsKey(s2) && (a2 = this.tileCache.get(s2), a2.key === o2))
            return a2;
          const l2 = [t2, e2, i2];
          let h2 = this.getTileCoordForTileUrlFunction(l2, r2);
          const c2 = this.getTileGrid().getExtent(), u2 = this.getTileGridForProjection(r2);
          if (h2 && c2) {
            const e3 = u2.getTileCoordExtent(h2);
            Xt(e3, -u2.getResolution(t2), e3), we(c2, e3) || (h2 = null);
          }
          let d2 = true;
          if (null !== h2) {
            const e3 = this.tileGrid, i3 = u2.getResolution(t2), s3 = e3.getZForResolution(i3, 1), o3 = u2.getTileCoordExtent(h2);
            Xt(o3, -i3, o3), e3.forEachTileCoord(o3, s3, function(t3) {
              d2 = d2 && !this.tileUrlFunction(t3, n2, r2);
            }.bind(this));
          }
          const g2 = new dl(l2, d2 ? tt : H, h2, this.getSourceTiles.bind(this, n2, r2));
          return g2.key = o2, a2 ? (g2.interimTile = a2, g2.refreshInterimChain(), this.tileCache.replace(s2, g2)) : this.tileCache.set(s2, g2), g2;
        }
        getTileGridForProjection(t2) {
          const e2 = t2.getCode();
          let i2 = this.tileGrids_[e2];
          if (!i2) {
            const t3 = this.tileGrid, n2 = t3.getResolutions().slice(), r2 = n2.map(function(e3, i3) {
              return t3.getOrigin(i3);
            }), s2 = n2.map(function(e3, i3) {
              return t3.getTileSize(i3);
            }), o2 = 43;
            for (let t4 = n2.length; t4 < o2; ++t4)
              n2.push(n2[t4 - 1] / 2), r2.push(r2[t4 - 1]), s2.push(s2[t4 - 1]);
            i2 = new ql({ extent: t3.getExtent(), origins: r2, resolutions: n2, tileSizes: s2 }), this.tileGrids_[e2] = i2;
          }
          return i2;
        }
        getTilePixelRatio(t2) {
          return t2;
        }
        getTilePixelSize(t2, e2, i2) {
          const n2 = Va(this.getTileGridForProjection(i2).getTileSize(t2), this.tmpSize);
          return [Math.round(n2[0] * e2), Math.round(n2[1] * e2)];
        }
        updateCacheSize(t2, e2) {
          super.updateCacheSize(2 * t2, e2), this.sourceTileCache.highWaterMark = this.getTileCacheForProjection(e2).highWaterMark;
        }
      }
      function tu(t2, e2) {
        t2.setLoader(function(i2, n2, r2) {
          _l(e2, t2.getFormat(), i2, n2, r2, t2.onLoad.bind(t2), t2.onError.bind(t2));
        });
      }
      class eu extends ql {
        constructor(t2) {
          super({ extent: t2.extent, origin: t2.origin, origins: t2.origins, resolutions: t2.resolutions, tileSize: t2.tileSize, tileSizes: t2.tileSizes, sizes: t2.sizes }), this.matrixIds_ = t2.matrixIds;
        }
        getMatrixId(t2) {
          return this.matrixIds_[t2];
        }
        getMatrixIds() {
          return this.matrixIds_;
        }
      }
      function iu(t2, e2, i2) {
        const n2 = [], r2 = [], s2 = [], o2 = [], a2 = [];
        i2 = void 0 !== i2 ? i2 : [];
        const l2 = Ui(t2.SupportedCRS), h2 = l2.getMetersPerUnit(), c2 = "ne" == l2.getAxisOrientation().substr(0, 2);
        return t2.TileMatrix.sort(function(t3, e3) {
          return e3.ScaleDenominator - t3.ScaleDenominator;
        }), t2.TileMatrix.forEach(function(e3) {
          let l3;
          if (l3 = !(i2.length > 0) || i2.find(function(i3) {
            return e3.Identifier == i3.TileMatrix || !e3.Identifier.includes(":") && t2.Identifier + ":" + e3.Identifier === i3.TileMatrix;
          }), l3) {
            r2.push(e3.Identifier);
            const t3 = 28e-5 * e3.ScaleDenominator / h2, i3 = e3.TileWidth, l4 = e3.TileHeight;
            c2 ? s2.push([e3.TopLeftCorner[1], e3.TopLeftCorner[0]]) : s2.push(e3.TopLeftCorner), n2.push(t3), o2.push(i3 == l4 ? i3 : [i3, l4]), a2.push([e3.MatrixWidth, e3.MatrixHeight]);
          }
        }), new eu({ extent: e2, origins: s2, resolutions: n2, matrixIds: r2, tileSizes: o2, sizes: a2 });
      }
      const nu = 34962, ru = 34963, su = 35044, ou = 35048, au = 5126, lu = ["experimental-webgl", "webgl", "webkit-3d", "moz-webgl"];
      function hu(t2, e2) {
        e2 = Object.assign({ preserveDrawingBuffer: true, antialias: !gt }, e2);
        const i2 = lu.length;
        for (let n2 = 0; n2 < i2; ++n2)
          try {
            const i3 = t2.getContext(lu[n2], e2);
            if (i3)
              return i3;
          } catch (t3) {
          }
        return null;
      }
      let cu;
      const uu = "http://www.w3.org/2001/XMLSchema-instance";
      function du(t2, e2) {
        return Du().createElementNS(t2, e2);
      }
      function gu(t2, e2) {
        return fu(t2, e2, []).join("");
      }
      function fu(t2, e2, i2) {
        if (t2.nodeType == Node.CDATA_SECTION_NODE || t2.nodeType == Node.TEXT_NODE)
          e2 ? i2.push(String(t2.nodeValue).replace(/(\r\n|\r|\n)/g, "")) : i2.push(t2.nodeValue);
        else {
          let n2;
          for (n2 = t2.firstChild; n2; n2 = n2.nextSibling)
            fu(n2, e2, i2);
        }
        return i2;
      }
      function pu(t2) {
        return "documentElement" in t2;
      }
      function mu(t2, e2, i2) {
        return t2.getAttributeNS(e2, i2) || "";
      }
      function _u(t2) {
        return new DOMParser().parseFromString(t2, "application/xml");
      }
      function yu(t2, e2) {
        return function(i2, n2) {
          const r2 = t2.call(void 0 !== e2 ? e2 : this, i2, n2);
          if (void 0 !== r2) {
            c(n2[n2.length - 1], r2);
          }
        };
      }
      function xu(t2, e2) {
        return function(i2, n2) {
          const r2 = t2.call(void 0 !== e2 ? e2 : this, i2, n2);
          if (void 0 !== r2) {
            n2[n2.length - 1].push(r2);
          }
        };
      }
      function vu(t2, e2) {
        return function(i2, n2) {
          const r2 = t2.call(void 0 !== e2 ? e2 : this, i2, n2);
          void 0 !== r2 && (n2[n2.length - 1] = r2);
        };
      }
      function Su(t2, e2, i2) {
        return function(n2, r2) {
          const s2 = t2.call(void 0 !== i2 ? i2 : this, n2, r2);
          if (void 0 !== s2) {
            const t3 = r2[r2.length - 1], i3 = void 0 !== e2 ? e2 : n2.localName;
            let o2;
            i3 in t3 ? o2 = t3[i3] : (o2 = [], t3[i3] = o2), o2.push(s2);
          }
        };
      }
      function wu(t2, e2, i2) {
        return function(n2, r2) {
          const s2 = t2.call(void 0 !== i2 ? i2 : this, n2, r2);
          if (void 0 !== s2) {
            r2[r2.length - 1][void 0 !== e2 ? e2 : n2.localName] = s2;
          }
        };
      }
      function Eu(t2, e2) {
        return function(i2, n2, r2) {
          t2.call(void 0 !== e2 ? e2 : this, i2, n2, r2);
          r2[r2.length - 1].node.appendChild(i2);
        };
      }
      function Tu(t2, e2) {
        let i2, n2;
        return function(e3, r2, s2) {
          if (void 0 === i2) {
            i2 = {};
            const r3 = {};
            r3[e3.localName] = t2, i2[e3.namespaceURI] = r3, n2 = Cu(e3.localName);
          }
          Mu(i2, n2, r2, s2);
        };
      }
      function Cu(t2, e2) {
        return function(i2, n2, r2) {
          const s2 = n2[n2.length - 1].node;
          let o2 = t2;
          void 0 === o2 && (o2 = r2);
          return du(void 0 !== e2 ? e2 : s2.namespaceURI, o2);
        };
      }
      const bu = Cu();
      function Ru(t2, e2) {
        const i2 = e2.length, n2 = new Array(i2);
        for (let r2 = 0; r2 < i2; ++r2)
          n2[r2] = t2[e2[r2]];
        return n2;
      }
      function Pu(t2, e2, i2) {
        let n2, r2;
        for (i2 = void 0 !== i2 ? i2 : {}, n2 = 0, r2 = t2.length; n2 < r2; ++n2)
          i2[t2[n2]] = e2;
        return i2;
      }
      function Iu(t2, e2, i2, n2) {
        let r2;
        for (r2 = e2.firstElementChild; r2; r2 = r2.nextElementSibling) {
          const e3 = t2[r2.namespaceURI];
          if (void 0 !== e3) {
            const t3 = e3[r2.localName];
            void 0 !== t3 && t3.call(n2, r2, i2);
          }
        }
      }
      function Lu(t2, e2, i2, n2, r2) {
        return n2.push(t2), Iu(e2, i2, n2, r2), n2.pop();
      }
      function Mu(t2, e2, i2, n2, r2, s2) {
        const o2 = (void 0 !== r2 ? r2 : i2).length;
        let a2, l2;
        for (let h2 = 0; h2 < o2; ++h2)
          a2 = i2[h2], void 0 !== a2 && (l2 = e2.call(void 0 !== s2 ? s2 : this, a2, n2, void 0 !== r2 ? r2[h2] : void 0), void 0 !== l2 && t2[l2.namespaceURI][l2.localName].call(s2, l2, a2, n2));
      }
      function Fu(t2, e2, i2, n2, r2, s2, o2) {
        return r2.push(t2), Mu(e2, i2, n2, r2, s2, o2), r2.pop();
      }
      let Au, Ou;
      function Nu() {
        return void 0 === Au && "undefined" != typeof XMLSerializer && (Au = new XMLSerializer()), Au;
      }
      function Du() {
        return void 0 === Ou && "undefined" != typeof document && (Ou = document.implementation.createDocument("", "", null)), Ou;
      }
      const ku = su;
      class Gu {
        constructor(t2, e2) {
          this.array = null, this.type = t2, at(t2 === nu || t2 === ru, 62), this.usage = void 0 !== e2 ? e2 : ku;
        }
        ofSize(t2) {
          this.array = new (ju(this.type))(t2);
        }
        fromArray(t2) {
          this.array = ju(this.type).from(t2);
        }
        fromArrayBuffer(t2) {
          this.array = new (ju(this.type))(t2);
        }
        getType() {
          return this.type;
        }
        getArray() {
          return this.array;
        }
        getUsage() {
          return this.usage;
        }
        getSize() {
          return this.array ? this.array.length : 0;
        }
      }
      function ju(t2) {
        switch (t2) {
          case nu:
            return Float32Array;
          case ru:
            return Uint32Array;
          default:
            return Float32Array;
        }
      }
      var Bu = "webglcontextlost", Uu = "webglcontextrestored";
      class zu {
        constructor(t2) {
          this.gl_ = t2.webGlContext;
          const e2 = this.gl_;
          this.scaleRatio_ = t2.scaleRatio || 1, this.renderTargetTexture_ = e2.createTexture(), this.renderTargetTextureSize_ = null, this.frameBuffer_ = e2.createFramebuffer();
          const i2 = e2.createShader(e2.VERTEX_SHADER);
          e2.shaderSource(i2, t2.vertexShader || "\n  precision mediump float;\n  \n  attribute vec2 a_position;\n  varying vec2 v_texCoord;\n  varying vec2 v_screenCoord;\n  \n  uniform vec2 u_screenSize;\n   \n  void main() {\n    v_texCoord = a_position * 0.5 + 0.5;\n    v_screenCoord = v_texCoord * u_screenSize;\n    gl_Position = vec4(a_position, 0.0, 1.0);\n  }\n"), e2.compileShader(i2);
          const n2 = e2.createShader(e2.FRAGMENT_SHADER);
          e2.shaderSource(n2, t2.fragmentShader || "\n  precision mediump float;\n   \n  uniform sampler2D u_image;\n  uniform float u_opacity;\n   \n  varying vec2 v_texCoord;\n   \n  void main() {\n    gl_FragColor = texture2D(u_image, v_texCoord) * u_opacity;\n  }\n"), e2.compileShader(n2), this.renderTargetProgram_ = e2.createProgram(), e2.attachShader(this.renderTargetProgram_, i2), e2.attachShader(this.renderTargetProgram_, n2), e2.linkProgram(this.renderTargetProgram_), this.renderTargetVerticesBuffer_ = e2.createBuffer();
          e2.bindBuffer(e2.ARRAY_BUFFER, this.renderTargetVerticesBuffer_), e2.bufferData(e2.ARRAY_BUFFER, new Float32Array([-1, -1, 1, -1, -1, 1, 1, -1, 1, 1, -1, 1]), e2.STATIC_DRAW), this.renderTargetAttribLocation_ = e2.getAttribLocation(this.renderTargetProgram_, "a_position"), this.renderTargetUniformLocation_ = e2.getUniformLocation(this.renderTargetProgram_, "u_screenSize"), this.renderTargetOpacityLocation_ = e2.getUniformLocation(this.renderTargetProgram_, "u_opacity"), this.renderTargetTextureLocation_ = e2.getUniformLocation(this.renderTargetProgram_, "u_image"), this.uniforms_ = [], t2.uniforms && Object.keys(t2.uniforms).forEach(function(i3) {
            this.uniforms_.push({ value: t2.uniforms[i3], location: e2.getUniformLocation(this.renderTargetProgram_, i3) });
          }.bind(this));
        }
        getGL() {
          return this.gl_;
        }
        init(t2) {
          const e2 = this.getGL(), i2 = [e2.drawingBufferWidth * this.scaleRatio_, e2.drawingBufferHeight * this.scaleRatio_];
          if (e2.bindFramebuffer(e2.FRAMEBUFFER, this.getFrameBuffer()), e2.viewport(0, 0, i2[0], i2[1]), !this.renderTargetTextureSize_ || this.renderTargetTextureSize_[0] !== i2[0] || this.renderTargetTextureSize_[1] !== i2[1]) {
            this.renderTargetTextureSize_ = i2;
            const t3 = 0, n2 = e2.RGBA, r2 = 0, s2 = e2.RGBA, o2 = e2.UNSIGNED_BYTE, a2 = null;
            e2.bindTexture(e2.TEXTURE_2D, this.renderTargetTexture_), e2.texImage2D(e2.TEXTURE_2D, t3, n2, i2[0], i2[1], r2, s2, o2, a2), e2.texParameteri(e2.TEXTURE_2D, e2.TEXTURE_MIN_FILTER, e2.LINEAR), e2.texParameteri(e2.TEXTURE_2D, e2.TEXTURE_WRAP_S, e2.CLAMP_TO_EDGE), e2.texParameteri(e2.TEXTURE_2D, e2.TEXTURE_WRAP_T, e2.CLAMP_TO_EDGE), e2.framebufferTexture2D(e2.FRAMEBUFFER, e2.COLOR_ATTACHMENT0, e2.TEXTURE_2D, this.renderTargetTexture_, 0);
          }
        }
        apply(t2, e2, i2, n2) {
          const r2 = this.getGL(), s2 = t2.size;
          if (r2.bindFramebuffer(r2.FRAMEBUFFER, e2 ? e2.getFrameBuffer() : null), r2.activeTexture(r2.TEXTURE0), r2.bindTexture(r2.TEXTURE_2D, this.renderTargetTexture_), !e2) {
            const e3 = z(r2.canvas);
            if (!t2.renderTargets[e3]) {
              const i3 = r2.getContextAttributes();
              i3 && i3.preserveDrawingBuffer && (r2.clearColor(0, 0, 0, 0), r2.clear(r2.COLOR_BUFFER_BIT)), t2.renderTargets[e3] = true;
            }
          }
          r2.enable(r2.BLEND), r2.blendFunc(r2.ONE, r2.ONE_MINUS_SRC_ALPHA), r2.viewport(0, 0, r2.drawingBufferWidth, r2.drawingBufferHeight), r2.bindBuffer(r2.ARRAY_BUFFER, this.renderTargetVerticesBuffer_), r2.useProgram(this.renderTargetProgram_), r2.enableVertexAttribArray(this.renderTargetAttribLocation_), r2.vertexAttribPointer(this.renderTargetAttribLocation_, 2, r2.FLOAT, false, 0, 0), r2.uniform2f(this.renderTargetUniformLocation_, s2[0], s2[1]), r2.uniform1i(this.renderTargetTextureLocation_, 0);
          const o2 = t2.layerStatesArray[t2.layerIndex].opacity;
          r2.uniform1f(this.renderTargetOpacityLocation_, o2), this.applyUniforms(t2), i2 && i2(r2, t2), r2.drawArrays(r2.TRIANGLES, 0, 6), n2 && n2(r2, t2);
        }
        getFrameBuffer() {
          return this.frameBuffer_;
        }
        applyUniforms(t2) {
          const e2 = this.getGL();
          let i2, n2 = 1;
          this.uniforms_.forEach(function(r2) {
            if (i2 = "function" == typeof r2.value ? r2.value(t2) : r2.value, i2 instanceof HTMLCanvasElement || i2 instanceof ImageData)
              r2.texture || (r2.texture = e2.createTexture()), e2.activeTexture(e2[`TEXTURE${n2}`]), e2.bindTexture(e2.TEXTURE_2D, r2.texture), e2.texParameteri(e2.TEXTURE_2D, e2.TEXTURE_MIN_FILTER, e2.LINEAR), e2.texParameteri(e2.TEXTURE_2D, e2.TEXTURE_WRAP_S, e2.CLAMP_TO_EDGE), e2.texParameteri(e2.TEXTURE_2D, e2.TEXTURE_WRAP_T, e2.CLAMP_TO_EDGE), i2 instanceof ImageData ? e2.texImage2D(e2.TEXTURE_2D, 0, e2.RGBA, e2.RGBA, i2.width, i2.height, 0, e2.UNSIGNED_BYTE, new Uint8Array(i2.data)) : e2.texImage2D(e2.TEXTURE_2D, 0, e2.RGBA, e2.RGBA, e2.UNSIGNED_BYTE, i2), e2.uniform1i(r2.location, n2++);
            else if (Array.isArray(i2))
              switch (i2.length) {
                case 2:
                  return void e2.uniform2f(r2.location, i2[0], i2[1]);
                case 3:
                  return void e2.uniform3f(r2.location, i2[0], i2[1], i2[2]);
                case 4:
                  return void e2.uniform4f(r2.location, i2[0], i2[1], i2[2], i2[3]);
                default:
                  return;
              }
            else
              "number" == typeof i2 && e2.uniform1f(r2.location, i2);
          });
        }
      }
      function Xu() {
        return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
      }
      function Vu(t2, e2) {
        return t2[0] = e2[0], t2[1] = e2[1], t2[4] = e2[2], t2[5] = e2[3], t2[12] = e2[4], t2[13] = e2[5], t2;
      }
      const Wu = "u_projectionMatrix", Zu = "u_offsetScaleMatrix", Yu = "u_offsetRotateMatrix", Ku = "u_time", qu = "u_zoom", Hu = "u_resolution", $u = "u_sizePx", Ju = "u_pixelRatio", Qu = { UNSIGNED_BYTE: 5121, UNSIGNED_SHORT: 5123, UNSIGNED_INT: 5125, FLOAT: au }, td = {};
      function ed(t2) {
        return "shared/" + t2;
      }
      let id = 0;
      class nd extends s {
        constructor(t2) {
          super(), t2 = t2 || {}, this.boundHandleWebGLContextLost_ = this.handleWebGLContextLost.bind(this), this.boundHandleWebGLContextRestored_ = this.handleWebGLContextRestored.bind(this), this.canvasCacheKey_ = t2.canvasCacheKey ? ed(t2.canvasCacheKey) : function() {
            const t3 = "unique/" + id;
            return id += 1, t3;
          }(), this.canvas_ = function(t3) {
            let e3 = td[t3];
            if (!e3) {
              const i2 = document.createElement("canvas");
              i2.style.position = "absolute", i2.style.left = "0", e3 = { users: 0, canvas: i2 }, td[t3] = e3;
            }
            return e3.users += 1, e3.canvas;
          }(this.canvasCacheKey_), this.gl_ = hu(this.canvas_), this.bufferCache_ = {}, this.extensionCache_ = {}, this.currentProgram_ = null, this.canvas_.addEventListener(Bu, this.boundHandleWebGLContextLost_), this.canvas_.addEventListener(Uu, this.boundHandleWebGLContextRestored_), this.offsetRotateMatrix_ = [1, 0, 0, 1, 0, 0], this.offsetScaleMatrix_ = [1, 0, 0, 1, 0, 0], this.tmpMat4_ = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], this.uniformLocations_ = {}, this.attribLocations_ = {}, this.uniforms_ = [], t2.uniforms && this.setUniforms(t2.uniforms);
          const e2 = this.getGL();
          this.postProcessPasses_ = t2.postProcesses ? t2.postProcesses.map(function(t3) {
            return new zu({ webGlContext: e2, scaleRatio: t3.scaleRatio, vertexShader: t3.vertexShader, fragmentShader: t3.fragmentShader, uniforms: t3.uniforms });
          }) : [new zu({ webGlContext: e2 })], this.shaderCompileErrors_ = null, this.startTime_ = Date.now();
        }
        setUniforms(t2) {
          this.uniforms_ = [];
          for (const e2 in t2)
            this.uniforms_.push({ name: e2, value: t2[e2] });
          this.uniformLocations_ = {};
        }
        canvasCacheKeyMatches(t2) {
          return this.canvasCacheKey_ === ed(t2);
        }
        getExtension(t2) {
          if (t2 in this.extensionCache_)
            return this.extensionCache_[t2];
          const e2 = this.gl_.getExtension(t2);
          return this.extensionCache_[t2] = e2, e2;
        }
        bindBuffer(t2) {
          const e2 = this.getGL(), i2 = z(t2);
          let n2 = this.bufferCache_[i2];
          if (!n2) {
            n2 = { buffer: t2, webGlBuffer: e2.createBuffer() }, this.bufferCache_[i2] = n2;
          }
          e2.bindBuffer(t2.getType(), n2.webGlBuffer);
        }
        flushBufferData(t2) {
          const e2 = this.getGL();
          this.bindBuffer(t2), e2.bufferData(t2.getType(), t2.getArray(), t2.getUsage());
        }
        deleteBuffer(t2) {
          const e2 = this.getGL(), i2 = z(t2), n2 = this.bufferCache_[i2];
          n2 && !e2.isContextLost() && e2.deleteBuffer(n2.webGlBuffer), delete this.bufferCache_[i2];
        }
        disposeInternal() {
          this.canvas_.removeEventListener(Bu, this.boundHandleWebGLContextLost_), this.canvas_.removeEventListener(Uu, this.boundHandleWebGLContextRestored_), function(t2) {
            const e2 = td[t2];
            if (!e2)
              return;
            if (e2.users -= 1, e2.users > 0)
              return;
            const i2 = hu(e2.canvas).getExtension("WEBGL_lose_context");
            i2 && i2.loseContext(), delete td[t2];
          }(this.canvasCacheKey_), delete this.gl_, delete this.canvas_;
        }
        prepareDraw(t2, e2) {
          const i2 = this.getGL(), n2 = this.getCanvas(), r2 = t2.size, s2 = t2.pixelRatio;
          n2.width = r2[0] * s2, n2.height = r2[1] * s2, n2.style.width = r2[0] + "px", n2.style.height = r2[1] + "px";
          for (let e3 = this.postProcessPasses_.length - 1; e3 >= 0; e3--)
            this.postProcessPasses_[e3].init(t2);
          i2.bindTexture(i2.TEXTURE_2D, null), i2.clearColor(0, 0, 0, 0), i2.clear(i2.COLOR_BUFFER_BIT), i2.enable(i2.BLEND), i2.blendFunc(i2.ONE, e2 ? i2.ZERO : i2.ONE_MINUS_SRC_ALPHA);
        }
        prepareDrawToRenderTarget(t2, e2, i2) {
          const n2 = this.getGL(), r2 = e2.getSize();
          n2.bindFramebuffer(n2.FRAMEBUFFER, e2.getFramebuffer()), n2.viewport(0, 0, r2[0], r2[1]), n2.bindTexture(n2.TEXTURE_2D, e2.getTexture()), n2.clearColor(0, 0, 0, 0), n2.clear(n2.COLOR_BUFFER_BIT), n2.enable(n2.BLEND), n2.blendFunc(n2.ONE, i2 ? n2.ZERO : n2.ONE_MINUS_SRC_ALPHA);
        }
        drawElements(t2, e2) {
          const i2 = this.getGL();
          this.getExtension("OES_element_index_uint");
          const n2 = i2.UNSIGNED_INT, r2 = e2 - t2, s2 = 4 * t2;
          i2.drawElements(i2.TRIANGLES, r2, n2, s2);
        }
        finalizeDraw(t2, e2, i2) {
          for (let n2 = 0, r2 = this.postProcessPasses_.length; n2 < r2; n2++)
            n2 === r2 - 1 ? this.postProcessPasses_[n2].apply(t2, null, e2, i2) : this.postProcessPasses_[n2].apply(t2, this.postProcessPasses_[n2 + 1]);
        }
        getCanvas() {
          return this.canvas_;
        }
        getGL() {
          return this.gl_;
        }
        applyFrameState(t2) {
          const e2 = t2.size, i2 = t2.viewState.rotation, n2 = t2.pixelRatio, r2 = wt(this.offsetScaleMatrix_);
          Pt(r2, 2 / e2[0], 2 / e2[1]);
          const s2 = wt(this.offsetRotateMatrix_);
          0 !== i2 && Rt(s2, -i2), this.setUniformMatrixValue(Zu, Vu(this.tmpMat4_, r2)), this.setUniformMatrixValue(Yu, Vu(this.tmpMat4_, s2)), this.setUniformFloatValue(Ku, 1e-3 * (Date.now() - this.startTime_)), this.setUniformFloatValue(qu, t2.viewState.zoom), this.setUniformFloatValue(Hu, t2.viewState.resolution), this.setUniformFloatValue(Ju, n2), this.setUniformFloatVec2($u, [e2[0], e2[1]]);
        }
        applyUniforms(t2) {
          const e2 = this.getGL();
          let i2, n2 = 0;
          this.uniforms_.forEach(function(r2) {
            if (i2 = "function" == typeof r2.value ? r2.value(t2) : r2.value, i2 instanceof HTMLCanvasElement || i2 instanceof HTMLImageElement || i2 instanceof ImageData) {
              r2.texture || (r2.prevValue = void 0, r2.texture = e2.createTexture()), e2.activeTexture(e2[`TEXTURE${n2}`]), e2.bindTexture(e2.TEXTURE_2D, r2.texture), e2.texParameteri(e2.TEXTURE_2D, e2.TEXTURE_MIN_FILTER, e2.LINEAR), e2.texParameteri(e2.TEXTURE_2D, e2.TEXTURE_WRAP_S, e2.CLAMP_TO_EDGE), e2.texParameteri(e2.TEXTURE_2D, e2.TEXTURE_WRAP_T, e2.CLAMP_TO_EDGE);
              (!(i2 instanceof HTMLImageElement) || i2.complete) && r2.prevValue !== i2 && (r2.prevValue = i2, e2.texImage2D(e2.TEXTURE_2D, 0, e2.RGBA, e2.RGBA, e2.UNSIGNED_BYTE, i2)), e2.uniform1i(this.getUniformLocation(r2.name), n2++);
            } else if (Array.isArray(i2) && 6 === i2.length)
              this.setUniformMatrixValue(r2.name, Vu(this.tmpMat4_, i2));
            else if (Array.isArray(i2) && i2.length <= 4)
              switch (i2.length) {
                case 2:
                  return void e2.uniform2f(this.getUniformLocation(r2.name), i2[0], i2[1]);
                case 3:
                  return void e2.uniform3f(this.getUniformLocation(r2.name), i2[0], i2[1], i2[2]);
                case 4:
                  return void e2.uniform4f(this.getUniformLocation(r2.name), i2[0], i2[1], i2[2], i2[3]);
                default:
                  return;
              }
            else
              "number" == typeof i2 && e2.uniform1f(this.getUniformLocation(r2.name), i2);
          }.bind(this));
        }
        useProgram(t2, e2) {
          this.getGL().useProgram(t2), this.currentProgram_ = t2, this.uniformLocations_ = {}, this.attribLocations_ = {}, this.applyFrameState(e2), this.applyUniforms(e2);
        }
        compileShader(t2, e2) {
          const i2 = this.getGL(), n2 = i2.createShader(e2);
          return i2.shaderSource(n2, t2), i2.compileShader(n2), n2;
        }
        getProgram(t2, e2) {
          const i2 = this.getGL(), n2 = this.compileShader(t2, i2.FRAGMENT_SHADER), r2 = this.compileShader(e2, i2.VERTEX_SHADER), s2 = i2.createProgram();
          if (i2.attachShader(s2, n2), i2.attachShader(s2, r2), i2.linkProgram(s2), !i2.getShaderParameter(n2, i2.COMPILE_STATUS)) {
            const t3 = `Fragment shader compliation failed: ${i2.getShaderInfoLog(n2)}`;
            throw new Error(t3);
          }
          if (i2.deleteShader(n2), !i2.getShaderParameter(r2, i2.COMPILE_STATUS)) {
            const t3 = `Vertex shader compilation failed: ${i2.getShaderInfoLog(r2)}`;
            throw new Error(t3);
          }
          if (i2.deleteShader(r2), !i2.getProgramParameter(s2, i2.LINK_STATUS)) {
            const t3 = `GL program linking failed: ${i2.getShaderInfoLog(r2)}`;
            throw new Error(t3);
          }
          return s2;
        }
        getUniformLocation(t2) {
          return void 0 === this.uniformLocations_[t2] && (this.uniformLocations_[t2] = this.getGL().getUniformLocation(this.currentProgram_, t2)), this.uniformLocations_[t2];
        }
        getAttributeLocation(t2) {
          return void 0 === this.attribLocations_[t2] && (this.attribLocations_[t2] = this.getGL().getAttribLocation(this.currentProgram_, t2)), this.attribLocations_[t2];
        }
        makeProjectionTransform(t2, e2) {
          const i2 = t2.size, n2 = t2.viewState.rotation, r2 = t2.viewState.resolution, s2 = t2.viewState.center;
          return wt(e2), Mt(e2, 0, 0, 2 / (r2 * i2[0]), 2 / (r2 * i2[1]), -n2, -s2[0], -s2[1]), e2;
        }
        setUniformFloatValue(t2, e2) {
          this.getGL().uniform1f(this.getUniformLocation(t2), e2);
        }
        setUniformFloatVec2(t2, e2) {
          this.getGL().uniform2fv(this.getUniformLocation(t2), e2);
        }
        setUniformFloatVec4(t2, e2) {
          this.getGL().uniform4fv(this.getUniformLocation(t2), e2);
        }
        setUniformMatrixValue(t2, e2) {
          this.getGL().uniformMatrix4fv(this.getUniformLocation(t2), false, e2);
        }
        enableAttributeArray_(t2, e2, i2, n2, r2) {
          const s2 = this.getAttributeLocation(t2);
          s2 < 0 || (this.getGL().enableVertexAttribArray(s2), this.getGL().vertexAttribPointer(s2, e2, i2, false, n2, r2));
        }
        enableAttributes(t2) {
          const e2 = rd(t2);
          let i2 = 0;
          for (let n2 = 0; n2 < t2.length; n2++) {
            const r2 = t2[n2];
            this.enableAttributeArray_(r2.name, r2.size, r2.type || au, e2, i2), i2 += r2.size * sd(r2.type);
          }
        }
        handleWebGLContextLost() {
          y(this.bufferCache_), this.currentProgram_ = null;
        }
        handleWebGLContextRestored() {
        }
        createTexture(t2, e2, i2) {
          const n2 = this.getGL();
          i2 = i2 || n2.createTexture();
          const r2 = n2.RGBA, s2 = n2.RGBA, o2 = n2.UNSIGNED_BYTE;
          return n2.bindTexture(n2.TEXTURE_2D, i2), e2 ? n2.texImage2D(n2.TEXTURE_2D, 0, r2, s2, o2, e2) : n2.texImage2D(n2.TEXTURE_2D, 0, r2, t2[0], t2[1], 0, s2, o2, null), n2.texParameteri(n2.TEXTURE_2D, n2.TEXTURE_MIN_FILTER, n2.LINEAR), n2.texParameteri(n2.TEXTURE_2D, n2.TEXTURE_WRAP_S, n2.CLAMP_TO_EDGE), n2.texParameteri(n2.TEXTURE_2D, n2.TEXTURE_WRAP_T, n2.CLAMP_TO_EDGE), i2;
        }
      }
      function rd(t2) {
        let e2 = 0;
        for (let i2 = 0; i2 < t2.length; i2++) {
          const n2 = t2[i2];
          e2 += n2.size * sd(n2.type);
        }
        return e2;
      }
      function sd(t2) {
        switch (t2) {
          case Qu.UNSIGNED_BYTE:
            return Uint8Array.BYTES_PER_ELEMENT;
          case Qu.UNSIGNED_SHORT:
            return Uint16Array.BYTES_PER_ELEMENT;
          case Qu.UNSIGNED_INT:
            return Uint32Array.BYTES_PER_ELEMENT;
          case Qu.FLOAT:
          default:
            return Float32Array.BYTES_PER_ELEMENT;
        }
      }
      class od {
        constructor(t2, e2) {
          this.name = t2, this.data = e2, this.texture_ = null;
        }
        getTexture(t2) {
          if (!this.texture_) {
            const e2 = t2.createTexture();
            t2.bindTexture(t2.TEXTURE_2D, e2), t2.texParameteri(t2.TEXTURE_2D, t2.TEXTURE_WRAP_S, t2.CLAMP_TO_EDGE), t2.texParameteri(t2.TEXTURE_2D, t2.TEXTURE_WRAP_T, t2.CLAMP_TO_EDGE), t2.texParameteri(t2.TEXTURE_2D, t2.TEXTURE_MIN_FILTER, t2.NEAREST), t2.texParameteri(t2.TEXTURE_2D, t2.TEXTURE_MAG_FILTER, t2.NEAREST), t2.texImage2D(t2.TEXTURE_2D, 0, t2.RGBA, this.data.length / 4, 1, 0, t2.RGBA, t2.UNSIGNED_BYTE, this.data), this.texture_ = e2;
          }
          return this.texture_;
        }
      }
      const ad = new Uint8Array(4);
      class ld {
        constructor(t2, e2) {
          this.helper_ = t2;
          const i2 = t2.getGL();
          this.texture_ = i2.createTexture(), this.framebuffer_ = i2.createFramebuffer(), this.size_ = e2 || [1, 1], this.data_ = new Uint8Array(0), this.dataCacheDirty_ = true, this.updateSize_();
        }
        setSize(t2) {
          u(t2, this.size_) || (this.size_[0] = t2[0], this.size_[1] = t2[1], this.updateSize_());
        }
        getSize() {
          return this.size_;
        }
        clearCachedData() {
          this.dataCacheDirty_ = true;
        }
        readAll() {
          if (this.dataCacheDirty_) {
            const t2 = this.size_, e2 = this.helper_.getGL();
            e2.bindFramebuffer(e2.FRAMEBUFFER, this.framebuffer_), e2.readPixels(0, 0, t2[0], t2[1], e2.RGBA, e2.UNSIGNED_BYTE, this.data_), this.dataCacheDirty_ = false;
          }
          return this.data_;
        }
        readPixel(t2, e2) {
          if (t2 < 0 || e2 < 0 || t2 > this.size_[0] || e2 >= this.size_[1])
            return ad[0] = 0, ad[1] = 0, ad[2] = 0, ad[3] = 0, ad;
          this.readAll();
          const i2 = Math.floor(t2) + (this.size_[1] - Math.floor(e2) - 1) * this.size_[0];
          return ad[0] = this.data_[4 * i2], ad[1] = this.data_[4 * i2 + 1], ad[2] = this.data_[4 * i2 + 2], ad[3] = this.data_[4 * i2 + 3], ad;
        }
        getTexture() {
          return this.texture_;
        }
        getFramebuffer() {
          return this.framebuffer_;
        }
        updateSize_() {
          const t2 = this.size_, e2 = this.helper_.getGL();
          this.texture_ = this.helper_.createTexture(t2, null, this.texture_), e2.bindFramebuffer(e2.FRAMEBUFFER, this.framebuffer_), e2.viewport(0, 0, t2[0], t2[1]), e2.framebufferTexture2D(e2.FRAMEBUFFER, e2.COLOR_ATTACHMENT0, e2.TEXTURE_2D, this.texture_, 0), this.data_ = new Uint8Array(t2[0] * t2[1] * 4);
        }
      }
      function hd(t2, e2, i2) {
        const n2 = i2 ? t2.LINEAR : t2.NEAREST;
        t2.bindTexture(t2.TEXTURE_2D, e2), t2.texParameteri(t2.TEXTURE_2D, t2.TEXTURE_WRAP_S, t2.CLAMP_TO_EDGE), t2.texParameteri(t2.TEXTURE_2D, t2.TEXTURE_WRAP_T, t2.CLAMP_TO_EDGE), t2.texParameteri(t2.TEXTURE_2D, t2.TEXTURE_MIN_FILTER, n2), t2.texParameteri(t2.TEXTURE_2D, t2.TEXTURE_MAG_FILTER, n2);
      }
      function cd(t2, e2, i2, n2, r2, s2) {
        const o2 = t2.getGL();
        let a2, l2;
        if (i2 instanceof Float32Array) {
          a2 = o2.FLOAT, t2.getExtension("OES_texture_float");
          l2 = null !== t2.getExtension("OES_texture_float_linear");
        } else
          a2 = o2.UNSIGNED_BYTE, l2 = true;
        hd(o2, e2, s2 && l2);
        const h2 = i2.byteLength / n2[1];
        let c2, u2 = 1;
        switch (h2 % 8 == 0 ? u2 = 8 : h2 % 4 == 0 ? u2 = 4 : h2 % 2 == 0 && (u2 = 2), r2) {
          case 1:
            c2 = o2.LUMINANCE;
            break;
          case 2:
            c2 = o2.LUMINANCE_ALPHA;
            break;
          case 3:
            c2 = o2.RGB;
            break;
          case 4:
            c2 = o2.RGBA;
            break;
          default:
            throw new Error(`Unsupported number of bands: ${r2}`);
        }
        const d2 = o2.getParameter(o2.UNPACK_ALIGNMENT);
        o2.pixelStorei(o2.UNPACK_ALIGNMENT, u2), o2.texImage2D(o2.TEXTURE_2D, 0, c2, n2[0], n2[1], 0, c2, a2, i2), o2.pixelStorei(o2.UNPACK_ALIGNMENT, d2);
      }
      let ud = null;
      class dd extends v {
        constructor(t2) {
          super(), this.tile, this.textures = [], this.handleTileChange_ = this.handleTileChange_.bind(this), this.renderSize_ = Va(t2.grid.getTileSize(t2.tile.tileCoord[0])), this.gutter_ = t2.gutter || 0, this.bandCount = NaN, this.helper_ = t2.helper;
          const e2 = new Gu(nu, su);
          e2.fromArray([0, 1, 1, 1, 1, 0, 0, 0]), this.helper_.flushBufferData(e2), this.coords = e2, this.setTile(t2.tile);
        }
        setTile(t2) {
          if (t2 !== this.tile)
            if (this.tile && this.tile.removeEventListener(S, this.handleTileChange_), this.tile = t2, this.textures.length = 0, this.loaded = t2.getState() === J, this.loaded)
              this.uploadTile_();
            else {
              if (t2 instanceof Vr) {
                const e2 = t2.getImage();
                e2 instanceof Image && !e2.crossOrigin && (e2.crossOrigin = "anonymous");
              }
              t2.addEventListener(S, this.handleTileChange_);
            }
        }
        uploadTile_() {
          const t2 = this.helper_, e2 = t2.getGL(), i2 = this.tile;
          if (i2 instanceof Vr || i2 instanceof zl) {
            const t3 = e2.createTexture();
            return this.textures.push(t3), this.bandCount = 4, void function(t4, e3, i3, n3) {
              hd(t4, e3, n3), t4.texImage2D(t4.TEXTURE_2D, 0, t4.RGBA, t4.RGBA, t4.UNSIGNED_BYTE, i3);
            }(e2, t3, i2.getImage(), i2.interpolate);
          }
          const n2 = i2.getSize(), r2 = [n2[0] + 2 * this.gutter_, n2[1] + 2 * this.gutter_], s2 = i2.getData(), o2 = s2 instanceof Float32Array, a2 = r2[0] * r2[1], l2 = o2 ? Float32Array : Uint8Array, h2 = l2.BYTES_PER_ELEMENT, c2 = s2.byteLength / r2[1];
          this.bandCount = Math.floor(c2 / h2 / r2[0]);
          const u2 = Math.ceil(this.bandCount / 4);
          if (1 === u2) {
            const n3 = e2.createTexture();
            return this.textures.push(n3), void cd(t2, n3, s2, r2, this.bandCount, i2.interpolate);
          }
          const d2 = new Array(u2);
          for (let t3 = 0; t3 < u2; ++t3) {
            const i3 = e2.createTexture();
            this.textures.push(i3);
            const n3 = t3 < u2 - 1 ? 4 : (this.bandCount - 1) % 4 + 1;
            d2[t3] = new l2(a2 * n3);
          }
          let g2 = 0, f2 = 0;
          const p2 = r2[0] * this.bandCount;
          for (let t3 = 0; t3 < r2[1]; ++t3) {
            for (let t4 = 0; t4 < p2; ++t4) {
              const e3 = s2[f2 + t4], i3 = Math.floor(g2 / this.bandCount), n3 = t4 % this.bandCount, r3 = d2[Math.floor(n3 / 4)];
              r3[i3 * (r3.length / a2) + n3 % 4] = e3, ++g2;
            }
            f2 += c2 / h2;
          }
          for (let e3 = 0; e3 < u2; ++e3) {
            const n3 = this.textures[e3], s3 = d2[e3];
            cd(t2, n3, s3, r2, s3.length / a2, i2.interpolate);
          }
        }
        handleTileChange_() {
          this.tile.getState() === J && (this.loaded = true, this.uploadTile_(), this.dispatchEvent(S));
        }
        disposeInternal() {
          const t2 = this.helper_.getGL();
          this.helper_.deleteBuffer(this.coords);
          for (let e2 = 0; e2 < this.textures.length; ++e2)
            t2.deleteTexture(this.textures[e2]);
          this.tile.removeEventListener(S, this.handleTileChange_);
        }
        getPixelData(t2, e2) {
          if (!this.loaded)
            return null;
          const i2 = this.renderSize_[0], n2 = this.renderSize_[1], r2 = this.gutter_;
          if (this.tile instanceof ot) {
            const s3 = this.tile.getSize(), o3 = s3[0], a3 = s3[1], l3 = o3 + 2 * r2, h3 = a3 + 2 * r2, c3 = r2 + Math.floor(o3 * (t2 / i2)), u2 = r2 + Math.floor(a3 * (e2 / n2)), d2 = this.tile.getData();
            if (d2 instanceof DataView) {
              const t3 = d2.byteLength / (l3 * h3), e3 = t3 * (u2 * l3 + c3), i3 = d2.buffer.slice(e3, e3 + t3);
              return new DataView(i3);
            }
            const g2 = this.bandCount * (u2 * l3 + c3);
            return d2.slice(g2, g2 + this.bandCount);
          }
          ud || function() {
            const t3 = document.createElement("canvas");
            t3.width = 1, t3.height = 1, ud = t3.getContext("2d");
          }(), ud.clearRect(0, 0, 1, 1);
          const s2 = this.tile.getImage(), o2 = s2.width - 2 * r2, a2 = s2.height - 2 * r2, l2 = r2 + Math.floor(o2 * (t2 / i2)), h2 = r2 + Math.floor(a2 * (e2 / n2));
          let c2;
          try {
            ud.drawImage(s2, l2, h2, 1, 1, 0, 0, 1, 1), c2 = ud.getImageData(0, 0, 1, 1).data;
          } catch (t3) {
            return ud = null, null;
          }
          return c2;
        }
      }
      class gd extends Cc {
        constructor(t2, e2) {
          super(t2), e2 = e2 || {}, this.inversePixelTransform_ = [1, 0, 0, 1, 0, 0], this.pixelContext_ = null, this.postProcesses_ = e2.postProcesses, this.uniforms_ = e2.uniforms, this.helper, t2.addChangeListener(gs, this.removeHelper.bind(this)), this.dispatchPreComposeEvent = this.dispatchPreComposeEvent.bind(this), this.dispatchPostComposeEvent = this.dispatchPostComposeEvent.bind(this);
        }
        dispatchPreComposeEvent(t2, e2) {
          const i2 = this.getLayer();
          if (i2.hasListener(_s)) {
            const n2 = new Ts(_s, void 0, e2, t2);
            i2.dispatchEvent(n2);
          }
        }
        dispatchPostComposeEvent(t2, e2) {
          const i2 = this.getLayer();
          if (i2.hasListener(ys)) {
            const n2 = new Ts(ys, void 0, e2, t2);
            i2.dispatchEvent(n2);
          }
        }
        reset(t2) {
          this.uniforms_ = t2.uniforms, this.helper && this.helper.setUniforms(this.uniforms_);
        }
        removeHelper() {
          this.helper && (this.helper.dispose(), delete this.helper);
        }
        prepareFrame(t2) {
          if (this.getLayer().getRenderSource()) {
            let e2, i2 = true, n2 = -1;
            for (let r3 = 0, s2 = t2.layerStatesArray.length; r3 < s2; r3++) {
              const s3 = t2.layerStatesArray[r3].layer, o2 = s3.getRenderer();
              if (!(o2 instanceof gd)) {
                i2 = true;
                continue;
              }
              const a2 = s3.getClassName();
              if ((i2 || a2 !== e2) && (n2 += 1, i2 = false), e2 = a2, o2 === this)
                break;
            }
            const r2 = "map/" + t2.mapId + "/group/" + n2;
            this.helper && this.helper.canvasCacheKeyMatches(r2) || (this.removeHelper(), this.helper = new nd({ postProcesses: this.postProcesses_, uniforms: this.uniforms_, canvasCacheKey: r2 }), e2 && (this.helper.getCanvas().className = e2), this.afterHelperCreated());
          }
          return this.prepareFrameInternal(t2);
        }
        afterHelperCreated() {
        }
        prepareFrameInternal(t2) {
          return true;
        }
        disposeInternal() {
          this.removeHelper(), super.disposeInternal();
        }
        dispatchRenderEvent_(t2, e2, i2) {
          const n2 = this.getLayer();
          if (n2.hasListener(t2)) {
            Mt(this.inversePixelTransform_, 0, 0, i2.pixelRatio, -i2.pixelRatio, 0, 0, -i2.size[1]);
            const r2 = new Ts(t2, this.inversePixelTransform_, i2, e2);
            n2.dispatchEvent(r2);
          }
        }
        preRender(t2, e2) {
          this.dispatchRenderEvent_(ps, t2, e2);
        }
        postRender(t2, e2) {
          this.dispatchRenderEvent_(ms, t2, e2);
        }
      }
      const fd = { TILE_TEXTURE_ARRAY: "u_tileTextures", TILE_TRANSFORM: "u_tileTransform", TRANSITION_ALPHA: "u_transitionAlpha", DEPTH: "u_depth", TEXTURE_PIXEL_WIDTH: "u_texturePixelWidth", TEXTURE_PIXEL_HEIGHT: "u_texturePixelHeight", TEXTURE_RESOLUTION: "u_textureResolution", TEXTURE_ORIGIN_X: "u_textureOriginX", TEXTURE_ORIGIN_Y: "u_textureOriginY", RENDER_EXTENT: "u_renderExtent", RESOLUTION: "u_resolution", ZOOM: "u_zoom" }, pd = { TEXTURE_COORD: "a_textureCoord" }, md = [{ name: pd.TEXTURE_COORD, size: 2, type: Qu.FLOAT }], _d = {};
      function yd(t2) {
        return 2 * (1 - 1 / (t2 + 1)) - 1;
      }
      function xd(t2, e2, i2) {
        i2 in t2 || (t2[i2] = []), t2[i2].push(e2);
      }
      function vd(t2, e2) {
        const i2 = t2.layerStatesArray[t2.layerIndex];
        i2.extent && (e2 = ye(e2, on(i2.extent, t2.viewState.projection)));
        const n2 = i2.layer.getRenderSource();
        if (!n2.getWrapX()) {
          const i3 = n2.getTileGridForProjection(t2.viewState.projection).getExtent();
          i3 && (e2 = ye(e2, i3));
        }
        return e2;
      }
      function Sd(t2, e2) {
        return `${t2.getKey()},${nl(e2)}`;
      }
      class wd extends gd {
        constructor(t2, e2) {
          super(t2, { uniforms: e2.uniforms }), this.renderComplete = false, this.tileTransform_ = [1, 0, 0, 1, 0, 0], this.tempMat4_ = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], this.tempTileRange_ = new hl(0, 0, 0, 0), this.tempTileCoord_ = el(0, 0, 0), this.tempSize_ = [0, 0], this.program_, this.vertexShader_ = e2.vertexShader, this.fragmentShader_ = e2.fragmentShader, this.indices_ = new Gu(ru, su), this.indices_.fromArray([0, 1, 3, 1, 2, 3]);
          const i2 = void 0 !== e2.cacheSize ? e2.cacheSize : 512;
          this.tileTextureCache_ = new tl(i2), this.paletteTextures_ = e2.paletteTextures || [], this.frameState_ = null, this.projection_ = void 0;
        }
        reset(t2) {
          super.reset({ uniforms: t2.uniforms }), this.vertexShader_ = t2.vertexShader, this.fragmentShader_ = t2.fragmentShader, this.paletteTextures_ = t2.paletteTextures || [], this.helper && (this.program_ = this.helper.getProgram(this.fragmentShader_, this.vertexShader_));
        }
        afterHelperCreated() {
          this.program_ = this.helper.getProgram(this.fragmentShader_, this.vertexShader_), this.helper.flushBufferData(this.indices_);
        }
        isDrawableTile_(t2) {
          const e2 = this.getLayer(), i2 = t2.getState(), n2 = e2.getUseInterimTilesOnError();
          return i2 == J || i2 == tt || i2 == Q && !n2;
        }
        prepareFrameInternal(t2) {
          this.projection_ ? t2.viewState.projection !== this.projection_ && (this.clearCache(), this.projection_ = t2.viewState.projection) : this.projection_ = t2.viewState.projection;
          const e2 = this.getLayer().getRenderSource();
          return !!e2 && (!Ee(vd(t2, t2.extent)) && "ready" === e2.getState());
        }
        enqueueTiles(t2, e2, i2, n2, r2) {
          const s2 = t2.viewState, o2 = this.getLayer(), a2 = o2.getRenderSource(), l2 = a2.getTileGridForProjection(s2.projection), h2 = a2.getGutterForProjection(s2.projection), c2 = z(a2);
          c2 in t2.wantedTiles || (t2.wantedTiles[c2] = {});
          const u2 = t2.wantedTiles[c2], d2 = this.tileTextureCache_, g2 = o2.getMapInternal(), f2 = Math.max(i2 - r2, l2.getMinZoom(), l2.getZForResolution(Math.min(o2.getMaxResolution(), g2 ? g2.getView().getResolutionForZoom(Math.max(o2.getMinZoom(), 0)) : l2.getResolution(0)), a2.zDirection));
          for (let r3 = i2; r3 >= f2; --r3) {
            const i3 = l2.getTileRangeForExtentAndZ(e2, r3, this.tempTileRange_), o3 = l2.getResolution(r3);
            for (let e3 = i3.minX; e3 <= i3.maxX; ++e3)
              for (let g3 = i3.minY; g3 <= i3.maxY; ++g3) {
                const i4 = el(r3, e3, g3, this.tempTileCoord_), f3 = Sd(a2, i4);
                let p2, m2;
                if (d2.containsKey(f3) && (p2 = d2.get(f3), m2 = p2.tile), !p2 || p2.tile.key !== a2.getKey())
                  if (m2 = a2.getTile(r3, e3, g3, t2.pixelRatio, s2.projection), p2)
                    if (this.isDrawableTile_(m2))
                      p2.setTile(m2);
                    else {
                      const t3 = m2.getInterimTile();
                      p2.setTile(t3);
                    }
                  else
                    p2 = new dd({ tile: m2, grid: l2, helper: this.helper, gutter: h2 }), d2.set(f3, p2);
                xd(n2, p2, r3);
                const _2 = m2.getKey();
                u2[_2] = true, m2.getState() === H && (t2.tileQueue.isKeyQueued(_2) || t2.tileQueue.enqueue([m2, c2, l2.getTileCoordCenter(i4), o3]));
              }
          }
        }
        renderFrame(t2) {
          this.frameState_ = t2, this.renderComplete = true;
          const e2 = this.helper.getGL();
          this.preRender(e2, t2);
          const i2 = t2.viewState, n2 = this.getLayer(), r2 = n2.getRenderSource(), s2 = r2.getTileGridForProjection(i2.projection), o2 = r2.getGutterForProjection(i2.projection), l2 = vd(t2, t2.extent), h2 = s2.getZForResolution(i2.resolution, r2.zDirection), c2 = {}, u2 = n2.getPreload();
          if (t2.nextExtent) {
            const e3 = s2.getZForResolution(i2.nextResolution, r2.zDirection), n3 = vd(t2, t2.nextExtent);
            this.enqueueTiles(t2, n3, e3, c2, u2);
          }
          this.enqueueTiles(t2, l2, h2, c2, 0), u2 > 0 && setTimeout(() => {
            this.enqueueTiles(t2, l2, h2 - 1, c2, u2 - 1);
          }, 0);
          const d2 = {}, g2 = z(this), f2 = t2.time;
          let p2 = false;
          const m2 = c2[h2];
          for (let t3 = 0, e3 = m2.length; t3 < e3; ++t3) {
            const e4 = m2[t3], i3 = e4.tile;
            if (i3 instanceof zl && i3.getState() === tt)
              continue;
            const n3 = i3.tileCoord;
            if (e4.loaded) {
              const t4 = i3.getAlpha(g2, f2);
              if (1 === t4) {
                i3.endTransition(g2);
                continue;
              }
              p2 = true;
              d2[nl(n3)] = t4;
            }
            this.renderComplete = false;
            if (this.findAltTiles_(s2, n3, h2 + 1, c2))
              continue;
            const r3 = s2.getMinZoom();
            for (let t4 = h2 - 1; t4 >= r3; --t4) {
              if (this.findAltTiles_(s2, n3, t4, c2))
                break;
            }
          }
          this.helper.useProgram(this.program_, t2), this.helper.prepareDraw(t2, !p2);
          const _2 = Object.keys(c2).map(Number).sort(a), y2 = i2.center[0], x2 = i2.center[1];
          for (let n3 = 0, r3 = _2.length; n3 < r3; ++n3) {
            const r4 = _2[n3], a2 = s2.getResolution(r4), h3 = Va(s2.getTileSize(r4), this.tempSize_), u3 = s2.getOrigin(r4), g3 = h3[0] + 2 * o2, f3 = h3[1] + 2 * o2, p3 = g3 / f3, m3 = (y2 - u3[0]) / (h3[0] * a2), v3 = (u3[1] - x2) / (h3[1] * a2), S3 = i2.resolution / a2, w2 = yd(r4), E2 = c2[r4];
            for (let n4 = 0, r5 = E2.length; n4 < r5; ++n4) {
              const r6 = E2[n4];
              if (!r6.loaded)
                continue;
              const c3 = r6.tile.tileCoord, _3 = nl(c3), y3 = c3[1], x3 = c3[2];
              wt(this.tileTransform_), Pt(this.tileTransform_, 2 / (t2.size[0] * S3 / g3), -2 / (t2.size[1] * S3 / g3)), Rt(this.tileTransform_, i2.rotation), Pt(this.tileTransform_, 1, 1 / p3), Lt(this.tileTransform_, (h3[0] * (y3 - m3) - o2) / g3, (h3[1] * (x3 - v3) - o2) / f3), this.helper.setUniformMatrixValue(fd.TILE_TRANSFORM, Vu(this.tempMat4_, this.tileTransform_)), this.helper.bindBuffer(r6.coords), this.helper.bindBuffer(this.indices_), this.helper.enableAttributes(md);
              let T2 = 0;
              for (; T2 < r6.textures.length; ) {
                const t3 = "TEXTURE" + T2, i3 = `${fd.TILE_TEXTURE_ARRAY}[${T2}]`;
                e2.activeTexture(e2[t3]), e2.bindTexture(e2.TEXTURE_2D, r6.textures[T2]), e2.uniform1i(this.helper.getUniformLocation(i3), T2), ++T2;
              }
              for (let t3 = 0; t3 < this.paletteTextures_.length; ++t3) {
                const i3 = this.paletteTextures_[t3];
                e2.activeTexture(e2["TEXTURE" + T2]);
                const n5 = i3.getTexture(e2);
                e2.bindTexture(e2.TEXTURE_2D, n5), e2.uniform1i(this.helper.getUniformLocation(i3.name), T2), ++T2;
              }
              const C2 = _3 in d2 ? d2[_3] : 1;
              C2 < 1 && (t2.animate = true), this.helper.setUniformFloatValue(fd.TRANSITION_ALPHA, C2), this.helper.setUniformFloatValue(fd.DEPTH, w2), this.helper.setUniformFloatValue(fd.TEXTURE_PIXEL_WIDTH, g3), this.helper.setUniformFloatValue(fd.TEXTURE_PIXEL_HEIGHT, f3), this.helper.setUniformFloatValue(fd.TEXTURE_RESOLUTION, a2), this.helper.setUniformFloatValue(fd.TEXTURE_ORIGIN_X, u3[0] + y3 * h3[0] * a2 - o2 * a2), this.helper.setUniformFloatValue(fd.TEXTURE_ORIGIN_Y, u3[1] - x3 * h3[1] * a2 + o2 * a2);
              let b2 = l2;
              o2 > 0 && (b2 = s2.getTileCoordExtent(c3), ye(b2, l2, b2)), this.helper.setUniformFloatVec4(fd.RENDER_EXTENT, b2), this.helper.setUniformFloatValue(fd.RESOLUTION, i2.resolution), this.helper.setUniformFloatValue(fd.ZOOM, i2.zoom), this.helper.drawElements(0, this.indices_.getSize());
            }
          }
          this.helper.finalizeDraw(t2, this.dispatchPreComposeEvent, this.dispatchPostComposeEvent);
          const v2 = this.helper.getCanvas(), S2 = this.tileTextureCache_;
          for (; S2.canExpireCache(); ) {
            S2.pop().dispose();
          }
          return t2.postRenderFunctions.push(function(t3, e3) {
            r2.updateCacheSize(0.1, e3.viewState.projection), r2.expireCache(e3.viewState.projection, _d);
          }), this.postRender(e2, t2), v2;
        }
        getData(t2) {
          if (!this.helper.getGL())
            return null;
          const e2 = this.frameState_;
          if (!e2)
            return null;
          const i2 = this.getLayer(), n2 = bt(e2.pixelToCoordinateTransform, t2.slice()), r2 = e2.viewState, s2 = i2.getExtent();
          if (s2 && !Zt(on(s2, r2.projection), n2))
            return null;
          const o2 = i2.getSources(zt([n2]), r2.resolution);
          let a2, l2, h2;
          for (a2 = o2.length - 1; a2 >= 0; --a2)
            if (l2 = o2[a2], "ready" === l2.getState()) {
              if (h2 = l2.getTileGridForProjection(r2.projection), l2.getWrapX())
                break;
              const t3 = h2.getExtent();
              if (!t3 || Zt(t3, n2))
                break;
            }
          if (a2 < 0)
            return null;
          const c2 = this.tileTextureCache_;
          for (let t3 = h2.getZForResolution(r2.resolution); t3 >= h2.getMinZoom(); --t3) {
            const e3 = h2.getTileCoordForCoordAndZ(n2, t3), i3 = Sd(l2, e3);
            if (!c2.containsKey(i3))
              continue;
            const r3 = c2.get(i3), s3 = r3.tile;
            if (s3 instanceof zl && s3.getState() === tt)
              return null;
            if (!r3.loaded)
              continue;
            const o3 = h2.getOrigin(t3), a3 = Va(h2.getTileSize(t3)), u2 = h2.getResolution(t3), d2 = (n2[0] - o3[0]) / u2 - e3[1] * a3[0], g2 = (o3[1] - n2[1]) / u2 - e3[2] * a3[1];
            return r3.getPixelData(d2, g2);
          }
          return null;
        }
        findAltTiles_(t2, e2, i2, n2) {
          const r2 = t2.getTileRangeForTileCoordAndZ(e2, i2, this.tempTileRange_);
          if (!r2)
            return false;
          let s2 = true;
          const o2 = this.tileTextureCache_, a2 = this.getLayer().getRenderSource();
          for (let t3 = r2.minX; t3 <= r2.maxX; ++t3)
            for (let e3 = r2.minY; e3 <= r2.maxY; ++e3) {
              const r3 = Sd(a2, [i2, t3, e3]);
              let l2 = false;
              if (o2.containsKey(r3)) {
                const t4 = o2.get(r3);
                t4.loaded && (xd(n2, t4, i2), l2 = true);
              }
              l2 || (s2 = false);
            }
          return s2;
        }
        clearCache() {
          const t2 = this.tileTextureCache_;
          t2.forEach((t3) => t3.dispose()), t2.clear();
        }
        removeHelper() {
          this.helper && this.clearCache(), super.removeHelper();
        }
        disposeInternal() {
          const t2 = this.helper;
          if (t2) {
            t2.getGL().deleteProgram(this.program_), delete this.program_, t2.deleteBuffer(this.indices_);
          }
          super.disposeInternal(), delete this.indices_, delete this.tileTextureCache_, delete this.frameState_;
        }
      }
      const Ed = 1, Td = 2, Cd = 4, bd = 8, Rd = 16, Pd = 31, Id = 0, Ld = {};
      function Md(t2) {
        if ("number" == typeof t2)
          return Ed;
        if ("boolean" == typeof t2)
          return bd;
        if ("string" == typeof t2)
          return ts(t2) ? Cd | Td : Td;
        if (!Array.isArray(t2))
          throw new Error(`Unhandled value type: ${JSON.stringify(t2)}`);
        const e2 = t2;
        if (e2.every(function(t3) {
          return "number" == typeof t3;
        }))
          return 3 === e2.length || 4 === e2.length ? Cd | Rd : Rd;
        if ("string" != typeof e2[0])
          throw new Error(`Expected an expression operator but received: ${JSON.stringify(e2)}`);
        const i2 = Ld[e2[0]];
        if (void 0 === i2)
          throw new Error(`Unrecognized expression operator: ${JSON.stringify(e2)}`);
        return i2.getReturnType(e2.slice(1));
      }
      function Fd(t2) {
        return Math.log2(t2) % 1 == 0;
      }
      function Ad(t2) {
        const e2 = t2.toString();
        return e2.includes(".") ? e2 : e2 + ".0";
      }
      function Od(t2) {
        if (t2.length < 2 || t2.length > 4)
          throw new Error("`formatArray` can only output `vec2`, `vec3` or `vec4` arrays.");
        return `vec${t2.length}(${t2.map(Ad).join(", ")})`;
      }
      function Nd(t2) {
        const e2 = $r(t2).slice();
        return e2.length < 4 && e2.push(1), Od(e2.map(function(t3, e3) {
          return e3 < 3 ? t3 / 255 : t3;
        }));
      }
      function Dd(t2, e2) {
        return void 0 === t2.stringLiteralsMap[e2] && (t2.stringLiteralsMap[e2] = Object.keys(t2.stringLiteralsMap).length), t2.stringLiteralsMap[e2];
      }
      function kd(t2, e2) {
        return Ad(Dd(t2, e2));
      }
      function Gd(t2, e2, i2) {
        if (Array.isArray(e2) && "string" == typeof e2[0]) {
          const n3 = Ld[e2[0]];
          if (void 0 === n3)
            throw new Error(`Unrecognized expression operator: ${JSON.stringify(e2)}`);
          return n3.toGlsl(t2, e2.slice(1), i2);
        }
        const n2 = Md(e2);
        if ((n2 & Ed) > 0)
          return Ad(e2);
        if ((n2 & bd) > 0)
          return e2.toString();
        if ((n2 & Td) > 0 && (void 0 === i2 || i2 == Td))
          return kd(t2, e2.toString());
        if ((n2 & Cd) > 0 && (void 0 === i2 || i2 == Cd))
          return Nd(e2);
        if ((n2 & Rd) > 0)
          return Od(e2);
        throw new Error(`Unexpected expression ${e2} (expected type ${i2})`);
      }
      function jd(t2) {
        if (!(Md(t2) & Ed))
          throw new Error(`A numeric value was expected, got ${JSON.stringify(t2)} instead`);
      }
      function Bd(t2) {
        for (let e2 = 0; e2 < t2.length; e2++)
          jd(t2[e2]);
      }
      function Ud(t2) {
        if (!(Md(t2) & Td))
          throw new Error(`A string value was expected, got ${JSON.stringify(t2)} instead`);
      }
      function zd(t2) {
        if (!(Md(t2) & bd))
          throw new Error(`A boolean value was expected, got ${JSON.stringify(t2)} instead`);
      }
      function Xd(t2, e2) {
        if (t2.length !== e2)
          throw new Error(`Exactly ${e2} arguments were expected, got ${t2.length} instead`);
      }
      function Vd(t2, e2) {
        if (t2.length < e2)
          throw new Error(`At least ${e2} arguments were expected, got ${t2.length} instead`);
      }
      function Wd(t2, e2) {
        if (t2.length > e2)
          throw new Error(`At most ${e2} arguments were expected, got ${t2.length} instead`);
      }
      function Zd(t2) {
        if (t2.length % 2 != 0)
          throw new Error(`An even amount of arguments was expected, got ${t2} instead`);
      }
      function Yd(t2, e2) {
        if (!Fd(e2))
          throw new Error(`Could not infer only one type from the following expression: ${JSON.stringify(t2)}`);
      }
      function Kd(t2) {
        return "u_var_" + t2;
      }
      Ld.get = { getReturnType: function(t2) {
        return Pd;
      }, toGlsl: function(t2, e2) {
        Xd(e2, 1), Ud(e2[0]);
        const i2 = e2[0].toString();
        t2.attributes.includes(i2) || t2.attributes.push(i2);
        return (t2.inFragmentShader ? "v_" : "a_") + i2;
      } }, Ld.var = { getReturnType: function(t2) {
        return Pd;
      }, toGlsl: function(t2, e2) {
        Xd(e2, 1), Ud(e2[0]);
        const i2 = e2[0].toString();
        return t2.variables.includes(i2) || t2.variables.push(i2), Kd(i2);
      } };
      const qd = "u_paletteTextures";
      Ld.palette = { getReturnType: function(t2) {
        return Cd;
      }, toGlsl: function(t2, e2) {
        Xd(e2, 2), jd(e2[0]);
        const i2 = Gd(t2, e2[0]), n2 = e2[1];
        if (!Array.isArray(n2))
          throw new Error("The second argument of palette must be an array");
        const r2 = n2.length, s2 = new Uint8Array(4 * r2);
        for (let t3 = 0; t3 < r2; t3++) {
          const e3 = n2[t3];
          let i3;
          if ("string" == typeof e3)
            i3 = Hr(e3);
          else {
            if (!Array.isArray(e3))
              throw new Error("The second argument of palette must be an array of strings or colors");
            const t4 = e3.length;
            if (4 === t4)
              i3 = e3;
            else {
              if (3 !== t4)
                throw new Error(`Expected palette color to have 3 or 4 values, got ${t4}`);
              i3 = [e3[0], e3[1], e3[2], 1];
            }
          }
          const r3 = 4 * t3;
          s2[r3] = i3[0], s2[r3 + 1] = i3[1], s2[r3 + 2] = i3[2], s2[r3 + 3] = 255 * i3[3];
        }
        t2.paletteTextures || (t2.paletteTextures = []);
        const o2 = `u_paletteTextures[${t2.paletteTextures.length}]`, a2 = new od(o2, s2);
        return t2.paletteTextures.push(a2), `texture2D(${o2}, vec2((${i2} + 0.5) / ${r2}.0, 0.5))`;
      } };
      const Hd = "getBandValue";
      function $d(t2) {
        return { getReturnType: function(t3) {
          return bd;
        }, toGlsl: function(e2, i2) {
          Xd(i2, 2);
          let n2 = Pd;
          for (let t3 = 0; t3 < i2.length; t3++)
            n2 &= Md(i2[t3]);
          if (n2 === Id)
            throw new Error(`All arguments should be of compatible type, got ${JSON.stringify(i2)} instead`);
          return n2 &= ~Cd, `(${Gd(e2, i2[0], n2)} ${t2} ${Gd(e2, i2[1], n2)})`;
        } };
      }
      function Jd(t2) {
        return { getReturnType: function(t3) {
          return bd;
        }, toGlsl: function(e2, i2) {
          Vd(i2, 2);
          for (let t3 = 0; t3 < i2.length; t3++)
            zd(i2[t3]);
          let n2 = "";
          return n2 = i2.map((t3) => Gd(e2, t3)).join(` ${t2} `), n2 = `(${n2})`, n2;
        } };
      }
      Ld.band = { getReturnType: function(t2) {
        return Ed;
      }, toGlsl: function(t2, e2) {
        Vd(e2, 1), Wd(e2, 3);
        const i2 = e2[0];
        if (!(Hd in t2.functions)) {
          let e3 = "";
          const i3 = t2.bandCount || 1;
          for (let t3 = 0; t3 < i3; t3++) {
            const n2 = Math.floor(t3 / 4);
            let r2 = t3 % 4;
            t3 === i3 - 1 && 1 === r2 && (r2 = 3);
            e3 += `
          if (band == ${t3 + 1}.0) {
            return texture2D(${`${fd.TILE_TEXTURE_ARRAY}[${n2}]`}, v_textureCoord + vec2(dx, dy))[${r2}];
          }
        `;
          }
          t2.functions.getBandValue = `
        float getBandValue(float band, float xOffset, float yOffset) {
          float dx = xOffset / ${fd.TEXTURE_PIXEL_WIDTH};
          float dy = yOffset / ${fd.TEXTURE_PIXEL_HEIGHT};
          ${e3}
        }
      `;
        }
        return `getBandValue(${Gd(t2, i2)}, ${Gd(t2, e2[1] || 0)}, ${Gd(t2, e2[2] || 0)})`;
      } }, Ld.time = { getReturnType: function(t2) {
        return Ed;
      }, toGlsl: function(t2, e2) {
        return Xd(e2, 0), "u_time";
      } }, Ld.zoom = { getReturnType: function(t2) {
        return Ed;
      }, toGlsl: function(t2, e2) {
        return Xd(e2, 0), "u_zoom";
      } }, Ld.resolution = { getReturnType: function(t2) {
        return Ed;
      }, toGlsl: function(t2, e2) {
        return Xd(e2, 0), "u_resolution";
      } }, Ld["*"] = { getReturnType: function(t2) {
        return Ed;
      }, toGlsl: function(t2, e2) {
        return Xd(e2, 2), Bd(e2), `(${Gd(t2, e2[0])} * ${Gd(t2, e2[1])})`;
      } }, Ld["/"] = { getReturnType: function(t2) {
        return Ed;
      }, toGlsl: function(t2, e2) {
        return Xd(e2, 2), Bd(e2), `(${Gd(t2, e2[0])} / ${Gd(t2, e2[1])})`;
      } }, Ld["+"] = { getReturnType: function(t2) {
        return Ed;
      }, toGlsl: function(t2, e2) {
        return Xd(e2, 2), Bd(e2), `(${Gd(t2, e2[0])} + ${Gd(t2, e2[1])})`;
      } }, Ld["-"] = { getReturnType: function(t2) {
        return Ed;
      }, toGlsl: function(t2, e2) {
        return Xd(e2, 2), Bd(e2), `(${Gd(t2, e2[0])} - ${Gd(t2, e2[1])})`;
      } }, Ld.clamp = { getReturnType: function(t2) {
        return Ed;
      }, toGlsl: function(t2, e2) {
        Xd(e2, 3), Bd(e2);
        const i2 = Gd(t2, e2[1]), n2 = Gd(t2, e2[2]);
        return `clamp(${Gd(t2, e2[0])}, ${i2}, ${n2})`;
      } }, Ld["%"] = { getReturnType: function(t2) {
        return Ed;
      }, toGlsl: function(t2, e2) {
        return Xd(e2, 2), Bd(e2), `mod(${Gd(t2, e2[0])}, ${Gd(t2, e2[1])})`;
      } }, Ld["^"] = { getReturnType: function(t2) {
        return Ed;
      }, toGlsl: function(t2, e2) {
        return Xd(e2, 2), Bd(e2), `pow(${Gd(t2, e2[0])}, ${Gd(t2, e2[1])})`;
      } }, Ld.abs = { getReturnType: function(t2) {
        return Ed;
      }, toGlsl: function(t2, e2) {
        return Xd(e2, 1), Bd(e2), `abs(${Gd(t2, e2[0])})`;
      } }, Ld.floor = { getReturnType: function(t2) {
        return Ed;
      }, toGlsl: function(t2, e2) {
        return Xd(e2, 1), Bd(e2), `floor(${Gd(t2, e2[0])})`;
      } }, Ld.round = { getReturnType: function(t2) {
        return Ed;
      }, toGlsl: function(t2, e2) {
        return Xd(e2, 1), Bd(e2), `floor(${Gd(t2, e2[0])} + 0.5)`;
      } }, Ld.ceil = { getReturnType: function(t2) {
        return Ed;
      }, toGlsl: function(t2, e2) {
        return Xd(e2, 1), Bd(e2), `ceil(${Gd(t2, e2[0])})`;
      } }, Ld.sin = { getReturnType: function(t2) {
        return Ed;
      }, toGlsl: function(t2, e2) {
        return Xd(e2, 1), Bd(e2), `sin(${Gd(t2, e2[0])})`;
      } }, Ld.cos = { getReturnType: function(t2) {
        return Ed;
      }, toGlsl: function(t2, e2) {
        return Xd(e2, 1), Bd(e2), `cos(${Gd(t2, e2[0])})`;
      } }, Ld.atan = { getReturnType: function(t2) {
        return Ed;
      }, toGlsl: function(t2, e2) {
        return Vd(e2, 1), Wd(e2, 2), Bd(e2), 2 === e2.length ? `atan(${Gd(t2, e2[0])}, ${Gd(t2, e2[1])})` : `atan(${Gd(t2, e2[0])})`;
      } }, Ld[">"] = { getReturnType: function(t2) {
        return bd;
      }, toGlsl: function(t2, e2) {
        return Xd(e2, 2), Bd(e2), `(${Gd(t2, e2[0])} > ${Gd(t2, e2[1])})`;
      } }, Ld[">="] = { getReturnType: function(t2) {
        return bd;
      }, toGlsl: function(t2, e2) {
        return Xd(e2, 2), Bd(e2), `(${Gd(t2, e2[0])} >= ${Gd(t2, e2[1])})`;
      } }, Ld["<"] = { getReturnType: function(t2) {
        return bd;
      }, toGlsl: function(t2, e2) {
        return Xd(e2, 2), Bd(e2), `(${Gd(t2, e2[0])} < ${Gd(t2, e2[1])})`;
      } }, Ld["<="] = { getReturnType: function(t2) {
        return bd;
      }, toGlsl: function(t2, e2) {
        return Xd(e2, 2), Bd(e2), `(${Gd(t2, e2[0])} <= ${Gd(t2, e2[1])})`;
      } }, Ld["=="] = $d("=="), Ld["!="] = $d("!="), Ld["!"] = { getReturnType: function(t2) {
        return bd;
      }, toGlsl: function(t2, e2) {
        return Xd(e2, 1), zd(e2[0]), `(!${Gd(t2, e2[0])})`;
      } }, Ld.all = Jd("&&"), Ld.any = Jd("||"), Ld.between = { getReturnType: function(t2) {
        return bd;
      }, toGlsl: function(t2, e2) {
        Xd(e2, 3), Bd(e2);
        const i2 = Gd(t2, e2[1]), n2 = Gd(t2, e2[2]), r2 = Gd(t2, e2[0]);
        return `(${r2} >= ${i2} && ${r2} <= ${n2})`;
      } }, Ld.array = { getReturnType: function(t2) {
        return Rd;
      }, toGlsl: function(t2, e2) {
        Vd(e2, 2), Wd(e2, 4), Bd(e2);
        const i2 = e2.map(function(e3) {
          return Gd(t2, e3, Ed);
        });
        return `vec${e2.length}(${i2.join(", ")})`;
      } }, Ld.color = { getReturnType: function(t2) {
        return Cd;
      }, toGlsl: function(t2, e2) {
        Vd(e2, 3), Wd(e2, 4), Bd(e2);
        const i2 = e2;
        3 === e2.length && i2.push(1);
        const n2 = e2.map(function(e3, i3) {
          return Gd(t2, e3, Ed) + (i3 < 3 ? " / 255.0" : "");
        });
        return `vec${e2.length}(${n2.join(", ")})`;
      } }, Ld.interpolate = { getReturnType: function(t2) {
        let e2 = Cd | Ed;
        for (let i2 = 3; i2 < t2.length; i2 += 2)
          e2 &= Md(t2[i2]);
        return e2;
      }, toGlsl: function(t2, e2, i2) {
        Zd(e2), Vd(e2, 6);
        const n2 = e2[0];
        let r2;
        switch (n2[0]) {
          case "linear":
            r2 = 1;
            break;
          case "exponential":
            r2 = n2[1];
            break;
          default:
            r2 = null;
        }
        if (!r2)
          throw new Error(`Invalid interpolation type for "interpolate" operator, received: ${JSON.stringify(n2)}`);
        i2 = void 0 !== i2 ? i2 : Pd;
        const s2 = Ld.interpolate.getReturnType(e2) & i2;
        Yd(e2, s2);
        const o2 = Gd(t2, e2[1]), a2 = Ad(r2);
        let l2 = "";
        for (let i3 = 2; i3 < e2.length - 2; i3 += 2) {
          const n3 = Gd(t2, e2[i3]), r3 = l2 || Gd(t2, e2[i3 + 1], s2), h2 = Gd(t2, e2[i3 + 2]);
          l2 = `mix(${r3}, ${Gd(t2, e2[i3 + 3], s2)}, pow(clamp((${o2} - ${n3}) / (${h2} - ${n3}), 0.0, 1.0), ${a2}))`;
        }
        return l2;
      } }, Ld.match = { getReturnType: function(t2) {
        let e2 = Pd;
        for (let i2 = 2; i2 < t2.length; i2 += 2)
          e2 &= Md(t2[i2]);
        return e2 &= Md(t2[t2.length - 1]), e2;
      }, toGlsl: function(t2, e2, i2) {
        Zd(e2), Vd(e2, 4), i2 = void 0 !== i2 ? i2 : Pd;
        const n2 = Ld.match.getReturnType(e2) & i2;
        Yd(e2, n2);
        const r2 = Gd(t2, e2[0]), s2 = Gd(t2, e2[e2.length - 1], n2);
        let o2 = null;
        for (let i3 = e2.length - 3; i3 >= 1; i3 -= 2) {
          o2 = `(${r2} == ${Gd(t2, e2[i3])} ? ${Gd(t2, e2[i3 + 1], n2)} : ${o2 || s2})`;
        }
        return o2;
      } }, Ld.case = { getReturnType: function(t2) {
        let e2 = Pd;
        for (let i2 = 1; i2 < t2.length; i2 += 2)
          e2 &= Md(t2[i2]);
        return e2 &= Md(t2[t2.length - 1]), e2;
      }, toGlsl: function(t2, e2, i2) {
        !function(t3) {
          if (t3.length % 2 == 0)
            throw new Error(`An odd amount of arguments was expected, got ${t3} instead`);
        }(e2), Vd(e2, 3), i2 = void 0 !== i2 ? i2 : Pd;
        const n2 = Ld.case.getReturnType(e2) & i2;
        Yd(e2, n2);
        for (let t3 = 0; t3 < e2.length - 1; t3 += 2)
          zd(e2[t3]);
        const r2 = Gd(t2, e2[e2.length - 1], n2);
        let s2 = null;
        for (let i3 = e2.length - 3; i3 >= 0; i3 -= 2) {
          s2 = `(${Gd(t2, e2[i3])} ? ${Gd(t2, e2[i3 + 1], n2)} : ${s2 || r2})`;
        }
        return s2;
      } };
      class Qd {
        constructor() {
          this.uniforms = [], this.attributes = [], this.varyings = [], this.sizeExpression = "vec2(1.0)", this.rotationExpression = "0.0", this.offsetExpression = "vec2(0.0)", this.colorExpression = "vec4(1.0)", this.texCoordExpression = "vec4(0.0, 0.0, 1.0, 1.0)", this.discardExpression = "false", this.rotateWithView = false;
        }
        addUniform(t2) {
          return this.uniforms.push(t2), this;
        }
        addAttribute(t2) {
          return this.attributes.push(t2), this;
        }
        addVarying(t2, e2, i2) {
          return this.varyings.push({ name: t2, type: e2, expression: i2 }), this;
        }
        setSizeExpression(t2) {
          return this.sizeExpression = t2, this;
        }
        setRotationExpression(t2) {
          return this.rotationExpression = t2, this;
        }
        setSymbolOffsetExpression(t2) {
          return this.offsetExpression = t2, this;
        }
        setColorExpression(t2) {
          return this.colorExpression = t2, this;
        }
        setTextureCoordinateExpression(t2) {
          return this.texCoordExpression = t2, this;
        }
        setFragmentDiscardExpression(t2) {
          return this.discardExpression = t2, this;
        }
        setSymbolRotateWithView(t2) {
          return this.rotateWithView = t2, this;
        }
        getSizeExpression() {
          return this.sizeExpression;
        }
        getOffsetExpression() {
          return this.offsetExpression;
        }
        getColorExpression() {
          return this.colorExpression;
        }
        getTextureCoordinateExpression() {
          return this.texCoordExpression;
        }
        getFragmentDiscardExpression() {
          return this.discardExpression;
        }
        getSymbolVertexShader(t2) {
          const e2 = this.rotateWithView ? "u_offsetScaleMatrix * u_offsetRotateMatrix" : "u_offsetScaleMatrix";
          let i2 = this.attributes, n2 = this.varyings;
          return t2 && (i2 = i2.concat("vec4 a_hitColor"), n2 = n2.concat({ name: "v_hitColor", type: "vec4", expression: "a_hitColor" })), `precision mediump float;
uniform mat4 u_projectionMatrix;
uniform mat4 u_offsetScaleMatrix;
uniform mat4 u_offsetRotateMatrix;
uniform float u_time;
uniform float u_zoom;
uniform float u_resolution;
${this.uniforms.map(function(t3) {
            return "uniform " + t3 + ";";
          }).join("\n")}
attribute vec2 a_position;
attribute float a_index;
${i2.map(function(t3) {
            return "attribute " + t3 + ";";
          }).join("\n")}
varying vec2 v_texCoord;
varying vec2 v_quadCoord;
${n2.map(function(t3) {
            return "varying " + t3.type + " " + t3.name + ";";
          }).join("\n")}
void main(void) {
  mat4 offsetMatrix = ${e2};
  vec2 halfSize = ${this.sizeExpression} * 0.5;
  vec2 offset = ${this.offsetExpression};
  float angle = ${this.rotationExpression};
  float offsetX;
  float offsetY;
  if (a_index == 0.0) {
    offsetX = (offset.x - halfSize.x) * cos(angle) + (offset.y - halfSize.y) * sin(angle);
    offsetY = (offset.y - halfSize.y) * cos(angle) - (offset.x - halfSize.x) * sin(angle);
  } else if (a_index == 1.0) {
    offsetX = (offset.x + halfSize.x) * cos(angle) + (offset.y - halfSize.y) * sin(angle);
    offsetY = (offset.y - halfSize.y) * cos(angle) - (offset.x + halfSize.x) * sin(angle);
  } else if (a_index == 2.0) {
    offsetX = (offset.x + halfSize.x) * cos(angle) + (offset.y + halfSize.y) * sin(angle);
    offsetY = (offset.y + halfSize.y) * cos(angle) - (offset.x + halfSize.x) * sin(angle);
  } else {
    offsetX = (offset.x - halfSize.x) * cos(angle) + (offset.y + halfSize.y) * sin(angle);
    offsetY = (offset.y + halfSize.y) * cos(angle) - (offset.x - halfSize.x) * sin(angle);
  }
  vec4 offsets = offsetMatrix * vec4(offsetX, offsetY, 0.0, 0.0);
  gl_Position = u_projectionMatrix * vec4(a_position, 0.0, 1.0) + offsets;
  vec4 texCoord = ${this.texCoordExpression};
  float u = a_index == 0.0 || a_index == 3.0 ? texCoord.s : texCoord.p;
  float v = a_index == 2.0 || a_index == 3.0 ? texCoord.t : texCoord.q;
  v_texCoord = vec2(u, v);
  u = a_index == 0.0 || a_index == 3.0 ? 0.0 : 1.0;
  v = a_index == 2.0 || a_index == 3.0 ? 0.0 : 1.0;
  v_quadCoord = vec2(u, v);
${n2.map(function(t3) {
            return "  " + t3.name + " = " + t3.expression + ";";
          }).join("\n")}
}`;
        }
        getSymbolFragmentShader(t2) {
          const e2 = t2 ? "  if (gl_FragColor.a < 0.1) { discard; } gl_FragColor = v_hitColor;" : "";
          let i2 = this.varyings;
          return t2 && (i2 = i2.concat({ name: "v_hitColor", type: "vec4", expression: "a_hitColor" })), `precision mediump float;
uniform float u_time;
uniform float u_zoom;
uniform float u_resolution;
${this.uniforms.map(function(t3) {
            return "uniform " + t3 + ";";
          }).join("\n")}
varying vec2 v_texCoord;
varying vec2 v_quadCoord;
${i2.map(function(t3) {
            return "varying " + t3.type + " " + t3.name + ";";
          }).join("\n")}
void main(void) {
  if (${this.discardExpression}) { discard; }
  gl_FragColor = ${this.colorExpression};
  gl_FragColor.rgb *= gl_FragColor.a;
${e2}
}`;
        }
      }
      function tg(t2) {
        const e2 = t2.symbol, i2 = void 0 !== e2.size ? e2.size : 1, n2 = e2.color || "white", r2 = e2.textureCoord || [0, 0, 1, 1], s2 = e2.offset || [0, 0], o2 = void 0 !== e2.opacity ? e2.opacity : 1, a2 = void 0 !== e2.rotation ? e2.rotation : 0, l2 = { inFragmentShader: false, variables: [], attributes: [], stringLiteralsMap: {}, functions: {} }, h2 = Gd(l2, i2, Rd | Ed), c2 = Gd(l2, s2, Rd), u2 = Gd(l2, r2, Rd), d2 = Gd(l2, a2, Ed), g2 = { inFragmentShader: true, variables: l2.variables, attributes: [], stringLiteralsMap: l2.stringLiteralsMap, functions: {} }, f2 = Gd(g2, n2, Cd), p2 = Gd(g2, o2, Ed);
        let m2 = "1.0";
        const _2 = `vec2(${Gd(g2, i2, Rd | Ed)}).x`;
        switch (e2.symbolType) {
          case "square":
          case "image":
            break;
          case "circle":
            m2 = `(1.0-smoothstep(1.-4./${_2},1.,dot(v_quadCoord-.5,v_quadCoord-.5)*4.))`;
            break;
          case "triangle":
            const t3 = "(v_quadCoord*2.-1.)", i3 = `(atan(${t3}.x,${t3}.y))`;
            m2 = `(1.0-smoothstep(.5-3./${_2},.5,cos(floor(.5+${i3}/2.094395102)*2.094395102-${i3})*length(${t3})))`;
            break;
          default:
            throw new Error("Unexpected symbol type: " + e2.symbolType);
        }
        const y2 = new Qd().setSizeExpression(`vec2(${h2})`).setRotationExpression(d2).setSymbolOffsetExpression(c2).setTextureCoordinateExpression(u2).setSymbolRotateWithView(!!e2.rotateWithView).setColorExpression(`vec4(${f2}.rgb, ${f2}.a * ${p2} * ${m2})`);
        if (t2.filter) {
          const e3 = Gd(g2, t2.filter, bd);
          y2.setFragmentDiscardExpression(`!${e3}`);
        }
        const x2 = {};
        if (g2.variables.forEach(function(e3) {
          const i3 = Kd(e3);
          y2.addUniform(`float ${i3}`), x2[i3] = function() {
            if (!t2.variables || void 0 === t2.variables[e3])
              throw new Error(`The following variable is missing from the style: ${e3}`);
            let i4 = t2.variables[e3];
            return "string" == typeof i4 && (i4 = Dd(l2, i4)), void 0 !== i4 ? i4 : -9999999;
          };
        }), "image" === e2.symbolType && e2.src) {
          const t3 = new Image();
          t3.crossOrigin = void 0 === e2.crossOrigin ? "anonymous" : e2.crossOrigin, t3.src = e2.src, y2.addUniform("sampler2D u_texture").setColorExpression(y2.getColorExpression() + " * texture2D(u_texture, v_texCoord)"), x2.u_texture = t3;
        }
        return g2.attributes.forEach(function(t3) {
          l2.attributes.includes(t3) || l2.attributes.push(t3), y2.addVarying(`v_${t3}`, "float", `a_${t3}`);
        }), l2.attributes.forEach(function(t3) {
          y2.addAttribute(`float a_${t3}`);
        }), { builder: y2, attributes: l2.attributes.map(function(t3) {
          return { name: t3, callback: function(e3, i3) {
            let n3 = i3[t3];
            return "string" == typeof n3 && (n3 = Dd(l2, n3)), void 0 !== n3 ? n3 : -9999999;
          } };
        }), uniforms: x2 };
      }
      class eg {
        constructor(t2) {
          this.opacity_ = t2.opacity, this.rotateWithView_ = t2.rotateWithView, this.rotation_ = t2.rotation, this.scale_ = t2.scale, this.scaleArray_ = Va(t2.scale), this.displacement_ = t2.displacement, this.declutterMode_ = t2.declutterMode;
        }
        clone() {
          const t2 = this.getScale();
          return new eg({ opacity: this.getOpacity(), scale: Array.isArray(t2) ? t2.slice() : t2, rotation: this.getRotation(), rotateWithView: this.getRotateWithView(), displacement: this.getDisplacement().slice(), declutterMode: this.getDeclutterMode() });
        }
        getOpacity() {
          return this.opacity_;
        }
        getRotateWithView() {
          return this.rotateWithView_;
        }
        getRotation() {
          return this.rotation_;
        }
        getScale() {
          return this.scale_;
        }
        getScaleArray() {
          return this.scaleArray_;
        }
        getDisplacement() {
          return this.displacement_;
        }
        getDeclutterMode() {
          return this.declutterMode_;
        }
        getAnchor() {
          return B();
        }
        getImage(t2) {
          return B();
        }
        getHitDetectionImage() {
          return B();
        }
        getPixelRatio(t2) {
          return 1;
        }
        getImageState() {
          return B();
        }
        getImageSize() {
          return B();
        }
        getOrigin() {
          return B();
        }
        getSize() {
          return B();
        }
        setDisplacement(t2) {
          this.displacement_ = t2;
        }
        setOpacity(t2) {
          this.opacity_ = t2;
        }
        setRotateWithView(t2) {
          this.rotateWithView_ = t2;
        }
        setRotation(t2) {
          this.rotation_ = t2;
        }
        setScale(t2) {
          this.scale_ = t2, this.scaleArray_ = Va(t2);
        }
        listenImageChange(t2) {
          B();
        }
        load() {
          B();
        }
        unlistenImageChange(t2) {
          B();
        }
      }
      class ig extends eg {
        constructor(t2) {
          super({ opacity: 1, rotateWithView: void 0 !== t2.rotateWithView && t2.rotateWithView, rotation: void 0 !== t2.rotation ? t2.rotation : 0, scale: void 0 !== t2.scale ? t2.scale : 1, displacement: void 0 !== t2.displacement ? t2.displacement : [0, 0], declutterMode: t2.declutterMode }), this.canvas_ = void 0, this.hitDetectionCanvas_ = null, this.fill_ = void 0 !== t2.fill ? t2.fill : null, this.origin_ = [0, 0], this.points_ = t2.points, this.radius_ = void 0 !== t2.radius ? t2.radius : t2.radius1, this.radius2_ = t2.radius2, this.angle_ = void 0 !== t2.angle ? t2.angle : 0, this.stroke_ = void 0 !== t2.stroke ? t2.stroke : null, this.size_ = null, this.renderOptions_ = null, this.render();
        }
        clone() {
          const t2 = this.getScale(), e2 = new ig({ fill: this.getFill() ? this.getFill().clone() : void 0, points: this.getPoints(), radius: this.getRadius(), radius2: this.getRadius2(), angle: this.getAngle(), stroke: this.getStroke() ? this.getStroke().clone() : void 0, rotation: this.getRotation(), rotateWithView: this.getRotateWithView(), scale: Array.isArray(t2) ? t2.slice() : t2, displacement: this.getDisplacement().slice(), declutterMode: this.getDeclutterMode() });
          return e2.setOpacity(this.getOpacity()), e2;
        }
        getAnchor() {
          const t2 = this.size_;
          if (!t2)
            return null;
          const e2 = this.getDisplacement(), i2 = this.getScaleArray();
          return [t2[0] / 2 - e2[0] / i2[0], t2[1] / 2 + e2[1] / i2[1]];
        }
        getAngle() {
          return this.angle_;
        }
        getFill() {
          return this.fill_;
        }
        setFill(t2) {
          this.fill_ = t2, this.render();
        }
        getHitDetectionImage() {
          return this.hitDetectionCanvas_ || this.createHitDetectionCanvas_(this.renderOptions_), this.hitDetectionCanvas_;
        }
        getImage(t2) {
          let e2 = this.canvas_[t2];
          if (!e2) {
            const i2 = this.renderOptions_, n2 = Dr(i2.size * t2, i2.size * t2);
            this.draw_(i2, n2, t2), e2 = n2.canvas, this.canvas_[t2] = e2;
          }
          return e2;
        }
        getPixelRatio(t2) {
          return t2;
        }
        getImageSize() {
          return this.size_;
        }
        getImageState() {
          return Lr;
        }
        getOrigin() {
          return this.origin_;
        }
        getPoints() {
          return this.points_;
        }
        getRadius() {
          return this.radius_;
        }
        getRadius2() {
          return this.radius2_;
        }
        getSize() {
          return this.size_;
        }
        getStroke() {
          return this.stroke_;
        }
        setStroke(t2) {
          this.stroke_ = t2, this.render();
        }
        listenImageChange(t2) {
        }
        load() {
        }
        unlistenImageChange(t2) {
        }
        calculateLineJoinSize_(t2, e2, i2) {
          if (0 === e2 || this.points_ === 1 / 0 || "bevel" !== t2 && "miter" !== t2)
            return e2;
          let n2 = this.radius_, r2 = void 0 === this.radius2_ ? n2 : this.radius2_;
          if (n2 < r2) {
            const t3 = n2;
            n2 = r2, r2 = t3;
          }
          const s2 = void 0 === this.radius2_ ? this.points_ : 2 * this.points_, o2 = 2 * Math.PI / s2, a2 = r2 * Math.sin(o2), l2 = n2 - Math.sqrt(r2 * r2 - a2 * a2), h2 = Math.sqrt(a2 * a2 + l2 * l2), c2 = h2 / a2;
          if ("miter" === t2 && c2 <= i2)
            return c2 * e2;
          const u2 = e2 / 2 / c2, d2 = e2 / 2 * (l2 / h2), g2 = Math.sqrt((n2 + u2) * (n2 + u2) + d2 * d2) - n2;
          if (void 0 === this.radius2_ || "bevel" === t2)
            return 2 * g2;
          const f2 = n2 * Math.sin(o2), p2 = r2 - Math.sqrt(n2 * n2 - f2 * f2), m2 = Math.sqrt(f2 * f2 + p2 * p2) / f2;
          if (m2 <= i2) {
            const t3 = m2 * e2 / 2 - r2 - n2;
            return 2 * Math.max(g2, t3);
          }
          return 2 * g2;
        }
        createRenderOptions() {
          let t2, e2 = Gs, i2 = 0, n2 = null, r2 = 0, s2 = 0;
          this.stroke_ && (t2 = this.stroke_.getColor(), null === t2 && (t2 = Bs), t2 = fl(t2), s2 = this.stroke_.getWidth(), void 0 === s2 && (s2 = 1), n2 = this.stroke_.getLineDash(), r2 = this.stroke_.getLineDashOffset(), e2 = this.stroke_.getLineJoin(), void 0 === e2 && (e2 = Gs), i2 = this.stroke_.getMiterLimit(), void 0 === i2 && (i2 = js));
          const o2 = this.calculateLineJoinSize_(e2, s2, i2), a2 = Math.max(this.radius_, this.radius2_ || 0);
          return { strokeStyle: t2, strokeWidth: s2, size: Math.ceil(2 * a2 + o2), lineDash: n2, lineDashOffset: r2, lineJoin: e2, miterLimit: i2 };
        }
        render() {
          this.renderOptions_ = this.createRenderOptions();
          const t2 = this.renderOptions_.size;
          this.canvas_ = {}, this.size_ = [t2, t2];
        }
        draw_(t2, e2, i2) {
          if (e2.scale(i2, i2), e2.translate(t2.size / 2, t2.size / 2), this.createPath_(e2), this.fill_) {
            let t3 = this.fill_.getColor();
            null === t3 && (t3 = Ns), e2.fillStyle = fl(t3), e2.fill();
          }
          this.stroke_ && (e2.strokeStyle = t2.strokeStyle, e2.lineWidth = t2.strokeWidth, t2.lineDash && (e2.setLineDash(t2.lineDash), e2.lineDashOffset = t2.lineDashOffset), e2.lineJoin = t2.lineJoin, e2.miterLimit = t2.miterLimit, e2.stroke());
        }
        createHitDetectionCanvas_(t2) {
          if (this.fill_) {
            let e2 = this.fill_.getColor(), i2 = 0;
            if ("string" == typeof e2 && (e2 = $r(e2)), null === e2 ? i2 = 1 : Array.isArray(e2) && (i2 = 4 === e2.length ? e2[3] : 1), 0 === i2) {
              const e3 = Dr(t2.size, t2.size);
              this.hitDetectionCanvas_ = e3.canvas, this.drawHitDetectionCanvas_(t2, e3);
            }
          }
          this.hitDetectionCanvas_ || (this.hitDetectionCanvas_ = this.getImage(1));
        }
        createPath_(t2) {
          let e2 = this.points_;
          const i2 = this.radius_;
          if (e2 === 1 / 0)
            t2.arc(0, 0, i2, 0, 2 * Math.PI);
          else {
            const n2 = void 0 === this.radius2_ ? i2 : this.radius2_;
            void 0 !== this.radius2_ && (e2 *= 2);
            const r2 = this.angle_ - Math.PI / 2, s2 = 2 * Math.PI / e2;
            for (let o2 = 0; o2 < e2; o2++) {
              const e3 = r2 + o2 * s2, a2 = o2 % 2 == 0 ? i2 : n2;
              t2.lineTo(a2 * Math.cos(e3), a2 * Math.sin(e3));
            }
            t2.closePath();
          }
        }
        drawHitDetectionCanvas_(t2, e2) {
          e2.translate(t2.size / 2, t2.size / 2), this.createPath_(e2), e2.fillStyle = Ns, e2.fill(), this.stroke_ && (e2.strokeStyle = t2.strokeStyle, e2.lineWidth = t2.strokeWidth, t2.lineDash && (e2.setLineDash(t2.lineDash), e2.lineDashOffset = t2.lineDashOffset), e2.lineJoin = t2.lineJoin, e2.miterLimit = t2.miterLimit, e2.stroke());
        }
      }
      class ng extends ig {
        constructor(t2) {
          super({ points: 1 / 0, fill: (t2 = t2 || { radius: 5 }).fill, radius: t2.radius, stroke: t2.stroke, scale: void 0 !== t2.scale ? t2.scale : 1, rotation: void 0 !== t2.rotation ? t2.rotation : 0, rotateWithView: void 0 !== t2.rotateWithView && t2.rotateWithView, displacement: void 0 !== t2.displacement ? t2.displacement : [0, 0], declutterMode: t2.declutterMode });
        }
        clone() {
          const t2 = this.getScale(), e2 = new ng({ fill: this.getFill() ? this.getFill().clone() : void 0, stroke: this.getStroke() ? this.getStroke().clone() : void 0, radius: this.getRadius(), scale: Array.isArray(t2) ? t2.slice() : t2, rotation: this.getRotation(), rotateWithView: this.getRotateWithView(), displacement: this.getDisplacement().slice(), declutterMode: this.getDeclutterMode() });
          return e2.setOpacity(this.getOpacity()), e2;
        }
        setRadius(t2) {
          this.radius_ = t2, this.render();
        }
      }
      class rg {
        constructor(t2) {
          t2 = t2 || {}, this.color_ = void 0 !== t2.color ? t2.color : null;
        }
        clone() {
          const t2 = this.getColor();
          return new rg({ color: Array.isArray(t2) ? t2.slice() : t2 || void 0 });
        }
        getColor() {
          return this.color_;
        }
        setColor(t2) {
          this.color_ = t2;
        }
      }
      let sg = null;
      class og extends v {
        constructor(t2, e2, i2, n2, r2, s2) {
          super(), this.hitDetectionImage_ = null, this.image_ = t2, this.crossOrigin_ = n2, this.canvas_ = {}, this.color_ = s2, this.unlisten_ = null, this.imageState_ = r2, this.size_ = i2, this.src_ = e2, this.tainted_;
        }
        initializeImage_() {
          this.image_ = new Image(), null !== this.crossOrigin_ && (this.image_.crossOrigin = this.crossOrigin_);
        }
        isTainted_() {
          if (void 0 === this.tainted_ && this.imageState_ === Lr) {
            sg || (sg = Dr(1, 1)), sg.drawImage(this.image_, 0, 0);
            try {
              sg.getImageData(0, 0, 1, 1), this.tainted_ = false;
            } catch (t2) {
              sg = null, this.tainted_ = true;
            }
          }
          return true === this.tainted_;
        }
        dispatchChangeEvent_() {
          this.dispatchEvent(S);
        }
        handleImageError_() {
          this.imageState_ = Mr, this.unlistenImage_(), this.dispatchChangeEvent_();
        }
        handleImageLoad_() {
          this.imageState_ = Lr, this.size_ ? (this.image_.width = this.size_[0], this.image_.height = this.size_[1]) : this.size_ = [this.image_.width, this.image_.height], this.unlistenImage_(), this.dispatchChangeEvent_();
        }
        getImage(t2) {
          return this.image_ || this.initializeImage_(), this.replaceColor_(t2), this.canvas_[t2] ? this.canvas_[t2] : this.image_;
        }
        getPixelRatio(t2) {
          return this.replaceColor_(t2), this.canvas_[t2] ? t2 : 1;
        }
        getImageState() {
          return this.imageState_;
        }
        getHitDetectionImage() {
          if (this.image_ || this.initializeImage_(), !this.hitDetectionImage_)
            if (this.isTainted_()) {
              const t2 = this.size_[0], e2 = this.size_[1], i2 = Dr(t2, e2);
              i2.fillRect(0, 0, t2, e2), this.hitDetectionImage_ = i2.canvas;
            } else
              this.hitDetectionImage_ = this.image_;
          return this.hitDetectionImage_;
        }
        getSize() {
          return this.size_;
        }
        getSrc() {
          return this.src_;
        }
        load() {
          if (this.imageState_ === Pr) {
            this.image_ || this.initializeImage_(), this.imageState_ = Ir;
            try {
              this.image_.src = this.src_;
            } catch (t2) {
              this.handleImageError_();
            }
            this.unlisten_ = Or(this.image_, this.handleImageLoad_.bind(this), this.handleImageError_.bind(this));
          }
        }
        replaceColor_(t2) {
          if (!this.color_ || this.canvas_[t2] || this.imageState_ !== Lr)
            return;
          const e2 = this.image_, i2 = document.createElement("canvas");
          i2.width = Math.ceil(e2.width * t2), i2.height = Math.ceil(e2.height * t2);
          const n2 = i2.getContext("2d");
          n2.scale(t2, t2), n2.drawImage(e2, 0, 0), n2.globalCompositeOperation = "multiply", n2.fillStyle = Kr(this.color_), n2.fillRect(0, 0, i2.width / t2, i2.height / t2), n2.globalCompositeOperation = "destination-in", n2.drawImage(e2, 0, 0), this.canvas_[t2] = i2;
        }
        unlistenImage_() {
          this.unlisten_ && (this.unlisten_(), this.unlisten_ = null);
        }
      }
      function ag(t2, e2, i2, n2, r2, s2) {
        let o2 = ns.get(e2, n2, s2);
        return o2 || (o2 = new og(t2, e2, i2, n2, r2, s2), ns.set(e2, n2, s2, o2)), o2;
      }
      class lg extends eg {
        constructor(t2) {
          const e2 = void 0 !== (t2 = t2 || {}).opacity ? t2.opacity : 1, i2 = void 0 !== t2.rotation ? t2.rotation : 0, n2 = void 0 !== t2.scale ? t2.scale : 1, r2 = void 0 !== t2.rotateWithView && t2.rotateWithView;
          super({ opacity: e2, rotation: i2, scale: n2, displacement: void 0 !== t2.displacement ? t2.displacement : [0, 0], rotateWithView: r2, declutterMode: t2.declutterMode }), this.anchor_ = void 0 !== t2.anchor ? t2.anchor : [0.5, 0.5], this.normalizedAnchor_ = null, this.anchorOrigin_ = void 0 !== t2.anchorOrigin ? t2.anchorOrigin : "top-left", this.anchorXUnits_ = void 0 !== t2.anchorXUnits ? t2.anchorXUnits : "fraction", this.anchorYUnits_ = void 0 !== t2.anchorYUnits ? t2.anchorYUnits : "fraction", this.crossOrigin_ = void 0 !== t2.crossOrigin ? t2.crossOrigin : null;
          const s2 = void 0 !== t2.img ? t2.img : null;
          this.imgSize_ = t2.imgSize;
          let o2 = t2.src;
          at(!(void 0 !== o2 && s2), 4), at(!s2 || s2 && this.imgSize_, 5), void 0 !== o2 && 0 !== o2.length || !s2 || (o2 = s2.src || z(s2)), at(void 0 !== o2 && o2.length > 0, 6);
          const a2 = void 0 !== t2.src ? Pr : Lr;
          this.color_ = void 0 !== t2.color ? $r(t2.color) : null, this.iconImage_ = ag(s2, o2, void 0 !== this.imgSize_ ? this.imgSize_ : null, this.crossOrigin_, a2, this.color_), this.offset_ = void 0 !== t2.offset ? t2.offset : [0, 0], this.offsetOrigin_ = void 0 !== t2.offsetOrigin ? t2.offsetOrigin : "top-left", this.origin_ = null, this.size_ = void 0 !== t2.size ? t2.size : null;
        }
        clone() {
          const t2 = this.getScale();
          return new lg({ anchor: this.anchor_.slice(), anchorOrigin: this.anchorOrigin_, anchorXUnits: this.anchorXUnits_, anchorYUnits: this.anchorYUnits_, color: this.color_ && this.color_.slice ? this.color_.slice() : this.color_ || void 0, crossOrigin: this.crossOrigin_, imgSize: this.imgSize_, offset: this.offset_.slice(), offsetOrigin: this.offsetOrigin_, opacity: this.getOpacity(), rotateWithView: this.getRotateWithView(), rotation: this.getRotation(), scale: Array.isArray(t2) ? t2.slice() : t2, size: null !== this.size_ ? this.size_.slice() : void 0, src: this.getSrc(), displacement: this.getDisplacement().slice(), declutterMode: this.getDeclutterMode() });
        }
        getAnchor() {
          let t2 = this.normalizedAnchor_;
          if (!t2) {
            t2 = this.anchor_;
            const e3 = this.getSize();
            if ("fraction" == this.anchorXUnits_ || "fraction" == this.anchorYUnits_) {
              if (!e3)
                return null;
              t2 = this.anchor_.slice(), "fraction" == this.anchorXUnits_ && (t2[0] *= e3[0]), "fraction" == this.anchorYUnits_ && (t2[1] *= e3[1]);
            }
            if ("top-left" != this.anchorOrigin_) {
              if (!e3)
                return null;
              t2 === this.anchor_ && (t2 = this.anchor_.slice()), "top-right" != this.anchorOrigin_ && "bottom-right" != this.anchorOrigin_ || (t2[0] = -t2[0] + e3[0]), "bottom-left" != this.anchorOrigin_ && "bottom-right" != this.anchorOrigin_ || (t2[1] = -t2[1] + e3[1]);
            }
            this.normalizedAnchor_ = t2;
          }
          const e2 = this.getDisplacement(), i2 = this.getScaleArray();
          return [t2[0] - e2[0] / i2[0], t2[1] + e2[1] / i2[1]];
        }
        setAnchor(t2) {
          this.anchor_ = t2, this.normalizedAnchor_ = null;
        }
        getColor() {
          return this.color_;
        }
        getImage(t2) {
          return this.iconImage_.getImage(t2);
        }
        getPixelRatio(t2) {
          return this.iconImage_.getPixelRatio(t2);
        }
        getImageSize() {
          return this.iconImage_.getSize();
        }
        getImageState() {
          return this.iconImage_.getImageState();
        }
        getHitDetectionImage() {
          return this.iconImage_.getHitDetectionImage();
        }
        getOrigin() {
          if (this.origin_)
            return this.origin_;
          let t2 = this.offset_;
          if ("top-left" != this.offsetOrigin_) {
            const e2 = this.getSize(), i2 = this.iconImage_.getSize();
            if (!e2 || !i2)
              return null;
            t2 = t2.slice(), "top-right" != this.offsetOrigin_ && "bottom-right" != this.offsetOrigin_ || (t2[0] = i2[0] - e2[0] - t2[0]), "bottom-left" != this.offsetOrigin_ && "bottom-right" != this.offsetOrigin_ || (t2[1] = i2[1] - e2[1] - t2[1]);
          }
          return this.origin_ = t2, this.origin_;
        }
        getSrc() {
          return this.iconImage_.getSrc();
        }
        getSize() {
          return this.size_ ? this.size_ : this.iconImage_.getSize();
        }
        listenImageChange(t2) {
          this.iconImage_.addEventListener(S, t2);
        }
        load() {
          this.iconImage_.load();
        }
        unlistenImageChange(t2) {
          this.iconImage_.removeEventListener(S, t2);
        }
      }
      class hg {
        constructor(t2) {
          t2 = t2 || {}, this.color_ = void 0 !== t2.color ? t2.color : null, this.lineCap_ = t2.lineCap, this.lineDash_ = void 0 !== t2.lineDash ? t2.lineDash : null, this.lineDashOffset_ = t2.lineDashOffset, this.lineJoin_ = t2.lineJoin, this.miterLimit_ = t2.miterLimit, this.width_ = t2.width;
        }
        clone() {
          const t2 = this.getColor();
          return new hg({ color: Array.isArray(t2) ? t2.slice() : t2 || void 0, lineCap: this.getLineCap(), lineDash: this.getLineDash() ? this.getLineDash().slice() : void 0, lineDashOffset: this.getLineDashOffset(), lineJoin: this.getLineJoin(), miterLimit: this.getMiterLimit(), width: this.getWidth() });
        }
        getColor() {
          return this.color_;
        }
        getLineCap() {
          return this.lineCap_;
        }
        getLineDash() {
          return this.lineDash_;
        }
        getLineDashOffset() {
          return this.lineDashOffset_;
        }
        getLineJoin() {
          return this.lineJoin_;
        }
        getMiterLimit() {
          return this.miterLimit_;
        }
        getWidth() {
          return this.width_;
        }
        setColor(t2) {
          this.color_ = t2;
        }
        setLineCap(t2) {
          this.lineCap_ = t2;
        }
        setLineDash(t2) {
          this.lineDash_ = t2;
        }
        setLineDashOffset(t2) {
          this.lineDashOffset_ = t2;
        }
        setLineJoin(t2) {
          this.lineJoin_ = t2;
        }
        setMiterLimit(t2) {
          this.miterLimit_ = t2;
        }
        setWidth(t2) {
          this.width_ = t2;
        }
      }
      class cg {
        constructor(t2) {
          t2 = t2 || {}, this.geometry_ = null, this.geometryFunction_ = pg, void 0 !== t2.geometry && this.setGeometry(t2.geometry), this.fill_ = void 0 !== t2.fill ? t2.fill : null, this.image_ = void 0 !== t2.image ? t2.image : null, this.renderer_ = void 0 !== t2.renderer ? t2.renderer : null, this.hitDetectionRenderer_ = void 0 !== t2.hitDetectionRenderer ? t2.hitDetectionRenderer : null, this.stroke_ = void 0 !== t2.stroke ? t2.stroke : null, this.text_ = void 0 !== t2.text ? t2.text : null, this.zIndex_ = t2.zIndex;
        }
        clone() {
          let t2 = this.getGeometry();
          return t2 && "object" == typeof t2 && (t2 = t2.clone()), new cg({ geometry: t2, fill: this.getFill() ? this.getFill().clone() : void 0, image: this.getImage() ? this.getImage().clone() : void 0, renderer: this.getRenderer(), stroke: this.getStroke() ? this.getStroke().clone() : void 0, text: this.getText() ? this.getText().clone() : void 0, zIndex: this.getZIndex() });
        }
        getRenderer() {
          return this.renderer_;
        }
        setRenderer(t2) {
          this.renderer_ = t2;
        }
        setHitDetectionRenderer(t2) {
          this.hitDetectionRenderer_ = t2;
        }
        getHitDetectionRenderer() {
          return this.hitDetectionRenderer_;
        }
        getGeometry() {
          return this.geometry_;
        }
        getGeometryFunction() {
          return this.geometryFunction_;
        }
        getFill() {
          return this.fill_;
        }
        setFill(t2) {
          this.fill_ = t2;
        }
        getImage() {
          return this.image_;
        }
        setImage(t2) {
          this.image_ = t2;
        }
        getStroke() {
          return this.stroke_;
        }
        setStroke(t2) {
          this.stroke_ = t2;
        }
        getText() {
          return this.text_;
        }
        setText(t2) {
          this.text_ = t2;
        }
        getZIndex() {
          return this.zIndex_;
        }
        setGeometry(t2) {
          "function" == typeof t2 ? this.geometryFunction_ = t2 : "string" == typeof t2 ? this.geometryFunction_ = function(e2) {
            return e2.get(t2);
          } : t2 ? void 0 !== t2 && (this.geometryFunction_ = function() {
            return t2;
          }) : this.geometryFunction_ = pg, this.geometry_ = t2;
        }
        setZIndex(t2) {
          this.zIndex_ = t2;
        }
      }
      function ug(t2) {
        let e2;
        if ("function" == typeof t2)
          e2 = t2;
        else {
          let i2;
          if (Array.isArray(t2))
            i2 = t2;
          else {
            at("function" == typeof t2.getZIndex, 41);
            i2 = [t2];
          }
          e2 = function() {
            return i2;
          };
        }
        return e2;
      }
      let dg = null;
      function gg(t2, e2) {
        if (!dg) {
          const t3 = new rg({ color: "rgba(255,255,255,0.4)" }), e3 = new hg({ color: "#3399CC", width: 1.25 });
          dg = [new cg({ image: new ng({ fill: t3, stroke: e3, radius: 5 }), fill: t3, stroke: e3 })];
        }
        return dg;
      }
      function fg() {
        const t2 = {}, e2 = [255, 255, 255, 1], i2 = [0, 153, 255, 1];
        return t2.Polygon = [new cg({ fill: new rg({ color: [255, 255, 255, 0.5] }) })], t2.MultiPolygon = t2.Polygon, t2.LineString = [new cg({ stroke: new hg({ color: e2, width: 5 }) }), new cg({ stroke: new hg({ color: i2, width: 3 }) })], t2.MultiLineString = t2.LineString, t2.Circle = t2.Polygon.concat(t2.LineString), t2.Point = [new cg({ image: new ng({ radius: 6, fill: new rg({ color: i2 }), stroke: new hg({ color: e2, width: 1.5 }) }), zIndex: 1 / 0 })], t2.MultiPoint = t2.Point, t2.GeometryCollection = t2.Polygon.concat(t2.LineString, t2.Point), t2;
      }
      function pg(t2) {
        return t2.getGeometry();
      }
      class mg {
        constructor(t2) {
          t2 = t2 || {}, this.font_ = t2.font, this.rotation_ = t2.rotation, this.rotateWithView_ = t2.rotateWithView, this.scale_ = t2.scale, this.scaleArray_ = Va(void 0 !== t2.scale ? t2.scale : 1), this.text_ = t2.text, this.textAlign_ = t2.textAlign, this.justify_ = t2.justify, this.textBaseline_ = t2.textBaseline, this.fill_ = void 0 !== t2.fill ? t2.fill : new rg({ color: "#333" }), this.maxAngle_ = void 0 !== t2.maxAngle ? t2.maxAngle : Math.PI / 4, this.placement_ = void 0 !== t2.placement ? t2.placement : "point", this.overflow_ = !!t2.overflow, this.stroke_ = void 0 !== t2.stroke ? t2.stroke : null, this.offsetX_ = void 0 !== t2.offsetX ? t2.offsetX : 0, this.offsetY_ = void 0 !== t2.offsetY ? t2.offsetY : 0, this.backgroundFill_ = t2.backgroundFill ? t2.backgroundFill : null, this.backgroundStroke_ = t2.backgroundStroke ? t2.backgroundStroke : null, this.padding_ = void 0 === t2.padding ? null : t2.padding;
        }
        clone() {
          const t2 = this.getScale();
          return new mg({ font: this.getFont(), placement: this.getPlacement(), maxAngle: this.getMaxAngle(), overflow: this.getOverflow(), rotation: this.getRotation(), rotateWithView: this.getRotateWithView(), scale: Array.isArray(t2) ? t2.slice() : t2, text: this.getText(), textAlign: this.getTextAlign(), justify: this.getJustify(), textBaseline: this.getTextBaseline(), fill: this.getFill() ? this.getFill().clone() : void 0, stroke: this.getStroke() ? this.getStroke().clone() : void 0, offsetX: this.getOffsetX(), offsetY: this.getOffsetY(), backgroundFill: this.getBackgroundFill() ? this.getBackgroundFill().clone() : void 0, backgroundStroke: this.getBackgroundStroke() ? this.getBackgroundStroke().clone() : void 0, padding: this.getPadding() || void 0 });
        }
        getOverflow() {
          return this.overflow_;
        }
        getFont() {
          return this.font_;
        }
        getMaxAngle() {
          return this.maxAngle_;
        }
        getPlacement() {
          return this.placement_;
        }
        getOffsetX() {
          return this.offsetX_;
        }
        getOffsetY() {
          return this.offsetY_;
        }
        getFill() {
          return this.fill_;
        }
        getRotateWithView() {
          return this.rotateWithView_;
        }
        getRotation() {
          return this.rotation_;
        }
        getScale() {
          return this.scale_;
        }
        getScaleArray() {
          return this.scaleArray_;
        }
        getStroke() {
          return this.stroke_;
        }
        getText() {
          return this.text_;
        }
        getTextAlign() {
          return this.textAlign_;
        }
        getJustify() {
          return this.justify_;
        }
        getTextBaseline() {
          return this.textBaseline_;
        }
        getBackgroundFill() {
          return this.backgroundFill_;
        }
        getBackgroundStroke() {
          return this.backgroundStroke_;
        }
        getPadding() {
          return this.padding_;
        }
        setOverflow(t2) {
          this.overflow_ = t2;
        }
        setFont(t2) {
          this.font_ = t2;
        }
        setMaxAngle(t2) {
          this.maxAngle_ = t2;
        }
        setOffsetX(t2) {
          this.offsetX_ = t2;
        }
        setOffsetY(t2) {
          this.offsetY_ = t2;
        }
        setPlacement(t2) {
          this.placement_ = t2;
        }
        setRotateWithView(t2) {
          this.rotateWithView_ = t2;
        }
        setFill(t2) {
          this.fill_ = t2;
        }
        setRotation(t2) {
          this.rotation_ = t2;
        }
        setScale(t2) {
          this.scale_ = t2, this.scaleArray_ = Va(void 0 !== t2 ? t2 : 1);
        }
        setStroke(t2) {
          this.stroke_ = t2;
        }
        setText(t2) {
          this.text_ = t2;
        }
        setTextAlign(t2) {
          this.textAlign_ = t2;
        }
        setJustify(t2) {
          this.justify_ = t2;
        }
        setTextBaseline(t2) {
          this.textBaseline_ = t2;
        }
        setBackgroundFill(t2) {
          this.backgroundFill_ = t2;
        }
        setBackgroundStroke(t2) {
          this.backgroundStroke_ = t2;
        }
        setPadding(t2) {
          this.padding_ = t2;
        }
      }
      function _g(t2) {
        return new cg({ fill: yg(t2, ""), stroke: xg(t2, ""), text: vg(t2), image: Sg(t2) });
      }
      function yg(t2, e2) {
        const i2 = t2[e2 + "fill-color"];
        if (i2)
          return new rg({ color: i2 });
      }
      function xg(t2, e2) {
        const i2 = t2[e2 + "stroke-width"], n2 = t2[e2 + "stroke-color"];
        if (i2 || n2)
          return new hg({ width: i2, color: n2, lineCap: t2[e2 + "stroke-line-cap"], lineJoin: t2[e2 + "stroke-line-join"], lineDash: t2[e2 + "stroke-line-dash"], lineDashOffset: t2[e2 + "stroke-line-dash-offset"], miterLimit: t2[e2 + "stroke-miter-limit"] });
      }
      function vg(t2) {
        const e2 = t2["text-value"];
        if (!e2)
          return;
        return new mg({ text: e2, font: t2["text-font"], maxAngle: t2["text-max-angle"], offsetX: t2["text-offset-x"], offsetY: t2["text-offset-y"], overflow: t2["text-overflow"], placement: t2["text-placement"], scale: t2["text-scale"], rotateWithView: t2["text-rotate-with-view"], rotation: t2["text-rotation"], textAlign: t2["text-align"], justify: t2["text-justify"], textBaseline: t2["text-baseline"], padding: t2["text-padding"], fill: yg(t2, "text-"), backgroundFill: yg(t2, "text-background-"), stroke: xg(t2, "text-"), backgroundStroke: xg(t2, "text-background-") });
      }
      function Sg(t2) {
        const e2 = t2["icon-src"], i2 = t2["icon-img"];
        if (e2 || i2) {
          return new lg({ src: e2, img: i2, imgSize: t2["icon-img-size"], anchor: t2["icon-anchor"], anchorOrigin: t2["icon-anchor-origin"], anchorXUnits: t2["icon-anchor-x-units"], anchorYUnits: t2["icon-anchor-y-units"], color: t2["icon-color"], crossOrigin: t2["icon-cross-origin"], offset: t2["icon-offset"], displacement: t2["icon-displacement"], opacity: t2["icon-opacity"], scale: t2["icon-scale"], rotation: t2["icon-rotation"], rotateWithView: t2["icon-rotate-with-view"], size: t2["icon-size"], declutterMode: t2["icon-declutter-mode"] });
        }
        const n2 = t2["shape-points"];
        if (n2) {
          const e3 = "shape-";
          return new ig({ points: n2, fill: yg(t2, e3), stroke: xg(t2, e3), radius: t2["shape-radius"], radius1: t2["shape-radius1"], radius2: t2["shape-radius2"], angle: t2["shape-angle"], displacement: t2["shape-displacement"], rotation: t2["shape-rotation"], rotateWithView: t2["shape-rotate-with-view"], scale: t2["shape-scale"], declutterMode: t2["shape-declutter-mode"] });
        }
        const r2 = t2["circle-radius"];
        if (r2) {
          const e3 = "circle-";
          return new ng({ radius: r2, fill: yg(t2, e3), stroke: xg(t2, e3), displacement: t2["circle-displacement"], scale: t2["circle-scale"], rotation: t2["circle-rotation"], rotateWithView: t2["circle-rotate-with-view"], declutterMode: t2["circle-declutter-mode"] });
        }
      }
      const wg = { "image/png": true, "image/jpeg": true, "image/gif": true, "image/webp": true }, Eg = { "application/vnd.mapbox-vector-tile": true, "application/geo+json": true };
      function Tg(t2, e2) {
        let i2, n2;
        for (let r2 = 0; r2 < t2.length; ++r2) {
          const s2 = t2[r2];
          if ("item" === s2.rel) {
            if (s2.type === e2) {
              i2 = s2.href;
              break;
            }
            (wg[s2.type] || !n2 && s2.type.startsWith("image/")) && (n2 = s2.href);
          }
        }
        if (!i2) {
          if (!n2)
            throw new Error('Could not find "item" link');
          i2 = n2;
        }
        return i2;
      }
      function Cg(t2, e2, i2) {
        let n2, r2;
        const s2 = {};
        for (let i3 = 0; i3 < t2.length; ++i3) {
          const o2 = t2[i3];
          if (s2[o2.type] = o2.href, "item" === o2.rel) {
            if (o2.type === e2) {
              n2 = o2.href;
              break;
            }
            Eg[o2.type] && (r2 = o2.href);
          }
        }
        if (!n2 && i2)
          for (let t3 = 0; t3 < i2.length; ++t3) {
            const e3 = i2[t3];
            if (s2[e3]) {
              n2 = s2[e3];
              break;
            }
          }
        if (!n2) {
          if (!r2)
            throw new Error('Could not find "item" link');
          n2 = r2;
        }
        return n2;
      }
      function bg(t2, e2, i2, n2) {
        let r2 = t2.projection;
        if (!r2 && (r2 = Ui(e2.crs), !r2))
          throw new Error(`Unsupported CRS: ${e2.crs}`);
        const s2 = "en" !== r2.getAxisOrientation().substr(0, 2), o2 = e2.tileMatrices, a2 = {};
        for (let t3 = 0; t3 < o2.length; ++t3) {
          const e3 = o2[t3];
          a2[e3.id] = e3;
        }
        const l2 = {}, h2 = [];
        if (n2)
          for (let t3 = 0; t3 < n2.length; ++t3) {
            const e3 = n2[t3], i3 = e3.tileMatrix;
            h2.push(i3), l2[i3] = e3;
          }
        else
          for (let t3 = 0; t3 < o2.length; ++t3) {
            const e3 = o2[t3].id;
            h2.push(e3);
          }
        const c2 = h2.length, u2 = new Array(c2), d2 = new Array(c2), g2 = new Array(c2), f2 = new Array(c2), p2 = [-1 / 0, -1 / 0, 1 / 0, 1 / 0];
        for (let t3 = 0; t3 < c2; ++t3) {
          const e3 = h2[t3], i3 = a2[e3], n3 = i3.pointOfOrigin;
          u2[t3] = s2 ? [n3[1], n3[0]] : n3, d2[t3] = i3.cellSize, g2[t3] = [i3.matrixWidth, i3.matrixHeight], f2[t3] = [i3.tileWidth, i3.tileHeight];
          const r3 = l2[e3];
          if (r3) {
            const e4 = i3.cellSize * i3.tileWidth, n4 = u2[t3][0] + r3.minTileCol * e4, s3 = u2[t3][0] + (r3.maxTileCol + 1) * e4, o3 = i3.cellSize * i3.tileHeight;
            let a3, l3;
            "bottomLeft" === i3.cornerOfOrigin ? (a3 = u2[t3][1] + r3.minTileRow * o3, l3 = u2[t3][1] + (r3.maxTileRow + 1) * o3) : (a3 = u2[t3][1] - (r3.maxTileRow + 1) * o3, l3 = u2[t3][1] - r3.minTileRow * o3), ye(p2, [n4, a3, s3, l3], p2);
          }
        }
        const m2 = new ql({ origins: u2, resolutions: d2, sizes: g2, tileSizes: f2, extent: n2 ? p2 : void 0 }), _2 = t2.context, y2 = t2.url;
        return { grid: m2, urlTemplate: i2, urlFunction: function(t3, e3, r3) {
          if (!t3)
            return;
          const s3 = h2[t3[0]], o3 = a2[s3], c3 = "bottomLeft" === o3.cornerOfOrigin, u3 = { tileMatrix: s3, tileCol: t3[1], tileRow: c3 ? -t3[2] - 1 : t3[2] };
          if (n2) {
            const t4 = l2[o3.id];
            if (u3.tileCol < t4.minTileCol || u3.tileCol > t4.maxTileCol || u3.tileRow < t4.minTileRow || u3.tileRow > t4.maxTileRow)
              return;
          }
          Object.assign(u3, _2);
          const d3 = i2.replace(/\{(\w+?)\}/g, function(t4, e4) {
            return u3[e4];
          });
          return Tl(y2, d3);
        } };
      }
      function Rg(t2) {
        return El(t2.url).then(function(e2) {
          return function(t3, e3) {
            const i2 = e3.tileMatrixSetLimits;
            let n2;
            if ("map" === e3.dataType)
              n2 = Tg(e3.links, t3.mediaType);
            else {
              if ("vector" !== e3.dataType)
                throw new Error('Expected tileset data type to be "map" or "vector"');
              n2 = Cg(e3.links, t3.mediaType, t3.supportedMediaTypes);
            }
            if (e3.tileMatrixSet)
              return bg(t3, e3.tileMatrixSet, n2, i2);
            const r2 = e3.links.find((t4) => "http://www.opengis.net/def/rel/ogc/1.0/tiling-scheme" === t4.rel);
            if (!r2)
              throw new Error("Expected http://www.opengis.net/def/rel/ogc/1.0/tiling-scheme link or tileMatrixSet");
            const s2 = r2.href;
            return El(Tl(t3.url, s2)).then(function(e4) {
              return bg(t3, e4, n2, i2);
            });
          }(t2, e2);
        });
      }
      const Pg = "renderOrder";
      class Ig extends vs {
        constructor(t2) {
          t2 = t2 || {};
          const e2 = Object.assign({}, t2);
          delete e2.style, delete e2.renderBuffer, delete e2.updateWhileAnimating, delete e2.updateWhileInteracting, super(e2), this.declutter_ = void 0 !== t2.declutter && t2.declutter, this.renderBuffer_ = void 0 !== t2.renderBuffer ? t2.renderBuffer : 100, this.style_ = null, this.styleFunction_ = void 0, this.setStyle(t2.style), this.updateWhileAnimating_ = void 0 !== t2.updateWhileAnimating && t2.updateWhileAnimating, this.updateWhileInteracting_ = void 0 !== t2.updateWhileInteracting && t2.updateWhileInteracting;
        }
        getDeclutter() {
          return this.declutter_;
        }
        getFeatures(t2) {
          return super.getFeatures(t2);
        }
        getRenderBuffer() {
          return this.renderBuffer_;
        }
        getRenderOrder() {
          return this.get(Pg);
        }
        getStyle() {
          return this.style_;
        }
        getStyleFunction() {
          return this.styleFunction_;
        }
        getUpdateWhileAnimating() {
          return this.updateWhileAnimating_;
        }
        getUpdateWhileInteracting() {
          return this.updateWhileInteracting_;
        }
        renderDeclutter(t2) {
          t2.declutterTree || (t2.declutterTree = new xh(9)), this.getRenderer().renderDeclutter(t2);
        }
        setRenderOrder(t2) {
          this.set(Pg, t2);
        }
        setStyle(t2) {
          let e2;
          if (void 0 === t2)
            e2 = gg;
          else if (null === t2)
            e2 = null;
          else if ("function" == typeof t2)
            e2 = t2;
          else if (t2 instanceof cg)
            e2 = t2;
          else if (Array.isArray(t2)) {
            const i2 = t2.length, n2 = new Array(i2);
            for (let e3 = 0; e3 < i2; ++e3) {
              const i3 = t2[e3];
              n2[e3] = i3 instanceof cg ? i3 : _g(i3);
            }
            e2 = n2;
          } else
            e2 = _g(t2);
          this.style_ = e2, this.styleFunction_ = null === t2 ? void 0 : ug(this.style_), this.changed();
        }
      }
      const Lg = "GENERATE_POLYGON_BUFFERS", Mg = "GENERATE_POINT_BUFFERS", Fg = "GENERATE_LINE_STRING_BUFFERS";
      var Ag = { exports: {} };
      function Og(t2, e2, i2) {
        i2 = i2 || 2;
        var n2, r2, s2, o2, a2, l2, h2, c2 = e2 && e2.length, u2 = c2 ? e2[0] * i2 : t2.length, d2 = Ng(t2, 0, u2, i2, true), g2 = [];
        if (!d2 || d2.next === d2.prev)
          return g2;
        if (c2 && (d2 = function(t3, e3, i3, n3) {
          var r3, s3, o3, a3 = [];
          for (r3 = 0, s3 = e3.length; r3 < s3; r3++)
            (o3 = Ng(t3, e3[r3] * n3, r3 < s3 - 1 ? e3[r3 + 1] * n3 : t3.length, n3, false)) === o3.next && (o3.steiner = true), a3.push(Zg(o3));
          for (a3.sort(zg), r3 = 0; r3 < a3.length; r3++)
            i3 = Dg(i3 = Xg(a3[r3], i3), i3.next);
          return i3;
        }(t2, e2, d2, i2)), t2.length > 80 * i2) {
          n2 = s2 = t2[0], r2 = o2 = t2[1];
          for (var f2 = i2; f2 < u2; f2 += i2)
            (a2 = t2[f2]) < n2 && (n2 = a2), (l2 = t2[f2 + 1]) < r2 && (r2 = l2), a2 > s2 && (s2 = a2), l2 > o2 && (o2 = l2);
          h2 = 0 !== (h2 = Math.max(s2 - n2, o2 - r2)) ? 1 / h2 : 0;
        }
        return kg(d2, g2, i2, n2, r2, h2), g2;
      }
      function Ng(t2, e2, i2, n2, r2) {
        var s2, o2;
        if (r2 === of(t2, e2, i2, n2) > 0)
          for (s2 = e2; s2 < i2; s2 += n2)
            o2 = nf(s2, t2[s2], t2[s2 + 1], o2);
        else
          for (s2 = i2 - n2; s2 >= e2; s2 -= n2)
            o2 = nf(s2, t2[s2], t2[s2 + 1], o2);
        return o2 && Hg(o2, o2.next) && (rf(o2), o2 = o2.next), o2;
      }
      function Dg(t2, e2) {
        if (!t2)
          return t2;
        e2 || (e2 = t2);
        var i2, n2 = t2;
        do {
          if (i2 = false, n2.steiner || !Hg(n2, n2.next) && 0 !== qg(n2.prev, n2, n2.next))
            n2 = n2.next;
          else {
            if (rf(n2), (n2 = e2 = n2.prev) === n2.next)
              break;
            i2 = true;
          }
        } while (i2 || n2 !== e2);
        return e2;
      }
      function kg(t2, e2, i2, n2, r2, s2, o2) {
        if (t2) {
          !o2 && s2 && function(t3, e3, i3, n3) {
            var r3 = t3;
            do {
              null === r3.z && (r3.z = Wg(r3.x, r3.y, e3, i3, n3)), r3.prevZ = r3.prev, r3.nextZ = r3.next, r3 = r3.next;
            } while (r3 !== t3);
            r3.prevZ.nextZ = null, r3.prevZ = null, function(t4) {
              var e4, i4, n4, r4, s3, o3, a3, l3, h3 = 1;
              do {
                for (i4 = t4, t4 = null, s3 = null, o3 = 0; i4; ) {
                  for (o3++, n4 = i4, a3 = 0, e4 = 0; e4 < h3 && (a3++, n4 = n4.nextZ); e4++)
                    ;
                  for (l3 = h3; a3 > 0 || l3 > 0 && n4; )
                    0 !== a3 && (0 === l3 || !n4 || i4.z <= n4.z) ? (r4 = i4, i4 = i4.nextZ, a3--) : (r4 = n4, n4 = n4.nextZ, l3--), s3 ? s3.nextZ = r4 : t4 = r4, r4.prevZ = s3, s3 = r4;
                  i4 = n4;
                }
                s3.nextZ = null, h3 *= 2;
              } while (o3 > 1);
            }(r3);
          }(t2, n2, r2, s2);
          for (var a2, l2, h2 = t2; t2.prev !== t2.next; )
            if (a2 = t2.prev, l2 = t2.next, s2 ? jg(t2, n2, r2, s2) : Gg(t2))
              e2.push(a2.i / i2), e2.push(t2.i / i2), e2.push(l2.i / i2), rf(t2), t2 = l2.next, h2 = l2.next;
            else if ((t2 = l2) === h2) {
              o2 ? 1 === o2 ? kg(t2 = Bg(Dg(t2), e2, i2), e2, i2, n2, r2, s2, 2) : 2 === o2 && Ug(t2, e2, i2, n2, r2, s2) : kg(Dg(t2), e2, i2, n2, r2, s2, 1);
              break;
            }
        }
      }
      function Gg(t2) {
        var e2 = t2.prev, i2 = t2, n2 = t2.next;
        if (qg(e2, i2, n2) >= 0)
          return false;
        for (var r2 = t2.next.next; r2 !== t2.prev; ) {
          if (Yg(e2.x, e2.y, i2.x, i2.y, n2.x, n2.y, r2.x, r2.y) && qg(r2.prev, r2, r2.next) >= 0)
            return false;
          r2 = r2.next;
        }
        return true;
      }
      function jg(t2, e2, i2, n2) {
        var r2 = t2.prev, s2 = t2, o2 = t2.next;
        if (qg(r2, s2, o2) >= 0)
          return false;
        for (var a2 = r2.x < s2.x ? r2.x < o2.x ? r2.x : o2.x : s2.x < o2.x ? s2.x : o2.x, l2 = r2.y < s2.y ? r2.y < o2.y ? r2.y : o2.y : s2.y < o2.y ? s2.y : o2.y, h2 = r2.x > s2.x ? r2.x > o2.x ? r2.x : o2.x : s2.x > o2.x ? s2.x : o2.x, c2 = r2.y > s2.y ? r2.y > o2.y ? r2.y : o2.y : s2.y > o2.y ? s2.y : o2.y, u2 = Wg(a2, l2, e2, i2, n2), d2 = Wg(h2, c2, e2, i2, n2), g2 = t2.prevZ, f2 = t2.nextZ; g2 && g2.z >= u2 && f2 && f2.z <= d2; ) {
          if (g2 !== t2.prev && g2 !== t2.next && Yg(r2.x, r2.y, s2.x, s2.y, o2.x, o2.y, g2.x, g2.y) && qg(g2.prev, g2, g2.next) >= 0)
            return false;
          if (g2 = g2.prevZ, f2 !== t2.prev && f2 !== t2.next && Yg(r2.x, r2.y, s2.x, s2.y, o2.x, o2.y, f2.x, f2.y) && qg(f2.prev, f2, f2.next) >= 0)
            return false;
          f2 = f2.nextZ;
        }
        for (; g2 && g2.z >= u2; ) {
          if (g2 !== t2.prev && g2 !== t2.next && Yg(r2.x, r2.y, s2.x, s2.y, o2.x, o2.y, g2.x, g2.y) && qg(g2.prev, g2, g2.next) >= 0)
            return false;
          g2 = g2.prevZ;
        }
        for (; f2 && f2.z <= d2; ) {
          if (f2 !== t2.prev && f2 !== t2.next && Yg(r2.x, r2.y, s2.x, s2.y, o2.x, o2.y, f2.x, f2.y) && qg(f2.prev, f2, f2.next) >= 0)
            return false;
          f2 = f2.nextZ;
        }
        return true;
      }
      function Bg(t2, e2, i2) {
        var n2 = t2;
        do {
          var r2 = n2.prev, s2 = n2.next.next;
          !Hg(r2, s2) && $g(r2, n2, n2.next, s2) && tf(r2, s2) && tf(s2, r2) && (e2.push(r2.i / i2), e2.push(n2.i / i2), e2.push(s2.i / i2), rf(n2), rf(n2.next), n2 = t2 = s2), n2 = n2.next;
        } while (n2 !== t2);
        return Dg(n2);
      }
      function Ug(t2, e2, i2, n2, r2, s2) {
        var o2 = t2;
        do {
          for (var a2 = o2.next.next; a2 !== o2.prev; ) {
            if (o2.i !== a2.i && Kg(o2, a2)) {
              var l2 = ef(o2, a2);
              return o2 = Dg(o2, o2.next), l2 = Dg(l2, l2.next), kg(o2, e2, i2, n2, r2, s2), void kg(l2, e2, i2, n2, r2, s2);
            }
            a2 = a2.next;
          }
          o2 = o2.next;
        } while (o2 !== t2);
      }
      function zg(t2, e2) {
        return t2.x - e2.x;
      }
      function Xg(t2, e2) {
        var i2 = function(t3, e3) {
          var i3, n3 = e3, r3 = t3.x, s2 = t3.y, o2 = -1 / 0;
          do {
            if (s2 <= n3.y && s2 >= n3.next.y && n3.next.y !== n3.y) {
              var a2 = n3.x + (s2 - n3.y) * (n3.next.x - n3.x) / (n3.next.y - n3.y);
              if (a2 <= r3 && a2 > o2) {
                if (o2 = a2, a2 === r3) {
                  if (s2 === n3.y)
                    return n3;
                  if (s2 === n3.next.y)
                    return n3.next;
                }
                i3 = n3.x < n3.next.x ? n3 : n3.next;
              }
            }
            n3 = n3.next;
          } while (n3 !== e3);
          if (!i3)
            return null;
          if (r3 === o2)
            return i3;
          var l2, h2 = i3, c2 = i3.x, u2 = i3.y, d2 = 1 / 0;
          n3 = i3;
          do {
            r3 >= n3.x && n3.x >= c2 && r3 !== n3.x && Yg(s2 < u2 ? r3 : o2, s2, c2, u2, s2 < u2 ? o2 : r3, s2, n3.x, n3.y) && (l2 = Math.abs(s2 - n3.y) / (r3 - n3.x), tf(n3, t3) && (l2 < d2 || l2 === d2 && (n3.x > i3.x || n3.x === i3.x && Vg(i3, n3))) && (i3 = n3, d2 = l2)), n3 = n3.next;
          } while (n3 !== h2);
          return i3;
        }(t2, e2);
        if (!i2)
          return e2;
        var n2 = ef(i2, t2), r2 = Dg(i2, i2.next);
        return Dg(n2, n2.next), e2 === i2 ? r2 : e2;
      }
      function Vg(t2, e2) {
        return qg(t2.prev, t2, e2.prev) < 0 && qg(e2.next, t2, t2.next) < 0;
      }
      function Wg(t2, e2, i2, n2, r2) {
        return (t2 = 1431655765 & ((t2 = 858993459 & ((t2 = 252645135 & ((t2 = 16711935 & ((t2 = 32767 * (t2 - i2) * r2) | t2 << 8)) | t2 << 4)) | t2 << 2)) | t2 << 1)) | (e2 = 1431655765 & ((e2 = 858993459 & ((e2 = 252645135 & ((e2 = 16711935 & ((e2 = 32767 * (e2 - n2) * r2) | e2 << 8)) | e2 << 4)) | e2 << 2)) | e2 << 1)) << 1;
      }
      function Zg(t2) {
        var e2 = t2, i2 = t2;
        do {
          (e2.x < i2.x || e2.x === i2.x && e2.y < i2.y) && (i2 = e2), e2 = e2.next;
        } while (e2 !== t2);
        return i2;
      }
      function Yg(t2, e2, i2, n2, r2, s2, o2, a2) {
        return (r2 - o2) * (e2 - a2) - (t2 - o2) * (s2 - a2) >= 0 && (t2 - o2) * (n2 - a2) - (i2 - o2) * (e2 - a2) >= 0 && (i2 - o2) * (s2 - a2) - (r2 - o2) * (n2 - a2) >= 0;
      }
      function Kg(t2, e2) {
        return t2.next.i !== e2.i && t2.prev.i !== e2.i && !function(t3, e3) {
          var i2 = t3;
          do {
            if (i2.i !== t3.i && i2.next.i !== t3.i && i2.i !== e3.i && i2.next.i !== e3.i && $g(i2, i2.next, t3, e3))
              return true;
            i2 = i2.next;
          } while (i2 !== t3);
          return false;
        }(t2, e2) && (tf(t2, e2) && tf(e2, t2) && function(t3, e3) {
          var i2 = t3, n2 = false, r2 = (t3.x + e3.x) / 2, s2 = (t3.y + e3.y) / 2;
          do {
            i2.y > s2 != i2.next.y > s2 && i2.next.y !== i2.y && r2 < (i2.next.x - i2.x) * (s2 - i2.y) / (i2.next.y - i2.y) + i2.x && (n2 = !n2), i2 = i2.next;
          } while (i2 !== t3);
          return n2;
        }(t2, e2) && (qg(t2.prev, t2, e2.prev) || qg(t2, e2.prev, e2)) || Hg(t2, e2) && qg(t2.prev, t2, t2.next) > 0 && qg(e2.prev, e2, e2.next) > 0);
      }
      function qg(t2, e2, i2) {
        return (e2.y - t2.y) * (i2.x - e2.x) - (e2.x - t2.x) * (i2.y - e2.y);
      }
      function Hg(t2, e2) {
        return t2.x === e2.x && t2.y === e2.y;
      }
      function $g(t2, e2, i2, n2) {
        var r2 = Qg(qg(t2, e2, i2)), s2 = Qg(qg(t2, e2, n2)), o2 = Qg(qg(i2, n2, t2)), a2 = Qg(qg(i2, n2, e2));
        return r2 !== s2 && o2 !== a2 || (!(0 !== r2 || !Jg(t2, i2, e2)) || (!(0 !== s2 || !Jg(t2, n2, e2)) || (!(0 !== o2 || !Jg(i2, t2, n2)) || !(0 !== a2 || !Jg(i2, e2, n2)))));
      }
      function Jg(t2, e2, i2) {
        return e2.x <= Math.max(t2.x, i2.x) && e2.x >= Math.min(t2.x, i2.x) && e2.y <= Math.max(t2.y, i2.y) && e2.y >= Math.min(t2.y, i2.y);
      }
      function Qg(t2) {
        return t2 > 0 ? 1 : t2 < 0 ? -1 : 0;
      }
      function tf(t2, e2) {
        return qg(t2.prev, t2, t2.next) < 0 ? qg(t2, e2, t2.next) >= 0 && qg(t2, t2.prev, e2) >= 0 : qg(t2, e2, t2.prev) < 0 || qg(t2, t2.next, e2) < 0;
      }
      function ef(t2, e2) {
        var i2 = new sf(t2.i, t2.x, t2.y), n2 = new sf(e2.i, e2.x, e2.y), r2 = t2.next, s2 = e2.prev;
        return t2.next = e2, e2.prev = t2, i2.next = r2, r2.prev = i2, n2.next = i2, i2.prev = n2, s2.next = n2, n2.prev = s2, n2;
      }
      function nf(t2, e2, i2, n2) {
        var r2 = new sf(t2, e2, i2);
        return n2 ? (r2.next = n2.next, r2.prev = n2, n2.next.prev = r2, n2.next = r2) : (r2.prev = r2, r2.next = r2), r2;
      }
      function rf(t2) {
        t2.next.prev = t2.prev, t2.prev.next = t2.next, t2.prevZ && (t2.prevZ.nextZ = t2.nextZ), t2.nextZ && (t2.nextZ.prevZ = t2.prevZ);
      }
      function sf(t2, e2, i2) {
        this.i = t2, this.x = e2, this.y = i2, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = false;
      }
      function of(t2, e2, i2, n2) {
        for (var r2 = 0, s2 = e2, o2 = i2 - n2; s2 < i2; s2 += n2)
          r2 += (t2[o2] - t2[s2]) * (t2[s2 + 1] + t2[o2 + 1]), o2 = s2;
        return r2;
      }
      Ag.exports = Og, Ag.exports.default = Og, Og.deviation = function(t2, e2, i2, n2) {
        var r2 = e2 && e2.length, s2 = r2 ? e2[0] * i2 : t2.length, o2 = Math.abs(of(t2, 0, s2, i2));
        if (r2)
          for (var a2 = 0, l2 = e2.length; a2 < l2; a2++) {
            var h2 = e2[a2] * i2, c2 = a2 < l2 - 1 ? e2[a2 + 1] * i2 : t2.length;
            o2 -= Math.abs(of(t2, h2, c2, i2));
          }
        var u2 = 0;
        for (a2 = 0; a2 < n2.length; a2 += 3) {
          var d2 = n2[a2] * i2, g2 = n2[a2 + 1] * i2, f2 = n2[a2 + 2] * i2;
          u2 += Math.abs((t2[d2] - t2[f2]) * (t2[g2 + 1] - t2[d2 + 1]) - (t2[d2] - t2[g2]) * (t2[f2 + 1] - t2[d2 + 1]));
        }
        return 0 === o2 && 0 === u2 ? 0 : Math.abs((u2 - o2) / o2);
      }, Og.flatten = function(t2) {
        for (var e2 = t2[0][0].length, i2 = { vertices: [], holes: [], dimensions: e2 }, n2 = 0, r2 = 0; r2 < t2.length; r2++) {
          for (var s2 = 0; s2 < t2[r2].length; s2++)
            for (var o2 = 0; o2 < e2; o2++)
              i2.vertices.push(t2[r2][s2][o2]);
          r2 > 0 && (n2 += t2[r2 - 1].length, i2.holes.push(n2));
        }
        return i2;
      };
      const af = [], lf = { vertexPosition: 0, indexPosition: 0 };
      function hf(t2, e2, i2, n2, r2) {
        t2[e2 + 0] = i2, t2[e2 + 1] = n2, t2[e2 + 2] = r2;
      }
      function cf(t2, e2) {
        const i2 = 256, n2 = 255;
        return (e2 = e2 || [])[0] = Math.floor(t2 / i2 / i2 / i2) / n2, e2[1] = Math.floor(t2 / i2 / i2) % i2 / n2, e2[2] = Math.floor(t2 / i2) % i2 / n2, e2[3] = t2 % i2 / n2, e2;
      }
      function uf(t2) {
        let e2 = 0;
        const i2 = 256, n2 = 255;
        return e2 += Math.round(t2[0] * i2 * i2 * i2 * n2), e2 += Math.round(t2[1] * i2 * i2 * n2), e2 += Math.round(t2[2] * i2 * n2), e2 += Math.round(t2[3] * n2), e2;
      }
      function df() {
        const t2 = 'const e="GENERATE_POLYGON_BUFFERS",t="GENERATE_POINT_BUFFERS",n="GENERATE_LINE_STRING_BUFFERS",r="undefined"!=typeof navigator&&void 0!==navigator.userAgent?navigator.userAgent.toLowerCase():"";r.includes("firefox");r.includes("safari")&&!r.includes("chrom")&&(r.includes("version/15.4")||/cpu (os|iphone os) 15_4 like mac os x/.test(r)),r.includes("webkit")&&r.includes("edge"),r.includes("macintosh"),"undefined"!=typeof WorkerGlobalScope&&"undefined"!=typeof OffscreenCanvas&&(self,WorkerGlobalScope),function(){let e=!1;try{const t=Object.defineProperty({},"passive",{get:function(){e=!0}});window.addEventListener("_",null,t),window.removeEventListener("_",null,t)}catch(e){}}();const o={1:"The view center is not defined",2:"The view resolution is not defined",3:"The view rotation is not defined",4:"`image` and `src` cannot be provided at the same time",5:"`imgSize` must be set when `image` is provided",7:"`format` must be set when `url` is set",8:"Unknown `serverType` configured",9:"`url` must be configured or set using `#setUrl()`",10:"The default `geometryFunction` can only handle `Point` geometries",11:"`options.featureTypes` must be an Array",12:"`options.geometryName` must also be provided when `options.bbox` is set",13:"Invalid corner",14:"Invalid color",15:"Tried to get a value for a key that does not exist in the cache",16:"Tried to set a value for a key that is used already",17:"`resolutions` must be sorted in descending order",18:"Either `origin` or `origins` must be configured, never both",19:"Number of `tileSizes` and `resolutions` must be equal",20:"Number of `origins` and `resolutions` must be equal",22:"Either `tileSize` or `tileSizes` must be configured, never both",24:"Invalid extent or geometry provided as `geometry`",25:"Cannot fit empty extent provided as `geometry`",26:"Features must have an id set",27:"Features must have an id set",28:\'`renderMode` must be `"hybrid"` or `"vector"`\',30:"The passed `feature` was already added to the source",31:"Tried to enqueue an `element` that was already added to the queue",32:"Transformation matrix cannot be inverted",33:"Invalid units",34:"Invalid geometry layout",36:"Unknown SRS type",37:"Unknown geometry type found",38:"`styleMapValue` has an unknown type",39:"Unknown geometry type",40:"Expected `feature` to have a geometry",41:"Expected an `ol/style/Style` or an array of `ol/style/Style.js`",42:"Question unknown, the answer is 42",43:"Expected `layers` to be an array or a `Collection`",47:"Expected `controls` to be an array or an `ol/Collection`",48:"Expected `interactions` to be an array or an `ol/Collection`",49:"Expected `overlays` to be an array or an `ol/Collection`",50:"`options.featureTypes` should be an Array",51:"Either `url` or `tileJSON` options must be provided",52:"Unknown `serverType` configured",53:"Unknown `tierSizeCalculation` configured",55:"The {-y} placeholder requires a tile grid with extent",56:"mapBrowserEvent must originate from a pointer event",57:"At least 2 conditions are required",59:"Invalid command found in the PBF",60:"Missing or invalid `size`",61:"Cannot determine IIIF Image API version from provided image information JSON",62:"A `WebGLArrayBuffer` must either be of type `ELEMENT_ARRAY_BUFFER` or `ARRAY_BUFFER`",64:"Layer opacity must be a number",66:"`forEachFeatureAtCoordinate` cannot be used on a WebGL layer if the hit detection logic has not been enabled. This is done by providing adequate shaders using the `hitVertexShader` and `hitFragmentShader` properties of `WebGLPointsLayerRenderer`",67:"A layer can only be added to the map once. Use either `layer.setMap()` or `map.addLayer()`, not both",68:"A VectorTile source can only be rendered if it has a projection compatible with the view projection"};class i extends Error{constructor(e){const t=o[e];super(t),this.code=e,this.name="AssertionError",this.message=t}}function s(e,t){const n=t[0],r=t[1];return t[0]=e[0]*n+e[2]*r+e[4],t[1]=e[1]*n+e[3]*r+e[5],t}function a(e,t){const n=(r=t)[0]*r[3]-r[1]*r[2];var r;!function(e,t){if(!e)throw new i(t)}(0!==n,32);const o=t[0],s=t[1],a=t[2],u=t[3],x=t[4],f=t[5];return e[0]=u/n,e[1]=-s/n,e[2]=-a/n,e[3]=o/n,e[4]=(a*f-u*x)/n,e[5]=-(o*f-s*x)/n,e}new Array(6);var u={exports:{}};function x(e,t,n){n=n||2;var r,o,i,s,a,u,x,y=t&&t.length,d=y?t[0]*n:e.length,h=f(e,0,d,n,!0),v=[];if(!h||h.next===h.prev)return v;if(y&&(h=function(e,t,n,r){var o,i,s,a=[];for(o=0,i=t.length;o<i;o++)(s=f(e,t[o]*r,o<i-1?t[o+1]*r:e.length,r,!1))===s.next&&(s.steiner=!0),a.push(w(s));for(a.sort(p),o=0;o<a.length;o++)n=l(n=g(a[o],n),n.next);return n}(e,t,h,n)),e.length>80*n){r=i=e[0],o=s=e[1];for(var b=n;b<d;b+=n)(a=e[b])<r&&(r=a),(u=e[b+1])<o&&(o=u),a>i&&(i=a),u>s&&(s=u);x=0!==(x=Math.max(i-r,s-o))?1/x:0}return c(h,v,n,r,o,x),v}function f(e,t,n,r,o){var i,s;if(o===B(e,t,n,r)>0)for(i=t;i<n;i+=r)s=U(i,e[i],e[i+1],s);else for(i=n-r;i>=t;i-=r)s=U(i,e[i],e[i+1],s);return s&&M(s,s.next)&&(z(s),s=s.next),s}function l(e,t){if(!e)return e;t||(t=e);var n,r=e;do{if(n=!1,r.steiner||!M(r,r.next)&&0!==Z(r.prev,r,r.next))r=r.next;else{if(z(r),(r=t=r.prev)===r.next)break;n=!0}}while(n||r!==t);return t}function c(e,t,n,r,o,i,s){if(e){!s&&i&&function(e,t,n,r){var o=e;do{null===o.z&&(o.z=m(o.x,o.y,t,n,r)),o.prevZ=o.prev,o.nextZ=o.next,o=o.next}while(o!==e);o.prevZ.nextZ=null,o.prevZ=null,function(e){var t,n,r,o,i,s,a,u,x=1;do{for(n=e,e=null,i=null,s=0;n;){for(s++,r=n,a=0,t=0;t<x&&(a++,r=r.nextZ);t++);for(u=x;a>0||u>0&&r;)0!==a&&(0===u||!r||n.z<=r.z)?(o=n,n=n.nextZ,a--):(o=r,r=r.nextZ,u--),i?i.nextZ=o:e=o,o.prevZ=i,i=o;n=r}i.nextZ=null,x*=2}while(s>1)}(o)}(e,r,o,i);for(var a,u,x=e;e.prev!==e.next;)if(a=e.prev,u=e.next,i?d(e,r,o,i):y(e))t.push(a.i/n),t.push(e.i/n),t.push(u.i/n),z(e),e=u.next,x=u.next;else if((e=u)===x){s?1===s?c(e=h(l(e),t,n),t,n,r,o,i,2):2===s&&v(e,t,n,r,o,i):c(l(e),t,n,r,o,i,1);break}}}function y(e){var t=e.prev,n=e,r=e.next;if(Z(t,n,r)>=0)return!1;for(var o=e.next.next;o!==e.prev;){if(A(t.x,t.y,n.x,n.y,r.x,r.y,o.x,o.y)&&Z(o.prev,o,o.next)>=0)return!1;o=o.next}return!0}function d(e,t,n,r){var o=e.prev,i=e,s=e.next;if(Z(o,i,s)>=0)return!1;for(var a=o.x<i.x?o.x<s.x?o.x:s.x:i.x<s.x?i.x:s.x,u=o.y<i.y?o.y<s.y?o.y:s.y:i.y<s.y?i.y:s.y,x=o.x>i.x?o.x>s.x?o.x:s.x:i.x>s.x?i.x:s.x,f=o.y>i.y?o.y>s.y?o.y:s.y:i.y>s.y?i.y:s.y,l=m(a,u,t,n,r),c=m(x,f,t,n,r),y=e.prevZ,d=e.nextZ;y&&y.z>=l&&d&&d.z<=c;){if(y!==e.prev&&y!==e.next&&A(o.x,o.y,i.x,i.y,s.x,s.y,y.x,y.y)&&Z(y.prev,y,y.next)>=0)return!1;if(y=y.prevZ,d!==e.prev&&d!==e.next&&A(o.x,o.y,i.x,i.y,s.x,s.y,d.x,d.y)&&Z(d.prev,d,d.next)>=0)return!1;d=d.nextZ}for(;y&&y.z>=l;){if(y!==e.prev&&y!==e.next&&A(o.x,o.y,i.x,i.y,s.x,s.y,y.x,y.y)&&Z(y.prev,y,y.next)>=0)return!1;y=y.prevZ}for(;d&&d.z<=c;){if(d!==e.prev&&d!==e.next&&A(o.x,o.y,i.x,i.y,s.x,s.y,d.x,d.y)&&Z(d.prev,d,d.next)>=0)return!1;d=d.nextZ}return!0}function h(e,t,n){var r=e;do{var o=r.prev,i=r.next.next;!M(o,i)&&F(o,r,r.next,i)&&k(o,i)&&k(i,o)&&(t.push(o.i/n),t.push(r.i/n),t.push(i.i/n),z(r),z(r.next),r=e=i),r=r.next}while(r!==e);return l(r)}function v(e,t,n,r,o,i){var s=e;do{for(var a=s.next.next;a!==s.prev;){if(s.i!==a.i&&E(s,a)){var u=S(s,a);return s=l(s,s.next),u=l(u,u.next),c(s,t,n,r,o,i),void c(u,t,n,r,o,i)}a=a.next}s=s.next}while(s!==e)}function p(e,t){return e.x-t.x}function g(e,t){var n=function(e,t){var n,r=t,o=e.x,i=e.y,s=-1/0;do{if(i<=r.y&&i>=r.next.y&&r.next.y!==r.y){var a=r.x+(i-r.y)*(r.next.x-r.x)/(r.next.y-r.y);if(a<=o&&a>s){if(s=a,a===o){if(i===r.y)return r;if(i===r.next.y)return r.next}n=r.x<r.next.x?r:r.next}}r=r.next}while(r!==t);if(!n)return null;if(o===s)return n;var u,x=n,f=n.x,l=n.y,c=1/0;r=n;do{o>=r.x&&r.x>=f&&o!==r.x&&A(i<l?o:s,i,f,l,i<l?s:o,i,r.x,r.y)&&(u=Math.abs(i-r.y)/(o-r.x),k(r,e)&&(u<c||u===c&&(r.x>n.x||r.x===n.x&&b(n,r)))&&(n=r,c=u)),r=r.next}while(r!==x);return n}(e,t);if(!n)return t;var r=S(n,e),o=l(n,n.next);return l(r,r.next),t===n?o:t}function b(e,t){return Z(e.prev,e,t.prev)<0&&Z(t.next,e,e.next)<0}function m(e,t,n,r,o){return(e=1431655765&((e=858993459&((e=252645135&((e=16711935&((e=32767*(e-n)*o)|e<<8))|e<<4))|e<<2))|e<<1))|(t=1431655765&((t=858993459&((t=252645135&((t=16711935&((t=32767*(t-r)*o)|t<<8))|t<<4))|t<<2))|t<<1))<<1}function w(e){var t=e,n=e;do{(t.x<n.x||t.x===n.x&&t.y<n.y)&&(n=t),t=t.next}while(t!==e);return n}function A(e,t,n,r,o,i,s,a){return(o-s)*(t-a)-(e-s)*(i-a)>=0&&(e-s)*(r-a)-(n-s)*(t-a)>=0&&(n-s)*(i-a)-(o-s)*(r-a)>=0}function E(e,t){return e.next.i!==t.i&&e.prev.i!==t.i&&!function(e,t){var n=e;do{if(n.i!==e.i&&n.next.i!==e.i&&n.i!==t.i&&n.next.i!==t.i&&F(n,n.next,e,t))return!0;n=n.next}while(n!==e);return!1}(e,t)&&(k(e,t)&&k(t,e)&&function(e,t){var n=e,r=!1,o=(e.x+t.x)/2,i=(e.y+t.y)/2;do{n.y>i!=n.next.y>i&&n.next.y!==n.y&&o<(n.next.x-n.x)*(i-n.y)/(n.next.y-n.y)+n.x&&(r=!r),n=n.next}while(n!==e);return r}(e,t)&&(Z(e.prev,e,t.prev)||Z(e,t.prev,t))||M(e,t)&&Z(e.prev,e,e.next)>0&&Z(t.prev,t,t.next)>0)}function Z(e,t,n){return(t.y-e.y)*(n.x-t.x)-(t.x-e.x)*(n.y-t.y)}function M(e,t){return e.x===t.x&&e.y===t.y}function F(e,t,n,r){var o=I(Z(e,t,n)),i=I(Z(e,t,r)),s=I(Z(n,r,e)),a=I(Z(n,r,t));return o!==i&&s!==a||(!(0!==o||!T(e,n,t))||(!(0!==i||!T(e,r,t))||(!(0!==s||!T(n,e,r))||!(0!==a||!T(n,t,r)))))}function T(e,t,n){return t.x<=Math.max(e.x,n.x)&&t.x>=Math.min(e.x,n.x)&&t.y<=Math.max(e.y,n.y)&&t.y>=Math.min(e.y,n.y)}function I(e){return e>0?1:e<0?-1:0}function k(e,t){return Z(e.prev,e,e.next)<0?Z(e,t,e.next)>=0&&Z(e,e.prev,t)>=0:Z(e,t,e.prev)<0||Z(e,e.next,t)<0}function S(e,t){var n=new R(e.i,e.x,e.y),r=new R(t.i,t.x,t.y),o=e.next,i=t.prev;return e.next=t,t.prev=e,n.next=o,o.prev=n,r.next=n,n.prev=r,i.next=r,r.prev=i,r}function U(e,t,n,r){var o=new R(e,t,n);return r?(o.next=r.next,o.prev=r,r.next.prev=o,r.next=o):(o.prev=o,o.next=o),o}function z(e){e.next.prev=e.prev,e.prev.next=e.next,e.prevZ&&(e.prevZ.nextZ=e.nextZ),e.nextZ&&(e.nextZ.prevZ=e.prevZ)}function R(e,t,n){this.i=e,this.x=t,this.y=n,this.prev=null,this.next=null,this.z=null,this.prevZ=null,this.nextZ=null,this.steiner=!1}function B(e,t,n,r){for(var o=0,i=t,s=n-r;i<n;i+=r)o+=(e[s]-e[i])*(e[i+1]+e[s+1]),s=i;return o}u.exports=x,u.exports.default=x,x.deviation=function(e,t,n,r){var o=t&&t.length,i=o?t[0]*n:e.length,s=Math.abs(B(e,0,i,n));if(o)for(var a=0,u=t.length;a<u;a++){var x=t[a]*n,f=a<u-1?t[a+1]*n:e.length;s-=Math.abs(B(e,x,f,n))}var l=0;for(a=0;a<r.length;a+=3){var c=r[a]*n,y=r[a+1]*n,d=r[a+2]*n;l+=Math.abs((e[c]-e[d])*(e[y+1]-e[c+1])-(e[c]-e[y])*(e[d+1]-e[c+1]))}return 0===s&&0===l?0:Math.abs((l-s)/s)},x.flatten=function(e){for(var t=e[0][0].length,n={vertices:[],holes:[],dimensions:t},r=0,o=0;o<e.length;o++){for(var i=0;i<e[o].length;i++)for(var s=0;s<t;s++)n.vertices.push(e[o][i][s]);o>0&&(r+=e[o-1].length,n.holes.push(r))}return n};const P=[],C={vertexPosition:0,indexPosition:0};function N(e,t,n,r,o){e[t+0]=n,e[t+1]=r,e[t+2]=o}function _(e,t,n,r,o,i){const s=3+o,a=e[t+0],u=e[t+1],x=P;x.length=o;for(let n=0;n<x.length;n++)x[n]=e[t+2+n];let f=i?i.vertexPosition:0,l=i?i.indexPosition:0;const c=f/s;return N(n,f,a,u,0),x.length&&n.set(x,f+3),f+=s,N(n,f,a,u,1),x.length&&n.set(x,f+3),f+=s,N(n,f,a,u,2),x.length&&n.set(x,f+3),f+=s,N(n,f,a,u,3),x.length&&n.set(x,f+3),f+=s,r[l++]=c,r[l++]=c+1,r[l++]=c+3,r[l++]=c+1,r[l++]=c+2,r[l++]=c+3,C.vertexPosition=f,C.indexPosition=l,C}function L(e,t,n,r,o,i,a,u,x,f){const l=5+u.length,c=i.length/l,y=[e[t+0],e[t+1]],d=[e[n],e[n+1]],h=s(f,[...y]),v=s(f,[...d]);function p(e,t,n){const r=1e4;return Math.round(1500*t)+Math.round(1500*n)*r+e*r*r}function g(e,t,n){const r=Math.sqrt((t[0]-e[0])*(t[0]-e[0])+(t[1]-e[1])*(t[1]-e[1])),o=[(t[0]-e[0])/r,(t[1]-e[1])/r],i=[-o[1],o[0]],s=Math.sqrt((n[0]-e[0])*(n[0]-e[0])+(n[1]-e[1])*(n[1]-e[1])),a=[(n[0]-e[0])/s,(n[1]-e[1])/s],u=0===r||0===s?0:Math.acos((x=a[0]*o[0]+a[1]*o[1],f=-1,l=1,Math.min(Math.max(x,f),l)));var x,f,l;return a[0]*i[0]+a[1]*i[1]>0?u:2*Math.PI-u}const b=null!==o;let m=0,w=0;if(null!==r){m=g(h,v,s(f,[...[e[r],e[r+1]]]))}if(b){w=g(v,h,s(f,[...[e[o],e[o+1]]]))}i.push(y[0],y[1],d[0],d[1],p(0,m,w)),i.push(...u),i.push(y[0],y[1],d[0],d[1],p(1,m,w)),i.push(...u),i.push(y[0],y[1],d[0],d[1],p(2,m,w)),i.push(...u),i.push(y[0],y[1],d[0],d[1],p(3,m,w)),i.push(...u),a.push(c,c+1,c+2,c+1,c+3,c+2)}function G(e,t,n,r,o){const i=2+o;let s=t;const a=e.slice(s,s+o);s+=o;const x=e[s++];let f=0;const l=new Array(x-1);for(let t=0;t<x;t++)f+=e[s++],t<x-1&&(l[t]=f);const c=e.slice(s,s+2*f),y=u.exports(c,l,2);for(let e=0;e<y.length;e++)r.push(y[e]+n.length/i);for(let e=0;e<c.length;e+=2)n.push(c[e],c[e+1],...a);return s+2*f}const O=self;O.onmessage=r=>{const o=r.data;switch(o.type){case t:{const e=3,t=2,n=o.customAttributesCount,r=t+n,i=new Float32Array(o.renderInstructions),s=i.length/r,a=4*s*(n+e),u=new Uint32Array(6*s),x=new Float32Array(a);let f;for(let e=0;e<i.length;e+=r)f=_(i,e,x,u,n,f);const l=Object.assign({vertexBuffer:x.buffer,indexBuffer:u.buffer,renderInstructions:i.buffer},o);O.postMessage(l,[x.buffer,u.buffer,i.buffer]);break}case n:{const e=[],t=[],n=o.customAttributesCount,r=2,i=new Float32Array(o.renderInstructions);let s=0;const u=o.renderInstructionsTransform,x=[1,0,0,1,0,0];let f,l;for(a(x,u);s<i.length;){l=Array.from(i.slice(s,s+n)),s+=n,f=i[s++];for(let n=0;n<f-1;n++)L(i,s+n*r,s+(n+1)*r,n>0?s+(n-1)*r:null,n<f-2?s+(n+2)*r:null,e,t,l,0,x);s+=f*r}const c=Uint32Array.from(t),y=Float32Array.from(e),d=Object.assign({vertexBuffer:y.buffer,indexBuffer:c.buffer,renderInstructions:i.buffer},o);O.postMessage(d,[y.buffer,c.buffer,i.buffer]);break}case e:{const e=[],t=[],n=o.customAttributesCount,r=new Float32Array(o.renderInstructions);let i=0;for(;i<r.length;)i=G(r,i,e,t,n);const s=Uint32Array.from(t),a=Float32Array.from(e),u=Object.assign({vertexBuffer:a.buffer,indexBuffer:s.buffer,renderInstructions:r.buffer},o);O.postMessage(u,[a.buffer,s.buffer,r.buffer]);break}}};';
        return new Worker("undefined" == typeof Blob ? "data:application/javascript;base64," + Buffer.from(t2, "binary").toString("base64") : URL.createObjectURL(new Blob([t2], { type: "application/javascript" })));
      }
      class gf extends gd {
        constructor(t2, e2) {
          const i2 = e2.uniforms || {}, n2 = [1, 0, 0, 1, 0, 0];
          i2[Wu] = n2, super(t2, { uniforms: i2, postProcesses: e2.postProcesses }), this.ready = false, this.sourceRevision_ = -1, this.verticesBuffer_ = new Gu(nu, ou), this.hitVerticesBuffer_ = new Gu(nu, ou), this.indicesBuffer_ = new Gu(ru, ou), this.vertexShader_ = e2.vertexShader, this.fragmentShader_ = e2.fragmentShader, this.program_, this.hitDetectionEnabled_ = !(!e2.hitFragmentShader || !e2.hitVertexShader), this.hitVertexShader_ = e2.hitVertexShader, this.hitFragmentShader_ = e2.hitFragmentShader, this.hitProgram_;
          const r2 = e2.attributes ? e2.attributes.map(function(t3) {
            return { name: "a_" + t3.name, size: 1, type: Qu.FLOAT };
          }) : [];
          this.attributes = [{ name: "a_position", size: 2, type: Qu.FLOAT }, { name: "a_index", size: 1, type: Qu.FLOAT }].concat(r2), this.hitDetectionAttributes = [{ name: "a_position", size: 2, type: Qu.FLOAT }, { name: "a_index", size: 1, type: Qu.FLOAT }, { name: "a_hitColor", size: 4, type: Qu.FLOAT }, { name: "a_featureUid", size: 1, type: Qu.FLOAT }].concat(r2), this.customAttributes = e2.attributes ? e2.attributes : [], this.previousExtent_ = [1 / 0, 1 / 0, -1 / 0, -1 / 0], this.currentTransform_ = n2, this.renderTransform_ = [1, 0, 0, 1, 0, 0], this.invertRenderTransform_ = [1, 0, 0, 1, 0, 0], this.renderInstructions_ = new Float32Array(0), this.hitRenderInstructions_ = new Float32Array(0), this.hitRenderTarget_, this.generateBuffersRun_ = 0, this.worker_ = df(), this.worker_.addEventListener("message", function(t3) {
            const e3 = t3.data;
            if (e3.type === Mg) {
              const i3 = e3.projectionTransform;
              e3.hitDetection ? (this.hitVerticesBuffer_.fromArrayBuffer(e3.vertexBuffer), this.helper.flushBufferData(this.hitVerticesBuffer_)) : (this.verticesBuffer_.fromArrayBuffer(e3.vertexBuffer), this.helper.flushBufferData(this.verticesBuffer_)), this.indicesBuffer_.fromArrayBuffer(e3.indexBuffer), this.helper.flushBufferData(this.indicesBuffer_), this.renderTransform_ = i3, Ft(this.invertRenderTransform_, this.renderTransform_), e3.hitDetection ? this.hitRenderInstructions_ = new Float32Array(t3.data.renderInstructions) : (this.renderInstructions_ = new Float32Array(t3.data.renderInstructions), e3.generateBuffersRun === this.generateBuffersRun_ && (this.ready = true)), this.getLayer().changed();
            }
          }.bind(this)), this.featureCache_ = {}, this.featureCount_ = 0;
          const s2 = this.getLayer().getSource();
          this.sourceListenKeys_ = [N(s2, Oh, this.handleSourceFeatureAdded_, this), N(s2, Nh, this.handleSourceFeatureChanged_, this), N(s2, kh, this.handleSourceFeatureDelete_, this), N(s2, Dh, this.handleSourceFeatureClear_, this)], s2.forEachFeature(function(t3) {
            this.featureCache_[z(t3)] = { feature: t3, properties: t3.getProperties(), geometry: t3.getGeometry() }, this.featureCount_++;
          }.bind(this));
        }
        afterHelperCreated() {
          this.program_ = this.helper.getProgram(this.fragmentShader_, this.vertexShader_), this.hitDetectionEnabled_ && (this.hitProgram_ = this.helper.getProgram(this.hitFragmentShader_, this.hitVertexShader_), this.hitRenderTarget_ = new ld(this.helper));
        }
        handleSourceFeatureAdded_(t2) {
          const e2 = t2.feature;
          this.featureCache_[z(e2)] = { feature: e2, properties: e2.getProperties(), geometry: e2.getGeometry() }, this.featureCount_++;
        }
        handleSourceFeatureChanged_(t2) {
          const e2 = t2.feature;
          this.featureCache_[z(e2)] = { feature: e2, properties: e2.getProperties(), geometry: e2.getGeometry() };
        }
        handleSourceFeatureDelete_(t2) {
          const e2 = t2.feature;
          delete this.featureCache_[z(e2)], this.featureCount_--;
        }
        handleSourceFeatureClear_() {
          this.featureCache_ = {}, this.featureCount_ = 0;
        }
        renderFrame(t2) {
          const e2 = this.helper.getGL();
          this.preRender(e2, t2);
          const i2 = t2.viewState.projection, n2 = this.getLayer().getSource().getWrapX() && i2.canWrapX(), r2 = i2.getExtent(), s2 = t2.extent, o2 = n2 ? Se(r2) : null, a2 = n2 ? Math.ceil((s2[2] - r2[2]) / o2) + 1 : 1, l2 = n2 ? Math.floor((s2[0] - r2[0]) / o2) : 0;
          let h2 = l2;
          const c2 = this.indicesBuffer_.getSize();
          do {
            this.helper.makeProjectionTransform(t2, this.currentTransform_), Lt(this.currentTransform_, h2 * o2, 0), Et(this.currentTransform_, this.invertRenderTransform_), this.helper.applyUniforms(t2), this.helper.drawElements(0, c2);
          } while (++h2 < a2);
          this.helper.finalizeDraw(t2, this.dispatchPreComposeEvent, this.dispatchPostComposeEvent);
          const u2 = this.helper.getCanvas();
          return this.hitDetectionEnabled_ && (this.renderHitDetection(t2, l2, a2, o2), this.hitRenderTarget_.clearCachedData()), this.postRender(e2, t2), u2;
        }
        prepareFrameInternal(t2) {
          const e2 = this.getLayer(), i2 = e2.getSource(), n2 = t2.viewState, r2 = !t2.viewHints[Ro] && !t2.viewHints[Po], s2 = !ee(this.previousExtent_, t2.extent), o2 = this.sourceRevision_ < i2.getRevision();
          if (o2 && (this.sourceRevision_ = i2.getRevision()), r2 && (s2 || o2)) {
            const r3 = n2.projection, s3 = n2.resolution, o3 = e2 instanceof Ig ? e2.getRenderBuffer() : 0, a2 = Xt(t2.extent, o3 * s3);
            i2.loadFeatures(a2, s3, r3), this.rebuildBuffers_(t2), this.previousExtent_ = t2.extent.slice();
          }
          return this.helper.useProgram(this.program_, t2), this.helper.prepareDraw(t2), this.helper.bindBuffer(this.verticesBuffer_), this.helper.bindBuffer(this.indicesBuffer_), this.helper.enableAttributes(this.attributes), true;
        }
        rebuildBuffers_(t2) {
          const e2 = [1, 0, 0, 1, 0, 0];
          this.helper.makeProjectionTransform(t2, e2);
          const i2 = (2 + this.customAttributes.length) * this.featureCount_;
          if (this.renderInstructions_ && this.renderInstructions_.length === i2 || (this.renderInstructions_ = new Float32Array(i2)), this.hitDetectionEnabled_) {
            const t3 = (7 + this.customAttributes.length) * this.featureCount_;
            this.hitRenderInstructions_ && this.hitRenderInstructions_.length === t3 || (this.hitRenderInstructions_ = new Float32Array(t3));
          }
          let n2, r2;
          const s2 = [], o2 = [];
          let a2, l2 = 0, h2 = 0;
          for (const t3 in this.featureCache_) {
            if (n2 = this.featureCache_[t3], r2 = n2.geometry, !r2 || "Point" !== r2.getType())
              continue;
            let i3;
            s2[0] = r2.getFlatCoordinates()[0], s2[1] = r2.getFlatCoordinates()[1], bt(e2, s2), a2 = cf(h2 + 6, o2), this.renderInstructions_[l2++] = s2[0], this.renderInstructions_[l2++] = s2[1], this.hitDetectionEnabled_ && (this.hitRenderInstructions_[h2++] = s2[0], this.hitRenderInstructions_[h2++] = s2[1], this.hitRenderInstructions_[h2++] = a2[0], this.hitRenderInstructions_[h2++] = a2[1], this.hitRenderInstructions_[h2++] = a2[2], this.hitRenderInstructions_[h2++] = a2[3], this.hitRenderInstructions_[h2++] = Number(t3));
            for (let t4 = 0; t4 < this.customAttributes.length; t4++)
              i3 = this.customAttributes[t4].callback(n2.feature, n2.properties), this.renderInstructions_[l2++] = i3, this.hitDetectionEnabled_ && (this.hitRenderInstructions_[h2++] = i3);
          }
          const c2 = { id: 0, type: Mg, renderInstructions: this.renderInstructions_.buffer, customAttributesCount: this.customAttributes.length };
          if (c2.projectionTransform = e2, c2.generateBuffersRun = ++this.generateBuffersRun_, this.ready = false, this.worker_.postMessage(c2, [this.renderInstructions_.buffer]), this.renderInstructions_ = null, this.hitDetectionEnabled_) {
            const t3 = { id: 0, type: Mg, renderInstructions: this.hitRenderInstructions_.buffer, customAttributesCount: 5 + this.customAttributes.length };
            t3.projectionTransform = e2, t3.hitDetection = true, this.worker_.postMessage(t3, [this.hitRenderInstructions_.buffer]), this.hitRenderInstructions_ = null;
          }
        }
        forEachFeatureAtCoordinate(t2, e2, i2, n2, r2) {
          if (at(this.hitDetectionEnabled_, 66), !this.hitRenderInstructions_)
            return;
          const s2 = bt(e2.coordinateToPixelTransform, t2.slice()), o2 = this.hitRenderTarget_.readPixel(s2[0] / 2, s2[1] / 2), a2 = uf([o2[0] / 255, o2[1] / 255, o2[2] / 255, o2[3] / 255]), l2 = this.hitRenderInstructions_[a2], h2 = Math.floor(l2).toString(), c2 = this.getLayer().getSource().getFeatureByUid(h2);
          return c2 ? n2(c2, this.getLayer(), null) : void 0;
        }
        renderHitDetection(t2, e2, i2, n2) {
          if (!this.hitVerticesBuffer_.getSize())
            return;
          let r2 = e2;
          this.hitRenderTarget_.setSize([Math.floor(t2.size[0] / 2), Math.floor(t2.size[1] / 2)]), this.helper.useProgram(this.hitProgram_, t2), this.helper.prepareDrawToRenderTarget(t2, this.hitRenderTarget_, true), this.helper.bindBuffer(this.hitVerticesBuffer_), this.helper.bindBuffer(this.indicesBuffer_), this.helper.enableAttributes(this.hitDetectionAttributes);
          do {
            this.helper.makeProjectionTransform(t2, this.currentTransform_), Lt(this.currentTransform_, r2 * n2, 0), Et(this.currentTransform_, this.invertRenderTransform_), this.helper.applyUniforms(t2);
            const e3 = this.indicesBuffer_.getSize();
            this.helper.drawElements(0, e3);
          } while (++r2 < i2);
        }
        disposeInternal() {
          this.worker_.terminate(), this.layer_ = null, this.sourceListenKeys_.forEach(function(t2) {
            k(t2);
          }), this.sourceListenKeys_ = null, super.disposeInternal();
        }
      }
      let ff = 0;
      class pf {
        constructor(t2, e2, i2, n2, r2) {
          this.helper_ = t2, this.worker_ = e2, this.program_ = this.helper_.getProgram(n2, i2), this.attributes = [], this.customAttributes = r2;
        }
        rebuild(t2, e2, i2, n2) {
          t2.renderInstructionsTransform = this.helper_.makeProjectionTransform(e2, [1, 0, 0, 1, 0, 0]), this.generateRenderInstructions(t2), this.generateBuffers_(t2, i2, n2);
        }
        render(t2, e2, i2, n2) {
          this.helper_.makeProjectionTransform(i2, e2), Lt(e2, n2, 0), Et(e2, t2.invertVerticesBufferTransform), this.helper_.useProgram(this.program_, i2), this.helper_.bindBuffer(t2.verticesBuffer), this.helper_.bindBuffer(t2.indicesBuffer), this.helper_.enableAttributes(this.attributes);
          const r2 = t2.indicesBuffer.getSize();
          this.helper_.drawElements(0, r2);
        }
        generateRenderInstructions(t2) {
          B();
        }
        generateBuffers_(t2, e2, i2) {
          const n2 = ff++;
          let r2;
          switch (e2) {
            case "Polygon":
              r2 = Lg;
              break;
            case "Point":
              r2 = Mg;
              break;
            case "LineString":
              r2 = Fg;
          }
          const s2 = { id: n2, type: r2, renderInstructions: t2.renderInstructions.buffer, renderInstructionsTransform: t2.renderInstructionsTransform, customAttributesCount: this.customAttributes.length };
          this.worker_.postMessage(s2, [t2.renderInstructions.buffer]), t2.renderInstructions = null;
          const o2 = function(e3) {
            const r3 = e3.data;
            r3.id === n2 && (this.worker_.removeEventListener("message", o2), t2.verticesBufferTransform = r3.renderInstructionsTransform, Ft(t2.invertVerticesBufferTransform, t2.verticesBufferTransform), t2.verticesBuffer.fromArrayBuffer(r3.vertexBuffer), this.helper_.flushBufferData(t2.verticesBuffer), t2.indicesBuffer.fromArrayBuffer(r3.indexBuffer), this.helper_.flushBufferData(t2.indicesBuffer), t2.renderInstructions = new Float32Array(r3.renderInstructions), i2());
          }.bind(this);
          this.worker_.addEventListener("message", o2);
        }
      }
      const mf = { SEGMENT_START: "a_segmentStart", SEGMENT_END: "a_segmentEnd", PARAMETERS: "a_parameters" };
      class _f extends pf {
        constructor(t2, e2, i2, n2, r2) {
          super(t2, e2, i2, n2, r2), this.attributes = [{ name: mf.SEGMENT_START, size: 2, type: Qu.FLOAT }, { name: mf.SEGMENT_END, size: 2, type: Qu.FLOAT }, { name: mf.PARAMETERS, size: 1, type: Qu.FLOAT }].concat(r2.map(function(t3) {
            return { name: "a_" + t3.name, size: 1, type: Qu.FLOAT };
          }));
        }
        generateRenderInstructions(t2) {
          const e2 = 2 * t2.verticesCount + (1 + this.customAttributes.length) * t2.geometriesCount;
          let i2;
          t2.renderInstructions && t2.renderInstructions.length === e2 || (t2.renderInstructions = new Float32Array(e2));
          const n2 = [];
          let r2, s2 = 0;
          for (const e3 in t2.entries) {
            i2 = t2.entries[e3];
            for (let e4 = 0, o2 = i2.flatCoordss.length; e4 < o2; e4++) {
              n2.length = i2.flatCoordss[e4].length, un(i2.flatCoordss[e4], 0, n2.length, 2, t2.renderInstructionsTransform, n2);
              for (let e5 = 0, n3 = this.customAttributes.length; e5 < n3; e5++)
                r2 = this.customAttributes[e5].callback(i2.feature), t2.renderInstructions[s2++] = r2;
              t2.renderInstructions[s2++] = n2.length / 2;
              for (let e5 = 0, i3 = n2.length; e5 < i3; e5 += 2)
                t2.renderInstructions[s2++] = n2[e5], t2.renderInstructions[s2++] = n2[e5 + 1];
            }
          }
        }
      }
      class yf {
        constructor() {
          this.polygonBatch = { entries: {}, geometriesCount: 0, verticesCount: 0, ringsCount: 0, renderInstructions: new Float32Array(0), verticesBuffer: new Gu(nu, ou), indicesBuffer: new Gu(ru, ou), renderInstructionsTransform: [1, 0, 0, 1, 0, 0], verticesBufferTransform: [1, 0, 0, 1, 0, 0], invertVerticesBufferTransform: [1, 0, 0, 1, 0, 0] }, this.pointBatch = { entries: {}, geometriesCount: 0, renderInstructions: new Float32Array(0), verticesBuffer: new Gu(nu, ou), indicesBuffer: new Gu(ru, ou), renderInstructionsTransform: [1, 0, 0, 1, 0, 0], verticesBufferTransform: [1, 0, 0, 1, 0, 0], invertVerticesBufferTransform: [1, 0, 0, 1, 0, 0] }, this.lineStringBatch = { entries: {}, geometriesCount: 0, verticesCount: 0, renderInstructions: new Float32Array(0), verticesBuffer: new Gu(nu, ou), indicesBuffer: new Gu(ru, ou), renderInstructionsTransform: [1, 0, 0, 1, 0, 0], verticesBufferTransform: [1, 0, 0, 1, 0, 0], invertVerticesBufferTransform: [1, 0, 0, 1, 0, 0] };
        }
        addFeatures(t2) {
          for (let e2 = 0; e2 < t2.length; e2++)
            this.addFeature(t2[e2]);
        }
        addFeature(t2) {
          const e2 = t2.getGeometry();
          e2 && this.addGeometry_(e2, t2);
        }
        addFeatureEntryInPointBatch_(t2) {
          const e2 = z(t2);
          return e2 in this.pointBatch.entries || (this.pointBatch.entries[e2] = { feature: t2, flatCoordss: [] }), this.pointBatch.entries[e2];
        }
        addFeatureEntryInLineStringBatch_(t2) {
          const e2 = z(t2);
          return e2 in this.lineStringBatch.entries || (this.lineStringBatch.entries[e2] = { feature: t2, flatCoordss: [], verticesCount: 0 }), this.lineStringBatch.entries[e2];
        }
        addFeatureEntryInPolygonBatch_(t2) {
          const e2 = z(t2);
          return e2 in this.polygonBatch.entries || (this.polygonBatch.entries[e2] = { feature: t2, flatCoordss: [], verticesCount: 0, ringsCount: 0, ringsVerticesCounts: [] }), this.polygonBatch.entries[e2];
        }
        clearFeatureEntryInPointBatch_(t2) {
          const e2 = this.pointBatch.entries[z(t2)];
          e2 && (this.pointBatch.geometriesCount -= e2.flatCoordss.length, delete this.pointBatch.entries[z(t2)]);
        }
        clearFeatureEntryInLineStringBatch_(t2) {
          const e2 = this.lineStringBatch.entries[z(t2)];
          e2 && (this.lineStringBatch.verticesCount -= e2.verticesCount, this.lineStringBatch.geometriesCount -= e2.flatCoordss.length, delete this.lineStringBatch.entries[z(t2)]);
        }
        clearFeatureEntryInPolygonBatch_(t2) {
          const e2 = this.polygonBatch.entries[z(t2)];
          e2 && (this.polygonBatch.verticesCount -= e2.verticesCount, this.polygonBatch.ringsCount -= e2.ringsCount, this.polygonBatch.geometriesCount -= e2.flatCoordss.length, delete this.polygonBatch.entries[z(t2)]);
        }
        addGeometry_(t2, e2) {
          let i2, n2, r2;
          switch (t2.getType()) {
            case "GeometryCollection":
              t2.getGeometries().map((t3) => this.addGeometry_(t3, e2));
              break;
            case "MultiPolygon":
              t2.getPolygons().map((t3) => this.addGeometry_(t3, e2));
              break;
            case "MultiLineString":
              t2.getLineStrings().map((t3) => this.addGeometry_(t3, e2));
              break;
            case "MultiPoint":
              t2.getPoints().map((t3) => this.addGeometry_(t3, e2));
              break;
            case "Polygon":
              const s2 = t2;
              r2 = this.addFeatureEntryInPolygonBatch_(e2), i2 = s2.getFlatCoordinates(), n2 = i2.length / 2;
              const o2 = s2.getLinearRingCount(), a2 = s2.getEnds().map((t3, e3, i3) => e3 > 0 ? (t3 - i3[e3 - 1]) / 2 : t3 / 2);
              this.polygonBatch.verticesCount += n2, this.polygonBatch.ringsCount += o2, this.polygonBatch.geometriesCount++, r2.flatCoordss.push(i2), r2.ringsVerticesCounts.push(a2), r2.verticesCount += n2, r2.ringsCount += o2, s2.getLinearRings().map((t3) => this.addGeometry_(t3, e2));
              break;
            case "Point":
              const l2 = t2;
              r2 = this.addFeatureEntryInPointBatch_(e2), i2 = l2.getFlatCoordinates(), this.pointBatch.geometriesCount++, r2.flatCoordss.push(i2);
              break;
            case "LineString":
            case "LinearRing":
              const h2 = t2;
              r2 = this.addFeatureEntryInLineStringBatch_(e2), i2 = h2.getFlatCoordinates(), n2 = i2.length / 2, this.lineStringBatch.verticesCount += n2, this.lineStringBatch.geometriesCount++, r2.flatCoordss.push(i2), r2.verticesCount += n2;
          }
        }
        changeFeature(t2) {
          this.clearFeatureEntryInPointBatch_(t2), this.clearFeatureEntryInPolygonBatch_(t2), this.clearFeatureEntryInLineStringBatch_(t2);
          const e2 = t2.getGeometry();
          e2 && this.addGeometry_(e2, t2);
        }
        removeFeature(t2) {
          this.clearFeatureEntryInPointBatch_(t2), this.clearFeatureEntryInPolygonBatch_(t2), this.clearFeatureEntryInLineStringBatch_(t2);
        }
        clear() {
          this.polygonBatch.entries = {}, this.polygonBatch.geometriesCount = 0, this.polygonBatch.verticesCount = 0, this.polygonBatch.ringsCount = 0, this.lineStringBatch.entries = {}, this.lineStringBatch.geometriesCount = 0, this.lineStringBatch.verticesCount = 0, this.pointBatch.entries = {}, this.pointBatch.geometriesCount = 0;
        }
      }
      const xf = { POSITION: "a_position", INDEX: "a_index" };
      class vf extends pf {
        constructor(t2, e2, i2, n2, r2) {
          super(t2, e2, i2, n2, r2), this.attributes = [{ name: xf.POSITION, size: 2, type: Qu.FLOAT }, { name: xf.INDEX, size: 1, type: Qu.FLOAT }].concat(r2.map(function(t3) {
            return { name: "a_" + t3.name, size: 1, type: Qu.FLOAT };
          }));
        }
        generateRenderInstructions(t2) {
          const e2 = (2 + this.customAttributes.length) * t2.geometriesCount;
          let i2;
          t2.renderInstructions && t2.renderInstructions.length === e2 || (t2.renderInstructions = new Float32Array(e2));
          const n2 = [];
          let r2, s2 = 0;
          for (const e3 in t2.entries) {
            i2 = t2.entries[e3];
            for (let e4 = 0, o2 = i2.flatCoordss.length; e4 < o2; e4++) {
              n2[0] = i2.flatCoordss[e4][0], n2[1] = i2.flatCoordss[e4][1], bt(t2.renderInstructionsTransform, n2), t2.renderInstructions[s2++] = n2[0], t2.renderInstructions[s2++] = n2[1];
              for (let e5 = 0, n3 = this.customAttributes.length; e5 < n3; e5++)
                r2 = this.customAttributes[e5].callback(i2.feature), t2.renderInstructions[s2++] = r2;
            }
          }
        }
      }
      const Sf = { POSITION: "a_position" };
      class wf extends pf {
        constructor(t2, e2, i2, n2, r2) {
          super(t2, e2, i2, n2, r2), this.attributes = [{ name: Sf.POSITION, size: 2, type: Qu.FLOAT }].concat(r2.map(function(t3) {
            return { name: "a_" + t3.name, size: 1, type: Qu.FLOAT };
          }));
        }
        generateRenderInstructions(t2) {
          const e2 = 2 * t2.verticesCount + (1 + this.customAttributes.length) * t2.geometriesCount + t2.ringsCount;
          let i2;
          t2.renderInstructions && t2.renderInstructions.length === e2 || (t2.renderInstructions = new Float32Array(e2));
          const n2 = [];
          let r2, s2 = 0;
          for (const e3 in t2.entries) {
            i2 = t2.entries[e3];
            for (let e4 = 0, o2 = i2.flatCoordss.length; e4 < o2; e4++) {
              n2.length = i2.flatCoordss[e4].length, un(i2.flatCoordss[e4], 0, n2.length, 2, t2.renderInstructionsTransform, n2);
              for (let e5 = 0, n3 = this.customAttributes.length; e5 < n3; e5++)
                r2 = this.customAttributes[e5].callback(i2.feature), t2.renderInstructions[s2++] = r2;
              t2.renderInstructions[s2++] = i2.ringsVerticesCounts[e4].length;
              for (let n3 = 0, r3 = i2.ringsVerticesCounts[e4].length; n3 < r3; n3++)
                t2.renderInstructions[s2++] = i2.ringsVerticesCounts[e4][n3];
              for (let e5 = 0, i3 = n2.length; e5 < i3; e5 += 2)
                t2.renderInstructions[s2++] = n2[e5], t2.renderInstructions[s2++] = n2[e5 + 1];
            }
          }
        }
      }
      function Ef(t2) {
        const e2 = $r(t2);
        return 256 * e2[0] * 256 + 256 * e2[1] + e2[2];
      }
      const Tf = "vec3(\n  fract(floor(a_color / 256.0 / 256.0) / 256.0),\n  fract(floor(a_color / 256.0) / 256.0),\n  fract(a_color / 256.0)\n);", Cf = `
  precision mediump float;
  uniform mat4 u_projectionMatrix;
  attribute vec2 a_position;
  attribute float a_color;
  attribute float a_opacity;
  varying vec3 v_color;
  varying float v_opacity;

  void main(void) {
    gl_Position = u_projectionMatrix * vec4(a_position, 0.0, 1.0);
    v_color = ${Tf}
    v_opacity = a_opacity;
  }`, bf = "\n  precision mediump float;\n  varying vec3 v_color;\n  varying float v_opacity;\n\n  void main(void) {\n    gl_FragColor = vec4(v_color, 1.0) * v_opacity;\n  }", Rf = `
  precision mediump float;
  uniform mat4 u_projectionMatrix;
  uniform vec2 u_sizePx;
  attribute vec2 a_segmentStart;
  attribute vec2 a_segmentEnd;
  attribute float a_parameters;
  attribute float a_color;
  attribute float a_opacity;
  attribute float a_width;
  varying vec2 v_segmentStart;
  varying vec2 v_segmentEnd;
  varying float v_angleStart;
  varying float v_angleEnd;
  varying vec3 v_color;
  varying float v_opacity;
  varying float v_width;

  vec2 worldToPx(vec2 worldPos) {
    vec4 screenPos = u_projectionMatrix * vec4(worldPos, 0.0, 1.0);
    return (0.5 * screenPos.xy + 0.5) * u_sizePx;
  }

  vec4 pxToScreen(vec2 pxPos) {
    vec2 screenPos = pxPos * 4.0 / u_sizePx;
    return vec4(screenPos.xy, 0.0, 0.0);
  }

  vec2 getOffsetDirection(vec2 normalPx, vec2 tangentPx, float joinAngle) {
    if (cos(joinAngle) > 0.93) return normalPx - tangentPx;
    float halfAngle = joinAngle / 2.0;
    vec2 angleBisectorNormal = vec2(
      sin(halfAngle) * normalPx.x + cos(halfAngle) * normalPx.y,
      -cos(halfAngle) * normalPx.x + sin(halfAngle) * normalPx.y
    );
    float length = 1.0 / sin(halfAngle);
    return angleBisectorNormal * length;
  }

  void main(void) {
    float anglePrecision = 1500.0;
    float paramShift = 10000.0;
    v_angleStart = fract(a_parameters / paramShift) * paramShift / anglePrecision;
    v_angleEnd = fract(floor(a_parameters / paramShift + 0.5) / paramShift) * paramShift / anglePrecision;
    float vertexNumber = floor(a_parameters / paramShift / paramShift + 0.0001);
    vec2 tangentPx = worldToPx(a_segmentEnd) - worldToPx(a_segmentStart);
    tangentPx = normalize(tangentPx);
    vec2 normalPx = vec2(-tangentPx.y, tangentPx.x);
    float normalDir = vertexNumber < 0.5 || (vertexNumber > 1.5 && vertexNumber < 2.5) ? 1.0 : -1.0;
    float tangentDir = vertexNumber < 1.5 ? 1.0 : -1.0;
    float angle = vertexNumber < 1.5 ? v_angleStart : v_angleEnd;
    vec2 offsetPx = getOffsetDirection(normalPx * normalDir, tangentDir * tangentPx, angle) * a_width * 0.5;
    vec2 position =  vertexNumber < 1.5 ? a_segmentStart : a_segmentEnd;
    gl_Position = u_projectionMatrix * vec4(position, 0.0, 1.0) + pxToScreen(offsetPx);
    v_segmentStart = worldToPx(a_segmentStart);
    v_segmentEnd = worldToPx(a_segmentEnd);
    v_color = ${Tf}
    v_opacity = a_opacity;
    v_width = a_width;
  }`, Pf = "\n  precision mediump float;\n  uniform float u_pixelRatio;\n  varying vec2 v_segmentStart;\n  varying vec2 v_segmentEnd;\n  varying float v_angleStart;\n  varying float v_angleEnd;\n  varying vec3 v_color;\n  varying float v_opacity;\n  varying float v_width;\n\n  float segmentDistanceField(vec2 point, vec2 start, vec2 end, float radius) {\n    vec2 startToPoint = point - start;\n    vec2 startToEnd = end - start;\n    float ratio = clamp(dot(startToPoint, startToEnd) / dot(startToEnd, startToEnd), 0.0, 1.0);\n    float dist = length(startToPoint - ratio * startToEnd);\n    return 1.0 - smoothstep(radius - 1.0, radius, dist);\n  }\n\n  void main(void) {\n    vec2 v_currentPoint = gl_FragCoord.xy / u_pixelRatio;\n    gl_FragColor = vec4(v_color, 1.0) * v_opacity;\n    gl_FragColor *= segmentDistanceField(v_currentPoint, v_segmentStart, v_segmentEnd, v_width);\n  }", If = `
  precision mediump float;
  uniform mat4 u_projectionMatrix;
  uniform mat4 u_offsetScaleMatrix;
  attribute vec2 a_position;
  attribute float a_index;
  attribute float a_color;
  attribute float a_opacity;
  varying vec2 v_texCoord;
  varying vec3 v_color;
  varying float v_opacity;

  void main(void) {
    mat4 offsetMatrix = u_offsetScaleMatrix;
    float size = 6.0;
    float offsetX = a_index == 0.0 || a_index == 3.0 ? -size / 2.0 : size / 2.0;
    float offsetY = a_index == 0.0 || a_index == 1.0 ? -size / 2.0 : size / 2.0;
    vec4 offsets = offsetMatrix * vec4(offsetX, offsetY, 0.0, 0.0);
    gl_Position = u_projectionMatrix * vec4(a_position, 0.0, 1.0) + offsets;
    float u = a_index == 0.0 || a_index == 3.0 ? 0.0 : 1.0;
    float v = a_index == 0.0 || a_index == 1.0 ? 0.0 : 1.0;
    v_texCoord = vec2(u, v);
    v_color = ${Tf}
    v_opacity = a_opacity;
  }`, Lf = "\n  precision mediump float;\n  varying vec3 v_color;\n  varying float v_opacity;\n\n  void main(void) {\n      gl_FragColor = vec4(v_color, 1.0) * v_opacity;\n  }";
      function Mf(t2) {
        return Object.keys(t2).map((e2) => ({ name: e2, callback: t2[e2] }));
      }
      const Ff = 0, Af = 1, Of = 2, Nf = 3, Df = 4, kf = 5, Gf = 6, jf = 7, Bf = 8, Uf = 9, zf = 10, Xf = 11, Vf = 12, Wf = [Bf], Zf = [Vf], Yf = [Af], Kf = [Nf];
      class qf extends Cl {
        constructor(t2, e2, i2, n2) {
          super(), this.tolerance = t2, this.maxExtent = e2, this.pixelRatio = n2, this.maxLineWidth = 0, this.resolution = i2, this.beginGeometryInstruction1_ = null, this.beginGeometryInstruction2_ = null, this.bufferedMaxExtent_ = null, this.instructions = [], this.coordinates = [], this.tmpCoordinate_ = [], this.hitDetectionInstructions = [], this.state = {};
        }
        applyPixelRatio(t2) {
          const e2 = this.pixelRatio;
          return 1 == e2 ? t2 : t2.map(function(t3) {
            return t3 * e2;
          });
        }
        appendFlatPointCoordinates(t2, e2) {
          const i2 = this.getBufferedMaxExtent(), n2 = this.tmpCoordinate_, r2 = this.coordinates;
          let s2 = r2.length;
          for (let o2 = 0, a2 = t2.length; o2 < a2; o2 += e2)
            n2[0] = t2[o2], n2[1] = t2[o2 + 1], Zt(i2, n2) && (r2[s2++] = n2[0], r2[s2++] = n2[1]);
          return s2;
        }
        appendFlatLineCoordinates(t2, e2, i2, n2, r2, s2) {
          const o2 = this.coordinates;
          let a2 = o2.length;
          const l2 = this.getBufferedMaxExtent();
          s2 && (e2 += n2);
          let h2 = t2[e2], c2 = t2[e2 + 1];
          const u2 = this.tmpCoordinate_;
          let d2, g2, f2, p2 = true;
          for (d2 = e2 + n2; d2 < i2; d2 += n2)
            u2[0] = t2[d2], u2[1] = t2[d2 + 1], f2 = qt(l2, u2), f2 !== g2 ? (p2 && (o2[a2++] = h2, o2[a2++] = c2, p2 = false), o2[a2++] = u2[0], o2[a2++] = u2[1]) : f2 === kt ? (o2[a2++] = u2[0], o2[a2++] = u2[1], p2 = false) : p2 = true, h2 = u2[0], c2 = u2[1], g2 = f2;
          return (r2 && p2 || d2 === e2 + n2) && (o2[a2++] = h2, o2[a2++] = c2), a2;
        }
        drawCustomCoordinates_(t2, e2, i2, n2, r2) {
          for (let s2 = 0, o2 = i2.length; s2 < o2; ++s2) {
            const o3 = i2[s2], a2 = this.appendFlatLineCoordinates(t2, e2, o3, n2, false, false);
            r2.push(a2), e2 = o3;
          }
          return e2;
        }
        drawCustom(t2, e2, i2, n2) {
          this.beginGeometry(t2, e2);
          const r2 = t2.getType(), s2 = t2.getStride(), o2 = this.coordinates.length;
          let a2, l2, h2, c2, u2;
          switch (r2) {
            case "MultiPolygon":
              a2 = t2.getOrientedFlatCoordinates(), c2 = [];
              const e3 = t2.getEndss();
              u2 = 0;
              for (let t3 = 0, i3 = e3.length; t3 < i3; ++t3) {
                const i4 = [];
                u2 = this.drawCustomCoordinates_(a2, u2, e3[t3], s2, i4), c2.push(i4);
              }
              this.instructions.push([Df, o2, c2, t2, i2, Bn]), this.hitDetectionInstructions.push([Df, o2, c2, t2, n2 || i2, Bn]);
              break;
            case "Polygon":
            case "MultiLineString":
              h2 = [], a2 = "Polygon" == r2 ? t2.getOrientedFlatCoordinates() : t2.getFlatCoordinates(), u2 = this.drawCustomCoordinates_(a2, 0, t2.getEnds(), s2, h2), this.instructions.push([Df, o2, h2, t2, i2, jn]), this.hitDetectionInstructions.push([Df, o2, h2, t2, n2 || i2, jn]);
              break;
            case "LineString":
            case "Circle":
              a2 = t2.getFlatCoordinates(), l2 = this.appendFlatLineCoordinates(a2, 0, a2.length, s2, false, false), this.instructions.push([Df, o2, l2, t2, i2, Gn]), this.hitDetectionInstructions.push([Df, o2, l2, t2, n2 || i2, Gn]);
              break;
            case "MultiPoint":
              a2 = t2.getFlatCoordinates(), l2 = this.appendFlatPointCoordinates(a2, s2), l2 > o2 && (this.instructions.push([Df, o2, l2, t2, i2, Gn]), this.hitDetectionInstructions.push([Df, o2, l2, t2, n2 || i2, Gn]));
              break;
            case "Point":
              a2 = t2.getFlatCoordinates(), this.coordinates.push(a2[0], a2[1]), l2 = this.coordinates.length, this.instructions.push([Df, o2, l2, t2, i2]), this.hitDetectionInstructions.push([Df, o2, l2, t2, n2 || i2]);
          }
          this.endGeometry(e2);
        }
        beginGeometry(t2, e2) {
          this.beginGeometryInstruction1_ = [Ff, e2, 0, t2], this.instructions.push(this.beginGeometryInstruction1_), this.beginGeometryInstruction2_ = [Ff, e2, 0, t2], this.hitDetectionInstructions.push(this.beginGeometryInstruction2_);
        }
        finish() {
          return { instructions: this.instructions, hitDetectionInstructions: this.hitDetectionInstructions, coordinates: this.coordinates };
        }
        reverseHitDetectionInstructions() {
          const t2 = this.hitDetectionInstructions;
          let e2;
          t2.reverse();
          const i2 = t2.length;
          let n2, r2, s2 = -1;
          for (e2 = 0; e2 < i2; ++e2)
            n2 = t2[e2], r2 = n2[0], r2 == jf ? s2 = e2 : r2 == Ff && (n2[2] = e2, h(this.hitDetectionInstructions, s2, e2), s2 = -1);
        }
        setFillStrokeStyle(t2, e2) {
          const i2 = this.state;
          if (t2) {
            const e3 = t2.getColor();
            i2.fillStyle = fl(e3 || Ns);
          } else
            i2.fillStyle = void 0;
          if (e2) {
            const t3 = e2.getColor();
            i2.strokeStyle = fl(t3 || Bs);
            const n2 = e2.getLineCap();
            i2.lineCap = void 0 !== n2 ? n2 : Ds;
            const r2 = e2.getLineDash();
            i2.lineDash = r2 ? r2.slice() : ks;
            const s2 = e2.getLineDashOffset();
            i2.lineDashOffset = s2 || 0;
            const o2 = e2.getLineJoin();
            i2.lineJoin = void 0 !== o2 ? o2 : Gs;
            const a2 = e2.getWidth();
            i2.lineWidth = void 0 !== a2 ? a2 : 1;
            const l2 = e2.getMiterLimit();
            i2.miterLimit = void 0 !== l2 ? l2 : js, i2.lineWidth > this.maxLineWidth && (this.maxLineWidth = i2.lineWidth, this.bufferedMaxExtent_ = null);
          } else
            i2.strokeStyle = void 0, i2.lineCap = void 0, i2.lineDash = null, i2.lineDashOffset = void 0, i2.lineJoin = void 0, i2.lineWidth = void 0, i2.miterLimit = void 0;
        }
        createFill(t2) {
          const e2 = t2.fillStyle, i2 = [zf, e2];
          return "string" != typeof e2 && i2.push(true), i2;
        }
        applyStroke(t2) {
          this.instructions.push(this.createStroke(t2));
        }
        createStroke(t2) {
          return [Xf, t2.strokeStyle, t2.lineWidth * this.pixelRatio, t2.lineCap, t2.lineJoin, t2.miterLimit, this.applyPixelRatio(t2.lineDash), t2.lineDashOffset * this.pixelRatio];
        }
        updateFillStyle(t2, e2) {
          const i2 = t2.fillStyle;
          "string" == typeof i2 && t2.currentFillStyle == i2 || (void 0 !== i2 && this.instructions.push(e2.call(this, t2)), t2.currentFillStyle = i2);
        }
        updateStrokeStyle(t2, e2) {
          const i2 = t2.strokeStyle, n2 = t2.lineCap, r2 = t2.lineDash, s2 = t2.lineDashOffset, o2 = t2.lineJoin, a2 = t2.lineWidth, l2 = t2.miterLimit;
          (t2.currentStrokeStyle != i2 || t2.currentLineCap != n2 || r2 != t2.currentLineDash && !u(t2.currentLineDash, r2) || t2.currentLineDashOffset != s2 || t2.currentLineJoin != o2 || t2.currentLineWidth != a2 || t2.currentMiterLimit != l2) && (void 0 !== i2 && e2.call(this, t2), t2.currentStrokeStyle = i2, t2.currentLineCap = n2, t2.currentLineDash = r2, t2.currentLineDashOffset = s2, t2.currentLineJoin = o2, t2.currentLineWidth = a2, t2.currentMiterLimit = l2);
        }
        endGeometry(t2) {
          this.beginGeometryInstruction1_[2] = this.instructions.length, this.beginGeometryInstruction1_ = null, this.beginGeometryInstruction2_[2] = this.hitDetectionInstructions.length, this.beginGeometryInstruction2_ = null;
          const e2 = [jf, t2];
          this.instructions.push(e2), this.hitDetectionInstructions.push(e2);
        }
        getBufferedMaxExtent() {
          if (!this.bufferedMaxExtent_ && (this.bufferedMaxExtent_ = Vt(this.maxExtent), this.maxLineWidth > 0)) {
            const t2 = this.resolution * (this.maxLineWidth + 1) / 2;
            Xt(this.bufferedMaxExtent_, t2, this.bufferedMaxExtent_);
          }
          return this.bufferedMaxExtent_;
        }
      }
      class Hf extends qf {
        constructor(t2, e2, i2, n2) {
          super(t2, e2, i2, n2), this.hitDetectionImage_ = null, this.image_ = null, this.imagePixelRatio_ = void 0, this.anchorX_ = void 0, this.anchorY_ = void 0, this.height_ = void 0, this.opacity_ = void 0, this.originX_ = void 0, this.originY_ = void 0, this.rotateWithView_ = void 0, this.rotation_ = void 0, this.scale_ = void 0, this.width_ = void 0, this.declutterMode_ = void 0, this.declutterImageWithText_ = void 0;
        }
        drawPoint(t2, e2) {
          if (!this.image_)
            return;
          this.beginGeometry(t2, e2);
          const i2 = t2.getFlatCoordinates(), n2 = t2.getStride(), r2 = this.coordinates.length, s2 = this.appendFlatPointCoordinates(i2, n2);
          this.instructions.push([Gf, r2, s2, this.image_, this.anchorX_ * this.imagePixelRatio_, this.anchorY_ * this.imagePixelRatio_, Math.ceil(this.height_ * this.imagePixelRatio_), this.opacity_, this.originX_ * this.imagePixelRatio_, this.originY_ * this.imagePixelRatio_, this.rotateWithView_, this.rotation_, [this.scale_[0] * this.pixelRatio / this.imagePixelRatio_, this.scale_[1] * this.pixelRatio / this.imagePixelRatio_], Math.ceil(this.width_ * this.imagePixelRatio_), this.declutterMode_, this.declutterImageWithText_]), this.hitDetectionInstructions.push([Gf, r2, s2, this.hitDetectionImage_, this.anchorX_, this.anchorY_, this.height_, this.opacity_, this.originX_, this.originY_, this.rotateWithView_, this.rotation_, this.scale_, this.width_, this.declutterMode_, this.declutterImageWithText_]), this.endGeometry(e2);
        }
        drawMultiPoint(t2, e2) {
          if (!this.image_)
            return;
          this.beginGeometry(t2, e2);
          const i2 = t2.getFlatCoordinates(), n2 = t2.getStride(), r2 = this.coordinates.length, s2 = this.appendFlatPointCoordinates(i2, n2);
          this.instructions.push([Gf, r2, s2, this.image_, this.anchorX_ * this.imagePixelRatio_, this.anchorY_ * this.imagePixelRatio_, Math.ceil(this.height_ * this.imagePixelRatio_), this.opacity_, this.originX_ * this.imagePixelRatio_, this.originY_ * this.imagePixelRatio_, this.rotateWithView_, this.rotation_, [this.scale_[0] * this.pixelRatio / this.imagePixelRatio_, this.scale_[1] * this.pixelRatio / this.imagePixelRatio_], Math.ceil(this.width_ * this.imagePixelRatio_), this.declutterMode_, this.declutterImageWithText_]), this.hitDetectionInstructions.push([Gf, r2, s2, this.hitDetectionImage_, this.anchorX_, this.anchorY_, this.height_, this.opacity_, this.originX_, this.originY_, this.rotateWithView_, this.rotation_, this.scale_, this.width_, this.declutterMode_, this.declutterImageWithText_]), this.endGeometry(e2);
        }
        finish() {
          return this.reverseHitDetectionInstructions(), this.anchorX_ = void 0, this.anchorY_ = void 0, this.hitDetectionImage_ = null, this.image_ = null, this.imagePixelRatio_ = void 0, this.height_ = void 0, this.scale_ = void 0, this.opacity_ = void 0, this.originX_ = void 0, this.originY_ = void 0, this.rotateWithView_ = void 0, this.rotation_ = void 0, this.width_ = void 0, super.finish();
        }
        setImageStyle(t2, e2) {
          const i2 = t2.getAnchor(), n2 = t2.getSize(), r2 = t2.getOrigin();
          this.imagePixelRatio_ = t2.getPixelRatio(this.pixelRatio), this.anchorX_ = i2[0], this.anchorY_ = i2[1], this.hitDetectionImage_ = t2.getHitDetectionImage(), this.image_ = t2.getImage(this.pixelRatio), this.height_ = n2[1], this.opacity_ = t2.getOpacity(), this.originX_ = r2[0], this.originY_ = r2[1], this.rotateWithView_ = t2.getRotateWithView(), this.rotation_ = t2.getRotation(), this.scale_ = t2.getScaleArray(), this.width_ = n2[0], this.declutterMode_ = t2.getDeclutterMode(), this.declutterImageWithText_ = e2;
        }
      }
      class $f extends qf {
        constructor(t2, e2, i2, n2) {
          super(t2, e2, i2, n2);
        }
        drawFlatCoordinates_(t2, e2, i2, n2) {
          const r2 = this.coordinates.length, s2 = this.appendFlatLineCoordinates(t2, e2, i2, n2, false, false), o2 = [Uf, r2, s2];
          return this.instructions.push(o2), this.hitDetectionInstructions.push(o2), i2;
        }
        drawLineString(t2, e2) {
          const i2 = this.state, n2 = i2.strokeStyle, r2 = i2.lineWidth;
          if (void 0 === n2 || void 0 === r2)
            return;
          this.updateStrokeStyle(i2, this.applyStroke), this.beginGeometry(t2, e2), this.hitDetectionInstructions.push([Xf, i2.strokeStyle, i2.lineWidth, i2.lineCap, i2.lineJoin, i2.miterLimit, ks, 0], Yf);
          const s2 = t2.getFlatCoordinates(), o2 = t2.getStride();
          this.drawFlatCoordinates_(s2, 0, s2.length, o2), this.hitDetectionInstructions.push(Zf), this.endGeometry(e2);
        }
        drawMultiLineString(t2, e2) {
          const i2 = this.state, n2 = i2.strokeStyle, r2 = i2.lineWidth;
          if (void 0 === n2 || void 0 === r2)
            return;
          this.updateStrokeStyle(i2, this.applyStroke), this.beginGeometry(t2, e2), this.hitDetectionInstructions.push([Xf, i2.strokeStyle, i2.lineWidth, i2.lineCap, i2.lineJoin, i2.miterLimit, i2.lineDash, i2.lineDashOffset], Yf);
          const s2 = t2.getEnds(), o2 = t2.getFlatCoordinates(), a2 = t2.getStride();
          let l2 = 0;
          for (let t3 = 0, e3 = s2.length; t3 < e3; ++t3)
            l2 = this.drawFlatCoordinates_(o2, l2, s2[t3], a2);
          this.hitDetectionInstructions.push(Zf), this.endGeometry(e2);
        }
        finish() {
          const t2 = this.state;
          return null != t2.lastStroke && t2.lastStroke != this.coordinates.length && this.instructions.push(Zf), this.reverseHitDetectionInstructions(), this.state = null, super.finish();
        }
        applyStroke(t2) {
          null != t2.lastStroke && t2.lastStroke != this.coordinates.length && (this.instructions.push(Zf), t2.lastStroke = this.coordinates.length), t2.lastStroke = 0, super.applyStroke(t2), this.instructions.push(Yf);
        }
      }
      class Jf extends qf {
        constructor(t2, e2, i2, n2) {
          super(t2, e2, i2, n2);
        }
        drawFlatCoordinatess_(t2, e2, i2, n2) {
          const r2 = this.state, s2 = void 0 !== r2.fillStyle, o2 = void 0 !== r2.strokeStyle, a2 = i2.length;
          this.instructions.push(Yf), this.hitDetectionInstructions.push(Yf);
          for (let r3 = 0; r3 < a2; ++r3) {
            const s3 = i2[r3], a3 = this.coordinates.length, l2 = this.appendFlatLineCoordinates(t2, e2, s3, n2, true, !o2), h2 = [Uf, a3, l2];
            this.instructions.push(h2), this.hitDetectionInstructions.push(h2), o2 && (this.instructions.push(Kf), this.hitDetectionInstructions.push(Kf)), e2 = s3;
          }
          return s2 && (this.instructions.push(Wf), this.hitDetectionInstructions.push(Wf)), o2 && (this.instructions.push(Zf), this.hitDetectionInstructions.push(Zf)), e2;
        }
        drawCircle(t2, e2) {
          const i2 = this.state, n2 = i2.fillStyle, r2 = i2.strokeStyle;
          if (void 0 === n2 && void 0 === r2)
            return;
          this.setFillStrokeStyles_(), this.beginGeometry(t2, e2), void 0 !== i2.fillStyle && this.hitDetectionInstructions.push([zf, Ns]), void 0 !== i2.strokeStyle && this.hitDetectionInstructions.push([Xf, i2.strokeStyle, i2.lineWidth, i2.lineCap, i2.lineJoin, i2.miterLimit, i2.lineDash, i2.lineDashOffset]);
          const s2 = t2.getFlatCoordinates(), o2 = t2.getStride(), a2 = this.coordinates.length;
          this.appendFlatLineCoordinates(s2, 0, s2.length, o2, false, false);
          const l2 = [Of, a2];
          this.instructions.push(Yf, l2), this.hitDetectionInstructions.push(Yf, l2), void 0 !== i2.fillStyle && (this.instructions.push(Wf), this.hitDetectionInstructions.push(Wf)), void 0 !== i2.strokeStyle && (this.instructions.push(Zf), this.hitDetectionInstructions.push(Zf)), this.endGeometry(e2);
        }
        drawPolygon(t2, e2) {
          const i2 = this.state, n2 = i2.fillStyle, r2 = i2.strokeStyle;
          if (void 0 === n2 && void 0 === r2)
            return;
          this.setFillStrokeStyles_(), this.beginGeometry(t2, e2), void 0 !== i2.fillStyle && this.hitDetectionInstructions.push([zf, Ns]), void 0 !== i2.strokeStyle && this.hitDetectionInstructions.push([Xf, i2.strokeStyle, i2.lineWidth, i2.lineCap, i2.lineJoin, i2.miterLimit, i2.lineDash, i2.lineDashOffset]);
          const s2 = t2.getEnds(), o2 = t2.getOrientedFlatCoordinates(), a2 = t2.getStride();
          this.drawFlatCoordinatess_(o2, 0, s2, a2), this.endGeometry(e2);
        }
        drawMultiPolygon(t2, e2) {
          const i2 = this.state, n2 = i2.fillStyle, r2 = i2.strokeStyle;
          if (void 0 === n2 && void 0 === r2)
            return;
          this.setFillStrokeStyles_(), this.beginGeometry(t2, e2), void 0 !== i2.fillStyle && this.hitDetectionInstructions.push([zf, Ns]), void 0 !== i2.strokeStyle && this.hitDetectionInstructions.push([Xf, i2.strokeStyle, i2.lineWidth, i2.lineCap, i2.lineJoin, i2.miterLimit, i2.lineDash, i2.lineDashOffset]);
          const s2 = t2.getEndss(), o2 = t2.getOrientedFlatCoordinates(), a2 = t2.getStride();
          let l2 = 0;
          for (let t3 = 0, e3 = s2.length; t3 < e3; ++t3)
            l2 = this.drawFlatCoordinatess_(o2, l2, s2[t3], a2);
          this.endGeometry(e2);
        }
        finish() {
          this.reverseHitDetectionInstructions(), this.state = null;
          const t2 = this.tolerance;
          if (0 !== t2) {
            const e2 = this.coordinates;
            for (let i2 = 0, n2 = e2.length; i2 < n2; ++i2)
              e2[i2] = On(e2[i2], t2);
          }
          return super.finish();
        }
        setFillStrokeStyles_() {
          const t2 = this.state;
          void 0 !== t2.fillStyle && this.updateFillStyle(t2, this.createFill), void 0 !== t2.strokeStyle && this.updateStrokeStyle(t2, this.applyStroke);
        }
      }
      function Qf(t2, e2, i2, n2, r2) {
        let s2, o2, a2, l2, h2, c2, u2, d2, g2, f2, p2 = i2, m2 = i2, _2 = 0, y2 = 0, x2 = i2;
        for (o2 = i2; o2 < n2; o2 += r2) {
          const i3 = e2[o2], n3 = e2[o2 + 1];
          void 0 !== h2 && (g2 = i3 - h2, f2 = n3 - c2, l2 = Math.sqrt(g2 * g2 + f2 * f2), void 0 !== u2 && (y2 += a2, s2 = Math.acos((u2 * g2 + d2 * f2) / (a2 * l2)), s2 > t2 && (y2 > _2 && (_2 = y2, p2 = x2, m2 = o2), y2 = 0, x2 = o2 - r2)), a2 = l2, u2 = g2, d2 = f2), h2 = i3, c2 = n3;
        }
        return y2 += l2, y2 > _2 ? [x2, o2] : [p2, m2];
      }
      const tp = { left: 0, end: 0, center: 0.5, right: 1, start: 1, top: 0, middle: 0.5, hanging: 0.2, alphabetic: 0.8, ideographic: 0.8, bottom: 1 };
      class ep extends qf {
        constructor(t2, e2, i2, n2) {
          super(t2, e2, i2, n2), this.labels_ = null, this.text_ = "", this.textOffsetX_ = 0, this.textOffsetY_ = 0, this.textRotateWithView_ = void 0, this.textRotation_ = 0, this.textFillState_ = null, this.fillStates = {}, this.textStrokeState_ = null, this.strokeStates = {}, this.textState_ = {}, this.textStates = {}, this.textKey_ = "", this.fillKey_ = "", this.strokeKey_ = "", this.declutterImageWithText_ = void 0;
        }
        finish() {
          const t2 = super.finish();
          return t2.textStates = this.textStates, t2.fillStates = this.fillStates, t2.strokeStates = this.strokeStates, t2;
        }
        drawText(t2, e2) {
          const i2 = this.textFillState_, n2 = this.textStrokeState_, r2 = this.textState_;
          if ("" === this.text_ || !r2 || !i2 && !n2)
            return;
          const s2 = this.coordinates;
          let o2 = s2.length;
          const a2 = t2.getType();
          let l2 = null, h2 = t2.getStride();
          if ("line" !== r2.placement || "LineString" != a2 && "MultiLineString" != a2 && "Polygon" != a2 && "MultiPolygon" != a2) {
            let i3 = r2.overflow ? null : [];
            switch (a2) {
              case "Point":
              case "MultiPoint":
                l2 = t2.getFlatCoordinates();
                break;
              case "LineString":
                l2 = t2.getFlatMidpoint();
                break;
              case "Circle":
                l2 = t2.getCenter();
                break;
              case "MultiLineString":
                l2 = t2.getFlatMidpoints(), h2 = 2;
                break;
              case "Polygon":
                l2 = t2.getFlatInteriorPoint(), r2.overflow || i3.push(l2[2] / this.resolution), h2 = 3;
                break;
              case "MultiPolygon":
                const e3 = t2.getFlatInteriorPoints();
                l2 = [];
                for (let t3 = 0, n4 = e3.length; t3 < n4; t3 += 3)
                  r2.overflow || i3.push(e3[t3 + 2] / this.resolution), l2.push(e3[t3], e3[t3 + 1]);
                if (0 === l2.length)
                  return;
                h2 = 2;
            }
            const n3 = this.appendFlatPointCoordinates(l2, h2);
            if (n3 === o2)
              return;
            if (i3 && (n3 - o2) / 2 != l2.length / h2) {
              let t3 = o2 / 2;
              i3 = i3.filter((e3, i4) => {
                const n4 = s2[2 * (t3 + i4)] === l2[i4 * h2] && s2[2 * (t3 + i4) + 1] === l2[i4 * h2 + 1];
                return n4 || --t3, n4;
              });
            }
            this.saveTextStates_(), (r2.backgroundFill || r2.backgroundStroke) && (this.setFillStrokeStyle(r2.backgroundFill, r2.backgroundStroke), r2.backgroundFill && (this.updateFillStyle(this.state, this.createFill), this.hitDetectionInstructions.push(this.createFill(this.state))), r2.backgroundStroke && (this.updateStrokeStyle(this.state, this.applyStroke), this.hitDetectionInstructions.push(this.createStroke(this.state)))), this.beginGeometry(t2, e2);
            let c2 = r2.padding;
            if (c2 != Xs && (r2.scale[0] < 0 || r2.scale[1] < 0)) {
              let t3 = r2.padding[0], e3 = r2.padding[1], i4 = r2.padding[2], n4 = r2.padding[3];
              r2.scale[0] < 0 && (e3 = -e3, n4 = -n4), r2.scale[1] < 0 && (t3 = -t3, i4 = -i4), c2 = [t3, e3, i4, n4];
            }
            const u2 = this.pixelRatio;
            this.instructions.push([Gf, o2, n3, null, NaN, NaN, NaN, 1, 0, 0, this.textRotateWithView_, this.textRotation_, [1, 1], NaN, void 0, this.declutterImageWithText_, c2 == Xs ? Xs : c2.map(function(t3) {
              return t3 * u2;
            }), !!r2.backgroundFill, !!r2.backgroundStroke, this.text_, this.textKey_, this.strokeKey_, this.fillKey_, this.textOffsetX_, this.textOffsetY_, i3]);
            const d2 = 1 / u2;
            this.hitDetectionInstructions.push([Gf, o2, n3, null, NaN, NaN, NaN, 1, 0, 0, this.textRotateWithView_, this.textRotation_, [d2, d2], NaN, void 0, this.declutterImageWithText_, c2, !!r2.backgroundFill, !!r2.backgroundStroke, this.text_, this.textKey_, this.strokeKey_, this.fillKey_, this.textOffsetX_, this.textOffsetY_, i3]), this.endGeometry(e2);
          } else {
            if (!we(this.getBufferedMaxExtent(), t2.getExtent()))
              return;
            let i3;
            if (l2 = t2.getFlatCoordinates(), "LineString" == a2)
              i3 = [l2.length];
            else if ("MultiLineString" == a2)
              i3 = t2.getEnds();
            else if ("Polygon" == a2)
              i3 = t2.getEnds().slice(0, 1);
            else if ("MultiPolygon" == a2) {
              const e3 = t2.getEndss();
              i3 = [];
              for (let t3 = 0, n4 = e3.length; t3 < n4; ++t3)
                i3.push(e3[t3][0]);
            }
            this.beginGeometry(t2, e2);
            const n3 = r2.textAlign;
            let c2, u2 = 0;
            for (let t3 = 0, e3 = i3.length; t3 < e3; ++t3) {
              if (null == n3) {
                const e5 = Qf(r2.maxAngle, l2, u2, i3[t3], h2);
                u2 = e5[0], c2 = e5[1];
              } else
                c2 = i3[t3];
              for (let t4 = u2; t4 < c2; t4 += h2)
                s2.push(l2[t4], l2[t4 + 1]);
              const e4 = s2.length;
              u2 = i3[t3], this.drawChars_(o2, e4), o2 = e4;
            }
            this.endGeometry(e2);
          }
        }
        saveTextStates_() {
          const t2 = this.textStrokeState_, e2 = this.textState_, i2 = this.textFillState_, n2 = this.strokeKey_;
          t2 && (n2 in this.strokeStates || (this.strokeStates[n2] = { strokeStyle: t2.strokeStyle, lineCap: t2.lineCap, lineDashOffset: t2.lineDashOffset, lineWidth: t2.lineWidth, lineJoin: t2.lineJoin, miterLimit: t2.miterLimit, lineDash: t2.lineDash }));
          const r2 = this.textKey_;
          r2 in this.textStates || (this.textStates[r2] = { font: e2.font, textAlign: e2.textAlign || Us, justify: e2.justify, textBaseline: e2.textBaseline || zs, scale: e2.scale });
          const s2 = this.fillKey_;
          i2 && (s2 in this.fillStates || (this.fillStates[s2] = { fillStyle: i2.fillStyle }));
        }
        drawChars_(t2, e2) {
          const i2 = this.textStrokeState_, n2 = this.textState_, r2 = this.strokeKey_, s2 = this.textKey_, o2 = this.fillKey_;
          this.saveTextStates_();
          const a2 = this.pixelRatio, l2 = tp[n2.textBaseline], h2 = this.textOffsetY_ * a2, c2 = this.text_, u2 = i2 ? i2.lineWidth * Math.abs(n2.scale[0]) / 2 : 0;
          this.instructions.push([kf, t2, e2, l2, n2.overflow, o2, n2.maxAngle, a2, h2, r2, u2 * a2, c2, s2, 1]), this.hitDetectionInstructions.push([kf, t2, e2, l2, n2.overflow, o2, n2.maxAngle, 1, h2, r2, u2, c2, s2, 1 / a2]);
        }
        setTextStyle(t2, e2) {
          let i2, n2, r2;
          if (t2) {
            const e3 = t2.getFill();
            e3 ? (n2 = this.textFillState_, n2 || (n2 = {}, this.textFillState_ = n2), n2.fillStyle = fl(e3.getColor() || Ns)) : (n2 = null, this.textFillState_ = n2);
            const s2 = t2.getStroke();
            if (s2) {
              r2 = this.textStrokeState_, r2 || (r2 = {}, this.textStrokeState_ = r2);
              const t3 = s2.getLineDash(), e4 = s2.getLineDashOffset(), i3 = s2.getWidth(), n3 = s2.getMiterLimit();
              r2.lineCap = s2.getLineCap() || Ds, r2.lineDash = t3 ? t3.slice() : ks, r2.lineDashOffset = void 0 === e4 ? 0 : e4, r2.lineJoin = s2.getLineJoin() || Gs, r2.lineWidth = void 0 === i3 ? 1 : i3, r2.miterLimit = void 0 === n3 ? js : n3, r2.strokeStyle = fl(s2.getColor() || Bs);
            } else
              r2 = null, this.textStrokeState_ = r2;
            i2 = this.textState_;
            const o2 = t2.getFont() || Os;
            Ks(o2);
            const a2 = t2.getScaleArray();
            i2.overflow = t2.getOverflow(), i2.font = o2, i2.maxAngle = t2.getMaxAngle(), i2.placement = t2.getPlacement(), i2.textAlign = t2.getTextAlign(), i2.justify = t2.getJustify(), i2.textBaseline = t2.getTextBaseline() || zs, i2.backgroundFill = t2.getBackgroundFill(), i2.backgroundStroke = t2.getBackgroundStroke(), i2.padding = t2.getPadding() || Xs, i2.scale = void 0 === a2 ? [1, 1] : a2;
            const l2 = t2.getOffsetX(), h2 = t2.getOffsetY(), c2 = t2.getRotateWithView(), u2 = t2.getRotation();
            this.text_ = t2.getText() || "", this.textOffsetX_ = void 0 === l2 ? 0 : l2, this.textOffsetY_ = void 0 === h2 ? 0 : h2, this.textRotateWithView_ = void 0 !== c2 && c2, this.textRotation_ = void 0 === u2 ? 0 : u2, this.strokeKey_ = r2 ? ("string" == typeof r2.strokeStyle ? r2.strokeStyle : z(r2.strokeStyle)) + r2.lineCap + r2.lineDashOffset + "|" + r2.lineWidth + r2.lineJoin + r2.miterLimit + "[" + r2.lineDash.join() + "]" : "", this.textKey_ = i2.font + i2.scale + (i2.textAlign || "?") + (i2.justify || "?") + (i2.textBaseline || "?"), this.fillKey_ = n2 ? "string" == typeof n2.fillStyle ? n2.fillStyle : "|" + z(n2.fillStyle) : "";
          } else
            this.text_ = "";
          this.declutterImageWithText_ = e2;
        }
      }
      const ip = { Circle: Jf, Default: qf, Image: Hf, LineString: $f, Polygon: Jf, Text: ep };
      class np {
        constructor(t2, e2, i2, n2) {
          this.tolerance_ = t2, this.maxExtent_ = e2, this.pixelRatio_ = n2, this.resolution_ = i2, this.buildersByZIndex_ = {};
        }
        finish() {
          const t2 = {};
          for (const e2 in this.buildersByZIndex_) {
            t2[e2] = t2[e2] || {};
            const i2 = this.buildersByZIndex_[e2];
            for (const n2 in i2) {
              const r2 = i2[n2].finish();
              t2[e2][n2] = r2;
            }
          }
          return t2;
        }
        getBuilder(t2, e2) {
          const i2 = void 0 !== t2 ? t2.toString() : "0";
          let n2 = this.buildersByZIndex_[i2];
          void 0 === n2 && (n2 = {}, this.buildersByZIndex_[i2] = n2);
          let r2 = n2[e2];
          if (void 0 === r2) {
            r2 = new (0, ip[e2])(this.tolerance_, this.maxExtent_, this.resolution_, this.pixelRatio_), n2[e2] = r2;
          }
          return r2;
        }
      }
      function rp(t2, e2, i2, n2, r2, s2, o2, a2, l2, h2, c2, u2) {
        let d2 = t2[e2], g2 = t2[e2 + 1], f2 = 0, p2 = 0, m2 = 0, _2 = 0;
        function y2() {
          f2 = d2, p2 = g2, d2 = t2[e2 += n2], g2 = t2[e2 + 1], _2 += m2, m2 = Math.sqrt((d2 - f2) * (d2 - f2) + (g2 - p2) * (g2 - p2));
        }
        do {
          y2();
        } while (e2 < i2 - n2 && _2 + m2 < s2);
        let x2 = 0 === m2 ? 0 : (s2 - _2) / m2;
        const v2 = hi(f2, d2, x2), S2 = hi(p2, g2, x2), w2 = e2 - n2, E2 = _2, T2 = s2 + a2 * l2(h2, r2, c2);
        for (; e2 < i2 - n2 && _2 + m2 < T2; )
          y2();
        x2 = 0 === m2 ? 0 : (T2 - _2) / m2;
        const C2 = hi(f2, d2, x2), b2 = hi(p2, g2, x2);
        let R2;
        if (u2) {
          const t3 = [v2, S2, C2, b2];
          dn(t3, 0, 4, 2, u2, t3, t3), R2 = t3[0] > t3[2];
        } else
          R2 = v2 > C2;
        const P2 = Math.PI, I2 = [], L2 = w2 + n2 === e2;
        let M2;
        if (m2 = 0, _2 = E2, d2 = t2[e2 = w2], g2 = t2[e2 + 1], L2) {
          y2(), M2 = Math.atan2(g2 - p2, d2 - f2), R2 && (M2 += M2 > 0 ? -P2 : P2);
          const t3 = (C2 + v2) / 2, e3 = (b2 + S2) / 2;
          return I2[0] = [t3, e3, (T2 - s2) / 2, M2, r2], I2;
        }
        for (let t3 = 0, u3 = (r2 = r2.replace(/\n/g, " ")).length; t3 < u3; ) {
          y2();
          let v3 = Math.atan2(g2 - p2, d2 - f2);
          if (R2 && (v3 += v3 > 0 ? -P2 : P2), void 0 !== M2) {
            let t4 = v3 - M2;
            if (t4 += t4 > P2 ? -2 * P2 : t4 < -P2 ? 2 * P2 : 0, Math.abs(t4) > o2)
              return null;
          }
          M2 = v3;
          const S3 = t3;
          let w3 = 0;
          for (; t3 < u3; ++t3) {
            const o3 = a2 * l2(h2, r2[R2 ? u3 - t3 - 1 : t3], c2);
            if (e2 + n2 < i2 && _2 + m2 < s2 + w3 + o3 / 2)
              break;
            w3 += o3;
          }
          if (t3 === S3)
            continue;
          const E3 = R2 ? r2.substring(u3 - S3, u3 - t3) : r2.substring(S3, t3);
          x2 = 0 === m2 ? 0 : (s2 + w3 / 2 - _2) / m2;
          const T3 = hi(f2, d2, x2), C3 = hi(p2, g2, x2);
          I2.push([T3, C3, w3 / 2, v3, E3]), s2 += w3;
        }
        return I2;
      }
      function sp(t2, e2, i2, n2) {
        let r2 = t2[e2], s2 = t2[e2 + 1], o2 = 0;
        for (let a2 = e2 + n2; a2 < i2; a2 += n2) {
          const e3 = t2[a2], i3 = t2[a2 + 1];
          o2 += Math.sqrt((e3 - r2) * (e3 - r2) + (i3 - s2) * (i3 - s2)), r2 = e3, s2 = i3;
        }
        return o2;
      }
      const op = [1 / 0, 1 / 0, -1 / 0, -1 / 0], ap = [], lp = [], hp = [], cp = [];
      function up(t2) {
        return t2[3].declutterBox;
      }
      const dp = new RegExp("[" + String.fromCharCode(1425) + "-" + String.fromCharCode(2303) + String.fromCharCode(64285) + "-" + String.fromCharCode(65023) + String.fromCharCode(65136) + "-" + String.fromCharCode(65276) + String.fromCharCode(67584) + "-" + String.fromCharCode(69631) + String.fromCharCode(124928) + "-" + String.fromCharCode(126975) + "]");
      function gp(t2, e2) {
        return "start" !== e2 && "end" !== e2 || dp.test(t2) || (e2 = "start" === e2 ? "left" : "right"), tp[e2];
      }
      function fp(t2, e2, i2) {
        return i2 > 0 && t2.push("\n", ""), t2.push(e2, ""), t2;
      }
      class pp {
        constructor(t2, e2, i2, n2) {
          this.overlaps = i2, this.pixelRatio = e2, this.resolution = t2, this.alignFill_, this.instructions = n2.instructions, this.coordinates = n2.coordinates, this.coordinateCache_ = {}, this.renderedTransform_ = [1, 0, 0, 1, 0, 0], this.hitDetectionInstructions = n2.hitDetectionInstructions, this.pixelCoordinates_ = null, this.viewRotation_ = 0, this.fillStates = n2.fillStates || {}, this.strokeStates = n2.strokeStates || {}, this.textStates = n2.textStates || {}, this.widths_ = {}, this.labels_ = {};
        }
        createLabel(t2, e2, i2, n2) {
          const r2 = t2 + e2 + i2 + n2;
          if (this.labels_[r2])
            return this.labels_[r2];
          const s2 = n2 ? this.strokeStates[n2] : null, o2 = i2 ? this.fillStates[i2] : null, a2 = this.textStates[e2], l2 = this.pixelRatio, h2 = [a2.scale[0] * l2, a2.scale[1] * l2], c2 = Array.isArray(t2), u2 = a2.justify ? tp[a2.justify] : gp(Array.isArray(t2) ? t2[0] : t2, a2.textAlign || Us), d2 = n2 && s2.lineWidth ? s2.lineWidth : 0, g2 = c2 ? t2 : t2.split("\n").reduce(fp, []), { width: f2, height: p2, widths: m2, heights: _2, lineWidths: y2 } = Qs(a2, g2), x2 = f2 + d2, v2 = [], S2 = (x2 + 2) * h2[0], w2 = (p2 + d2) * h2[1], E2 = { width: S2 < 0 ? Math.floor(S2) : Math.ceil(S2), height: w2 < 0 ? Math.floor(w2) : Math.ceil(w2), contextInstructions: v2 };
          1 == h2[0] && 1 == h2[1] || v2.push("scale", h2), n2 && (v2.push("strokeStyle", s2.strokeStyle), v2.push("lineWidth", d2), v2.push("lineCap", s2.lineCap), v2.push("lineJoin", s2.lineJoin), v2.push("miterLimit", s2.miterLimit), v2.push("setLineDash", [s2.lineDash]), v2.push("lineDashOffset", s2.lineDashOffset)), i2 && v2.push("fillStyle", o2.fillStyle), v2.push("textBaseline", "middle"), v2.push("textAlign", "center");
          const T2 = 0.5 - u2;
          let C2 = u2 * x2 + T2 * d2;
          const b2 = [], R2 = [];
          let P2, I2 = 0, L2 = 0, M2 = 0, F2 = 0;
          for (let t3 = 0, e3 = g2.length; t3 < e3; t3 += 2) {
            const e4 = g2[t3];
            if ("\n" === e4) {
              L2 += I2, I2 = 0, C2 = u2 * x2 + T2 * d2, ++F2;
              continue;
            }
            const r3 = g2[t3 + 1] || a2.font;
            r3 !== P2 && (n2 && b2.push("font", r3), i2 && R2.push("font", r3), P2 = r3), I2 = Math.max(I2, _2[M2]);
            const s3 = [e4, C2 + T2 * m2[M2] + u2 * (m2[M2] - y2[F2]), 0.5 * (d2 + I2) + L2];
            C2 += m2[M2], n2 && b2.push("strokeText", s3), i2 && R2.push("fillText", s3), ++M2;
          }
          return Array.prototype.push.apply(v2, b2), Array.prototype.push.apply(v2, R2), this.labels_[r2] = E2, E2;
        }
        replayTextBackground_(t2, e2, i2, n2, r2, s2, o2) {
          t2.beginPath(), t2.moveTo.apply(t2, e2), t2.lineTo.apply(t2, i2), t2.lineTo.apply(t2, n2), t2.lineTo.apply(t2, r2), t2.lineTo.apply(t2, e2), s2 && (this.alignFill_ = s2[2], this.fill_(t2)), o2 && (this.setStrokeStyle_(t2, o2), t2.stroke());
        }
        calculateImageOrLabelDimensions_(t2, e2, i2, n2, r2, s2, o2, a2, l2, h2, c2, u2, d2, g2, f2, p2) {
          let m2 = i2 - (o2 *= u2[0]), _2 = n2 - (a2 *= u2[1]);
          const y2 = r2 + l2 > t2 ? t2 - l2 : r2, x2 = s2 + h2 > e2 ? e2 - h2 : s2, v2 = g2[3] + y2 * u2[0] + g2[1], S2 = g2[0] + x2 * u2[1] + g2[2], w2 = m2 - g2[3], E2 = _2 - g2[0];
          let T2;
          return (f2 || 0 !== c2) && (ap[0] = w2, cp[0] = w2, ap[1] = E2, lp[1] = E2, lp[0] = w2 + v2, hp[0] = lp[0], hp[1] = E2 + S2, cp[1] = hp[1]), 0 !== c2 ? (T2 = Mt([1, 0, 0, 1, 0, 0], i2, n2, 1, 1, c2, -i2, -n2), bt(T2, ap), bt(T2, lp), bt(T2, hp), bt(T2, cp), $t(Math.min(ap[0], lp[0], hp[0], cp[0]), Math.min(ap[1], lp[1], hp[1], cp[1]), Math.max(ap[0], lp[0], hp[0], cp[0]), Math.max(ap[1], lp[1], hp[1], cp[1]), op)) : $t(Math.min(w2, w2 + v2), Math.min(E2, E2 + S2), Math.max(w2, w2 + v2), Math.max(E2, E2 + S2), op), d2 && (m2 = Math.round(m2), _2 = Math.round(_2)), { drawImageX: m2, drawImageY: _2, drawImageW: y2, drawImageH: x2, originX: l2, originY: h2, declutterBox: { minX: op[0], minY: op[1], maxX: op[2], maxY: op[3], value: p2 }, canvasTransform: T2, scale: u2 };
        }
        replayImageOrLabel_(t2, e2, i2, n2, r2, s2, o2) {
          const a2 = !(!s2 && !o2), l2 = n2.declutterBox, h2 = t2.canvas, c2 = o2 ? o2[2] * n2.scale[0] / 2 : 0;
          return l2.minX - c2 <= h2.width / e2 && l2.maxX + c2 >= 0 && l2.minY - c2 <= h2.height / e2 && l2.maxY + c2 >= 0 && (a2 && this.replayTextBackground_(t2, ap, lp, hp, cp, s2, o2), to(t2, n2.canvasTransform, r2, i2, n2.originX, n2.originY, n2.drawImageW, n2.drawImageH, n2.drawImageX, n2.drawImageY, n2.scale)), true;
        }
        fill_(t2) {
          if (this.alignFill_) {
            const e2 = bt(this.renderedTransform_, [0, 0]), i2 = 512 * this.pixelRatio;
            t2.save(), t2.translate(e2[0] % i2, e2[1] % i2), t2.rotate(this.viewRotation_);
          }
          t2.fill(), this.alignFill_ && t2.restore();
        }
        setStrokeStyle_(t2, e2) {
          t2.strokeStyle = e2[1], t2.lineWidth = e2[2], t2.lineCap = e2[3], t2.lineJoin = e2[4], t2.miterLimit = e2[5], t2.lineDashOffset = e2[7], t2.setLineDash(e2[6]);
        }
        drawLabelWithPointPlacement_(t2, e2, i2, n2) {
          const r2 = this.textStates[e2], s2 = this.createLabel(t2, e2, n2, i2), o2 = this.strokeStates[i2], a2 = this.pixelRatio, l2 = gp(Array.isArray(t2) ? t2[0] : t2, r2.textAlign || Us), h2 = tp[r2.textBaseline || zs], c2 = o2 && o2.lineWidth ? o2.lineWidth : 0;
          return { label: s2, anchorX: l2 * (s2.width / a2 - 2 * r2.scale[0]) + 2 * (0.5 - l2) * c2, anchorY: h2 * s2.height / a2 + 2 * (0.5 - h2) * c2 };
        }
        execute_(t2, e2, i2, n2, r2, s2, o2, a2) {
          let l2;
          this.pixelCoordinates_ && u(i2, this.renderedTransform_) ? l2 = this.pixelCoordinates_ : (this.pixelCoordinates_ || (this.pixelCoordinates_ = []), l2 = un(this.coordinates, 0, this.coordinates.length, 2, i2, this.pixelCoordinates_), Ct(this.renderedTransform_, i2));
          let h2 = 0;
          const c2 = n2.length;
          let d2, g2, f2, p2, m2, _2, y2, x2, v2, S2, w2, E2, T2 = 0, C2 = 0, b2 = 0, R2 = null, P2 = null;
          const I2 = this.coordinateCache_, L2 = this.viewRotation_, M2 = Math.round(1e12 * Math.atan2(-i2[1], i2[0])) / 1e12, F2 = { context: t2, pixelRatio: this.pixelRatio, resolution: this.resolution, rotation: L2 }, A2 = this.instructions != n2 || this.overlaps ? 0 : 200;
          let O2, N2, D2, k2;
          for (; h2 < c2; ) {
            const i3 = n2[h2];
            switch (i3[0]) {
              case Ff:
                O2 = i3[1], k2 = i3[3], O2.getGeometry() ? void 0 === o2 || we(o2, k2.getExtent()) ? ++h2 : h2 = i3[2] + 1 : h2 = i3[2];
                break;
              case Af:
                C2 > A2 && (this.fill_(t2), C2 = 0), b2 > A2 && (t2.stroke(), b2 = 0), C2 || b2 || (t2.beginPath(), p2 = NaN, m2 = NaN), ++h2;
                break;
              case Of:
                T2 = i3[1];
                const n3 = l2[T2], c3 = l2[T2 + 1], u2 = l2[T2 + 2] - n3, G2 = l2[T2 + 3] - c3, j2 = Math.sqrt(u2 * u2 + G2 * G2);
                t2.moveTo(n3 + j2, c3), t2.arc(n3, c3, j2, 0, 2 * Math.PI, true), ++h2;
                break;
              case Nf:
                t2.closePath(), ++h2;
                break;
              case Df:
                T2 = i3[1], d2 = i3[2];
                const B2 = i3[3], U2 = i3[4], z2 = 6 == i3.length ? i3[5] : void 0;
                F2.geometry = B2, F2.feature = O2, h2 in I2 || (I2[h2] = []);
                const X2 = I2[h2];
                z2 ? z2(l2, T2, d2, 2, X2) : (X2[0] = l2[T2], X2[1] = l2[T2 + 1], X2.length = 2), U2(X2, F2), ++h2;
                break;
              case Gf:
                T2 = i3[1], d2 = i3[2], x2 = i3[3], g2 = i3[4], f2 = i3[5];
                let V2 = i3[6];
                const W2 = i3[7], Z2 = i3[8], Y2 = i3[9], K2 = i3[10];
                let q2 = i3[11];
                const H2 = i3[12];
                let $2 = i3[13];
                const J2 = i3[14], Q2 = i3[15];
                if (!x2 && i3.length >= 20) {
                  v2 = i3[19], S2 = i3[20], w2 = i3[21], E2 = i3[22];
                  const t3 = this.drawLabelWithPointPlacement_(v2, S2, w2, E2);
                  x2 = t3.label, i3[3] = x2;
                  const e3 = i3[23];
                  g2 = (t3.anchorX - e3) * this.pixelRatio, i3[4] = g2;
                  const n4 = i3[24];
                  f2 = (t3.anchorY - n4) * this.pixelRatio, i3[5] = f2, V2 = x2.height, i3[6] = V2, $2 = x2.width, i3[13] = $2;
                }
                let tt2, et2, it2, nt2;
                i3.length > 25 && (tt2 = i3[25]), i3.length > 17 ? (et2 = i3[16], it2 = i3[17], nt2 = i3[18]) : (et2 = Xs, it2 = false, nt2 = false), K2 && M2 ? q2 += L2 : K2 || M2 || (q2 -= L2);
                let rt2 = 0;
                for (; T2 < d2; T2 += 2) {
                  if (tt2 && tt2[rt2++] < $2 / this.pixelRatio)
                    continue;
                  const i4 = this.calculateImageOrLabelDimensions_(x2.width, x2.height, l2[T2], l2[T2 + 1], $2, V2, g2, f2, Z2, Y2, q2, H2, r2, et2, it2 || nt2, O2), n4 = [t2, e2, x2, i4, W2, it2 ? R2 : null, nt2 ? P2 : null];
                  if (a2) {
                    if ("none" === J2)
                      continue;
                    if ("obstacle" === J2) {
                      a2.insert(i4.declutterBox);
                      continue;
                    }
                    {
                      let t3, e3;
                      if (Q2) {
                        const i5 = d2 - T2;
                        if (!Q2[i5]) {
                          Q2[i5] = n4;
                          continue;
                        }
                        if (t3 = Q2[i5], delete Q2[i5], e3 = up(t3), a2.collides(e3))
                          continue;
                      }
                      if (a2.collides(i4.declutterBox))
                        continue;
                      t3 && (a2.insert(e3), this.replayImageOrLabel_.apply(this, t3)), a2.insert(i4.declutterBox);
                    }
                  }
                  this.replayImageOrLabel_.apply(this, n4);
                }
                ++h2;
                break;
              case kf:
                const st2 = i3[1], ot2 = i3[2], at2 = i3[3], lt2 = i3[4];
                E2 = i3[5];
                const ht2 = i3[6], ct2 = i3[7], ut2 = i3[8];
                w2 = i3[9];
                const dt2 = i3[10];
                v2 = i3[11], S2 = i3[12];
                const gt2 = [i3[13], i3[13]], ft2 = this.textStates[S2], pt2 = ft2.font, mt2 = [ft2.scale[0] * ct2, ft2.scale[1] * ct2];
                let _t2;
                pt2 in this.widths_ ? _t2 = this.widths_[pt2] : (_t2 = {}, this.widths_[pt2] = _t2);
                const yt2 = sp(l2, st2, ot2, 2), xt2 = Math.abs(mt2[0]) * Js(pt2, v2, _t2);
                if (lt2 || xt2 <= yt2) {
                  const i4 = this.textStates[S2].textAlign, n4 = rp(l2, st2, ot2, 2, v2, (yt2 - xt2) * tp[i4], ht2, Math.abs(mt2[0]), Js, pt2, _t2, M2 ? 0 : this.viewRotation_);
                  t:
                    if (n4) {
                      const i5 = [];
                      let r3, s3, o3, l3, h3;
                      if (w2)
                        for (r3 = 0, s3 = n4.length; r3 < s3; ++r3) {
                          h3 = n4[r3], o3 = h3[4], l3 = this.createLabel(o3, S2, "", w2), g2 = h3[2] + (mt2[0] < 0 ? -dt2 : dt2), f2 = at2 * l3.height + 2 * (0.5 - at2) * dt2 * mt2[1] / mt2[0] - ut2;
                          const s4 = this.calculateImageOrLabelDimensions_(l3.width, l3.height, h3[0], h3[1], l3.width, l3.height, g2, f2, 0, 0, h3[3], gt2, false, Xs, false, O2);
                          if (a2 && a2.collides(s4.declutterBox))
                            break t;
                          i5.push([t2, e2, l3, s4, 1, null, null]);
                        }
                      if (E2)
                        for (r3 = 0, s3 = n4.length; r3 < s3; ++r3) {
                          h3 = n4[r3], o3 = h3[4], l3 = this.createLabel(o3, S2, E2, ""), g2 = h3[2], f2 = at2 * l3.height - ut2;
                          const s4 = this.calculateImageOrLabelDimensions_(l3.width, l3.height, h3[0], h3[1], l3.width, l3.height, g2, f2, 0, 0, h3[3], gt2, false, Xs, false, O2);
                          if (a2 && a2.collides(s4.declutterBox))
                            break t;
                          i5.push([t2, e2, l3, s4, 1, null, null]);
                        }
                      a2 && a2.load(i5.map(up));
                      for (let t3 = 0, e3 = i5.length; t3 < e3; ++t3)
                        this.replayImageOrLabel_.apply(this, i5[t3]);
                    }
                }
                ++h2;
                break;
              case jf:
                if (void 0 !== s2) {
                  O2 = i3[1];
                  const t3 = s2(O2, k2);
                  if (t3)
                    return t3;
                }
                ++h2;
                break;
              case Bf:
                A2 ? C2++ : this.fill_(t2), ++h2;
                break;
              case Uf:
                for (T2 = i3[1], d2 = i3[2], N2 = l2[T2], D2 = l2[T2 + 1], _2 = N2 + 0.5 | 0, y2 = D2 + 0.5 | 0, _2 === p2 && y2 === m2 || (t2.moveTo(N2, D2), p2 = _2, m2 = y2), T2 += 2; T2 < d2; T2 += 2)
                  N2 = l2[T2], D2 = l2[T2 + 1], _2 = N2 + 0.5 | 0, y2 = D2 + 0.5 | 0, T2 != d2 - 2 && _2 === p2 && y2 === m2 || (t2.lineTo(N2, D2), p2 = _2, m2 = y2);
                ++h2;
                break;
              case zf:
                R2 = i3, this.alignFill_ = i3[2], C2 && (this.fill_(t2), C2 = 0, b2 && (t2.stroke(), b2 = 0)), t2.fillStyle = i3[1], ++h2;
                break;
              case Xf:
                P2 = i3, b2 && (t2.stroke(), b2 = 0), this.setStrokeStyle_(t2, i3), ++h2;
                break;
              case Vf:
                A2 ? b2++ : t2.stroke(), ++h2;
                break;
              default:
                ++h2;
            }
          }
          C2 && this.fill_(t2), b2 && t2.stroke();
        }
        execute(t2, e2, i2, n2, r2, s2) {
          this.viewRotation_ = n2, this.execute_(t2, e2, i2, this.instructions, r2, void 0, void 0, s2);
        }
        executeHitDetection(t2, e2, i2, n2, r2) {
          return this.viewRotation_ = i2, this.execute_(t2, 1, e2, this.hitDetectionInstructions, true, n2, r2);
        }
      }
      const mp = ["Polygon", "Circle", "LineString", "Image", "Text", "Default"];
      class _p {
        constructor(t2, e2, i2, n2, r2, s2) {
          this.maxExtent_ = t2, this.overlaps_ = n2, this.pixelRatio_ = i2, this.resolution_ = e2, this.renderBuffer_ = s2, this.executorsByZIndex_ = {}, this.hitDetectionContext_ = null, this.hitDetectionTransform_ = [1, 0, 0, 1, 0, 0], this.createExecutors_(r2);
        }
        clip(t2, e2) {
          const i2 = this.getClipCoords(e2);
          t2.beginPath(), t2.moveTo(i2[0], i2[1]), t2.lineTo(i2[2], i2[3]), t2.lineTo(i2[4], i2[5]), t2.lineTo(i2[6], i2[7]), t2.clip();
        }
        createExecutors_(t2) {
          for (const e2 in t2) {
            let i2 = this.executorsByZIndex_[e2];
            void 0 === i2 && (i2 = {}, this.executorsByZIndex_[e2] = i2);
            const n2 = t2[e2];
            for (const t3 in n2) {
              const e3 = n2[t3];
              i2[t3] = new pp(this.resolution_, this.pixelRatio_, this.overlaps_, e3);
            }
          }
        }
        hasExecutors(t2) {
          for (const e2 in this.executorsByZIndex_) {
            const i2 = this.executorsByZIndex_[e2];
            for (let e3 = 0, n2 = t2.length; e3 < n2; ++e3)
              if (t2[e3] in i2)
                return true;
          }
          return false;
        }
        forEachFeatureAtCoordinate(t2, e2, i2, n2, r2, s2) {
          const o2 = 2 * (n2 = Math.round(n2)) + 1, l2 = Mt(this.hitDetectionTransform_, n2 + 0.5, n2 + 0.5, 1 / e2, -1 / e2, -i2, -t2[0], -t2[1]), h2 = !this.hitDetectionContext_;
          h2 && (this.hitDetectionContext_ = Dr(o2, o2));
          const c2 = this.hitDetectionContext_;
          let u2;
          c2.canvas.width !== o2 || c2.canvas.height !== o2 ? (c2.canvas.width = o2, c2.canvas.height = o2) : h2 || c2.clearRect(0, 0, o2, o2), void 0 !== this.renderBuffer_ && (u2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], re(u2, t2), Xt(u2, e2 * (this.renderBuffer_ + n2), u2));
          const d2 = xp(n2);
          let g2;
          function f2(t3, e3) {
            const i3 = c2.getImageData(0, 0, o2, o2).data;
            for (let a2 = 0, l3 = d2.length; a2 < l3; a2++)
              if (i3[d2[a2]] > 0) {
                if (!s2 || "Image" !== g2 && "Text" !== g2 || s2.includes(t3)) {
                  const i4 = (d2[a2] - 3) / 4, s3 = n2 - i4 % o2, l4 = n2 - (i4 / o2 | 0), h3 = r2(t3, e3, s3 * s3 + l4 * l4);
                  if (h3)
                    return h3;
                }
                c2.clearRect(0, 0, o2, o2);
                break;
              }
          }
          const p2 = Object.keys(this.executorsByZIndex_).map(Number);
          let m2, _2, y2, x2, v2;
          for (p2.sort(a), m2 = p2.length - 1; m2 >= 0; --m2) {
            const t3 = p2[m2].toString();
            for (y2 = this.executorsByZIndex_[t3], _2 = mp.length - 1; _2 >= 0; --_2)
              if (g2 = mp[_2], x2 = y2[g2], void 0 !== x2 && (v2 = x2.executeHitDetection(c2, l2, i2, f2, u2), v2))
                return v2;
          }
        }
        getClipCoords(t2) {
          const e2 = this.maxExtent_;
          if (!e2)
            return null;
          const i2 = e2[0], n2 = e2[1], r2 = e2[2], s2 = e2[3], o2 = [i2, n2, i2, s2, r2, s2, r2, n2];
          return un(o2, 0, 8, 2, t2, o2), o2;
        }
        isEmpty() {
          return x(this.executorsByZIndex_);
        }
        execute(t2, e2, i2, n2, r2, s2, o2) {
          const l2 = Object.keys(this.executorsByZIndex_).map(Number);
          let h2, c2, u2, d2, g2, f2;
          for (l2.sort(a), this.maxExtent_ && (t2.save(), this.clip(t2, i2)), s2 = s2 || mp, o2 && l2.reverse(), h2 = 0, c2 = l2.length; h2 < c2; ++h2) {
            const a2 = l2[h2].toString();
            for (g2 = this.executorsByZIndex_[a2], u2 = 0, d2 = s2.length; u2 < d2; ++u2) {
              f2 = g2[s2[u2]], void 0 !== f2 && f2.execute(t2, e2, i2, n2, r2, o2);
            }
          }
          this.maxExtent_ && t2.restore();
        }
      }
      const yp = {};
      function xp(t2) {
        if (void 0 !== yp[t2])
          return yp[t2];
        const e2 = 2 * t2 + 1, i2 = t2 * t2, n2 = new Array(i2 + 1);
        for (let r3 = 0; r3 <= t2; ++r3)
          for (let s2 = 0; s2 <= t2; ++s2) {
            const o2 = r3 * r3 + s2 * s2;
            if (o2 > i2)
              break;
            let a2 = n2[o2];
            a2 || (a2 = [], n2[o2] = a2), a2.push(4 * ((t2 + r3) * e2 + (t2 + s2)) + 3), r3 > 0 && a2.push(4 * ((t2 - r3) * e2 + (t2 + s2)) + 3), s2 > 0 && (a2.push(4 * ((t2 + r3) * e2 + (t2 - s2)) + 3), r3 > 0 && a2.push(4 * ((t2 - r3) * e2 + (t2 - s2)) + 3));
          }
        const r2 = [];
        for (let t3 = 0, e3 = n2.length; t3 < e3; ++t3)
          n2[t3] && r2.push(...n2[t3]);
        return yp[t2] = r2, r2;
      }
      const vp = 0.5;
      function Sp(t2, e2, i2, n2, r2, s2, o2) {
        const l2 = Dr(t2[0] * vp, t2[1] * vp);
        l2.imageSmoothingEnabled = false;
        const h2 = l2.canvas, c2 = new bl(l2, vp, r2, null, o2), u2 = i2.length, d2 = Math.floor(16777215 / u2), g2 = {};
        for (let t3 = 1; t3 <= u2; ++t3) {
          const e3 = i2[t3 - 1], o3 = e3.getStyleFunction() || n2;
          if (!n2)
            continue;
          let a2 = o3(e3, s2);
          if (!a2)
            continue;
          Array.isArray(a2) || (a2 = [a2]);
          const l3 = "#" + ("000000" + (t3 * d2).toString(16)).slice(-6);
          for (let t4 = 0, i3 = a2.length; t4 < i3; ++t4) {
            const i4 = a2[t4], n3 = i4.getGeometryFunction()(e3);
            if (!n3 || !we(r2, n3.getExtent()))
              continue;
            const s3 = i4.clone(), o4 = s3.getFill();
            o4 && o4.setColor(l3);
            const h3 = s3.getStroke();
            h3 && (h3.setColor(l3), h3.setLineDash(null)), s3.setText(void 0);
            const c3 = i4.getImage();
            if (c3 && 0 !== c3.getOpacity()) {
              const t5 = c3.getImageSize();
              if (!t5)
                continue;
              const e4 = Dr(t5[0], t5[1], void 0, { alpha: false }), i5 = e4.canvas;
              e4.fillStyle = l3, e4.fillRect(0, 0, i5.width, i5.height), s3.setImage(new lg({ img: i5, imgSize: t5, anchor: c3.getAnchor(), anchorXUnits: "pixels", anchorYUnits: "pixels", offset: c3.getOrigin(), opacity: 1, size: c3.getSize(), scale: c3.getScale(), rotation: c3.getRotation(), rotateWithView: c3.getRotateWithView() }));
            }
            const u3 = s3.getZIndex() || 0;
            let d3 = g2[u3];
            d3 || (d3 = {}, g2[u3] = d3, d3.Polygon = [], d3.Circle = [], d3.LineString = [], d3.Point = []), d3[n3.getType().replace("Multi", "")].push(n3, s3);
          }
        }
        const f2 = Object.keys(g2).map(Number).sort(a);
        for (let t3 = 0, i3 = f2.length; t3 < i3; ++t3) {
          const i4 = g2[f2[t3]];
          for (const t4 in i4) {
            const n3 = i4[t4];
            for (let t5 = 0, i5 = n3.length; t5 < i5; t5 += 2) {
              c2.setStyle(n3[t5 + 1]);
              for (let i6 = 0, r3 = e2.length; i6 < r3; ++i6)
                c2.setTransform(e2[i6]), c2.drawGeometry(n3[t5]);
            }
          }
        }
        return l2.getImageData(0, 0, h2.width, h2.height);
      }
      function wp(t2, e2, i2) {
        const n2 = [];
        if (i2) {
          const r2 = Math.floor(Math.round(t2[0]) * vp), s2 = Math.floor(Math.round(t2[1]) * vp), o2 = 4 * (ii(r2, 0, i2.width - 1) + ii(s2, 0, i2.height - 1) * i2.width), a2 = i2.data[o2], l2 = i2.data[o2 + 1], h2 = i2.data[o2 + 2] + 256 * (l2 + 256 * a2), c2 = Math.floor(16777215 / e2.length);
          h2 && h2 % c2 == 0 && n2.push(e2[h2 / c2 - 1]);
        }
        return n2;
      }
      class Ep extends Pc {
        constructor(t2) {
          super(t2), this.boundHandleStyleImageChange_ = this.handleStyleImageChange_.bind(this), this.animatingOrInteracting_, this.hitDetectionImageData_ = null, this.renderedFeatures_ = null, this.renderedRevision_ = -1, this.renderedResolution_ = NaN, this.renderedExtent_ = [1 / 0, 1 / 0, -1 / 0, -1 / 0], this.wrappedRenderedExtent_ = [1 / 0, 1 / 0, -1 / 0, -1 / 0], this.renderedRotation_, this.renderedCenter_ = null, this.renderedProjection_ = null, this.renderedRenderOrder_ = null, this.replayGroup_ = null, this.replayGroupChanged = true, this.declutterExecutorGroup = null, this.clipping = true, this.compositionContext_ = null, this.opacity_ = 1;
        }
        renderWorlds(t2, e2, i2) {
          const n2 = e2.extent, r2 = e2.viewState, s2 = r2.center, o2 = r2.resolution, a2 = r2.projection, l2 = r2.rotation, h2 = a2.getExtent(), c2 = this.getLayer().getSource(), u2 = e2.pixelRatio, d2 = e2.viewHints, g2 = !(d2[Ro] || d2[Po]), f2 = this.compositionContext_, p2 = Math.round(e2.size[0] * u2), m2 = Math.round(e2.size[1] * u2), _2 = c2.getWrapX() && a2.canWrapX(), y2 = _2 ? Se(h2) : null, x2 = _2 ? Math.ceil((n2[2] - h2[2]) / y2) + 1 : 1;
          let v2 = _2 ? Math.floor((n2[0] - h2[0]) / y2) : 0;
          do {
            const e3 = this.getRenderTransform(s2, o2, l2, u2, p2, m2, v2 * y2);
            t2.execute(f2, 1, e3, l2, g2, void 0, i2);
          } while (++v2 < x2);
        }
        setupCompositionContext_() {
          if (1 !== this.opacity_) {
            const t2 = Dr(this.context.canvas.width, this.context.canvas.height, bc);
            this.compositionContext_ = t2;
          } else
            this.compositionContext_ = this.context;
        }
        releaseCompositionContext_() {
          if (1 !== this.opacity_) {
            const t2 = this.context.globalAlpha;
            this.context.globalAlpha = this.opacity_, this.context.drawImage(this.compositionContext_.canvas, 0, 0), this.context.globalAlpha = t2, kr(this.compositionContext_), bc.push(this.compositionContext_.canvas), this.compositionContext_ = null;
          }
        }
        renderDeclutter(t2) {
          this.declutterExecutorGroup && (this.setupCompositionContext_(), this.renderWorlds(this.declutterExecutorGroup, t2, t2.declutterTree), this.releaseCompositionContext_());
        }
        renderFrame(t2, e2) {
          const i2 = t2.pixelRatio, n2 = t2.layerStatesArray[t2.layerIndex];
          It(this.pixelTransform, 1 / i2, 1 / i2), Ft(this.inversePixelTransform, this.pixelTransform);
          const r2 = Nt(this.pixelTransform);
          this.useContainer(e2, r2, this.getBackground(t2));
          const s2 = this.context, o2 = s2.canvas, a2 = this.replayGroup_, l2 = this.declutterExecutorGroup;
          if ((!a2 || a2.isEmpty()) && (!l2 || l2.isEmpty()))
            return null;
          const h2 = Math.round(t2.size[0] * i2), c2 = Math.round(t2.size[1] * i2);
          o2.width != h2 || o2.height != c2 ? (o2.width = h2, o2.height = c2, o2.style.transform !== r2 && (o2.style.transform = r2)) : this.containerReused || s2.clearRect(0, 0, h2, c2), this.preRender(s2, t2);
          const u2 = t2.viewState, d2 = u2.projection;
          this.opacity_ = n2.opacity, this.setupCompositionContext_();
          let g2 = false, f2 = true;
          if (n2.extent && this.clipping) {
            const e3 = on(n2.extent, d2);
            f2 = we(e3, t2.extent), g2 = f2 && !Yt(e3, t2.extent), g2 && this.clipUnrotated(this.compositionContext_, t2, e3);
          }
          return f2 && this.renderWorlds(a2, t2), g2 && this.compositionContext_.restore(), this.releaseCompositionContext_(), this.postRender(s2, t2), this.renderedRotation_ !== u2.rotation && (this.renderedRotation_ = u2.rotation, this.hitDetectionImageData_ = null), this.container;
        }
        getFeatures(t2) {
          return new Promise(function(e2) {
            if (!this.hitDetectionImageData_ && !this.animatingOrInteracting_) {
              const t3 = [this.context.canvas.width, this.context.canvas.height];
              bt(this.pixelTransform, t3);
              const e3 = this.renderedCenter_, i2 = this.renderedResolution_, n2 = this.renderedRotation_, r2 = this.renderedProjection_, s2 = this.wrappedRenderedExtent_, o2 = this.getLayer(), a2 = [], l2 = t3[0] * vp, h2 = t3[1] * vp;
              a2.push(this.getRenderTransform(e3, i2, n2, vp, l2, h2, 0).slice());
              const c2 = o2.getSource(), u2 = r2.getExtent();
              if (c2.getWrapX() && r2.canWrapX() && !Yt(u2, s2)) {
                let t4 = s2[0];
                const r3 = Se(u2);
                let o3, c3 = 0;
                for (; t4 < u2[0]; )
                  --c3, o3 = r3 * c3, a2.push(this.getRenderTransform(e3, i2, n2, vp, l2, h2, o3).slice()), t4 += r3;
                for (c3 = 0, t4 = s2[2]; t4 > u2[2]; )
                  ++c3, o3 = r3 * c3, a2.push(this.getRenderTransform(e3, i2, n2, vp, l2, h2, o3).slice()), t4 -= r3;
              }
              this.hitDetectionImageData_ = Sp(t3, a2, this.renderedFeatures_, o2.getStyleFunction(), s2, i2, n2);
            }
            e2(wp(t2, this.renderedFeatures_, this.hitDetectionImageData_));
          }.bind(this));
        }
        forEachFeatureAtCoordinate(t2, e2, i2, n2, r2) {
          if (!this.replayGroup_)
            return;
          const s2 = e2.viewState.resolution, o2 = e2.viewState.rotation, a2 = this.getLayer(), l2 = {}, h2 = function(t3, e3, i3) {
            const s3 = z(t3), o3 = l2[s3];
            if (o3) {
              if (true !== o3 && i3 < o3.distanceSq) {
                if (0 === i3)
                  return l2[s3] = true, r2.splice(r2.lastIndexOf(o3), 1), n2(t3, a2, e3);
                o3.geometry = e3, o3.distanceSq = i3;
              }
            } else {
              if (0 === i3)
                return l2[s3] = true, n2(t3, a2, e3);
              r2.push(l2[s3] = { feature: t3, layer: a2, geometry: e3, distanceSq: i3, callback: n2 });
            }
          };
          let c2;
          const u2 = [this.replayGroup_];
          return this.declutterExecutorGroup && u2.push(this.declutterExecutorGroup), u2.some((n3) => c2 = n3.forEachFeatureAtCoordinate(t2, s2, o2, i2, h2, n3 === this.declutterExecutorGroup && e2.declutterTree ? e2.declutterTree.all().map((t3) => t3.value) : null)), c2;
        }
        handleFontsChanged() {
          const t2 = this.getLayer();
          t2.getVisible() && this.replayGroup_ && t2.changed();
        }
        handleStyleImageChange_(t2) {
          this.renderIfReadyAndVisible();
        }
        prepareFrame(t2) {
          const e2 = this.getLayer(), i2 = e2.getSource();
          if (!i2)
            return false;
          const n2 = t2.viewHints[Ro], r2 = t2.viewHints[Po], s2 = e2.getUpdateWhileAnimating(), o2 = e2.getUpdateWhileInteracting();
          if (this.ready && !s2 && n2 || !o2 && r2)
            return this.animatingOrInteracting_ = true, true;
          this.animatingOrInteracting_ = false;
          const a2 = t2.extent, l2 = t2.viewState, h2 = l2.projection, c2 = l2.resolution, d2 = t2.pixelRatio, g2 = e2.getRevision(), f2 = e2.getRenderBuffer();
          let p2 = e2.getRenderOrder();
          void 0 === p2 && (p2 = Pl);
          const m2 = l2.center.slice(), _2 = Xt(a2, f2 * c2), y2 = _2.slice(), x2 = [_2.slice()], v2 = h2.getExtent();
          if (i2.getWrapX() && h2.canWrapX() && !Yt(v2, t2.extent)) {
            const t3 = Se(v2), e3 = Math.max(Se(_2) / 2, t3);
            _2[0] = v2[0] - e3, _2[2] = v2[2] + e3, Pi(m2, h2);
            const i3 = Pe(x2[0], h2);
            i3[0] < v2[0] && i3[2] < v2[2] ? x2.push([i3[0] + t3, i3[1], i3[2] + t3, i3[3]]) : i3[0] > v2[0] && i3[2] > v2[2] && x2.push([i3[0] - t3, i3[1], i3[2] - t3, i3[3]]);
          }
          if (this.ready && this.renderedResolution_ == c2 && this.renderedRevision_ == g2 && this.renderedRenderOrder_ == p2 && Yt(this.wrappedRenderedExtent_, _2))
            return u(this.renderedExtent_, y2) || (this.hitDetectionImageData_ = null, this.renderedExtent_ = y2), this.renderedCenter_ = m2, this.replayGroupChanged = false, true;
          this.replayGroup_ = null;
          const S2 = new np(Ll(c2, d2), _2, c2, d2);
          let w2;
          this.getLayer().getDeclutter() && (w2 = new np(Ll(c2, d2), _2, c2, d2));
          const E2 = en();
          let T2;
          if (E2) {
            for (let t3 = 0, e3 = x2.length; t3 < e3; ++t3) {
              const e4 = sn(x2[t3], h2);
              i2.loadFeatures(e4, an(c2, h2), E2);
            }
            T2 = qi(E2, h2);
          } else
            for (let t3 = 0, e3 = x2.length; t3 < e3; ++t3)
              i2.loadFeatures(x2[t3], c2, h2);
          const C2 = Il(c2, d2);
          let b2 = true;
          const R2 = function(t3) {
            let i3;
            const n3 = t3.getStyleFunction() || e2.getStyleFunction();
            if (n3 && (i3 = n3(t3, c2)), i3) {
              const e3 = this.renderFeature(t3, C2, i3, S2, T2, w2);
              b2 = b2 && !e3;
            }
          }.bind(this), P2 = sn(_2, h2), I2 = i2.getFeaturesInExtent(P2);
          p2 && I2.sort(p2);
          for (let t3 = 0, e3 = I2.length; t3 < e3; ++t3)
            R2(I2[t3]);
          this.renderedFeatures_ = I2, this.ready = b2;
          const L2 = S2.finish(), M2 = new _p(_2, c2, d2, i2.getOverlaps(), L2, e2.getRenderBuffer());
          return w2 && (this.declutterExecutorGroup = new _p(_2, c2, d2, i2.getOverlaps(), w2.finish(), e2.getRenderBuffer())), this.renderedResolution_ = c2, this.renderedRevision_ = g2, this.renderedRenderOrder_ = p2, this.renderedExtent_ = y2, this.wrappedRenderedExtent_ = _2, this.renderedCenter_ = m2, this.renderedProjection_ = h2, this.replayGroup_ = M2, this.hitDetectionImageData_ = null, this.replayGroupChanged = true, true;
        }
        renderFeature(t2, e2, i2, n2, r2, s2) {
          if (!i2)
            return false;
          let o2 = false;
          if (Array.isArray(i2))
            for (let a2 = 0, l2 = i2.length; a2 < l2; ++a2)
              o2 = Ml(n2, t2, i2[a2], e2, this.boundHandleStyleImageChange_, r2, s2) || o2;
          else
            o2 = Ml(n2, t2, i2, e2, this.boundHandleStyleImageChange_, r2, s2);
          return o2;
        }
      }
      class Tp extends Ic {
        constructor(t2) {
          super(t2), this.vectorRenderer_ = new Ep(t2), this.layerImageRatio_ = t2.getImageRatio(), this.coordinateToVectorPixelTransform_ = [1, 0, 0, 1, 0, 0], this.renderedPixelToCoordinateTransform_ = null;
        }
        disposeInternal() {
          this.vectorRenderer_.dispose(), super.disposeInternal();
        }
        getFeatures(t2) {
          if (!this.vectorRenderer_)
            return new Promise((t3) => t3([]));
          const e2 = bt(this.coordinateToVectorPixelTransform_, bt(this.renderedPixelToCoordinateTransform_, t2.slice()));
          return this.vectorRenderer_.getFeatures(e2);
        }
        handleFontsChanged() {
          this.vectorRenderer_.handleFontsChanged();
        }
        prepareFrame(t2) {
          const e2 = t2.pixelRatio, i2 = t2.viewState, n2 = i2.resolution, r2 = t2.viewHints, s2 = this.vectorRenderer_;
          let o2 = t2.extent;
          1 !== this.layerImageRatio_ && (o2 = o2.slice(0), Ce(o2, this.layerImageRatio_));
          const a2 = Se(o2) / n2, l2 = _e(o2) / n2;
          if (!r2[Ro] && !r2[Po] && !Ee(o2)) {
            s2.useContainer(null, null);
            const r3 = s2.context, h2 = t2.layerStatesArray[t2.layerIndex];
            r3.globalAlpha = h2.opacity;
            const c2 = Object.assign({}, h2, { opacity: 1 }), u2 = Object.assign({}, t2, { declutterTree: new xh(9), extent: o2, size: [a2, l2], viewState: Object.assign({}, t2.viewState, { rotation: 0 }), layerStatesArray: [c2], layerIndex: 0 });
            let d2 = true;
            const g2 = new Nr(o2, n2, e2, r3.canvas, function(t3) {
              s2.prepareFrame(u2) && s2.replayGroupChanged && (s2.clipping = false, s2.renderFrame(u2, null) && (s2.renderDeclutter(u2), d2 = false), t3());
            });
            g2.addEventListener(S, function() {
              if (g2.getState() !== Lr)
                return;
              this.image_ = d2 ? null : g2;
              const t3 = g2.getResolution(), n3 = g2.getPixelRatio(), r4 = t3 * e2 / n3;
              this.renderedResolution = r4, this.coordinateToVectorPixelTransform_ = Mt(this.coordinateToVectorPixelTransform_, a2 / 2, l2 / 2, 1 / r4, -1 / r4, 0, -i2.center[0], -i2.center[1]);
            }.bind(this)), g2.load();
          }
          return this.image_ && (this.renderedPixelToCoordinateTransform_ = t2.pixelToCoordinateTransform.slice()), !!this.image_;
        }
        preRender() {
        }
        postRender() {
        }
        renderDeclutter() {
        }
        forEachFeatureAtCoordinate(t2, e2, i2, n2, r2) {
          return this.vectorRenderer_ ? this.vectorRenderer_.forEachFeatureAtCoordinate(t2, e2, i2, n2, r2) : super.forEachFeatureAtCoordinate(t2, e2, i2, n2, r2);
        }
      }
      const Cp = { image: ["Polygon", "Circle", "LineString", "Image", "Text"], hybrid: ["Polygon", "LineString"], vector: [] }, bp = { hybrid: ["Image", "Text", "Default"], vector: ["Polygon", "Circle", "LineString", "Image", "Text", "Default"] };
      class Rp extends Oc {
        constructor(t2) {
          super(t2), this.boundHandleStyleImageChange_ = this.handleStyleImageChange_.bind(this), this.renderedLayerRevision_, this.renderedPixelToCoordinateTransform_ = null, this.renderedRotation_, this.tmpTransform_ = [1, 0, 0, 1, 0, 0];
        }
        prepareTile(t2, e2, i2) {
          let n2;
          const r2 = t2.getState();
          return r2 !== J && r2 !== Q || (this.updateExecutorGroup_(t2, e2, i2), this.tileImageNeedsRender_(t2) && (n2 = true)), n2;
        }
        getTile(t2, e2, i2, n2) {
          const r2 = n2.pixelRatio, s2 = n2.viewState, o2 = s2.resolution, a2 = s2.projection, l2 = this.getLayer(), h2 = l2.getSource().getTile(t2, e2, i2, r2, a2), c2 = n2.viewHints, u2 = !(c2[Ro] || c2[Po]);
          !u2 && h2.wantedResolution || (h2.wantedResolution = o2);
          return this.prepareTile(h2, r2, a2) && (u2 || Date.now() - n2.time < 8) && "vector" !== l2.getRenderMode() && this.renderTileImage_(h2, n2), super.getTile(t2, e2, i2, n2);
        }
        isDrawableTile(t2) {
          const e2 = this.getLayer();
          return super.isDrawableTile(t2) && ("vector" === e2.getRenderMode() ? z(e2) in t2.executorGroups : t2.hasContext(e2));
        }
        getTileImage(t2) {
          return t2.getImage(this.getLayer());
        }
        prepareFrame(t2) {
          const e2 = this.getLayer().getRevision();
          return this.renderedLayerRevision_ !== e2 && (this.renderedLayerRevision_ = e2, this.renderedTiles.length = 0), super.prepareFrame(t2);
        }
        updateExecutorGroup_(t2, e2, i2) {
          const n2 = this.getLayer(), r2 = n2.getRevision(), s2 = n2.getRenderOrder() || null, o2 = t2.wantedResolution, a2 = t2.getReplayState(n2);
          if (!a2.dirty && a2.renderedResolution === o2 && a2.renderedRevision == r2 && a2.renderedRenderOrder == s2)
            return;
          const l2 = n2.getSource(), h2 = n2.getDeclutter(), c2 = l2.getTileGrid(), u2 = l2.getTileGridForProjection(i2).getTileCoordExtent(t2.wrappedTileCoord), d2 = l2.getSourceTiles(e2, i2, t2), g2 = z(n2);
          delete t2.hitDetectionImageData[g2], t2.executorGroups[g2] = [], h2 && (t2.declutterExecutorGroups[g2] = []), a2.dirty = false;
          for (let i3 = 0, r3 = d2.length; i3 < r3; ++i3) {
            const r4 = d2[i3];
            if (r4.getState() != J)
              continue;
            const f2 = r4.tileCoord, p2 = c2.getTileCoordExtent(f2), m2 = ye(u2, p2), _2 = Xt(m2, n2.getRenderBuffer() * o2, this.tmpExtent), y2 = ee(p2, m2) ? null : _2, x2 = new np(0, _2, o2, e2), v2 = h2 ? new np(0, m2, o2, e2) : void 0, S2 = Il(o2, e2), w2 = function(t3) {
              let e3;
              const i4 = t3.getStyleFunction() || n2.getStyleFunction();
              if (i4 && (e3 = i4(t3, o2)), e3) {
                const i5 = this.renderFeature(t3, S2, e3, x2, v2);
                a2.dirty = a2.dirty || i5;
              }
            }, E2 = r4.getFeatures();
            s2 && s2 !== a2.renderedRenderOrder && E2.sort(s2);
            for (let t3 = 0, e3 = E2.length; t3 < e3; ++t3) {
              const e4 = E2[t3];
              y2 && !we(y2, e4.getGeometry().getExtent()) || w2.call(this, e4);
            }
            const T2 = x2.finish(), C2 = "vector" !== n2.getRenderMode() && h2 && 1 === d2.length ? null : m2, b2 = new _p(C2, o2, e2, l2.getOverlaps(), T2, n2.getRenderBuffer());
            if (t2.executorGroups[g2].push(b2), v2) {
              const i4 = new _p(null, o2, e2, l2.getOverlaps(), v2.finish(), n2.getRenderBuffer());
              t2.declutterExecutorGroups[g2].push(i4);
            }
          }
          a2.renderedRevision = r2, a2.renderedRenderOrder = s2, a2.renderedResolution = o2;
        }
        forEachFeatureAtCoordinate(t2, e2, i2, n2, r2) {
          const s2 = e2.viewState.resolution, o2 = e2.viewState.rotation;
          i2 = null == i2 ? 0 : i2;
          const a2 = this.getLayer(), l2 = a2.getSource().getTileGridForProjection(e2.viewState.projection), h2 = zt([t2]);
          Xt(h2, s2 * i2, h2);
          const c2 = {}, u2 = function(t3, e3, i3) {
            let s3 = t3.getId();
            void 0 === s3 && (s3 = z(t3));
            const o3 = c2[s3];
            if (o3) {
              if (true !== o3 && i3 < o3.distanceSq) {
                if (0 === i3)
                  return c2[s3] = true, r2.splice(r2.lastIndexOf(o3), 1), n2(t3, a2, e3);
                o3.geometry = e3, o3.distanceSq = i3;
              }
            } else {
              if (0 === i3)
                return c2[s3] = true, n2(t3, a2, e3);
              r2.push(c2[s3] = { feature: t3, layer: a2, geometry: e3, distanceSq: i3, callback: n2 });
            }
          }, d2 = this.renderedTiles;
          let g2;
          for (let n3 = 0, r3 = d2.length; !g2 && n3 < r3; ++n3) {
            const r4 = d2[n3];
            if (!we(l2.getTileCoordExtent(r4.wrappedTileCoord), h2))
              continue;
            const c3 = z(a2), f2 = [r4.executorGroups[c3]], p2 = r4.declutterExecutorGroups[c3];
            p2 && f2.push(p2), f2.some((n4) => {
              const r5 = n4 === p2 ? e2.declutterTree.all().map((t3) => t3.value) : null;
              for (let e3 = 0, a3 = n4.length; e3 < a3; ++e3) {
                const a4 = n4[e3];
                if (g2 = a4.forEachFeatureAtCoordinate(t2, s2, o2, i2, u2, r5), g2)
                  return true;
              }
            });
          }
          return g2;
        }
        getFeatures(t2) {
          return new Promise(function(e2, i2) {
            const n2 = this.getLayer(), r2 = z(n2), s2 = n2.getSource(), o2 = this.renderedProjection, a2 = o2.getExtent(), l2 = this.renderedResolution, h2 = s2.getTileGridForProjection(o2), c2 = bt(this.renderedPixelToCoordinateTransform_, t2.slice()), u2 = h2.getTileCoordForCoordAndResolution(c2, l2);
            let d2;
            for (let t3 = 0, e3 = this.renderedTiles.length; t3 < e3; ++t3)
              if (u2.toString() === this.renderedTiles[t3].tileCoord.toString()) {
                if (d2 = this.renderedTiles[t3], d2.getState() === J) {
                  const t4 = h2.getTileCoordExtent(d2.tileCoord);
                  s2.getWrapX() && o2.canWrapX() && !Yt(a2, t4) && Pi(c2, o2);
                  break;
                }
                d2 = void 0;
              }
            if (!d2 || d2.loadingSourceTiles > 0)
              return void e2([]);
            const g2 = xe(h2.getTileCoordExtent(d2.wrappedTileCoord)), f2 = [(c2[0] - g2[0]) / l2, (g2[1] - c2[1]) / l2], p2 = d2.getSourceTiles().reduce(function(t3, e3) {
              return t3.concat(e3.getFeatures());
            }, []);
            let m2 = d2.hitDetectionImageData[r2];
            if (!m2 && !this.animatingOrInteracting_) {
              const t3 = Va(h2.getTileSize(h2.getZForResolution(l2, s2.zDirection))), e3 = this.renderedRotation_;
              m2 = Sp(t3, [this.getRenderTransform(h2.getTileCoordCenter(d2.wrappedTileCoord), l2, 0, vp, t3[0] * vp, t3[1] * vp, 0)], p2, n2.getStyleFunction(), h2.getTileCoordExtent(d2.wrappedTileCoord), d2.getReplayState(n2).renderedResolution, e3), d2.hitDetectionImageData[r2] = m2;
            }
            e2(wp(f2, p2, m2));
          }.bind(this));
        }
        handleFontsChanged() {
          const t2 = this.getLayer();
          t2.getVisible() && void 0 !== this.renderedLayerRevision_ && t2.changed();
        }
        handleStyleImageChange_(t2) {
          this.renderIfReadyAndVisible();
        }
        renderDeclutter(t2) {
          const e2 = this.context, i2 = e2.globalAlpha;
          e2.globalAlpha = this.getLayer().getOpacity();
          const n2 = t2.viewHints, r2 = !(n2[Ro] || n2[Po]), s2 = this.renderedTiles;
          for (let e3 = 0, i3 = s2.length; e3 < i3; ++e3) {
            const i4 = s2[e3], n3 = i4.declutterExecutorGroups[z(this.getLayer())];
            if (n3)
              for (let e4 = n3.length - 1; e4 >= 0; --e4)
                n3[e4].execute(this.context, 1, this.getTileRenderTransform(i4, t2), t2.viewState.rotation, r2, void 0, t2.declutterTree);
          }
          e2.globalAlpha = i2;
        }
        getTileRenderTransform(t2, e2) {
          const i2 = e2.pixelRatio, n2 = e2.viewState, r2 = n2.center, s2 = n2.resolution, o2 = n2.rotation, a2 = e2.size, l2 = Math.round(a2[0] * i2), h2 = Math.round(a2[1] * i2), c2 = this.getLayer().getSource().getTileGridForProjection(e2.viewState.projection), u2 = t2.tileCoord, d2 = c2.getTileCoordExtent(t2.wrappedTileCoord), g2 = c2.getTileCoordExtent(u2, this.tmpExtent)[0] - d2[0];
          return Et(Pt(this.inversePixelTransform.slice(), 1 / i2, 1 / i2), this.getRenderTransform(r2, s2, o2, i2, l2, h2, g2));
        }
        postRender(t2, e2) {
          const i2 = e2.viewHints, n2 = !(i2[Ro] || i2[Po]);
          this.renderedPixelToCoordinateTransform_ = e2.pixelToCoordinateTransform.slice(), this.renderedRotation_ = e2.viewState.rotation;
          const r2 = this.getLayer(), s2 = r2.getRenderMode(), o2 = t2.globalAlpha;
          t2.globalAlpha = r2.getOpacity();
          const a2 = bp[s2], l2 = e2.viewState, h2 = l2.rotation, c2 = r2.getSource(), u2 = c2.getTileGridForProjection(l2.projection).getZForResolution(l2.resolution, c2.zDirection), d2 = this.renderedTiles, g2 = [], f2 = [];
          let p2 = true;
          for (let i3 = d2.length - 1; i3 >= 0; --i3) {
            const s3 = d2[i3];
            p2 = p2 && !s3.getReplayState(r2).dirty;
            const o3 = s3.executorGroups[z(r2)].filter((t3) => t3.hasExecutors(a2));
            if (0 === o3.length)
              continue;
            const l3 = this.getTileRenderTransform(s3, e2), c3 = s3.tileCoord[0];
            let m2 = false;
            const _2 = o3[0].getClipCoords(l3);
            if (_2) {
              for (let e3 = 0, i4 = g2.length; e3 < i4; ++e3)
                if (u2 !== c3 && c3 < f2[e3]) {
                  const i5 = g2[e3];
                  we([_2[0], _2[3], _2[4], _2[7]], [i5[0], i5[3], i5[4], i5[7]]) && (m2 || (t2.save(), m2 = true), t2.beginPath(), t2.moveTo(_2[0], _2[1]), t2.lineTo(_2[2], _2[3]), t2.lineTo(_2[4], _2[5]), t2.lineTo(_2[6], _2[7]), t2.moveTo(i5[6], i5[7]), t2.lineTo(i5[4], i5[5]), t2.lineTo(i5[2], i5[3]), t2.lineTo(i5[0], i5[1]), t2.clip());
                }
              g2.push(_2), f2.push(c3);
            }
            for (let e3 = 0, i4 = o3.length; e3 < i4; ++e3) {
              o3[e3].execute(t2, 1, l3, h2, n2, a2);
            }
            m2 && t2.restore();
          }
          t2.globalAlpha = o2, this.ready = p2, super.postRender(t2, e2);
        }
        renderFeature(t2, e2, i2, n2, r2) {
          if (!i2)
            return false;
          let s2 = false;
          if (Array.isArray(i2))
            for (let o2 = 0, a2 = i2.length; o2 < a2; ++o2)
              s2 = Ml(n2, t2, i2[o2], e2, this.boundHandleStyleImageChange_, void 0, r2) || s2;
          else
            s2 = Ml(n2, t2, i2, e2, this.boundHandleStyleImageChange_, void 0, r2);
          return s2;
        }
        tileImageNeedsRender_(t2) {
          const e2 = this.getLayer();
          if ("vector" === e2.getRenderMode())
            return false;
          const i2 = t2.getReplayState(e2), n2 = e2.getRevision(), r2 = t2.wantedResolution;
          return i2.renderedTileResolution !== r2 || i2.renderedTileRevision !== n2;
        }
        renderTileImage_(t2, e2) {
          const i2 = this.getLayer(), n2 = t2.getReplayState(i2), r2 = i2.getRevision(), s2 = t2.executorGroups[z(i2)];
          n2.renderedTileRevision = r2;
          const o2 = t2.wrappedTileCoord, a2 = o2[0], l2 = i2.getSource();
          let h2 = e2.pixelRatio;
          const c2 = e2.viewState.projection, u2 = l2.getTileGridForProjection(c2), d2 = u2.getResolution(t2.tileCoord[0]), g2 = e2.pixelRatio / t2.wantedResolution * d2, f2 = u2.getResolution(a2), p2 = t2.getContext(i2);
          h2 = Math.round(Math.max(h2, g2 / h2));
          const m2 = l2.getTilePixelSize(a2, h2, c2);
          p2.canvas.width = m2[0], p2.canvas.height = m2[1];
          const _2 = h2 / g2;
          if (1 !== _2) {
            const t3 = wt(this.tmpTransform_);
            Pt(t3, _2, _2), p2.setTransform.apply(p2, t3);
          }
          const y2 = u2.getTileCoordExtent(o2, this.tmpExtent), x2 = g2 / f2, v2 = wt(this.tmpTransform_);
          Pt(v2, x2, -x2), Lt(v2, -y2[0], -y2[3]);
          for (let t3 = 0, e3 = s2.length; t3 < e3; ++t3) {
            s2[t3].execute(p2, _2, v2, 0, true, Cp[i2.getRenderMode()]);
          }
          n2.renderedTileResolution = t2.wantedResolution;
        }
      }
      class Pp extends _n {
        constructor(t2, e2, i2) {
          super(), void 0 !== i2 && void 0 === e2 ? this.setFlatCoordinates(i2, t2) : (e2 = e2 || 0, this.setCenterAndRadius(t2, e2, i2));
        }
        clone() {
          const t2 = new Pp(this.flatCoordinates.slice(), void 0, this.layout);
          return t2.applyProperties(this), t2;
        }
        closestPointXY(t2, e2, i2, n2) {
          const r2 = this.flatCoordinates, s2 = t2 - r2[0], o2 = e2 - r2[1], a2 = s2 * s2 + o2 * o2;
          if (a2 < n2) {
            if (0 === a2)
              for (let t3 = 0; t3 < this.stride; ++t3)
                i2[t3] = r2[t3];
            else {
              const t3 = this.getRadius() / Math.sqrt(a2);
              i2[0] = r2[0] + t3 * s2, i2[1] = r2[1] + t3 * o2;
              for (let t4 = 2; t4 < this.stride; ++t4)
                i2[t4] = r2[t4];
            }
            return i2.length = this.stride, a2;
          }
          return n2;
        }
        containsXY(t2, e2) {
          const i2 = this.flatCoordinates, n2 = t2 - i2[0], r2 = e2 - i2[1];
          return n2 * n2 + r2 * r2 <= this.getRadiusSquared_();
        }
        getCenter() {
          return this.flatCoordinates.slice(0, this.stride);
        }
        computeExtent(t2) {
          const e2 = this.flatCoordinates, i2 = e2[this.stride] - e2[0];
          return $t(e2[0] - i2, e2[1] - i2, e2[0] + i2, e2[1] + i2, t2);
        }
        getRadius() {
          return Math.sqrt(this.getRadiusSquared_());
        }
        getRadiusSquared_() {
          const t2 = this.flatCoordinates[this.stride] - this.flatCoordinates[0], e2 = this.flatCoordinates[this.stride + 1] - this.flatCoordinates[1];
          return t2 * t2 + e2 * e2;
        }
        getType() {
          return "Circle";
        }
        intersectsExtent(t2) {
          if (we(t2, this.getExtent())) {
            const e2 = this.getCenter();
            return t2[0] <= e2[0] && t2[2] >= e2[0] || (t2[1] <= e2[1] && t2[3] >= e2[1] || he(t2, this.intersectsCoordinate.bind(this)));
          }
          return false;
        }
        setCenter(t2) {
          const e2 = this.stride, i2 = this.flatCoordinates[e2] - this.flatCoordinates[0], n2 = t2.slice();
          n2[e2] = n2[0] + i2;
          for (let i3 = 1; i3 < e2; ++i3)
            n2[e2 + i3] = t2[i3];
          this.setFlatCoordinates(this.layout, n2), this.changed();
        }
        setCenterAndRadius(t2, e2, i2) {
          this.setLayout(i2, t2, 0), this.flatCoordinates || (this.flatCoordinates = []);
          const n2 = this.flatCoordinates;
          let r2 = Rn(n2, 0, t2, this.stride);
          n2[r2++] = n2[0] + e2;
          for (let t3 = 1, e3 = this.stride; t3 < e3; ++t3)
            n2[r2++] = n2[t3];
          n2.length = r2, this.changed();
        }
        getCoordinates() {
          return null;
        }
        setCoordinates(t2, e2) {
        }
        setRadius(t2) {
          this.flatCoordinates[this.stride] = this.flatCoordinates[0] + t2, this.changed();
        }
        rotate(t2, e2) {
          const i2 = this.getCenter(), n2 = this.getStride();
          this.setCenter(dn(i2, 0, i2.length, n2, t2, e2, i2)), this.changed();
        }
        translate(t2, e2) {
          const i2 = this.getCenter(), n2 = this.getStride();
          this.setCenter(fn(i2, 0, i2.length, n2, t2, e2, i2)), this.changed();
        }
      }
      Pp.prototype.transform;
      class Ip extends mn {
        constructor(t2) {
          super(), this.geometries_ = t2 || null, this.changeEventsKeys_ = [], this.listenGeometriesChange_();
        }
        unlistenGeometriesChange_() {
          this.changeEventsKeys_.forEach(k), this.changeEventsKeys_.length = 0;
        }
        listenGeometriesChange_() {
          if (this.geometries_)
            for (let t2 = 0, e2 = this.geometries_.length; t2 < e2; ++t2)
              this.changeEventsKeys_.push(N(this.geometries_[t2], S, this.changed, this));
        }
        clone() {
          const t2 = new Ip(null);
          return t2.setGeometries(this.geometries_), t2.applyProperties(this), t2;
        }
        closestPointXY(t2, e2, i2, n2) {
          if (n2 < Wt(this.getExtent(), t2, e2))
            return n2;
          const r2 = this.geometries_;
          for (let s2 = 0, o2 = r2.length; s2 < o2; ++s2)
            n2 = r2[s2].closestPointXY(t2, e2, i2, n2);
          return n2;
        }
        containsXY(t2, e2) {
          const i2 = this.geometries_;
          for (let n2 = 0, r2 = i2.length; n2 < r2; ++n2)
            if (i2[n2].containsXY(t2, e2))
              return true;
          return false;
        }
        computeExtent(t2) {
          Jt(t2);
          const e2 = this.geometries_;
          for (let i2 = 0, n2 = e2.length; i2 < n2; ++i2)
            ne(t2, e2[i2].getExtent());
          return t2;
        }
        getGeometries() {
          return Lp(this.geometries_);
        }
        getGeometriesArray() {
          return this.geometries_;
        }
        getGeometriesArrayRecursive() {
          let t2 = [];
          const e2 = this.geometries_;
          for (let i2 = 0, n2 = e2.length; i2 < n2; ++i2)
            e2[i2].getType() === this.getType() ? t2 = t2.concat(e2[i2].getGeometriesArrayRecursive()) : t2.push(e2[i2]);
          return t2;
        }
        getSimplifiedGeometry(t2) {
          if (this.simplifiedGeometryRevision !== this.getRevision() && (this.simplifiedGeometryMaxMinSquaredTolerance = 0, this.simplifiedGeometryRevision = this.getRevision()), t2 < 0 || 0 !== this.simplifiedGeometryMaxMinSquaredTolerance && t2 < this.simplifiedGeometryMaxMinSquaredTolerance)
            return this;
          const e2 = [], i2 = this.geometries_;
          let n2 = false;
          for (let r2 = 0, s2 = i2.length; r2 < s2; ++r2) {
            const s3 = i2[r2], o2 = s3.getSimplifiedGeometry(t2);
            e2.push(o2), o2 !== s3 && (n2 = true);
          }
          if (n2) {
            const t3 = new Ip(null);
            return t3.setGeometriesArray(e2), t3;
          }
          return this.simplifiedGeometryMaxMinSquaredTolerance = t2, this;
        }
        getType() {
          return "GeometryCollection";
        }
        intersectsExtent(t2) {
          const e2 = this.geometries_;
          for (let i2 = 0, n2 = e2.length; i2 < n2; ++i2)
            if (e2[i2].intersectsExtent(t2))
              return true;
          return false;
        }
        isEmpty() {
          return 0 === this.geometries_.length;
        }
        rotate(t2, e2) {
          const i2 = this.geometries_;
          for (let n2 = 0, r2 = i2.length; n2 < r2; ++n2)
            i2[n2].rotate(t2, e2);
          this.changed();
        }
        scale(t2, e2, i2) {
          i2 || (i2 = ge(this.getExtent()));
          const n2 = this.geometries_;
          for (let r2 = 0, s2 = n2.length; r2 < s2; ++r2)
            n2[r2].scale(t2, e2, i2);
          this.changed();
        }
        setGeometries(t2) {
          this.setGeometriesArray(Lp(t2));
        }
        setGeometriesArray(t2) {
          this.unlistenGeometriesChange_(), this.geometries_ = t2, this.listenGeometriesChange_(), this.changed();
        }
        applyTransform(t2) {
          const e2 = this.geometries_;
          for (let i2 = 0, n2 = e2.length; i2 < n2; ++i2)
            e2[i2].applyTransform(t2);
          this.changed();
        }
        translate(t2, e2) {
          const i2 = this.geometries_;
          for (let n2 = 0, r2 = i2.length; n2 < r2; ++n2)
            i2[n2].translate(t2, e2);
          this.changed();
        }
        disposeInternal() {
          this.unlistenGeometriesChange_(), super.disposeInternal();
        }
      }
      function Lp(t2) {
        const e2 = [];
        for (let i2 = 0, n2 = t2.length; i2 < n2; ++i2)
          e2.push(t2[i2].clone());
        return e2;
      }
      function Mp(t2, e2, i2, n2, r2, s2, a2) {
        let l2, h2;
        const c2 = (i2 - e2) / n2;
        if (1 === c2)
          l2 = e2;
        else if (2 === c2)
          l2 = e2, h2 = r2;
        else if (0 !== c2) {
          let s3 = t2[e2], a3 = t2[e2 + 1], c3 = 0;
          const u2 = [0];
          for (let r3 = e2 + n2; r3 < i2; r3 += n2) {
            const e3 = t2[r3], i3 = t2[r3 + 1];
            c3 += Math.sqrt((e3 - s3) * (e3 - s3) + (i3 - a3) * (i3 - a3)), u2.push(c3), s3 = e3, a3 = i3;
          }
          const d2 = r2 * c3, g2 = o(u2, d2);
          g2 < 0 ? (h2 = (d2 - u2[-g2 - 2]) / (u2[-g2 - 1] - u2[-g2 - 2]), l2 = e2 + (-g2 - 2) * n2) : l2 = e2 + g2 * n2;
        }
        a2 = a2 > 1 ? a2 : 2, s2 = s2 || new Array(a2);
        for (let e3 = 0; e3 < a2; ++e3)
          s2[e3] = void 0 === l2 ? NaN : void 0 === h2 ? t2[l2 + e3] : hi(t2[l2 + e3], t2[l2 + n2 + e3], h2);
        return s2;
      }
      function Fp(t2, e2, i2, n2, r2, s2) {
        if (i2 == e2)
          return null;
        let o2;
        if (r2 < t2[e2 + n2 - 1])
          return s2 ? (o2 = t2.slice(e2, e2 + n2), o2[n2 - 1] = r2, o2) : null;
        if (t2[i2 - 1] < r2)
          return s2 ? (o2 = t2.slice(i2 - n2, i2), o2[n2 - 1] = r2, o2) : null;
        if (r2 == t2[e2 + n2 - 1])
          return t2.slice(e2, e2 + n2);
        let a2 = e2 / n2, l2 = i2 / n2;
        for (; a2 < l2; ) {
          const e3 = a2 + l2 >> 1;
          r2 < t2[(e3 + 1) * n2 - 1] ? l2 = e3 : a2 = e3 + 1;
        }
        const h2 = t2[a2 * n2 - 1];
        if (r2 == h2)
          return t2.slice((a2 - 1) * n2, (a2 - 1) * n2 + n2);
        const c2 = (r2 - h2) / (t2[(a2 + 1) * n2 - 1] - h2);
        o2 = [];
        for (let e3 = 0; e3 < n2 - 1; ++e3)
          o2.push(hi(t2[(a2 - 1) * n2 + e3], t2[a2 * n2 + e3], c2));
        return o2.push(r2), o2;
      }
      function Ap(t2, e2, i2, n2, r2, s2, o2) {
        if (o2)
          return Fp(t2, e2, i2[i2.length - 1], n2, r2, s2);
        let a2;
        if (r2 < t2[n2 - 1])
          return s2 ? (a2 = t2.slice(0, n2), a2[n2 - 1] = r2, a2) : null;
        if (t2[t2.length - 1] < r2)
          return s2 ? (a2 = t2.slice(t2.length - n2), a2[n2 - 1] = r2, a2) : null;
        for (let s3 = 0, o3 = i2.length; s3 < o3; ++s3) {
          const o4 = i2[s3];
          if (e2 != o4) {
            if (r2 < t2[e2 + n2 - 1])
              return null;
            if (r2 <= t2[o4 - 1])
              return Fp(t2, e2, o4, n2, r2, false);
            e2 = o4;
          }
        }
        return null;
      }
      class Op extends _n {
        constructor(t2, e2) {
          super(), this.flatMidpoint_ = null, this.flatMidpointRevision_ = -1, this.maxDelta_ = -1, this.maxDeltaRevision_ = -1, void 0 === e2 || Array.isArray(t2[0]) ? this.setCoordinates(t2, e2) : this.setFlatCoordinates(e2, t2);
        }
        appendCoordinate(t2) {
          this.flatCoordinates ? c(this.flatCoordinates, t2) : this.flatCoordinates = t2.slice(), this.changed();
        }
        clone() {
          const t2 = new Op(this.flatCoordinates.slice(), this.layout);
          return t2.applyProperties(this), t2;
        }
        closestPointXY(t2, e2, i2, n2) {
          return n2 < Wt(this.getExtent(), t2, e2) ? n2 : (this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt(Sn(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, 0)), this.maxDeltaRevision_ = this.getRevision()), Tn(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, this.maxDelta_, false, t2, e2, i2, n2));
        }
        forEachSegment(t2) {
          return Jn(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, t2);
        }
        getCoordinateAtM(t2, e2) {
          return "XYM" != this.layout && "XYZM" != this.layout ? null : (e2 = void 0 !== e2 && e2, Fp(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, t2, e2));
        }
        getCoordinates() {
          return Gn(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
        }
        getCoordinateAt(t2, e2) {
          return Mp(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, t2, e2, this.stride);
        }
        getLength() {
          return sp(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
        }
        getFlatMidpoint() {
          return this.flatMidpointRevision_ != this.getRevision() && (this.flatMidpoint_ = this.getCoordinateAt(0.5, this.flatMidpoint_), this.flatMidpointRevision_ = this.getRevision()), this.flatMidpoint_;
        }
        getSimplifiedGeometryInternal(t2) {
          const e2 = [];
          return e2.length = Mn(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, t2, e2, 0), new Op(e2, "XY");
        }
        getType() {
          return "LineString";
        }
        intersectsExtent(t2) {
          return Qn(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, t2);
        }
        setCoordinates(t2, e2) {
          this.setLayout(e2, t2, 1), this.flatCoordinates || (this.flatCoordinates = []), this.flatCoordinates.length = Pn(this.flatCoordinates, 0, t2, this.stride), this.changed();
        }
      }
      class Np extends _n {
        constructor(t2, e2, i2) {
          if (super(), this.ends_ = [], this.maxDelta_ = -1, this.maxDeltaRevision_ = -1, Array.isArray(t2[0]))
            this.setCoordinates(t2, e2);
          else if (void 0 !== e2 && i2)
            this.setFlatCoordinates(e2, t2), this.ends_ = i2;
          else {
            let e3 = this.getLayout();
            const i3 = t2, n2 = [], r2 = [];
            for (let t3 = 0, s2 = i3.length; t3 < s2; ++t3) {
              const s3 = i3[t3];
              0 === t3 && (e3 = s3.getLayout()), c(n2, s3.getFlatCoordinates()), r2.push(n2.length);
            }
            this.setFlatCoordinates(e3, n2), this.ends_ = r2;
          }
        }
        appendLineString(t2) {
          this.flatCoordinates ? c(this.flatCoordinates, t2.getFlatCoordinates().slice()) : this.flatCoordinates = t2.getFlatCoordinates().slice(), this.ends_.push(this.flatCoordinates.length), this.changed();
        }
        clone() {
          const t2 = new Np(this.flatCoordinates.slice(), this.layout, this.ends_.slice());
          return t2.applyProperties(this), t2;
        }
        closestPointXY(t2, e2, i2, n2) {
          return n2 < Wt(this.getExtent(), t2, e2) ? n2 : (this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt(wn(this.flatCoordinates, 0, this.ends_, this.stride, 0)), this.maxDeltaRevision_ = this.getRevision()), Cn(this.flatCoordinates, 0, this.ends_, this.stride, this.maxDelta_, false, t2, e2, i2, n2));
        }
        getCoordinateAtM(t2, e2, i2) {
          return "XYM" != this.layout && "XYZM" != this.layout || 0 === this.flatCoordinates.length ? null : (e2 = void 0 !== e2 && e2, i2 = void 0 !== i2 && i2, Ap(this.flatCoordinates, 0, this.ends_, this.stride, t2, e2, i2));
        }
        getCoordinates() {
          return jn(this.flatCoordinates, 0, this.ends_, this.stride);
        }
        getEnds() {
          return this.ends_;
        }
        getLineString(t2) {
          return t2 < 0 || this.ends_.length <= t2 ? null : new Op(this.flatCoordinates.slice(0 === t2 ? 0 : this.ends_[t2 - 1], this.ends_[t2]), this.layout);
        }
        getLineStrings() {
          const t2 = this.flatCoordinates, e2 = this.ends_, i2 = this.layout, n2 = [];
          let r2 = 0;
          for (let s2 = 0, o2 = e2.length; s2 < o2; ++s2) {
            const o3 = e2[s2], a2 = new Op(t2.slice(r2, o3), i2);
            n2.push(a2), r2 = o3;
          }
          return n2;
        }
        getFlatMidpoints() {
          const t2 = [], e2 = this.flatCoordinates;
          let i2 = 0;
          const n2 = this.ends_, r2 = this.stride;
          for (let s2 = 0, o2 = n2.length; s2 < o2; ++s2) {
            const o3 = n2[s2];
            c(t2, Mp(e2, i2, o3, r2, 0.5)), i2 = o3;
          }
          return t2;
        }
        getSimplifiedGeometryInternal(t2) {
          const e2 = [], i2 = [];
          return e2.length = Fn(this.flatCoordinates, 0, this.ends_, this.stride, t2, e2, 0, i2), new Np(e2, "XY", i2);
        }
        getType() {
          return "MultiLineString";
        }
        intersectsExtent(t2) {
          return tr(this.flatCoordinates, 0, this.ends_, this.stride, t2);
        }
        setCoordinates(t2, e2) {
          this.setLayout(e2, t2, 2), this.flatCoordinates || (this.flatCoordinates = []);
          const i2 = In(this.flatCoordinates, 0, t2, this.stride, this.ends_);
          this.flatCoordinates.length = 0 === i2.length ? 0 : i2[i2.length - 1], this.changed();
        }
      }
      class Dp extends _n {
        constructor(t2, e2) {
          super(), e2 && !Array.isArray(t2[0]) ? this.setFlatCoordinates(e2, t2) : this.setCoordinates(t2, e2);
        }
        appendPoint(t2) {
          this.flatCoordinates ? c(this.flatCoordinates, t2.getFlatCoordinates()) : this.flatCoordinates = t2.getFlatCoordinates().slice(), this.changed();
        }
        clone() {
          const t2 = new Dp(this.flatCoordinates.slice(), this.layout);
          return t2.applyProperties(this), t2;
        }
        closestPointXY(t2, e2, i2, n2) {
          if (n2 < Wt(this.getExtent(), t2, e2))
            return n2;
          const r2 = this.flatCoordinates, s2 = this.stride;
          for (let o2 = 0, a2 = r2.length; o2 < a2; o2 += s2) {
            const a3 = ri(t2, e2, r2[o2], r2[o2 + 1]);
            if (a3 < n2) {
              n2 = a3;
              for (let t3 = 0; t3 < s2; ++t3)
                i2[t3] = r2[o2 + t3];
              i2.length = s2;
            }
          }
          return n2;
        }
        getCoordinates() {
          return Gn(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
        }
        getPoint(t2) {
          const e2 = this.flatCoordinates ? this.flatCoordinates.length / this.stride : 0;
          return t2 < 0 || e2 <= t2 ? null : new Wn(this.flatCoordinates.slice(t2 * this.stride, (t2 + 1) * this.stride), this.layout);
        }
        getPoints() {
          const t2 = this.flatCoordinates, e2 = this.layout, i2 = this.stride, n2 = [];
          for (let r2 = 0, s2 = t2.length; r2 < s2; r2 += i2) {
            const s3 = new Wn(t2.slice(r2, r2 + i2), e2);
            n2.push(s3);
          }
          return n2;
        }
        getType() {
          return "MultiPoint";
        }
        intersectsExtent(t2) {
          const e2 = this.flatCoordinates, i2 = this.stride;
          for (let n2 = 0, r2 = e2.length; n2 < r2; n2 += i2) {
            if (Kt(t2, e2[n2], e2[n2 + 1]))
              return true;
          }
          return false;
        }
        setCoordinates(t2, e2) {
          this.setLayout(e2, t2, 1), this.flatCoordinates || (this.flatCoordinates = []), this.flatCoordinates.length = Pn(this.flatCoordinates, 0, t2, this.stride), this.changed();
        }
      }
      function kp(t2, e2, i2, n2) {
        const r2 = [];
        let s2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
        for (let o2 = 0, a2 = i2.length; o2 < a2; ++o2) {
          const a3 = i2[o2];
          s2 = te(t2, e2, a3[0], n2), r2.push((s2[0] + s2[2]) / 2, (s2[1] + s2[3]) / 2), e2 = a3[a3.length - 1];
        }
        return r2;
      }
      class Gp extends _n {
        constructor(t2, e2, i2) {
          if (super(), this.endss_ = [], this.flatInteriorPointsRevision_ = -1, this.flatInteriorPoints_ = null, this.maxDelta_ = -1, this.maxDeltaRevision_ = -1, this.orientedRevision_ = -1, this.orientedFlatCoordinates_ = null, !i2 && !Array.isArray(t2[0])) {
            let n2 = this.getLayout();
            const r2 = t2, s2 = [], o2 = [];
            for (let t3 = 0, e3 = r2.length; t3 < e3; ++t3) {
              const e4 = r2[t3];
              0 === t3 && (n2 = e4.getLayout());
              const i3 = s2.length, a2 = e4.getEnds();
              for (let t4 = 0, e5 = a2.length; t4 < e5; ++t4)
                a2[t4] += i3;
              c(s2, e4.getFlatCoordinates()), o2.push(a2);
            }
            e2 = n2, t2 = s2, i2 = o2;
          }
          void 0 !== e2 && i2 ? (this.setFlatCoordinates(e2, t2), this.endss_ = i2) : this.setCoordinates(t2, e2);
        }
        appendPolygon(t2) {
          let e2;
          if (this.flatCoordinates) {
            const i2 = this.flatCoordinates.length;
            c(this.flatCoordinates, t2.getFlatCoordinates()), e2 = t2.getEnds().slice();
            for (let t3 = 0, n2 = e2.length; t3 < n2; ++t3)
              e2[t3] += i2;
          } else
            this.flatCoordinates = t2.getFlatCoordinates().slice(), e2 = t2.getEnds().slice(), this.endss_.push();
          this.endss_.push(e2), this.changed();
        }
        clone() {
          const t2 = this.endss_.length, e2 = new Array(t2);
          for (let i3 = 0; i3 < t2; ++i3)
            e2[i3] = this.endss_[i3].slice();
          const i2 = new Gp(this.flatCoordinates.slice(), this.layout, e2);
          return i2.applyProperties(this), i2;
        }
        closestPointXY(t2, e2, i2, n2) {
          return n2 < Wt(this.getExtent(), t2, e2) ? n2 : (this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt(En(this.flatCoordinates, 0, this.endss_, this.stride, 0)), this.maxDeltaRevision_ = this.getRevision()), bn(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, this.maxDelta_, true, t2, e2, i2, n2));
        }
        containsXY(t2, e2) {
          return qn(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, t2, e2);
        }
        getArea() {
          return Xn(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride);
        }
        getCoordinates(t2) {
          let e2;
          return void 0 !== t2 ? (e2 = this.getOrientedFlatCoordinates().slice(), hr(e2, 0, this.endss_, this.stride, t2)) : e2 = this.flatCoordinates, Bn(e2, 0, this.endss_, this.stride);
        }
        getEndss() {
          return this.endss_;
        }
        getFlatInteriorPoints() {
          if (this.flatInteriorPointsRevision_ != this.getRevision()) {
            const t2 = kp(this.flatCoordinates, 0, this.endss_, this.stride);
            this.flatInteriorPoints_ = $n(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, t2), this.flatInteriorPointsRevision_ = this.getRevision();
          }
          return this.flatInteriorPoints_;
        }
        getInteriorPoints() {
          return new Dp(this.getFlatInteriorPoints().slice(), "XYM");
        }
        getOrientedFlatCoordinates() {
          if (this.orientedRevision_ != this.getRevision()) {
            const t2 = this.flatCoordinates;
            ar(t2, 0, this.endss_, this.stride) ? this.orientedFlatCoordinates_ = t2 : (this.orientedFlatCoordinates_ = t2.slice(), this.orientedFlatCoordinates_.length = hr(this.orientedFlatCoordinates_, 0, this.endss_, this.stride)), this.orientedRevision_ = this.getRevision();
          }
          return this.orientedFlatCoordinates_;
        }
        getSimplifiedGeometryInternal(t2) {
          const e2 = [], i2 = [];
          return e2.length = kn(this.flatCoordinates, 0, this.endss_, this.stride, Math.sqrt(t2), e2, 0, i2), new Gp(e2, "XY", i2);
        }
        getPolygon(t2) {
          if (t2 < 0 || this.endss_.length <= t2)
            return null;
          let e2;
          if (0 === t2)
            e2 = 0;
          else {
            const i3 = this.endss_[t2 - 1];
            e2 = i3[i3.length - 1];
          }
          const i2 = this.endss_[t2].slice(), n2 = i2[i2.length - 1];
          if (0 !== e2)
            for (let t3 = 0, n3 = i2.length; t3 < n3; ++t3)
              i2[t3] -= e2;
          return new ur(this.flatCoordinates.slice(e2, n2), this.layout, i2);
        }
        getPolygons() {
          const t2 = this.layout, e2 = this.flatCoordinates, i2 = this.endss_, n2 = [];
          let r2 = 0;
          for (let s2 = 0, o2 = i2.length; s2 < o2; ++s2) {
            const o3 = i2[s2].slice(), a2 = o3[o3.length - 1];
            if (0 !== r2)
              for (let t3 = 0, e3 = o3.length; t3 < e3; ++t3)
                o3[t3] -= r2;
            const l2 = new ur(e2.slice(r2, a2), t2, o3);
            n2.push(l2), r2 = a2;
          }
          return n2;
        }
        getType() {
          return "MultiPolygon";
        }
        intersectsExtent(t2) {
          return nr(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, t2);
        }
        setCoordinates(t2, e2) {
          this.setLayout(e2, t2, 3), this.flatCoordinates || (this.flatCoordinates = []);
          const i2 = Ln(this.flatCoordinates, 0, t2, this.stride, this.endss_);
          if (0 === i2.length)
            this.flatCoordinates.length = 0;
          else {
            const t3 = i2[i2.length - 1];
            this.flatCoordinates.length = 0 === t3.length ? 0 : t3[t3.length - 1];
          }
          this.changed();
        }
      }
      const jp = [1, 0, 0, 1, 0, 0];
      class Bp {
        constructor(t2, e2, i2, n2, r2) {
          this.styleFunction, this.extent_, this.id_ = r2, this.type_ = t2, this.flatCoordinates_ = e2, this.flatInteriorPoints_ = null, this.flatMidpoints_ = null, this.ends_ = i2, this.properties_ = n2;
        }
        get(t2) {
          return this.properties_[t2];
        }
        getExtent() {
          return this.extent_ || (this.extent_ = "Point" === this.type_ ? Qt(this.flatCoordinates_) : te(this.flatCoordinates_, 0, this.flatCoordinates_.length, 2)), this.extent_;
        }
        getFlatInteriorPoint() {
          if (!this.flatInteriorPoints_) {
            const t2 = ge(this.getExtent());
            this.flatInteriorPoints_ = Hn(this.flatCoordinates_, 0, this.ends_, 2, t2, 0);
          }
          return this.flatInteriorPoints_;
        }
        getFlatInteriorPoints() {
          if (!this.flatInteriorPoints_) {
            const t2 = kp(this.flatCoordinates_, 0, this.ends_, 2);
            this.flatInteriorPoints_ = $n(this.flatCoordinates_, 0, this.ends_, 2, t2);
          }
          return this.flatInteriorPoints_;
        }
        getFlatMidpoint() {
          return this.flatMidpoints_ || (this.flatMidpoints_ = Mp(this.flatCoordinates_, 0, this.flatCoordinates_.length, 2, 0.5)), this.flatMidpoints_;
        }
        getFlatMidpoints() {
          if (!this.flatMidpoints_) {
            this.flatMidpoints_ = [];
            const t2 = this.flatCoordinates_;
            let e2 = 0;
            const i2 = this.ends_;
            for (let n2 = 0, r2 = i2.length; n2 < r2; ++n2) {
              const r3 = i2[n2], s2 = Mp(t2, e2, r3, 2, 0.5);
              c(this.flatMidpoints_, s2), e2 = r3;
            }
          }
          return this.flatMidpoints_;
        }
        getId() {
          return this.id_;
        }
        getOrientedFlatCoordinates() {
          return this.flatCoordinates_;
        }
        getGeometry() {
          return this;
        }
        getSimplifiedGeometry(t2) {
          return this;
        }
        simplifyTransformed(t2, e2) {
          return this;
        }
        getProperties() {
          return this.properties_;
        }
        getStride() {
          return 2;
        }
        getStyleFunction() {
          return this.styleFunction;
        }
        getType() {
          return this.type_;
        }
        transform(t2) {
          const e2 = (t2 = Ui(t2)).getExtent(), i2 = t2.getWorldExtent();
          if (e2 && i2) {
            const t3 = _e(i2) / _e(e2);
            Mt(jp, i2[0], i2[3], t3, -t3, 0, 0, 0), un(this.flatCoordinates_, 0, this.flatCoordinates_.length, 2, jp, this.flatCoordinates_);
          }
        }
        getEnds() {
          return this.ends_;
        }
      }
      function Up(t2) {
        const e2 = t2.getType();
        switch (e2) {
          case "Point":
            return new Wn(t2.getFlatCoordinates());
          case "MultiPoint":
            return new Dp(t2.getFlatCoordinates(), "XY");
          case "LineString":
            return new Op(t2.getFlatCoordinates(), "XY");
          case "MultiLineString":
            return new Np(t2.getFlatCoordinates(), "XY", t2.getEnds());
          case "Polygon":
            const i2 = t2.getFlatCoordinates(), n2 = t2.getEnds(), r2 = cr(i2, n2);
            return r2.length > 1 ? new Gp(i2, "XY", r2) : new ur(i2, "XY", n2);
          default:
            throw new Error("Invalid geometry type:" + e2);
        }
      }
      Bp.prototype.getEndss = Bp.prototype.getEnds, Bp.prototype.getFlatCoordinates = Bp.prototype.getOrientedFlatCoordinates;
      class zp extends Ig {
        constructor(t2) {
          super(t2);
        }
        createRenderer() {
          return new Ep(this);
        }
      }
      function Xp(t2, e2, i2) {
        const n2 = [];
        let r2 = t2(0), s2 = t2(1), o2 = e2(r2), a2 = e2(s2);
        const l2 = [s2, r2], h2 = [a2, o2], c2 = [1, 0], u2 = {};
        let d2, g2, f2, p2, m2, _2, y2 = 1e5;
        for (; --y2 > 0 && c2.length > 0; )
          f2 = c2.pop(), r2 = l2.pop(), o2 = h2.pop(), _2 = f2.toString(), _2 in u2 || (n2.push(o2[0], o2[1]), u2[_2] = true), p2 = c2.pop(), s2 = l2.pop(), a2 = h2.pop(), m2 = (f2 + p2) / 2, d2 = t2(m2), g2 = e2(d2), ni(g2[0], g2[1], o2[0], o2[1], a2[0], a2[1]) < i2 ? (n2.push(a2[0], a2[1]), _2 = p2.toString(), u2[_2] = true) : (c2.push(p2, m2, m2, f2), h2.push(a2, g2, g2, o2), l2.push(s2, d2, d2, r2));
        return n2;
      }
      function Vp(t2, e2, i2, n2, r2) {
        return Xp(function(n3) {
          return [t2, e2 + (i2 - e2) * n3];
        }, Hi(Ui("EPSG:4326"), n2), r2);
      }
      function Wp(t2, e2, i2, n2, r2) {
        return Xp(function(n3) {
          return [e2 + (i2 - e2) * n3, t2];
        }, Hi(Ui("EPSG:4326"), n2), r2);
      }
      const Zp = new hg({ color: "rgba(0,0,0,0.2)" }), Yp = [90, 45, 30, 20, 10, 5, 2, 1, 0.5, 20 / 60, 10 / 60, 5 / 60, 2 / 60, 1 / 60, 30 / 3600, 20 / 3600, 10 / 3600, 5 / 3600, 2 / 3600, 1 / 3600];
      const Kp = "blur", qp = "gradient", Hp = "radius", $p = ["#00f", "#0ff", "#0f0", "#ff0", "#f00"];
      class Jp {
        constructor() {
          this.dataProjection = void 0, this.defaultFeatureProjection = void 0, this.supportedMediaTypes = null;
        }
        getReadOptions(t2, e2) {
          if (e2) {
            let i2 = e2.dataProjection ? Ui(e2.dataProjection) : this.readProjection(t2);
            e2.extent && i2 && "tile-pixels" === i2.getUnits() && (i2 = Ui(i2), i2.setWorldExtent(e2.extent)), e2 = { dataProjection: i2, featureProjection: e2.featureProjection };
          }
          return this.adaptOptions(e2);
        }
        adaptOptions(t2) {
          return Object.assign({ dataProjection: this.dataProjection, featureProjection: this.defaultFeatureProjection }, t2);
        }
        getType() {
          return B();
        }
        readFeature(t2, e2) {
          return B();
        }
        readFeatures(t2, e2) {
          return B();
        }
        readGeometry(t2, e2) {
          return B();
        }
        readProjection(t2) {
          return B();
        }
        writeFeature(t2, e2) {
          return B();
        }
        writeFeatures(t2, e2) {
          return B();
        }
        writeGeometry(t2, e2) {
          return B();
        }
      }
      function Qp(t2, e2, i2) {
        const n2 = i2 ? Ui(i2.featureProjection) : null, r2 = i2 ? Ui(i2.dataProjection) : null;
        let s2;
        if (s2 = n2 && r2 && !Ki(n2, r2) ? (e2 ? t2.clone() : t2).transform(e2 ? n2 : r2, e2 ? r2 : n2) : t2, e2 && i2 && void 0 !== i2.decimals) {
          const e3 = Math.pow(10, i2.decimals), n3 = function(t3) {
            for (let i3 = 0, n4 = t3.length; i3 < n4; ++i3)
              t3[i3] = Math.round(t3[i3] * e3) / e3;
            return t3;
          };
          s2 === t2 && (s2 = t2.clone()), s2.applyTransform(n3);
        }
        return s2;
      }
      function tm(t2, e2) {
        const i2 = e2 ? Ui(e2.featureProjection) : null, n2 = e2 ? Ui(e2.dataProjection) : null;
        return i2 && n2 && !Ki(i2, n2) ? Ji(t2, n2, i2) : t2;
      }
      var em = {
        read: function(t2, e2, i2, n2, r2) {
          var s2, o2, a2 = 8 * r2 - n2 - 1, l2 = (1 << a2) - 1, h2 = l2 >> 1, c2 = -7, u2 = i2 ? r2 - 1 : 0, d2 = i2 ? -1 : 1, g2 = t2[e2 + u2];
          for (u2 += d2, s2 = g2 & (1 << -c2) - 1, g2 >>= -c2, c2 += a2; c2 > 0; s2 = 256 * s2 + t2[e2 + u2], u2 += d2, c2 -= 8)
            ;
          for (o2 = s2 & (1 << -c2) - 1, s2 >>= -c2, c2 += n2; c2 > 0; o2 = 256 * o2 + t2[e2 + u2], u2 += d2, c2 -= 8)
            ;
          if (0 === s2)
            s2 = 1 - h2;
          else {
            if (s2 === l2)
              return o2 ? NaN : 1 / 0 * (g2 ? -1 : 1);
            o2 += Math.pow(2, n2), s2 -= h2;
          }
          return (g2 ? -1 : 1) * o2 * Math.pow(2, s2 - n2);
        },
        write: function(t2, e2, i2, n2, r2, s2) {
          var o2, a2, l2, h2 = 8 * s2 - r2 - 1, c2 = (1 << h2) - 1, u2 = c2 >> 1, d2 = 23 === r2 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, g2 = n2 ? 0 : s2 - 1, f2 = n2 ? 1 : -1, p2 = e2 < 0 || 0 === e2 && 1 / e2 < 0 ? 1 : 0;
          for (e2 = Math.abs(e2), isNaN(e2) || e2 === 1 / 0 ? (a2 = isNaN(e2) ? 1 : 0, o2 = c2) : (o2 = Math.floor(Math.log(e2) / Math.LN2), e2 * (l2 = Math.pow(2, -o2)) < 1 && (o2--, l2 *= 2), (e2 += o2 + u2 >= 1 ? d2 / l2 : d2 * Math.pow(2, 1 - u2)) * l2 >= 2 && (o2++, l2 /= 2), o2 + u2 >= c2 ? (a2 = 0, o2 = c2) : o2 + u2 >= 1 ? (a2 = (e2 * l2 - 1) * Math.pow(2, r2), o2 += u2) : (a2 = e2 * Math.pow(2, u2 - 1) * Math.pow(2, r2), o2 = 0)); r2 >= 8; t2[i2 + g2] = 255 & a2, g2 += f2, a2 /= 256, r2 -= 8)
            ;
          for (o2 = o2 << r2 | a2, h2 += r2; h2 > 0; t2[i2 + g2] = 255 & o2, g2 += f2, o2 /= 256, h2 -= 8)
            ;
          t2[i2 + g2 - f2] |= 128 * p2;
        }
      }, im = rm, nm = em;
      function rm(t2) {
        this.buf = ArrayBuffer.isView && ArrayBuffer.isView(t2) ? t2 : new Uint8Array(t2 || 0), this.pos = 0, this.type = 0, this.length = this.buf.length;
      }
      rm.Varint = 0, rm.Fixed64 = 1, rm.Bytes = 2, rm.Fixed32 = 5;
      var sm = 4294967296, om = 1 / sm, am = "undefined" == typeof TextDecoder ? null : new TextDecoder("utf8");
      function lm(t2) {
        return t2.type === rm.Bytes ? t2.readVarint() + t2.pos : t2.pos + 1;
      }
      function hm(t2, e2, i2) {
        return i2 ? 4294967296 * e2 + (t2 >>> 0) : 4294967296 * (e2 >>> 0) + (t2 >>> 0);
      }
      function cm(t2, e2, i2) {
        var n2 = e2 <= 16383 ? 1 : e2 <= 2097151 ? 2 : e2 <= 268435455 ? 3 : Math.floor(Math.log(e2) / (7 * Math.LN2));
        i2.realloc(n2);
        for (var r2 = i2.pos - 1; r2 >= t2; r2--)
          i2.buf[r2 + n2] = i2.buf[r2];
      }
      function um(t2, e2) {
        for (var i2 = 0; i2 < t2.length; i2++)
          e2.writeVarint(t2[i2]);
      }
      function dm(t2, e2) {
        for (var i2 = 0; i2 < t2.length; i2++)
          e2.writeSVarint(t2[i2]);
      }
      function gm(t2, e2) {
        for (var i2 = 0; i2 < t2.length; i2++)
          e2.writeFloat(t2[i2]);
      }
      function fm(t2, e2) {
        for (var i2 = 0; i2 < t2.length; i2++)
          e2.writeDouble(t2[i2]);
      }
      function pm(t2, e2) {
        for (var i2 = 0; i2 < t2.length; i2++)
          e2.writeBoolean(t2[i2]);
      }
      function mm(t2, e2) {
        for (var i2 = 0; i2 < t2.length; i2++)
          e2.writeFixed32(t2[i2]);
      }
      function _m(t2, e2) {
        for (var i2 = 0; i2 < t2.length; i2++)
          e2.writeSFixed32(t2[i2]);
      }
      function ym(t2, e2) {
        for (var i2 = 0; i2 < t2.length; i2++)
          e2.writeFixed64(t2[i2]);
      }
      function xm(t2, e2) {
        for (var i2 = 0; i2 < t2.length; i2++)
          e2.writeSFixed64(t2[i2]);
      }
      function vm(t2, e2) {
        return (t2[e2] | t2[e2 + 1] << 8 | t2[e2 + 2] << 16) + 16777216 * t2[e2 + 3];
      }
      function Sm(t2, e2, i2) {
        t2[i2] = e2, t2[i2 + 1] = e2 >>> 8, t2[i2 + 2] = e2 >>> 16, t2[i2 + 3] = e2 >>> 24;
      }
      function wm(t2, e2) {
        return (t2[e2] | t2[e2 + 1] << 8 | t2[e2 + 2] << 16) + (t2[e2 + 3] << 24);
      }
      rm.prototype = { destroy: function() {
        this.buf = null;
      }, readFields: function(t2, e2, i2) {
        for (i2 = i2 || this.length; this.pos < i2; ) {
          var n2 = this.readVarint(), r2 = n2 >> 3, s2 = this.pos;
          this.type = 7 & n2, t2(r2, e2, this), this.pos === s2 && this.skip(n2);
        }
        return e2;
      }, readMessage: function(t2, e2) {
        return this.readFields(t2, e2, this.readVarint() + this.pos);
      }, readFixed32: function() {
        var t2 = vm(this.buf, this.pos);
        return this.pos += 4, t2;
      }, readSFixed32: function() {
        var t2 = wm(this.buf, this.pos);
        return this.pos += 4, t2;
      }, readFixed64: function() {
        var t2 = vm(this.buf, this.pos) + vm(this.buf, this.pos + 4) * sm;
        return this.pos += 8, t2;
      }, readSFixed64: function() {
        var t2 = vm(this.buf, this.pos) + wm(this.buf, this.pos + 4) * sm;
        return this.pos += 8, t2;
      }, readFloat: function() {
        var t2 = nm.read(this.buf, this.pos, true, 23, 4);
        return this.pos += 4, t2;
      }, readDouble: function() {
        var t2 = nm.read(this.buf, this.pos, true, 52, 8);
        return this.pos += 8, t2;
      }, readVarint: function(t2) {
        var e2, i2, n2 = this.buf;
        return e2 = 127 & (i2 = n2[this.pos++]), i2 < 128 ? e2 : (e2 |= (127 & (i2 = n2[this.pos++])) << 7, i2 < 128 ? e2 : (e2 |= (127 & (i2 = n2[this.pos++])) << 14, i2 < 128 ? e2 : (e2 |= (127 & (i2 = n2[this.pos++])) << 21, i2 < 128 ? e2 : function(t3, e3, i3) {
          var n3, r2, s2 = i3.buf;
          if (r2 = s2[i3.pos++], n3 = (112 & r2) >> 4, r2 < 128)
            return hm(t3, n3, e3);
          if (r2 = s2[i3.pos++], n3 |= (127 & r2) << 3, r2 < 128)
            return hm(t3, n3, e3);
          if (r2 = s2[i3.pos++], n3 |= (127 & r2) << 10, r2 < 128)
            return hm(t3, n3, e3);
          if (r2 = s2[i3.pos++], n3 |= (127 & r2) << 17, r2 < 128)
            return hm(t3, n3, e3);
          if (r2 = s2[i3.pos++], n3 |= (127 & r2) << 24, r2 < 128)
            return hm(t3, n3, e3);
          if (r2 = s2[i3.pos++], n3 |= (1 & r2) << 31, r2 < 128)
            return hm(t3, n3, e3);
          throw new Error("Expected varint not more than 10 bytes");
        }(e2 |= (15 & (i2 = n2[this.pos])) << 28, t2, this))));
      }, readVarint64: function() {
        return this.readVarint(true);
      }, readSVarint: function() {
        var t2 = this.readVarint();
        return t2 % 2 == 1 ? (t2 + 1) / -2 : t2 / 2;
      }, readBoolean: function() {
        return Boolean(this.readVarint());
      }, readString: function() {
        var t2 = this.readVarint() + this.pos, e2 = this.pos;
        return this.pos = t2, t2 - e2 >= 12 && am ? function(t3, e3, i2) {
          return am.decode(t3.subarray(e3, i2));
        }(this.buf, e2, t2) : function(t3, e3, i2) {
          var n2 = "", r2 = e3;
          for (; r2 < i2; ) {
            var s2, o2, a2, l2 = t3[r2], h2 = null, c2 = l2 > 239 ? 4 : l2 > 223 ? 3 : l2 > 191 ? 2 : 1;
            if (r2 + c2 > i2)
              break;
            1 === c2 ? l2 < 128 && (h2 = l2) : 2 === c2 ? 128 == (192 & (s2 = t3[r2 + 1])) && (h2 = (31 & l2) << 6 | 63 & s2) <= 127 && (h2 = null) : 3 === c2 ? (s2 = t3[r2 + 1], o2 = t3[r2 + 2], 128 == (192 & s2) && 128 == (192 & o2) && ((h2 = (15 & l2) << 12 | (63 & s2) << 6 | 63 & o2) <= 2047 || h2 >= 55296 && h2 <= 57343) && (h2 = null)) : 4 === c2 && (s2 = t3[r2 + 1], o2 = t3[r2 + 2], a2 = t3[r2 + 3], 128 == (192 & s2) && 128 == (192 & o2) && 128 == (192 & a2) && ((h2 = (15 & l2) << 18 | (63 & s2) << 12 | (63 & o2) << 6 | 63 & a2) <= 65535 || h2 >= 1114112) && (h2 = null)), null === h2 ? (h2 = 65533, c2 = 1) : h2 > 65535 && (h2 -= 65536, n2 += String.fromCharCode(h2 >>> 10 & 1023 | 55296), h2 = 56320 | 1023 & h2), n2 += String.fromCharCode(h2), r2 += c2;
          }
          return n2;
        }(this.buf, e2, t2);
      }, readBytes: function() {
        var t2 = this.readVarint() + this.pos, e2 = this.buf.subarray(this.pos, t2);
        return this.pos = t2, e2;
      }, readPackedVarint: function(t2, e2) {
        if (this.type !== rm.Bytes)
          return t2.push(this.readVarint(e2));
        var i2 = lm(this);
        for (t2 = t2 || []; this.pos < i2; )
          t2.push(this.readVarint(e2));
        return t2;
      }, readPackedSVarint: function(t2) {
        if (this.type !== rm.Bytes)
          return t2.push(this.readSVarint());
        var e2 = lm(this);
        for (t2 = t2 || []; this.pos < e2; )
          t2.push(this.readSVarint());
        return t2;
      }, readPackedBoolean: function(t2) {
        if (this.type !== rm.Bytes)
          return t2.push(this.readBoolean());
        var e2 = lm(this);
        for (t2 = t2 || []; this.pos < e2; )
          t2.push(this.readBoolean());
        return t2;
      }, readPackedFloat: function(t2) {
        if (this.type !== rm.Bytes)
          return t2.push(this.readFloat());
        var e2 = lm(this);
        for (t2 = t2 || []; this.pos < e2; )
          t2.push(this.readFloat());
        return t2;
      }, readPackedDouble: function(t2) {
        if (this.type !== rm.Bytes)
          return t2.push(this.readDouble());
        var e2 = lm(this);
        for (t2 = t2 || []; this.pos < e2; )
          t2.push(this.readDouble());
        return t2;
      }, readPackedFixed32: function(t2) {
        if (this.type !== rm.Bytes)
          return t2.push(this.readFixed32());
        var e2 = lm(this);
        for (t2 = t2 || []; this.pos < e2; )
          t2.push(this.readFixed32());
        return t2;
      }, readPackedSFixed32: function(t2) {
        if (this.type !== rm.Bytes)
          return t2.push(this.readSFixed32());
        var e2 = lm(this);
        for (t2 = t2 || []; this.pos < e2; )
          t2.push(this.readSFixed32());
        return t2;
      }, readPackedFixed64: function(t2) {
        if (this.type !== rm.Bytes)
          return t2.push(this.readFixed64());
        var e2 = lm(this);
        for (t2 = t2 || []; this.pos < e2; )
          t2.push(this.readFixed64());
        return t2;
      }, readPackedSFixed64: function(t2) {
        if (this.type !== rm.Bytes)
          return t2.push(this.readSFixed64());
        var e2 = lm(this);
        for (t2 = t2 || []; this.pos < e2; )
          t2.push(this.readSFixed64());
        return t2;
      }, skip: function(t2) {
        var e2 = 7 & t2;
        if (e2 === rm.Varint)
          for (; this.buf[this.pos++] > 127; )
            ;
        else if (e2 === rm.Bytes)
          this.pos = this.readVarint() + this.pos;
        else if (e2 === rm.Fixed32)
          this.pos += 4;
        else {
          if (e2 !== rm.Fixed64)
            throw new Error("Unimplemented type: " + e2);
          this.pos += 8;
        }
      }, writeTag: function(t2, e2) {
        this.writeVarint(t2 << 3 | e2);
      }, realloc: function(t2) {
        for (var e2 = this.length || 16; e2 < this.pos + t2; )
          e2 *= 2;
        if (e2 !== this.length) {
          var i2 = new Uint8Array(e2);
          i2.set(this.buf), this.buf = i2, this.length = e2;
        }
      }, finish: function() {
        return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);
      }, writeFixed32: function(t2) {
        this.realloc(4), Sm(this.buf, t2, this.pos), this.pos += 4;
      }, writeSFixed32: function(t2) {
        this.realloc(4), Sm(this.buf, t2, this.pos), this.pos += 4;
      }, writeFixed64: function(t2) {
        this.realloc(8), Sm(this.buf, -1 & t2, this.pos), Sm(this.buf, Math.floor(t2 * om), this.pos + 4), this.pos += 8;
      }, writeSFixed64: function(t2) {
        this.realloc(8), Sm(this.buf, -1 & t2, this.pos), Sm(this.buf, Math.floor(t2 * om), this.pos + 4), this.pos += 8;
      }, writeVarint: function(t2) {
        (t2 = +t2 || 0) > 268435455 || t2 < 0 ? function(t3, e2) {
          var i2, n2;
          t3 >= 0 ? (i2 = t3 % 4294967296 | 0, n2 = t3 / 4294967296 | 0) : (n2 = ~(-t3 / 4294967296), 4294967295 ^ (i2 = ~(-t3 % 4294967296)) ? i2 = i2 + 1 | 0 : (i2 = 0, n2 = n2 + 1 | 0));
          if (t3 >= 18446744073709552e3 || t3 < -18446744073709552e3)
            throw new Error("Given varint doesn't fit into 10 bytes");
          e2.realloc(10), function(t4, e3, i3) {
            i3.buf[i3.pos++] = 127 & t4 | 128, t4 >>>= 7, i3.buf[i3.pos++] = 127 & t4 | 128, t4 >>>= 7, i3.buf[i3.pos++] = 127 & t4 | 128, t4 >>>= 7, i3.buf[i3.pos++] = 127 & t4 | 128, t4 >>>= 7, i3.buf[i3.pos] = 127 & t4;
          }(i2, 0, e2), function(t4, e3) {
            var i3 = (7 & t4) << 4;
            if (e3.buf[e3.pos++] |= i3 | ((t4 >>>= 3) ? 128 : 0), !t4)
              return;
            if (e3.buf[e3.pos++] = 127 & t4 | ((t4 >>>= 7) ? 128 : 0), !t4)
              return;
            if (e3.buf[e3.pos++] = 127 & t4 | ((t4 >>>= 7) ? 128 : 0), !t4)
              return;
            if (e3.buf[e3.pos++] = 127 & t4 | ((t4 >>>= 7) ? 128 : 0), !t4)
              return;
            if (e3.buf[e3.pos++] = 127 & t4 | ((t4 >>>= 7) ? 128 : 0), !t4)
              return;
            e3.buf[e3.pos++] = 127 & t4;
          }(n2, e2);
        }(t2, this) : (this.realloc(4), this.buf[this.pos++] = 127 & t2 | (t2 > 127 ? 128 : 0), t2 <= 127 || (this.buf[this.pos++] = 127 & (t2 >>>= 7) | (t2 > 127 ? 128 : 0), t2 <= 127 || (this.buf[this.pos++] = 127 & (t2 >>>= 7) | (t2 > 127 ? 128 : 0), t2 <= 127 || (this.buf[this.pos++] = t2 >>> 7 & 127))));
      }, writeSVarint: function(t2) {
        this.writeVarint(t2 < 0 ? 2 * -t2 - 1 : 2 * t2);
      }, writeBoolean: function(t2) {
        this.writeVarint(Boolean(t2));
      }, writeString: function(t2) {
        t2 = String(t2), this.realloc(4 * t2.length), this.pos++;
        var e2 = this.pos;
        this.pos = function(t3, e3, i3) {
          for (var n2, r2, s2 = 0; s2 < e3.length; s2++) {
            if ((n2 = e3.charCodeAt(s2)) > 55295 && n2 < 57344) {
              if (!r2) {
                n2 > 56319 || s2 + 1 === e3.length ? (t3[i3++] = 239, t3[i3++] = 191, t3[i3++] = 189) : r2 = n2;
                continue;
              }
              if (n2 < 56320) {
                t3[i3++] = 239, t3[i3++] = 191, t3[i3++] = 189, r2 = n2;
                continue;
              }
              n2 = r2 - 55296 << 10 | n2 - 56320 | 65536, r2 = null;
            } else
              r2 && (t3[i3++] = 239, t3[i3++] = 191, t3[i3++] = 189, r2 = null);
            n2 < 128 ? t3[i3++] = n2 : (n2 < 2048 ? t3[i3++] = n2 >> 6 | 192 : (n2 < 65536 ? t3[i3++] = n2 >> 12 | 224 : (t3[i3++] = n2 >> 18 | 240, t3[i3++] = n2 >> 12 & 63 | 128), t3[i3++] = n2 >> 6 & 63 | 128), t3[i3++] = 63 & n2 | 128);
          }
          return i3;
        }(this.buf, t2, this.pos);
        var i2 = this.pos - e2;
        i2 >= 128 && cm(e2, i2, this), this.pos = e2 - 1, this.writeVarint(i2), this.pos += i2;
      }, writeFloat: function(t2) {
        this.realloc(4), nm.write(this.buf, t2, this.pos, true, 23, 4), this.pos += 4;
      }, writeDouble: function(t2) {
        this.realloc(8), nm.write(this.buf, t2, this.pos, true, 52, 8), this.pos += 8;
      }, writeBytes: function(t2) {
        var e2 = t2.length;
        this.writeVarint(e2), this.realloc(e2);
        for (var i2 = 0; i2 < e2; i2++)
          this.buf[this.pos++] = t2[i2];
      }, writeRawMessage: function(t2, e2) {
        this.pos++;
        var i2 = this.pos;
        t2(e2, this);
        var n2 = this.pos - i2;
        n2 >= 128 && cm(i2, n2, this), this.pos = i2 - 1, this.writeVarint(n2), this.pos += n2;
      }, writeMessage: function(t2, e2, i2) {
        this.writeTag(t2, rm.Bytes), this.writeRawMessage(e2, i2);
      }, writePackedVarint: function(t2, e2) {
        e2.length && this.writeMessage(t2, um, e2);
      }, writePackedSVarint: function(t2, e2) {
        e2.length && this.writeMessage(t2, dm, e2);
      }, writePackedBoolean: function(t2, e2) {
        e2.length && this.writeMessage(t2, pm, e2);
      }, writePackedFloat: function(t2, e2) {
        e2.length && this.writeMessage(t2, gm, e2);
      }, writePackedDouble: function(t2, e2) {
        e2.length && this.writeMessage(t2, fm, e2);
      }, writePackedFixed32: function(t2, e2) {
        e2.length && this.writeMessage(t2, mm, e2);
      }, writePackedSFixed32: function(t2, e2) {
        e2.length && this.writeMessage(t2, _m, e2);
      }, writePackedFixed64: function(t2, e2) {
        e2.length && this.writeMessage(t2, ym, e2);
      }, writePackedSFixed64: function(t2, e2) {
        e2.length && this.writeMessage(t2, xm, e2);
      }, writeBytesField: function(t2, e2) {
        this.writeTag(t2, rm.Bytes), this.writeBytes(e2);
      }, writeFixed32Field: function(t2, e2) {
        this.writeTag(t2, rm.Fixed32), this.writeFixed32(e2);
      }, writeSFixed32Field: function(t2, e2) {
        this.writeTag(t2, rm.Fixed32), this.writeSFixed32(e2);
      }, writeFixed64Field: function(t2, e2) {
        this.writeTag(t2, rm.Fixed64), this.writeFixed64(e2);
      }, writeSFixed64Field: function(t2, e2) {
        this.writeTag(t2, rm.Fixed64), this.writeSFixed64(e2);
      }, writeVarintField: function(t2, e2) {
        this.writeTag(t2, rm.Varint), this.writeVarint(e2);
      }, writeSVarintField: function(t2, e2) {
        this.writeTag(t2, rm.Varint), this.writeSVarint(e2);
      }, writeStringField: function(t2, e2) {
        this.writeTag(t2, rm.Bytes), this.writeString(e2);
      }, writeFloatField: function(t2, e2) {
        this.writeTag(t2, rm.Fixed32), this.writeFloat(e2);
      }, writeDoubleField: function(t2, e2) {
        this.writeTag(t2, rm.Fixed64), this.writeDouble(e2);
      }, writeBooleanField: function(t2, e2) {
        this.writeVarintField(t2, Boolean(e2));
      } };
      class Em extends Jp {
        constructor(t2) {
          super(), t2 = t2 || {}, this.dataProjection = new Ae({ code: "", units: "tile-pixels" }), this.featureClass_ = t2.featureClass ? t2.featureClass : Bp, this.geometryName_ = t2.geometryName, this.layerName_ = t2.layerName ? t2.layerName : "layer", this.layers_ = t2.layers ? t2.layers : null, this.idProperty_ = t2.idProperty, this.supportedMediaTypes = ["application/vnd.mapbox-vector-tile", "application/x-protobuf"];
        }
        readRawGeometry_(t2, e2, i2, n2) {
          t2.pos = e2.geometry;
          const r2 = t2.readVarint() + t2.pos;
          let s2 = 1, o2 = 0, a2 = 0, l2 = 0, h2 = 0, c2 = 0;
          for (; t2.pos < r2; ) {
            if (!o2) {
              const e3 = t2.readVarint();
              s2 = 7 & e3, o2 = e3 >> 3;
            }
            o2--, 1 === s2 || 2 === s2 ? (a2 += t2.readSVarint(), l2 += t2.readSVarint(), 1 === s2 && h2 > c2 && (n2.push(h2), c2 = h2), i2.push(a2, l2), h2 += 2) : 7 === s2 ? h2 > c2 && (i2.push(i2[c2], i2[c2 + 1]), h2 += 2) : at(false, 59);
          }
          h2 > c2 && (n2.push(h2), c2 = h2);
        }
        createFeature_(t2, e2, i2) {
          const n2 = e2.type;
          if (0 === n2)
            return null;
          let r2;
          const s2 = e2.properties;
          let o2;
          this.idProperty_ ? (o2 = s2[this.idProperty_], delete s2[this.idProperty_]) : o2 = e2.id, s2[this.layerName_] = e2.layer.name;
          const a2 = [], l2 = [];
          this.readRawGeometry_(t2, e2, a2, l2);
          const h2 = function(t3, e3) {
            let i3;
            1 === t3 ? i3 = 1 === e3 ? "Point" : "MultiPoint" : 2 === t3 ? i3 = 1 === e3 ? "LineString" : "MultiLineString" : 3 === t3 && (i3 = "Polygon");
            return i3;
          }(n2, l2.length);
          if (this.featureClass_ === Bp)
            r2 = new this.featureClass_(h2, a2, l2, s2, o2), r2.transform(i2.dataProjection);
          else {
            let t3;
            if ("Polygon" == h2) {
              const e4 = cr(a2, l2);
              t3 = e4.length > 1 ? new Gp(a2, "XY", e4) : new ur(a2, "XY", l2);
            } else
              t3 = "Point" === h2 ? new Wn(a2, "XY") : "LineString" === h2 ? new Op(a2, "XY") : "MultiPoint" === h2 ? new Dp(a2, "XY") : "MultiLineString" === h2 ? new Np(a2, "XY", l2) : null;
            r2 = new (0, this.featureClass_)(), this.geometryName_ && r2.setGeometryName(this.geometryName_);
            const e3 = Qp(t3, false, i2);
            r2.setGeometry(e3), void 0 !== o2 && r2.setId(o2), r2.setProperties(s2, true);
          }
          return r2;
        }
        getType() {
          return "arraybuffer";
        }
        readFeatures(t2, e2) {
          const i2 = this.layers_, n2 = Ui((e2 = this.adaptOptions(e2)).dataProjection);
          n2.setWorldExtent(e2.extent), e2.dataProjection = n2;
          const r2 = new im(t2), s2 = r2.readFields(Tm, {}), o2 = [];
          for (const t3 in s2) {
            if (i2 && !i2.includes(t3))
              continue;
            const a2 = s2[t3], l2 = a2 ? [0, 0, a2.extent, a2.extent] : null;
            n2.setExtent(l2);
            for (let t4 = 0, i3 = a2.length; t4 < i3; ++t4) {
              const i4 = Rm(r2, a2, t4), n3 = this.createFeature_(r2, i4, e2);
              null !== n3 && o2.push(n3);
            }
          }
          return o2;
        }
        readProjection(t2) {
          return this.dataProjection;
        }
        setLayers(t2) {
          this.layers_ = t2;
        }
      }
      function Tm(t2, e2, i2) {
        if (3 === t2) {
          const t3 = { keys: [], values: [], features: [] }, n2 = i2.readVarint() + i2.pos;
          i2.readFields(Cm, t3, n2), t3.length = t3.features.length, t3.length && (e2[t3.name] = t3);
        }
      }
      function Cm(t2, e2, i2) {
        if (15 === t2)
          e2.version = i2.readVarint();
        else if (1 === t2)
          e2.name = i2.readString();
        else if (5 === t2)
          e2.extent = i2.readVarint();
        else if (2 === t2)
          e2.features.push(i2.pos);
        else if (3 === t2)
          e2.keys.push(i2.readString());
        else if (4 === t2) {
          let n2 = null;
          const r2 = i2.readVarint() + i2.pos;
          for (; i2.pos < r2; )
            n2 = 1 === (t2 = i2.readVarint() >> 3) ? i2.readString() : 2 === t2 ? i2.readFloat() : 3 === t2 ? i2.readDouble() : 4 === t2 ? i2.readVarint64() : 5 === t2 ? i2.readVarint() : 6 === t2 ? i2.readSVarint() : 7 === t2 ? i2.readBoolean() : null;
          e2.values.push(n2);
        }
      }
      function bm(t2, e2, i2) {
        if (1 == t2)
          e2.id = i2.readVarint();
        else if (2 == t2) {
          const t3 = i2.readVarint() + i2.pos;
          for (; i2.pos < t3; ) {
            const t4 = e2.layer.keys[i2.readVarint()], n2 = e2.layer.values[i2.readVarint()];
            e2.properties[t4] = n2;
          }
        } else
          3 == t2 ? e2.type = i2.readVarint() : 4 == t2 && (e2.geometry = i2.pos);
      }
      function Rm(t2, e2, i2) {
        t2.pos = e2.features[i2];
        const n2 = t2.readVarint() + t2.pos, r2 = { layer: e2, type: 0, properties: {} };
        return t2.readFields(bm, r2, n2), r2;
      }
      class Pm extends Ig {
        constructor(t2) {
          t2 = t2 || {};
          const e2 = Object.assign({}, t2);
          delete e2.preload, delete e2.useInterimTilesOnError, super(e2), this.on, this.once, this.un;
          const i2 = t2.renderMode || "hybrid";
          at("hybrid" == i2 || "vector" == i2, 28), this.renderMode_ = i2, this.setPreload(t2.preload ? t2.preload : 0), this.setUseInterimTilesOnError(void 0 === t2.useInterimTilesOnError || t2.useInterimTilesOnError), this.getBackground, this.setBackground;
        }
        createRenderer() {
          return new Rp(this);
        }
        getFeatures(t2) {
          return super.getFeatures(t2);
        }
        getRenderMode() {
          return this.renderMode_;
        }
        getPreload() {
          return this.get(Mc);
        }
        getUseInterimTilesOnError() {
          return this.get(Fc);
        }
        setPreload(t2) {
          this.set(Mc, t2);
        }
        setUseInterimTilesOnError(t2) {
          this.set(Fc, t2);
        }
      }
      class Im extends i {
        constructor(t2) {
          super(w), this.error = t2;
        }
      }
      function Lm(t2, e2) {
        const i2 = `
    attribute vec2 ${pd.TEXTURE_COORD};
    uniform mat4 ${fd.TILE_TRANSFORM};
    uniform float ${fd.TEXTURE_PIXEL_WIDTH};
    uniform float ${fd.TEXTURE_PIXEL_HEIGHT};
    uniform float ${fd.TEXTURE_RESOLUTION};
    uniform float ${fd.TEXTURE_ORIGIN_X};
    uniform float ${fd.TEXTURE_ORIGIN_Y};
    uniform float ${fd.DEPTH};

    varying vec2 v_textureCoord;
    varying vec2 v_mapCoord;

    void main() {
      v_textureCoord = ${pd.TEXTURE_COORD};
      v_mapCoord = vec2(
        ${fd.TEXTURE_ORIGIN_X} + ${fd.TEXTURE_RESOLUTION} * ${fd.TEXTURE_PIXEL_WIDTH} * v_textureCoord[0],
        ${fd.TEXTURE_ORIGIN_Y} - ${fd.TEXTURE_RESOLUTION} * ${fd.TEXTURE_PIXEL_HEIGHT} * v_textureCoord[1]
      );
      gl_Position = ${fd.TILE_TRANSFORM} * vec4(${pd.TEXTURE_COORD}, ${fd.DEPTH}, 1.0);
    }
  `, n2 = { inFragmentShader: true, variables: [], attributes: [], stringLiteralsMap: {}, functions: {}, bandCount: e2 }, r2 = [];
        if (void 0 !== t2.color) {
          const e3 = Gd(n2, t2.color, Cd);
          r2.push(`color = ${e3};`);
        }
        if (void 0 !== t2.contrast) {
          const e3 = Gd(n2, t2.contrast, Ed);
          r2.push(`color.rgb = clamp((${e3} + 1.0) * color.rgb - (${e3} / 2.0), vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));`);
        }
        if (void 0 !== t2.exposure) {
          const e3 = Gd(n2, t2.exposure, Ed);
          r2.push(`color.rgb = clamp((${e3} + 1.0) * color.rgb, vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));`);
        }
        if (void 0 !== t2.saturation) {
          const e3 = Gd(n2, t2.saturation, Ed);
          r2.push(`
      float saturation = ${e3} + 1.0;
      float sr = (1.0 - saturation) * 0.2126;
      float sg = (1.0 - saturation) * 0.7152;
      float sb = (1.0 - saturation) * 0.0722;
      mat3 saturationMatrix = mat3(
        sr + saturation, sr, sr,
        sg, sg + saturation, sg,
        sb, sb, sb + saturation
      );
      color.rgb = clamp(saturationMatrix * color.rgb, vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));
    `);
        }
        if (void 0 !== t2.gamma) {
          const e3 = Gd(n2, t2.gamma, Ed);
          r2.push(`color.rgb = pow(color.rgb, vec3(1.0 / ${e3}));`);
        }
        if (void 0 !== t2.brightness) {
          const e3 = Gd(n2, t2.brightness, Ed);
          r2.push(`color.rgb = clamp(color.rgb + ${e3}, vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));`);
        }
        const s2 = {}, o2 = n2.variables.length;
        if (o2 > 1 && !t2.variables)
          throw new Error(`Missing variables in style (expected ${n2.variables})`);
        for (let e3 = 0; e3 < o2; ++e3) {
          const i3 = n2.variables[e3];
          if (!(i3 in t2.variables))
            throw new Error(`Missing '${i3}' in style variables`);
          s2[Kd(i3)] = function() {
            let e4 = t2.variables[i3];
            return "string" == typeof e4 && (e4 = Dd(n2, e4)), void 0 !== e4 ? e4 : -9999999;
          };
        }
        const a2 = Object.keys(s2).map(function(t3) {
          return `uniform float ${t3};`;
        }), l2 = Math.ceil(e2 / 4);
        a2.push(`uniform sampler2D ${fd.TILE_TEXTURE_ARRAY}[${l2}];`), n2.paletteTextures && a2.push(`uniform sampler2D u_paletteTextures[${n2.paletteTextures.length}];`);
        const h2 = Object.keys(n2.functions).map(function(t3) {
          return n2.functions[t3];
        });
        return { vertexShader: i2, fragmentShader: `
    #ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    #else
    precision mediump float;
    #endif

    varying vec2 v_textureCoord;
    varying vec2 v_mapCoord;
    uniform vec4 ${fd.RENDER_EXTENT};
    uniform float ${fd.TRANSITION_ALPHA};
    uniform float ${fd.TEXTURE_PIXEL_WIDTH};
    uniform float ${fd.TEXTURE_PIXEL_HEIGHT};
    uniform float ${fd.RESOLUTION};
    uniform float ${fd.ZOOM};

    ${a2.join("\n")}

    ${h2.join("\n")}

    void main() {
      if (
        v_mapCoord[0] < ${fd.RENDER_EXTENT}[0] ||
        v_mapCoord[1] < ${fd.RENDER_EXTENT}[1] ||
        v_mapCoord[0] > ${fd.RENDER_EXTENT}[2] ||
        v_mapCoord[1] > ${fd.RENDER_EXTENT}[3]
      ) {
        discard;
      }

      vec4 color = texture2D(${fd.TILE_TEXTURE_ARRAY}[0],  v_textureCoord);

      ${r2.join("\n")}

      if (color.a == 0.0) {
        discard;
      }

      gl_FragColor = color;
      gl_FragColor.rgb *= gl_FragColor.a;
      gl_FragColor *= ${fd.TRANSITION_ALPHA};
    }`, uniforms: s2, paletteTextures: n2.paletteTextures };
      }
      class Mm extends Ac {
        constructor(t2) {
          const e2 = (t2 = t2 ? Object.assign({}, t2) : {}).style || {};
          delete t2.style;
          const i2 = t2.cacheSize;
          delete t2.cacheSize, super(t2), this.sources_ = t2.sources, this.renderedSource_ = null, this.renderedResolution_ = NaN, this.style_ = e2, this.cacheSize_ = i2, this.styleVariables_ = this.style_.variables || {}, this.addChangeListener(ds, this.handleSourceUpdate_);
        }
        getSources(t2, e2) {
          const i2 = this.getSource();
          return this.sources_ ? "function" == typeof this.sources_ ? this.sources_(t2, e2) : this.sources_ : i2 ? [i2] : [];
        }
        getRenderSource() {
          return this.renderedSource_ || this.getSource();
        }
        getSourceState() {
          const t2 = this.getRenderSource();
          return t2 ? t2.getState() : "undefined";
        }
        handleSourceUpdate_() {
          this.hasRenderer() && this.getRenderer().clearCache(), this.getSource() && this.setStyle(this.style_);
        }
        getSourceBandCount_() {
          const t2 = Number.MAX_SAFE_INTEGER, e2 = this.getSources([-t2, -t2, t2, t2], t2);
          return e2 && e2.length && "bandCount" in e2[0] ? e2[0].bandCount : 4;
        }
        createRenderer() {
          const t2 = Lm(this.style_, this.getSourceBandCount_());
          return new wd(this, { vertexShader: t2.vertexShader, fragmentShader: t2.fragmentShader, uniforms: t2.uniforms, cacheSize: this.cacheSize_, paletteTextures: t2.paletteTextures });
        }
        renderSources(t2, e2) {
          const i2 = this.getRenderer();
          let n2;
          for (let r2 = 0, s2 = e2.length; r2 < s2; ++r2)
            this.renderedSource_ = e2[r2], i2.prepareFrame(t2) && (n2 = i2.renderFrame(t2));
          return n2;
        }
        render(t2, e2) {
          this.rendered = true;
          const i2 = t2.viewState, n2 = this.getSources(t2.extent, i2.resolution);
          let r2 = true;
          for (let t3 = 0, e3 = n2.length; t3 < e3; ++t3) {
            const e4 = n2[t3], i3 = e4.getState();
            if ("loading" == i3) {
              const t4 = () => {
                "ready" == e4.getState() && (e4.removeEventListener("change", t4), this.changed());
              };
              e4.addEventListener("change", t4);
            }
            r2 = r2 && "ready" == i3;
          }
          const s2 = this.renderSources(t2, n2);
          if (this.getRenderer().renderComplete && r2)
            return this.renderedResolution_ = i2.resolution, s2;
          if (this.renderedResolution_ > 0.5 * i2.resolution) {
            const e3 = this.getSources(t2.extent, this.renderedResolution_).filter((t3) => !n2.includes(t3));
            if (e3.length > 0)
              return this.renderSources(t2, e3);
          }
          return s2;
        }
        setStyle(t2) {
          this.styleVariables_ = t2.variables || {}, this.style_ = t2;
          const e2 = Lm(this.style_, this.getSourceBandCount_());
          this.getRenderer().reset({ vertexShader: e2.vertexShader, fragmentShader: e2.fragmentShader, uniforms: e2.uniforms, paletteTextures: e2.paletteTextures }), this.changed();
        }
        updateStyleVariables(t2) {
          Object.assign(this.styleVariables_, t2), this.changed();
        }
      }
      Mm.prototype.dispose;
      const Fm = "addfeatures";
      class Am extends i {
        constructor(t2, e2, i2, n2) {
          super(t2), this.features = i2, this.file = e2, this.projection = n2;
        }
      }
      const Om = "drawstart", Nm = "drawend", Dm = "drawabort";
      class km extends i {
        constructor(t2, e2) {
          super(t2), this.feature = e2;
        }
      }
      function Gm(t2, e2) {
        return ri(t2[0], t2[1], e2[0], e2[1]);
      }
      function jm(t2, e2) {
        const i2 = t2.length;
        return e2 < 0 ? t2[e2 + i2] : e2 >= i2 ? t2[e2 - i2] : t2[e2];
      }
      function Bm(t2, e2, i2) {
        let n2, r2;
        e2 < i2 ? (n2 = e2, r2 = i2) : (n2 = i2, r2 = e2);
        const s2 = Math.ceil(n2), o2 = Math.floor(r2);
        if (s2 > o2) {
          return Gm(Zm(t2, n2), Zm(t2, r2));
        }
        let a2 = 0;
        if (n2 < s2) {
          a2 += Gm(Zm(t2, n2), jm(t2, s2));
        }
        if (o2 < r2) {
          a2 += Gm(jm(t2, o2), Zm(t2, r2));
        }
        for (let e3 = s2; e3 < o2 - 1; ++e3) {
          a2 += Gm(jm(t2, e3), jm(t2, e3 + 1));
        }
        return a2;
      }
      function Um(t2, e2, i2) {
        if (e2 instanceof Op)
          Xm(t2, e2.getCoordinates(), false, i2);
        else if (e2 instanceof Np) {
          const n2 = e2.getCoordinates();
          for (let e3 = 0, r2 = n2.length; e3 < r2; ++e3)
            Xm(t2, n2[e3], false, i2);
        } else if (e2 instanceof ur) {
          const n2 = e2.getCoordinates();
          for (let e3 = 0, r2 = n2.length; e3 < r2; ++e3)
            Xm(t2, n2[e3], true, i2);
        } else if (e2 instanceof Gp) {
          const n2 = e2.getCoordinates();
          for (let e3 = 0, r2 = n2.length; e3 < r2; ++e3) {
            const r3 = n2[e3];
            for (let e4 = 0, n3 = r3.length; e4 < n3; ++e4)
              Xm(t2, r3[e4], true, i2);
          }
        } else if (e2 instanceof Ip) {
          const n2 = e2.getGeometries();
          for (let e3 = 0; e3 < n2.length; ++e3)
            Um(t2, n2[e3], i2);
        } else
          ;
      }
      const zm = { index: -1, endIndex: NaN };
      function Xm(t2, e2, i2, n2) {
        const r2 = t2[0], s2 = t2[1];
        for (let t3 = 0, o2 = e2.length - 1; t3 < o2; ++t3) {
          const o3 = Wm(r2, s2, e2[t3], e2[t3 + 1]);
          if (0 === o3.squaredDistance) {
            const r3 = t3 + o3.along;
            return void n2.push({ coordinates: e2, ring: i2, startIndex: r3, endIndex: r3 });
          }
        }
      }
      const Vm = { along: 0, squaredDistance: 0 };
      function Wm(t2, e2, i2, n2) {
        const r2 = i2[0], s2 = i2[1], o2 = n2[0] - r2, a2 = n2[1] - s2;
        let l2 = 0, h2 = r2, c2 = s2;
        return 0 === o2 && 0 === a2 || (l2 = ii(((t2 - r2) * o2 + (e2 - s2) * a2) / (o2 * o2 + a2 * a2), 0, 1), h2 += o2 * l2, c2 += a2 * l2), Vm.along = l2, Vm.squaredDistance = ci(ri(t2, e2, h2, c2), 10), Vm;
      }
      function Zm(t2, e2) {
        const i2 = t2.length;
        let n2 = Math.floor(e2);
        const r2 = e2 - n2;
        n2 >= i2 ? n2 -= i2 : n2 < 0 && (n2 += i2);
        let s2 = n2 + 1;
        s2 >= i2 && (s2 -= i2);
        const o2 = t2[n2], a2 = o2[0], l2 = o2[1], h2 = t2[s2];
        return [a2 + (h2[0] - a2) * r2, l2 + (h2[1] - l2) * r2];
      }
      function Ym() {
        const t2 = fg();
        return function(e2, i2) {
          return t2[e2.getGeometry().getType()];
        };
      }
      const Km = "extentchanged";
      class qm extends i {
        constructor(t2) {
          super(Km), this.extent = t2;
        }
      }
      function Hm() {
        const t2 = fg();
        return function(e2, i2) {
          return t2.Polygon;
        };
      }
      function $m() {
        const t2 = fg();
        return function(e2, i2) {
          return t2.Point;
        };
      }
      function Jm(t2) {
        return function(e2) {
          return zt([t2, e2]);
        };
      }
      function Qm(t2, e2) {
        return t2[0] == e2[0] ? function(i2) {
          return zt([t2, [i2[0], e2[1]]]);
        } : t2[1] == e2[1] ? function(i2) {
          return zt([t2, [e2[0], i2[1]]]);
        } : null;
      }
      function t_(t2) {
        return parseFloat(t2);
      }
      function e_(t2) {
        return function(t3) {
          return ci(t3, 5);
        }(t2).toString();
      }
      function i_(t2, e2) {
        return !isNaN(t2) && t2 !== t_(e_(e2));
      }
      const n_ = [0, 0, 0, 0], r_ = [], s_ = "modifystart", o_ = "modifyend";
      class a_ extends i {
        constructor(t2, e2, i2) {
          super(t2), this.features = e2, this.mapBrowserEvent = i2;
        }
      }
      function l_(t2, e2) {
        return t2.index - e2.index;
      }
      function h_(t2, e2, i2) {
        const n2 = e2.geometry;
        if ("Circle" === n2.getType()) {
          let r3 = n2;
          if (1 === e2.index) {
            const e3 = en();
            e3 && (r3 = r3.clone().transform(e3, i2));
            const n3 = Ti(r3.getCenter(), rn(t2, i2)), s2 = Math.sqrt(n3) - r3.getRadius();
            return s2 * s2;
          }
        }
        const r2 = rn(t2, i2);
        return r_[0] = rn(e2.segment[0], i2), r_[1] = rn(e2.segment[1], i2), bi(r2, r_);
      }
      function c_(t2, e2, i2) {
        const n2 = e2.geometry;
        if ("Circle" === n2.getType() && 1 === e2.index) {
          let e3 = n2;
          const r3 = en();
          return r3 && (e3 = e3.clone().transform(r3, i2)), nn(e3.getClosestPoint(rn(t2, i2)), i2);
        }
        const r2 = rn(t2, i2);
        return r_[0] = rn(e2.segment[0], i2), r_[1] = rn(e2.segment[1], i2), nn(yi(r2, r_), i2);
      }
      function u_() {
        const t2 = fg();
        return function(e2, i2) {
          return t2.Point;
        };
      }
      const d_ = "select";
      class g_ extends i {
        constructor(t2, e2, i2, n2) {
          super(t2), this.selected = e2, this.deselected = i2, this.mapBrowserEvent = n2;
        }
      }
      const f_ = {};
      class p_ extends ea {
        constructor(t2) {
          let e2;
          if (super(), this.on, this.once, this.un, t2 = t2 || {}, this.boundAddFeature_ = this.addFeature_.bind(this), this.boundRemoveFeature_ = this.removeFeature_.bind(this), this.condition_ = t2.condition ? t2.condition : pa, this.addCondition_ = t2.addCondition ? t2.addCondition : fa, this.removeCondition_ = t2.removeCondition ? t2.removeCondition : fa, this.toggleCondition_ = t2.toggleCondition ? t2.toggleCondition : _a, this.multi_ = !!t2.multi && t2.multi, this.filter_ = t2.filter ? t2.filter : g, this.hitTolerance_ = t2.hitTolerance ? t2.hitTolerance : 0, this.style_ = void 0 !== t2.style ? t2.style : function() {
            const t3 = fg();
            return c(t3.Polygon, t3.LineString), c(t3.GeometryCollection, t3.LineString), function(e3) {
              return e3.getGeometry() ? t3[e3.getGeometry().getType()] : null;
            };
          }(), this.features_ = t2.features || new q(), t2.layers)
            if ("function" == typeof t2.layers)
              e2 = t2.layers;
            else {
              const i2 = t2.layers;
              e2 = function(t3) {
                return i2.includes(t3);
              };
            }
          else
            e2 = g;
          this.layerFilter_ = e2, this.featureLayerAssociation_ = {};
        }
        addFeatureLayerAssociation_(t2, e2) {
          this.featureLayerAssociation_[z(t2)] = e2;
        }
        getFeatures() {
          return this.features_;
        }
        getHitTolerance() {
          return this.hitTolerance_;
        }
        getLayer(t2) {
          return this.featureLayerAssociation_[z(t2)];
        }
        setHitTolerance(t2) {
          this.hitTolerance_ = t2;
        }
        setMap(t2) {
          this.getMap() && this.style_ && this.features_.forEach(this.restorePreviousStyle_.bind(this)), super.setMap(t2), t2 ? (this.features_.addEventListener(W, this.boundAddFeature_), this.features_.addEventListener(Z, this.boundRemoveFeature_), this.style_ && this.features_.forEach(this.applySelectedStyle_.bind(this))) : (this.features_.removeEventListener(W, this.boundAddFeature_), this.features_.removeEventListener(Z, this.boundRemoveFeature_));
        }
        addFeature_(t2) {
          const e2 = t2.element;
          if (this.style_ && this.applySelectedStyle_(e2), !this.getLayer(e2)) {
            const t3 = this.getMap().getAllLayers().find(function(t4) {
              if (t4 instanceof zp && t4.getSource() && t4.getSource().hasFeature(e2))
                return t4;
            });
            t3 && this.addFeatureLayerAssociation_(e2, t3);
          }
        }
        removeFeature_(t2) {
          this.style_ && this.restorePreviousStyle_(t2.element);
        }
        getStyle() {
          return this.style_;
        }
        applySelectedStyle_(t2) {
          const e2 = z(t2);
          e2 in f_ || (f_[e2] = t2.getStyle()), t2.setStyle(this.style_);
        }
        restorePreviousStyle_(t2) {
          const e2 = this.getMap().getInteractions().getArray();
          for (let i3 = e2.length - 1; i3 >= 0; --i3) {
            const n2 = e2[i3];
            if (n2 !== this && n2 instanceof p_ && n2.getStyle() && -1 !== n2.getFeatures().getArray().lastIndexOf(t2))
              return void t2.setStyle(n2.getStyle());
          }
          const i2 = z(t2);
          t2.setStyle(f_[i2]), delete f_[i2];
        }
        removeFeatureLayerAssociation_(t2) {
          delete this.featureLayerAssociation_[z(t2)];
        }
        handleEvent(t2) {
          if (!this.condition_(t2))
            return true;
          const e2 = this.addCondition_(t2), i2 = this.removeCondition_(t2), n2 = this.toggleCondition_(t2), r2 = !e2 && !i2 && !n2, s2 = t2.map, o2 = this.getFeatures(), a2 = [], l2 = [];
          if (r2) {
            y(this.featureLayerAssociation_), s2.forEachFeatureAtPixel(t2.pixel, function(t3, e3) {
              if (t3 instanceof lt && this.filter_(t3, e3))
                return this.addFeatureLayerAssociation_(t3, e3), l2.push(t3), !this.multi_;
            }.bind(this), { layerFilter: this.layerFilter_, hitTolerance: this.hitTolerance_ });
            for (let t3 = o2.getLength() - 1; t3 >= 0; --t3) {
              const e3 = o2.item(t3), i3 = l2.indexOf(e3);
              i3 > -1 ? l2.splice(i3, 1) : (o2.remove(e3), a2.push(e3));
            }
            0 !== l2.length && o2.extend(l2);
          } else {
            s2.forEachFeatureAtPixel(t2.pixel, function(t3, r3) {
              if (t3 instanceof lt && this.filter_(t3, r3))
                return !e2 && !n2 || o2.getArray().includes(t3) ? (i2 || n2) && o2.getArray().includes(t3) && (a2.push(t3), this.removeFeatureLayerAssociation_(t3)) : (this.addFeatureLayerAssociation_(t3, r3), l2.push(t3)), !this.multi_;
            }.bind(this), { layerFilter: this.layerFilter_, hitTolerance: this.hitTolerance_ });
            for (let t3 = a2.length - 1; t3 >= 0; --t3)
              o2.remove(a2[t3]);
            o2.extend(l2);
          }
          return (l2.length > 0 || a2.length > 0) && this.dispatchEvent(new g_(d_, l2, a2, t2)), true;
        }
      }
      function m_(t2) {
        return t2.feature ? t2.feature : t2.element ? t2.element : void 0;
      }
      const __ = [];
      const y_ = "translatestart", x_ = "translating", v_ = "translateend";
      class S_ extends i {
        constructor(t2, e2, i2, n2, r2) {
          super(t2), this.features = e2, this.coordinate = i2, this.startCoordinate = n2, this.mapBrowserEvent = r2;
        }
      }
      function w_(t2, e2, i2, n2, r2, s2) {
        void 0 !== r2 ? s2 = void 0 !== s2 ? s2 : 0 : (r2 = [], s2 = 0);
        let o2 = e2;
        for (; o2 < i2; ) {
          const e3 = t2[o2++];
          r2[s2++] = t2[o2++], r2[s2++] = e3;
          for (let e4 = 2; e4 < n2; ++e4)
            r2[s2++] = t2[o2++];
        }
        return r2.length = s2, r2;
      }
      class E_ extends Jp {
        constructor() {
          super();
        }
        getType() {
          return "json";
        }
        readFeature(t2, e2) {
          return this.readFeatureFromObject(T_(t2), this.getReadOptions(t2, e2));
        }
        readFeatures(t2, e2) {
          return this.readFeaturesFromObject(T_(t2), this.getReadOptions(t2, e2));
        }
        readFeatureFromObject(t2, e2) {
          return B();
        }
        readFeaturesFromObject(t2, e2) {
          return B();
        }
        readGeometry(t2, e2) {
          return this.readGeometryFromObject(T_(t2), this.getReadOptions(t2, e2));
        }
        readGeometryFromObject(t2, e2) {
          return B();
        }
        readProjection(t2) {
          return this.readProjectionFromObject(T_(t2));
        }
        readProjectionFromObject(t2) {
          return B();
        }
        writeFeature(t2, e2) {
          return JSON.stringify(this.writeFeatureObject(t2, e2));
        }
        writeFeatureObject(t2, e2) {
          return B();
        }
        writeFeatures(t2, e2) {
          return JSON.stringify(this.writeFeaturesObject(t2, e2));
        }
        writeFeaturesObject(t2, e2) {
          return B();
        }
        writeGeometry(t2, e2) {
          return JSON.stringify(this.writeGeometryObject(t2, e2));
        }
        writeGeometryObject(t2, e2) {
          return B();
        }
      }
      function T_(t2) {
        if ("string" == typeof t2) {
          const e2 = JSON.parse(t2);
          return e2 || null;
        }
        return null !== t2 ? t2 : null;
      }
      const C_ = { Point: function(t2) {
        let e2;
        e2 = void 0 !== t2.m && void 0 !== t2.z ? new Wn([t2.x, t2.y, t2.z, t2.m], "XYZM") : void 0 !== t2.z ? new Wn([t2.x, t2.y, t2.z], "XYZ") : void 0 !== t2.m ? new Wn([t2.x, t2.y, t2.m], "XYM") : new Wn([t2.x, t2.y]);
        return e2;
      }, LineString: function(t2) {
        const e2 = P_(t2);
        return new Op(t2.paths[0], e2);
      }, Polygon: function(t2) {
        const e2 = P_(t2);
        return new ur(t2.rings, e2);
      }, MultiPoint: function(t2) {
        const e2 = P_(t2);
        return new Dp(t2.points, e2);
      }, MultiLineString: function(t2) {
        const e2 = P_(t2);
        return new Np(t2.paths, e2);
      }, MultiPolygon: function(t2) {
        const e2 = P_(t2);
        return new Gp(t2.rings, e2);
      } }, b_ = { Point: function(t2, e2) {
        const i2 = t2.getCoordinates();
        let n2;
        const r2 = t2.getLayout();
        "XYZ" === r2 ? n2 = { x: i2[0], y: i2[1], z: i2[2] } : "XYM" === r2 ? n2 = { x: i2[0], y: i2[1], m: i2[2] } : "XYZM" === r2 ? n2 = { x: i2[0], y: i2[1], z: i2[2], m: i2[3] } : "XY" === r2 ? n2 = { x: i2[0], y: i2[1] } : at(false, 34);
        return n2;
      }, LineString: function(t2, e2) {
        const i2 = I_(t2);
        return { hasZ: i2.hasZ, hasM: i2.hasM, paths: [t2.getCoordinates()] };
      }, Polygon: function(t2, e2) {
        const i2 = I_(t2);
        return { hasZ: i2.hasZ, hasM: i2.hasM, rings: t2.getCoordinates(false) };
      }, MultiPoint: function(t2, e2) {
        const i2 = I_(t2);
        return { hasZ: i2.hasZ, hasM: i2.hasM, points: t2.getCoordinates() };
      }, MultiLineString: function(t2, e2) {
        const i2 = I_(t2);
        return { hasZ: i2.hasZ, hasM: i2.hasM, paths: t2.getCoordinates() };
      }, MultiPolygon: function(t2, e2) {
        const i2 = I_(t2), n2 = t2.getCoordinates(false), r2 = [];
        for (let t3 = 0; t3 < n2.length; t3++)
          for (let e3 = n2[t3].length - 1; e3 >= 0; e3--)
            r2.push(n2[t3][e3]);
        return { hasZ: i2.hasZ, hasM: i2.hasM, rings: r2 };
      } };
      function R_(t2, e2) {
        if (!t2)
          return null;
        let i2;
        if ("number" == typeof t2.x && "number" == typeof t2.y)
          i2 = "Point";
        else if (t2.points)
          i2 = "MultiPoint";
        else if (t2.paths) {
          i2 = 1 === t2.paths.length ? "LineString" : "MultiLineString";
        } else if (t2.rings) {
          const e3 = t2, n2 = P_(e3), r2 = function(t3, e4) {
            const i3 = [], n3 = [], r3 = [];
            let s2, o2;
            for (s2 = 0, o2 = t3.length; s2 < o2; ++s2) {
              i3.length = 0, Pn(i3, 0, t3[s2], e4.length);
              sr(i3, 0, i3.length, e4.length) ? n3.push([t3[s2]]) : r3.push(t3[s2]);
            }
            for (; r3.length; ) {
              const t4 = r3.shift();
              let e5 = false;
              for (s2 = n3.length - 1; s2 >= 0; s2--) {
                const i4 = n3[s2][0];
                if (Yt(new Vn(i4).getExtent(), new Vn(t4).getExtent())) {
                  n3[s2].push(t4), e5 = true;
                  break;
                }
              }
              e5 || n3.push([t4.reverse()]);
            }
            return n3;
          }(e3.rings, n2);
          1 === r2.length ? (i2 = "Polygon", t2 = Object.assign({}, t2, { rings: r2[0] })) : (i2 = "MultiPolygon", t2 = Object.assign({}, t2, { rings: r2 }));
        }
        return Qp((0, C_[i2])(t2), false, e2);
      }
      function P_(t2) {
        let e2 = "XY";
        return true === t2.hasZ && true === t2.hasM ? e2 = "XYZM" : true === t2.hasZ ? e2 = "XYZ" : true === t2.hasM && (e2 = "XYM"), e2;
      }
      function I_(t2) {
        const e2 = t2.getLayout();
        return { hasZ: "XYZ" === e2 || "XYZM" === e2, hasM: "XYM" === e2 || "XYZM" === e2 };
      }
      function L_(t2, e2) {
        return (0, b_[t2.getType()])(Qp(t2, true, e2), e2);
      }
      class M_ extends Jp {
        constructor() {
          super(), this.xmlSerializer_ = Nu();
        }
        getType() {
          return "xml";
        }
        readFeature(t2, e2) {
          if (t2) {
            if ("string" == typeof t2) {
              const i2 = _u(t2);
              return this.readFeatureFromDocument(i2, e2);
            }
            return pu(t2) ? this.readFeatureFromDocument(t2, e2) : this.readFeatureFromNode(t2, e2);
          }
          return null;
        }
        readFeatureFromDocument(t2, e2) {
          const i2 = this.readFeaturesFromDocument(t2, e2);
          return i2.length > 0 ? i2[0] : null;
        }
        readFeatureFromNode(t2, e2) {
          return null;
        }
        readFeatures(t2, e2) {
          if (t2) {
            if ("string" == typeof t2) {
              const i2 = _u(t2);
              return this.readFeaturesFromDocument(i2, e2);
            }
            return pu(t2) ? this.readFeaturesFromDocument(t2, e2) : this.readFeaturesFromNode(t2, e2);
          }
          return [];
        }
        readFeaturesFromDocument(t2, e2) {
          const i2 = [];
          for (let n2 = t2.firstChild; n2; n2 = n2.nextSibling)
            n2.nodeType == Node.ELEMENT_NODE && c(i2, this.readFeaturesFromNode(n2, e2));
          return i2;
        }
        readFeaturesFromNode(t2, e2) {
          return B();
        }
        readGeometry(t2, e2) {
          if (t2) {
            if ("string" == typeof t2) {
              const i2 = _u(t2);
              return this.readGeometryFromDocument(i2, e2);
            }
            return pu(t2) ? this.readGeometryFromDocument(t2, e2) : this.readGeometryFromNode(t2, e2);
          }
          return null;
        }
        readGeometryFromDocument(t2, e2) {
          return null;
        }
        readGeometryFromNode(t2, e2) {
          return null;
        }
        readProjection(t2) {
          if (t2) {
            if ("string" == typeof t2) {
              const e2 = _u(t2);
              return this.readProjectionFromDocument(e2);
            }
            return pu(t2) ? this.readProjectionFromDocument(t2) : this.readProjectionFromNode(t2);
          }
          return null;
        }
        readProjectionFromDocument(t2) {
          return this.dataProjection;
        }
        readProjectionFromNode(t2) {
          return this.dataProjection;
        }
        writeFeature(t2, e2) {
          const i2 = this.writeFeatureNode(t2, e2);
          return this.xmlSerializer_.serializeToString(i2);
        }
        writeFeatureNode(t2, e2) {
          return null;
        }
        writeFeatures(t2, e2) {
          const i2 = this.writeFeaturesNode(t2, e2);
          return this.xmlSerializer_.serializeToString(i2);
        }
        writeFeaturesNode(t2, e2) {
          return null;
        }
        writeGeometry(t2, e2) {
          const i2 = this.writeGeometryNode(t2, e2);
          return this.xmlSerializer_.serializeToString(i2);
        }
        writeGeometryNode(t2, e2) {
          return null;
        }
      }
      const F_ = "http://www.opengis.net/gml", A_ = /^\s*$/;
      class O_ extends M_ {
        constructor(t2) {
          super(), t2 = t2 || {}, this.featureType = t2.featureType, this.featureNS = t2.featureNS, this.srsName = t2.srsName, this.schemaLocation = "", this.FEATURE_COLLECTION_PARSERS = {}, this.FEATURE_COLLECTION_PARSERS[this.namespace] = { featureMember: xu(this.readFeaturesInternal), featureMembers: vu(this.readFeaturesInternal) }, this.supportedMediaTypes = ["application/gml+xml"];
        }
        readFeaturesInternal(t2, e2) {
          const i2 = t2.localName;
          let n2 = null;
          if ("FeatureCollection" == i2)
            n2 = Lu([], this.FEATURE_COLLECTION_PARSERS, t2, e2, this);
          else if ("featureMembers" == i2 || "featureMember" == i2 || "member" == i2) {
            const r2 = e2[0];
            let s2 = r2.featureType, o2 = r2.featureNS;
            const a2 = "p", l2 = "p0";
            if (!s2 && t2.childNodes) {
              s2 = [], o2 = {};
              for (let e3 = 0, i3 = t2.childNodes.length; e3 < i3; ++e3) {
                const i4 = t2.childNodes[e3];
                if (1 === i4.nodeType) {
                  const t3 = i4.nodeName.split(":").pop();
                  if (!s2.includes(t3)) {
                    let e4 = "", n3 = 0;
                    const r3 = i4.namespaceURI;
                    for (const t4 in o2) {
                      if (o2[t4] === r3) {
                        e4 = t4;
                        break;
                      }
                      ++n3;
                    }
                    e4 || (e4 = a2 + n3, o2[e4] = r3), s2.push(e4 + ":" + t3);
                  }
                }
              }
              "featureMember" != i2 && (r2.featureType = s2, r2.featureNS = o2);
            }
            if ("string" == typeof o2) {
              const t3 = o2;
              o2 = {}, o2[l2] = t3;
            }
            const h2 = {}, c2 = Array.isArray(s2) ? s2 : [s2];
            for (const t3 in o2) {
              const e3 = {};
              for (let n3 = 0, r3 = c2.length; n3 < r3; ++n3) {
                (c2[n3].includes(":") ? c2[n3].split(":")[0] : l2) === t3 && (e3[c2[n3].split(":").pop()] = "featureMembers" == i2 ? xu(this.readFeatureElement, this) : vu(this.readFeatureElement, this));
              }
              h2[o2[t3]] = e3;
            }
            n2 = Lu("featureMember" == i2 || "member" == i2 ? void 0 : [], h2, t2, e2);
          }
          return null === n2 && (n2 = []), n2;
        }
        readGeometryOrExtent(t2, e2) {
          const i2 = e2[0];
          return i2.srsName = t2.firstElementChild.getAttribute("srsName"), i2.srsDimension = t2.firstElementChild.getAttribute("srsDimension"), Lu(null, this.GEOMETRY_PARSERS, t2, e2, this);
        }
        readExtentElement(t2, e2) {
          const i2 = e2[0], n2 = this.readGeometryOrExtent(t2, e2);
          return n2 ? tm(n2, i2) : void 0;
        }
        readGeometryElement(t2, e2) {
          const i2 = e2[0], n2 = this.readGeometryOrExtent(t2, e2);
          return n2 ? Qp(n2, false, i2) : void 0;
        }
        readFeatureElementInternal(t2, e2, i2) {
          let n2;
          const r2 = {};
          for (let s2 = t2.firstElementChild; s2; s2 = s2.nextElementSibling) {
            let t3;
            const o2 = s2.localName;
            0 === s2.childNodes.length || 1 === s2.childNodes.length && (3 === s2.firstChild.nodeType || 4 === s2.firstChild.nodeType) ? (t3 = gu(s2, false), A_.test(t3) && (t3 = void 0)) : (i2 && (t3 = "boundedBy" === o2 ? this.readExtentElement(s2, e2) : this.readGeometryElement(s2, e2)), t3 ? "boundedBy" !== o2 && (n2 = o2) : t3 = this.readFeatureElementInternal(s2, e2, false));
            const a2 = s2.attributes.length;
            if (a2 > 0) {
              t3 = { _content_: t3 };
              for (let e3 = 0; e3 < a2; e3++) {
                t3[s2.attributes[e3].name] = s2.attributes[e3].value;
              }
            }
            r2[o2] ? (r2[o2] instanceof Array || (r2[o2] = [r2[o2]]), r2[o2].push(t3)) : r2[o2] = t3;
          }
          if (i2) {
            const e3 = new lt(r2);
            n2 && e3.setGeometryName(n2);
            const i3 = t2.getAttribute("fid") || mu(t2, this.namespace, "id");
            return i3 && e3.setId(i3), e3;
          }
          return r2;
        }
        readFeatureElement(t2, e2) {
          return this.readFeatureElementInternal(t2, e2, true);
        }
        readPoint(t2, e2) {
          const i2 = this.readFlatCoordinatesFromNode(t2, e2);
          if (i2)
            return new Wn(i2, "XYZ");
        }
        readMultiPoint(t2, e2) {
          const i2 = Lu([], this.MULTIPOINT_PARSERS, t2, e2, this);
          return i2 ? new Dp(i2) : void 0;
        }
        readMultiLineString(t2, e2) {
          const i2 = Lu([], this.MULTILINESTRING_PARSERS, t2, e2, this);
          if (i2)
            return new Np(i2);
        }
        readMultiPolygon(t2, e2) {
          const i2 = Lu([], this.MULTIPOLYGON_PARSERS, t2, e2, this);
          if (i2)
            return new Gp(i2);
        }
        pointMemberParser(t2, e2) {
          Iu(this.POINTMEMBER_PARSERS, t2, e2, this);
        }
        lineStringMemberParser(t2, e2) {
          Iu(this.LINESTRINGMEMBER_PARSERS, t2, e2, this);
        }
        polygonMemberParser(t2, e2) {
          Iu(this.POLYGONMEMBER_PARSERS, t2, e2, this);
        }
        readLineString(t2, e2) {
          const i2 = this.readFlatCoordinatesFromNode(t2, e2);
          if (i2) {
            return new Op(i2, "XYZ");
          }
        }
        readFlatLinearRing(t2, e2) {
          const i2 = Lu(null, this.GEOMETRY_FLAT_COORDINATES_PARSERS, t2, e2, this);
          return i2 || void 0;
        }
        readLinearRing(t2, e2) {
          const i2 = this.readFlatCoordinatesFromNode(t2, e2);
          if (i2)
            return new Vn(i2, "XYZ");
        }
        readPolygon(t2, e2) {
          const i2 = Lu([null], this.FLAT_LINEAR_RINGS_PARSERS, t2, e2, this);
          if (i2 && i2[0]) {
            const t3 = i2[0], e3 = [t3.length];
            let n2, r2;
            for (n2 = 1, r2 = i2.length; n2 < r2; ++n2)
              c(t3, i2[n2]), e3.push(t3.length);
            return new ur(t3, "XYZ", e3);
          }
        }
        readFlatCoordinatesFromNode(t2, e2) {
          return Lu(null, this.GEOMETRY_FLAT_COORDINATES_PARSERS, t2, e2, this);
        }
        readGeometryFromNode(t2, e2) {
          const i2 = this.readGeometryElement(t2, [this.getReadOptions(t2, e2 || {})]);
          return i2 || null;
        }
        readFeaturesFromNode(t2, e2) {
          const i2 = { featureType: this.featureType, featureNS: this.featureNS };
          i2 && Object.assign(i2, this.getReadOptions(t2, e2));
          return this.readFeaturesInternal(t2, [i2]) || [];
        }
        readProjectionFromNode(t2) {
          return Ui(this.srsName ? this.srsName : t2.firstElementChild.getAttribute("srsName"));
        }
      }
      function N_(t2) {
        return D_(gu(t2, false));
      }
      function D_(t2) {
        const e2 = /^\s*(true|1)|(false|0)\s*$/.exec(t2);
        return e2 ? void 0 !== e2[1] || false : void 0;
      }
      function k_(t2) {
        const e2 = gu(t2, false), i2 = Date.parse(e2);
        return isNaN(i2) ? void 0 : i2 / 1e3;
      }
      function G_(t2) {
        return j_(gu(t2, false));
      }
      function j_(t2) {
        const e2 = /^\s*([+\-]?\d*\.?\d+(?:e[+\-]?\d+)?)\s*$/i.exec(t2);
        return e2 ? parseFloat(e2[1]) : void 0;
      }
      function B_(t2) {
        return U_(gu(t2, false));
      }
      function U_(t2) {
        const e2 = /^\s*(\d+)\s*$/.exec(t2);
        return e2 ? parseInt(e2[1], 10) : void 0;
      }
      function z_(t2) {
        return gu(t2, false).trim();
      }
      function X_(t2, e2) {
        K_(t2, e2 ? "1" : "0");
      }
      function V_(t2, e2) {
        t2.appendChild(Du().createCDATASection(e2));
      }
      function W_(t2, e2) {
        const i2 = new Date(1e3 * e2), n2 = i2.getUTCFullYear() + "-" + fi(i2.getUTCMonth() + 1, 2) + "-" + fi(i2.getUTCDate(), 2) + "T" + fi(i2.getUTCHours(), 2) + ":" + fi(i2.getUTCMinutes(), 2) + ":" + fi(i2.getUTCSeconds(), 2) + "Z";
        t2.appendChild(Du().createTextNode(n2));
      }
      function Z_(t2, e2) {
        const i2 = e2.toPrecision();
        t2.appendChild(Du().createTextNode(i2));
      }
      function Y_(t2, e2) {
        const i2 = e2.toString();
        t2.appendChild(Du().createTextNode(i2));
      }
      function K_(t2, e2) {
        t2.appendChild(Du().createTextNode(e2));
      }
      O_.prototype.namespace = F_, O_.prototype.FLAT_LINEAR_RINGS_PARSERS = { "http://www.opengis.net/gml": {} }, O_.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = { "http://www.opengis.net/gml": {} }, O_.prototype.GEOMETRY_PARSERS = { "http://www.opengis.net/gml": {} }, O_.prototype.MULTIPOINT_PARSERS = { "http://www.opengis.net/gml": { pointMember: xu(O_.prototype.pointMemberParser), pointMembers: xu(O_.prototype.pointMemberParser) } }, O_.prototype.MULTILINESTRING_PARSERS = { "http://www.opengis.net/gml": { lineStringMember: xu(O_.prototype.lineStringMemberParser), lineStringMembers: xu(O_.prototype.lineStringMemberParser) } }, O_.prototype.MULTIPOLYGON_PARSERS = { "http://www.opengis.net/gml": { polygonMember: xu(O_.prototype.polygonMemberParser), polygonMembers: xu(O_.prototype.polygonMemberParser) } }, O_.prototype.POINTMEMBER_PARSERS = { "http://www.opengis.net/gml": { Point: xu(O_.prototype.readFlatCoordinatesFromNode) } }, O_.prototype.LINESTRINGMEMBER_PARSERS = { "http://www.opengis.net/gml": { LineString: xu(O_.prototype.readLineString) } }, O_.prototype.POLYGONMEMBER_PARSERS = { "http://www.opengis.net/gml": { Polygon: xu(O_.prototype.readPolygon) } }, O_.prototype.RING_PARSERS = { "http://www.opengis.net/gml": { LinearRing: vu(O_.prototype.readFlatLinearRing) } };
      const q_ = { MultiLineString: "lineStringMember", MultiCurve: "curveMember", MultiPolygon: "polygonMember", MultiSurface: "surfaceMember" };
      class H_ extends O_ {
        constructor(t2) {
          super(t2 = t2 || {}), this.FEATURE_COLLECTION_PARSERS[F_].featureMember = xu(this.readFeaturesInternal), this.schemaLocation = t2.schemaLocation ? t2.schemaLocation : "http://www.opengis.net/gml http://schemas.opengis.net/gml/2.1.2/feature.xsd";
        }
        readFlatCoordinates(t2, e2) {
          const i2 = gu(t2, false).replace(/^\s*|\s*$/g, ""), n2 = e2[0].srsName;
          let r2 = "enu";
          if (n2) {
            const t3 = Ui(n2);
            t3 && (r2 = t3.getAxisOrientation());
          }
          const s2 = i2.trim().split(/\s+/), o2 = [];
          for (let t3 = 0, e3 = s2.length; t3 < e3; t3++) {
            const e4 = s2[t3].split(/,+/), i3 = parseFloat(e4[0]), n3 = parseFloat(e4[1]), a2 = 3 === e4.length ? parseFloat(e4[2]) : 0;
            "en" === r2.substr(0, 2) ? o2.push(i3, n3, a2) : o2.push(n3, i3, a2);
          }
          return o2;
        }
        readBox(t2, e2) {
          const i2 = Lu([null], this.BOX_PARSERS_, t2, e2, this);
          return $t(i2[1][0], i2[1][1], i2[1][3], i2[1][4]);
        }
        innerBoundaryIsParser(t2, e2) {
          const i2 = Lu(void 0, this.RING_PARSERS, t2, e2, this);
          if (i2) {
            e2[e2.length - 1].push(i2);
          }
        }
        outerBoundaryIsParser(t2, e2) {
          const i2 = Lu(void 0, this.RING_PARSERS, t2, e2, this);
          if (i2) {
            e2[e2.length - 1][0] = i2;
          }
        }
        GEOMETRY_NODE_FACTORY_(t2, e2, i2) {
          const n2 = e2[e2.length - 1], r2 = n2.multiSurface, s2 = n2.surface, o2 = n2.multiCurve;
          return Array.isArray(t2) ? i2 = "Envelope" : "MultiPolygon" === (i2 = t2.getType()) && true === r2 ? i2 = "MultiSurface" : "Polygon" === i2 && true === s2 ? i2 = "Surface" : "MultiLineString" === i2 && true === o2 && (i2 = "MultiCurve"), du("http://www.opengis.net/gml", i2);
        }
        writeFeatureElement(t2, e2, i2) {
          const n2 = e2.getId();
          n2 && t2.setAttribute("fid", n2);
          const r2 = i2[i2.length - 1], s2 = r2.featureNS, o2 = e2.getGeometryName();
          r2.serializers || (r2.serializers = {}, r2.serializers[s2] = {});
          const a2 = [], l2 = [];
          if (e2.hasProperties()) {
            const t3 = e2.getProperties();
            for (const e3 in t3) {
              const i3 = t3[e3];
              null !== i3 && (a2.push(e3), l2.push(i3), e3 == o2 || "function" == typeof i3.getSimplifiedGeometry ? e3 in r2.serializers[s2] || (r2.serializers[s2][e3] = Eu(this.writeGeometryElement, this)) : e3 in r2.serializers[s2] || (r2.serializers[s2][e3] = Eu(K_)));
            }
          }
          const h2 = Object.assign({}, r2);
          h2.node = t2, Fu(h2, r2.serializers, Cu(void 0, s2), l2, i2, a2);
        }
        writeCurveOrLineString(t2, e2, i2) {
          const n2 = i2[i2.length - 1].srsName;
          if ("LineStringSegment" !== t2.nodeName && n2 && t2.setAttribute("srsName", n2), "LineString" === t2.nodeName || "LineStringSegment" === t2.nodeName) {
            const n3 = this.createCoordinatesNode_(t2.namespaceURI);
            t2.appendChild(n3), this.writeCoordinates_(n3, e2, i2);
          } else if ("Curve" === t2.nodeName) {
            const n3 = du(t2.namespaceURI, "segments");
            t2.appendChild(n3), this.writeCurveSegments_(n3, e2, i2);
          }
        }
        writeLineStringOrCurveMember(t2, e2, i2) {
          const n2 = this.GEOMETRY_NODE_FACTORY_(e2, i2);
          n2 && (t2.appendChild(n2), this.writeCurveOrLineString(n2, e2, i2));
        }
        writeMultiCurveOrLineString(t2, e2, i2) {
          const n2 = i2[i2.length - 1], r2 = n2.hasZ, s2 = n2.srsName, o2 = n2.curve;
          s2 && t2.setAttribute("srsName", s2);
          const a2 = e2.getLineStrings();
          Fu({ node: t2, hasZ: r2, srsName: s2, curve: o2 }, this.LINESTRINGORCURVEMEMBER_SERIALIZERS, this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_, a2, i2, void 0, this);
        }
        writeGeometryElement(t2, e2, i2) {
          const n2 = i2[i2.length - 1], r2 = Object.assign({}, n2);
          let s2;
          r2.node = t2, s2 = Array.isArray(e2) ? tm(e2, n2) : Qp(e2, true, n2), Fu(r2, this.GEOMETRY_SERIALIZERS, this.GEOMETRY_NODE_FACTORY_, [s2], i2, void 0, this);
        }
        createCoordinatesNode_(t2) {
          const e2 = du(t2, "coordinates");
          return e2.setAttribute("decimal", "."), e2.setAttribute("cs", ","), e2.setAttribute("ts", " "), e2;
        }
        writeCoordinates_(t2, e2, i2) {
          const n2 = i2[i2.length - 1], r2 = n2.hasZ, s2 = n2.srsName, o2 = e2.getCoordinates(), a2 = o2.length, l2 = new Array(a2);
          for (let t3 = 0; t3 < a2; ++t3) {
            const e3 = o2[t3];
            l2[t3] = this.getCoords_(e3, s2, r2);
          }
          K_(t2, l2.join(" "));
        }
        writeCurveSegments_(t2, e2, i2) {
          const n2 = du(t2.namespaceURI, "LineStringSegment");
          t2.appendChild(n2), this.writeCurveOrLineString(n2, e2, i2);
        }
        writeSurfaceOrPolygon(t2, e2, i2) {
          const n2 = i2[i2.length - 1], r2 = n2.hasZ, s2 = n2.srsName;
          if ("PolygonPatch" !== t2.nodeName && s2 && t2.setAttribute("srsName", s2), "Polygon" === t2.nodeName || "PolygonPatch" === t2.nodeName) {
            const n3 = e2.getLinearRings();
            Fu({ node: t2, hasZ: r2, srsName: s2 }, this.RING_SERIALIZERS, this.RING_NODE_FACTORY_, n3, i2, void 0, this);
          } else if ("Surface" === t2.nodeName) {
            const n3 = du(t2.namespaceURI, "patches");
            t2.appendChild(n3), this.writeSurfacePatches_(n3, e2, i2);
          }
        }
        RING_NODE_FACTORY_(t2, e2, i2) {
          const n2 = e2[e2.length - 1], r2 = n2.node, s2 = n2.exteriorWritten;
          return void 0 === s2 && (n2.exteriorWritten = true), du(r2.namespaceURI, void 0 !== s2 ? "innerBoundaryIs" : "outerBoundaryIs");
        }
        writeSurfacePatches_(t2, e2, i2) {
          const n2 = du(t2.namespaceURI, "PolygonPatch");
          t2.appendChild(n2), this.writeSurfaceOrPolygon(n2, e2, i2);
        }
        writeRing(t2, e2, i2) {
          const n2 = du(t2.namespaceURI, "LinearRing");
          t2.appendChild(n2), this.writeLinearRing(n2, e2, i2);
        }
        getCoords_(t2, e2, i2) {
          let n2 = "enu";
          e2 && (n2 = Ui(e2).getAxisOrientation());
          let r2 = "en" === n2.substr(0, 2) ? t2[0] + "," + t2[1] : t2[1] + "," + t2[0];
          if (i2) {
            r2 += "," + (t2[2] || 0);
          }
          return r2;
        }
        writePoint(t2, e2, i2) {
          const n2 = i2[i2.length - 1], r2 = n2.hasZ, s2 = n2.srsName;
          s2 && t2.setAttribute("srsName", s2);
          const o2 = this.createCoordinatesNode_(t2.namespaceURI);
          t2.appendChild(o2);
          const a2 = e2.getCoordinates();
          K_(o2, this.getCoords_(a2, s2, r2));
        }
        writeMultiPoint(t2, e2, i2) {
          const n2 = i2[i2.length - 1], r2 = n2.hasZ, s2 = n2.srsName;
          s2 && t2.setAttribute("srsName", s2);
          const o2 = e2.getPoints();
          Fu({ node: t2, hasZ: r2, srsName: s2 }, this.POINTMEMBER_SERIALIZERS, Cu("pointMember"), o2, i2, void 0, this);
        }
        writePointMember(t2, e2, i2) {
          const n2 = du(t2.namespaceURI, "Point");
          t2.appendChild(n2), this.writePoint(n2, e2, i2);
        }
        writeLinearRing(t2, e2, i2) {
          const n2 = i2[i2.length - 1].srsName;
          n2 && t2.setAttribute("srsName", n2);
          const r2 = this.createCoordinatesNode_(t2.namespaceURI);
          t2.appendChild(r2), this.writeCoordinates_(r2, e2, i2);
        }
        writeMultiSurfaceOrPolygon(t2, e2, i2) {
          const n2 = i2[i2.length - 1], r2 = n2.hasZ, s2 = n2.srsName, o2 = n2.surface;
          s2 && t2.setAttribute("srsName", s2);
          const a2 = e2.getPolygons();
          Fu({ node: t2, hasZ: r2, srsName: s2, surface: o2 }, this.SURFACEORPOLYGONMEMBER_SERIALIZERS, this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_, a2, i2, void 0, this);
        }
        writeSurfaceOrPolygonMember(t2, e2, i2) {
          const n2 = this.GEOMETRY_NODE_FACTORY_(e2, i2);
          n2 && (t2.appendChild(n2), this.writeSurfaceOrPolygon(n2, e2, i2));
        }
        writeEnvelope(t2, e2, i2) {
          const n2 = i2[i2.length - 1].srsName;
          n2 && t2.setAttribute("srsName", n2);
          const r2 = [e2[0] + " " + e2[1], e2[2] + " " + e2[3]];
          Fu({ node: t2 }, this.ENVELOPE_SERIALIZERS, bu, r2, i2, ["lowerCorner", "upperCorner"], this);
        }
        MULTIGEOMETRY_MEMBER_NODE_FACTORY_(t2, e2, i2) {
          const n2 = e2[e2.length - 1].node;
          return du("http://www.opengis.net/gml", q_[n2.nodeName]);
        }
      }
      H_.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = { "http://www.opengis.net/gml": { coordinates: vu(H_.prototype.readFlatCoordinates) } }, H_.prototype.FLAT_LINEAR_RINGS_PARSERS = { "http://www.opengis.net/gml": { innerBoundaryIs: H_.prototype.innerBoundaryIsParser, outerBoundaryIs: H_.prototype.outerBoundaryIsParser } }, H_.prototype.BOX_PARSERS_ = { "http://www.opengis.net/gml": { coordinates: xu(H_.prototype.readFlatCoordinates) } }, H_.prototype.GEOMETRY_PARSERS = { "http://www.opengis.net/gml": { Point: vu(O_.prototype.readPoint), MultiPoint: vu(O_.prototype.readMultiPoint), LineString: vu(O_.prototype.readLineString), MultiLineString: vu(O_.prototype.readMultiLineString), LinearRing: vu(O_.prototype.readLinearRing), Polygon: vu(O_.prototype.readPolygon), MultiPolygon: vu(O_.prototype.readMultiPolygon), Box: vu(H_.prototype.readBox) } }, H_.prototype.GEOMETRY_SERIALIZERS = { "http://www.opengis.net/gml": { Curve: Eu(H_.prototype.writeCurveOrLineString), MultiCurve: Eu(H_.prototype.writeMultiCurveOrLineString), Point: Eu(H_.prototype.writePoint), MultiPoint: Eu(H_.prototype.writeMultiPoint), LineString: Eu(H_.prototype.writeCurveOrLineString), MultiLineString: Eu(H_.prototype.writeMultiCurveOrLineString), LinearRing: Eu(H_.prototype.writeLinearRing), Polygon: Eu(H_.prototype.writeSurfaceOrPolygon), MultiPolygon: Eu(H_.prototype.writeMultiSurfaceOrPolygon), Surface: Eu(H_.prototype.writeSurfaceOrPolygon), MultiSurface: Eu(H_.prototype.writeMultiSurfaceOrPolygon), Envelope: Eu(H_.prototype.writeEnvelope) } }, H_.prototype.LINESTRINGORCURVEMEMBER_SERIALIZERS = { "http://www.opengis.net/gml": { lineStringMember: Eu(H_.prototype.writeLineStringOrCurveMember), curveMember: Eu(H_.prototype.writeLineStringOrCurveMember) } }, H_.prototype.RING_SERIALIZERS = { "http://www.opengis.net/gml": { outerBoundaryIs: Eu(H_.prototype.writeRing), innerBoundaryIs: Eu(H_.prototype.writeRing) } }, H_.prototype.POINTMEMBER_SERIALIZERS = { "http://www.opengis.net/gml": { pointMember: Eu(H_.prototype.writePointMember) } }, H_.prototype.SURFACEORPOLYGONMEMBER_SERIALIZERS = { "http://www.opengis.net/gml": { surfaceMember: Eu(H_.prototype.writeSurfaceOrPolygonMember), polygonMember: Eu(H_.prototype.writeSurfaceOrPolygonMember) } }, H_.prototype.ENVELOPE_SERIALIZERS = { "http://www.opengis.net/gml": { lowerCorner: Eu(K_), upperCorner: Eu(K_) } };
      const $_ = { MultiLineString: "lineStringMember", MultiCurve: "curveMember", MultiPolygon: "polygonMember", MultiSurface: "surfaceMember" };
      class J_ extends O_ {
        constructor(t2) {
          super(t2 = t2 || {}), this.surface_ = void 0 !== t2.surface && t2.surface, this.curve_ = void 0 !== t2.curve && t2.curve, this.multiCurve_ = void 0 === t2.multiCurve || t2.multiCurve, this.multiSurface_ = void 0 === t2.multiSurface || t2.multiSurface, this.schemaLocation = t2.schemaLocation ? t2.schemaLocation : "http://www.opengis.net/gml http://schemas.opengis.net/gml/3.1.1/profiles/gmlsfProfile/1.0.0/gmlsf.xsd", this.hasZ = void 0 !== t2.hasZ && t2.hasZ;
        }
        readMultiCurve(t2, e2) {
          const i2 = Lu([], this.MULTICURVE_PARSERS, t2, e2, this);
          if (i2) {
            return new Np(i2);
          }
        }
        readFlatCurveRing(t2, e2) {
          const i2 = Lu([], this.MULTICURVE_PARSERS, t2, e2, this), n2 = [];
          for (let t3 = 0, e3 = i2.length; t3 < e3; ++t3)
            c(n2, i2[t3].getFlatCoordinates());
          return n2;
        }
        readMultiSurface(t2, e2) {
          const i2 = Lu([], this.MULTISURFACE_PARSERS, t2, e2, this);
          if (i2)
            return new Gp(i2);
        }
        curveMemberParser(t2, e2) {
          Iu(this.CURVEMEMBER_PARSERS, t2, e2, this);
        }
        surfaceMemberParser(t2, e2) {
          Iu(this.SURFACEMEMBER_PARSERS, t2, e2, this);
        }
        readPatch(t2, e2) {
          return Lu([null], this.PATCHES_PARSERS, t2, e2, this);
        }
        readSegment(t2, e2) {
          return Lu([], this.SEGMENTS_PARSERS, t2, e2, this);
        }
        readPolygonPatch(t2, e2) {
          return Lu([null], this.FLAT_LINEAR_RINGS_PARSERS, t2, e2, this);
        }
        readLineStringSegment(t2, e2) {
          return Lu([null], this.GEOMETRY_FLAT_COORDINATES_PARSERS, t2, e2, this);
        }
        interiorParser(t2, e2) {
          const i2 = Lu(void 0, this.RING_PARSERS, t2, e2, this);
          if (i2) {
            e2[e2.length - 1].push(i2);
          }
        }
        exteriorParser(t2, e2) {
          const i2 = Lu(void 0, this.RING_PARSERS, t2, e2, this);
          if (i2) {
            e2[e2.length - 1][0] = i2;
          }
        }
        readSurface(t2, e2) {
          const i2 = Lu([null], this.SURFACE_PARSERS, t2, e2, this);
          if (i2 && i2[0]) {
            const t3 = i2[0], e3 = [t3.length];
            let n2, r2;
            for (n2 = 1, r2 = i2.length; n2 < r2; ++n2)
              c(t3, i2[n2]), e3.push(t3.length);
            return new ur(t3, "XYZ", e3);
          }
        }
        readCurve(t2, e2) {
          const i2 = Lu([null], this.CURVE_PARSERS, t2, e2, this);
          if (i2) {
            return new Op(i2, "XYZ");
          }
        }
        readEnvelope(t2, e2) {
          const i2 = Lu([null], this.ENVELOPE_PARSERS, t2, e2, this);
          return $t(i2[1][0], i2[1][1], i2[2][0], i2[2][1]);
        }
        readFlatPos(t2, e2) {
          let i2 = gu(t2, false);
          const n2 = /^\s*([+\-]?\d*\.?\d+(?:[eE][+\-]?\d+)?)\s*/, r2 = [];
          let s2;
          for (; s2 = n2.exec(i2); )
            r2.push(parseFloat(s2[1])), i2 = i2.substr(s2[0].length);
          if ("" !== i2)
            return;
          const o2 = e2[0].srsName;
          let a2 = "enu";
          if (o2) {
            a2 = Ui(o2).getAxisOrientation();
          }
          if ("neu" === a2) {
            let t3, e3;
            for (t3 = 0, e3 = r2.length; t3 < e3; t3 += 3) {
              const e4 = r2[t3], i3 = r2[t3 + 1];
              r2[t3] = i3, r2[t3 + 1] = e4;
            }
          }
          const l2 = r2.length;
          return 2 == l2 && r2.push(0), 0 !== l2 ? r2 : void 0;
        }
        readFlatPosList(t2, e2) {
          const i2 = gu(t2, false).replace(/^\s*|\s*$/g, ""), n2 = e2[0], r2 = n2.srsName, s2 = n2.srsDimension;
          let o2 = "enu";
          if (r2) {
            o2 = Ui(r2).getAxisOrientation();
          }
          const a2 = i2.split(/\s+/);
          let l2, h2, c2, u2 = 2;
          t2.getAttribute("srsDimension") ? u2 = U_(t2.getAttribute("srsDimension")) : t2.getAttribute("dimension") ? u2 = U_(t2.getAttribute("dimension")) : t2.parentNode.getAttribute("srsDimension") ? u2 = U_(t2.parentNode.getAttribute("srsDimension")) : s2 && (u2 = U_(s2));
          const d2 = [];
          for (let t3 = 0, e3 = a2.length; t3 < e3; t3 += u2)
            l2 = parseFloat(a2[t3]), h2 = parseFloat(a2[t3 + 1]), c2 = 3 === u2 ? parseFloat(a2[t3 + 2]) : 0, "en" === o2.substr(0, 2) ? d2.push(l2, h2, c2) : d2.push(h2, l2, c2);
          return d2;
        }
        writePos_(t2, e2, i2) {
          const n2 = i2[i2.length - 1], r2 = n2.hasZ, s2 = r2 ? "3" : "2";
          t2.setAttribute("srsDimension", s2);
          const o2 = n2.srsName;
          let a2 = "enu";
          o2 && (a2 = Ui(o2).getAxisOrientation());
          const l2 = e2.getCoordinates();
          let h2;
          if (h2 = "en" === a2.substr(0, 2) ? l2[0] + " " + l2[1] : l2[1] + " " + l2[0], r2) {
            h2 += " " + (l2[2] || 0);
          }
          K_(t2, h2);
        }
        getCoords_(t2, e2, i2) {
          let n2 = "enu";
          e2 && (n2 = Ui(e2).getAxisOrientation());
          let r2 = "en" === n2.substr(0, 2) ? t2[0] + " " + t2[1] : t2[1] + " " + t2[0];
          if (i2) {
            r2 += " " + (t2[2] || 0);
          }
          return r2;
        }
        writePosList_(t2, e2, i2) {
          const n2 = i2[i2.length - 1], r2 = n2.hasZ, s2 = r2 ? "3" : "2";
          t2.setAttribute("srsDimension", s2);
          const o2 = n2.srsName, a2 = e2.getCoordinates(), l2 = a2.length, h2 = new Array(l2);
          let c2;
          for (let t3 = 0; t3 < l2; ++t3)
            c2 = a2[t3], h2[t3] = this.getCoords_(c2, o2, r2);
          K_(t2, h2.join(" "));
        }
        writePoint(t2, e2, i2) {
          const n2 = i2[i2.length - 1].srsName;
          n2 && t2.setAttribute("srsName", n2);
          const r2 = du(t2.namespaceURI, "pos");
          t2.appendChild(r2), this.writePos_(r2, e2, i2);
        }
        writeEnvelope(t2, e2, i2) {
          const n2 = i2[i2.length - 1].srsName;
          n2 && t2.setAttribute("srsName", n2);
          const r2 = [e2[0] + " " + e2[1], e2[2] + " " + e2[3]];
          Fu({ node: t2 }, this.ENVELOPE_SERIALIZERS, bu, r2, i2, ["lowerCorner", "upperCorner"], this);
        }
        writeLinearRing(t2, e2, i2) {
          const n2 = i2[i2.length - 1].srsName;
          n2 && t2.setAttribute("srsName", n2);
          const r2 = du(t2.namespaceURI, "posList");
          t2.appendChild(r2), this.writePosList_(r2, e2, i2);
        }
        RING_NODE_FACTORY_(t2, e2, i2) {
          const n2 = e2[e2.length - 1], r2 = n2.node, s2 = n2.exteriorWritten;
          return void 0 === s2 && (n2.exteriorWritten = true), du(r2.namespaceURI, void 0 !== s2 ? "interior" : "exterior");
        }
        writeSurfaceOrPolygon(t2, e2, i2) {
          const n2 = i2[i2.length - 1], r2 = n2.hasZ, s2 = n2.srsName;
          if ("PolygonPatch" !== t2.nodeName && s2 && t2.setAttribute("srsName", s2), "Polygon" === t2.nodeName || "PolygonPatch" === t2.nodeName) {
            const n3 = e2.getLinearRings();
            Fu({ node: t2, hasZ: r2, srsName: s2 }, this.RING_SERIALIZERS, this.RING_NODE_FACTORY_, n3, i2, void 0, this);
          } else if ("Surface" === t2.nodeName) {
            const n3 = du(t2.namespaceURI, "patches");
            t2.appendChild(n3), this.writeSurfacePatches_(n3, e2, i2);
          }
        }
        writeCurveOrLineString(t2, e2, i2) {
          const n2 = i2[i2.length - 1].srsName;
          if ("LineStringSegment" !== t2.nodeName && n2 && t2.setAttribute("srsName", n2), "LineString" === t2.nodeName || "LineStringSegment" === t2.nodeName) {
            const n3 = du(t2.namespaceURI, "posList");
            t2.appendChild(n3), this.writePosList_(n3, e2, i2);
          } else if ("Curve" === t2.nodeName) {
            const n3 = du(t2.namespaceURI, "segments");
            t2.appendChild(n3), this.writeCurveSegments_(n3, e2, i2);
          }
        }
        writeMultiSurfaceOrPolygon(t2, e2, i2) {
          const n2 = i2[i2.length - 1], r2 = n2.hasZ, s2 = n2.srsName, o2 = n2.surface;
          s2 && t2.setAttribute("srsName", s2);
          const a2 = e2.getPolygons();
          Fu({ node: t2, hasZ: r2, srsName: s2, surface: o2 }, this.SURFACEORPOLYGONMEMBER_SERIALIZERS, this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_, a2, i2, void 0, this);
        }
        writeMultiPoint(t2, e2, i2) {
          const n2 = i2[i2.length - 1], r2 = n2.srsName, s2 = n2.hasZ;
          r2 && t2.setAttribute("srsName", r2);
          const o2 = e2.getPoints();
          Fu({ node: t2, hasZ: s2, srsName: r2 }, this.POINTMEMBER_SERIALIZERS, Cu("pointMember"), o2, i2, void 0, this);
        }
        writeMultiCurveOrLineString(t2, e2, i2) {
          const n2 = i2[i2.length - 1], r2 = n2.hasZ, s2 = n2.srsName, o2 = n2.curve;
          s2 && t2.setAttribute("srsName", s2);
          const a2 = e2.getLineStrings();
          Fu({ node: t2, hasZ: r2, srsName: s2, curve: o2 }, this.LINESTRINGORCURVEMEMBER_SERIALIZERS, this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_, a2, i2, void 0, this);
        }
        writeRing(t2, e2, i2) {
          const n2 = du(t2.namespaceURI, "LinearRing");
          t2.appendChild(n2), this.writeLinearRing(n2, e2, i2);
        }
        writeSurfaceOrPolygonMember(t2, e2, i2) {
          const n2 = this.GEOMETRY_NODE_FACTORY_(e2, i2);
          n2 && (t2.appendChild(n2), this.writeSurfaceOrPolygon(n2, e2, i2));
        }
        writePointMember(t2, e2, i2) {
          const n2 = du(t2.namespaceURI, "Point");
          t2.appendChild(n2), this.writePoint(n2, e2, i2);
        }
        writeLineStringOrCurveMember(t2, e2, i2) {
          const n2 = this.GEOMETRY_NODE_FACTORY_(e2, i2);
          n2 && (t2.appendChild(n2), this.writeCurveOrLineString(n2, e2, i2));
        }
        writeSurfacePatches_(t2, e2, i2) {
          const n2 = du(t2.namespaceURI, "PolygonPatch");
          t2.appendChild(n2), this.writeSurfaceOrPolygon(n2, e2, i2);
        }
        writeCurveSegments_(t2, e2, i2) {
          const n2 = du(t2.namespaceURI, "LineStringSegment");
          t2.appendChild(n2), this.writeCurveOrLineString(n2, e2, i2);
        }
        writeGeometryElement(t2, e2, i2) {
          const n2 = i2[i2.length - 1], r2 = Object.assign({}, n2);
          let s2;
          r2.node = t2, s2 = Array.isArray(e2) ? tm(e2, n2) : Qp(e2, true, n2), Fu(r2, this.GEOMETRY_SERIALIZERS, this.GEOMETRY_NODE_FACTORY_, [s2], i2, void 0, this);
        }
        writeFeatureElement(t2, e2, i2) {
          const n2 = e2.getId();
          n2 && t2.setAttribute("fid", n2);
          const r2 = i2[i2.length - 1], s2 = r2.featureNS, o2 = e2.getGeometryName();
          r2.serializers || (r2.serializers = {}, r2.serializers[s2] = {});
          const a2 = [], l2 = [];
          if (e2.hasProperties()) {
            const t3 = e2.getProperties();
            for (const e3 in t3) {
              const i3 = t3[e3];
              null !== i3 && (a2.push(e3), l2.push(i3), e3 == o2 || "function" == typeof i3.getSimplifiedGeometry ? e3 in r2.serializers[s2] || (r2.serializers[s2][e3] = Eu(this.writeGeometryElement, this)) : e3 in r2.serializers[s2] || (r2.serializers[s2][e3] = Eu(K_)));
            }
          }
          const h2 = Object.assign({}, r2);
          h2.node = t2, Fu(h2, r2.serializers, Cu(void 0, s2), l2, i2, a2);
        }
        writeFeatureMembers_(t2, e2, i2) {
          const n2 = i2[i2.length - 1], r2 = n2.featureType, s2 = n2.featureNS, o2 = {};
          o2[s2] = {}, o2[s2][r2] = Eu(this.writeFeatureElement, this);
          const a2 = Object.assign({}, n2);
          a2.node = t2, Fu(a2, o2, Cu(r2, s2), e2, i2);
        }
        MULTIGEOMETRY_MEMBER_NODE_FACTORY_(t2, e2, i2) {
          const n2 = e2[e2.length - 1].node;
          return du(this.namespace, $_[n2.nodeName]);
        }
        GEOMETRY_NODE_FACTORY_(t2, e2, i2) {
          const n2 = e2[e2.length - 1], r2 = n2.multiSurface, s2 = n2.surface, o2 = n2.curve, a2 = n2.multiCurve;
          return Array.isArray(t2) ? i2 = "Envelope" : "MultiPolygon" === (i2 = t2.getType()) && true === r2 ? i2 = "MultiSurface" : "Polygon" === i2 && true === s2 ? i2 = "Surface" : "LineString" === i2 && true === o2 ? i2 = "Curve" : "MultiLineString" === i2 && true === a2 && (i2 = "MultiCurve"), du(this.namespace, i2);
        }
        writeGeometryNode(t2, e2) {
          e2 = this.adaptOptions(e2);
          const i2 = du(this.namespace, "geom"), n2 = { node: i2, hasZ: this.hasZ, srsName: this.srsName, curve: this.curve_, surface: this.surface_, multiSurface: this.multiSurface_, multiCurve: this.multiCurve_ };
          return e2 && Object.assign(n2, e2), this.writeGeometryElement(i2, t2, [n2]), i2;
        }
        writeFeaturesNode(t2, e2) {
          e2 = this.adaptOptions(e2);
          const i2 = du(this.namespace, "featureMembers");
          i2.setAttributeNS(uu, "xsi:schemaLocation", this.schemaLocation);
          const n2 = { srsName: this.srsName, hasZ: this.hasZ, curve: this.curve_, surface: this.surface_, multiSurface: this.multiSurface_, multiCurve: this.multiCurve_, featureNS: this.featureNS, featureType: this.featureType };
          return e2 && Object.assign(n2, e2), this.writeFeatureMembers_(i2, t2, [n2]), i2;
        }
      }
      J_.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = { "http://www.opengis.net/gml": { pos: vu(J_.prototype.readFlatPos), posList: vu(J_.prototype.readFlatPosList), coordinates: vu(H_.prototype.readFlatCoordinates) } }, J_.prototype.FLAT_LINEAR_RINGS_PARSERS = { "http://www.opengis.net/gml": { interior: J_.prototype.interiorParser, exterior: J_.prototype.exteriorParser } }, J_.prototype.GEOMETRY_PARSERS = { "http://www.opengis.net/gml": { Point: vu(O_.prototype.readPoint), MultiPoint: vu(O_.prototype.readMultiPoint), LineString: vu(O_.prototype.readLineString), MultiLineString: vu(O_.prototype.readMultiLineString), LinearRing: vu(O_.prototype.readLinearRing), Polygon: vu(O_.prototype.readPolygon), MultiPolygon: vu(O_.prototype.readMultiPolygon), Surface: vu(J_.prototype.readSurface), MultiSurface: vu(J_.prototype.readMultiSurface), Curve: vu(J_.prototype.readCurve), MultiCurve: vu(J_.prototype.readMultiCurve), Envelope: vu(J_.prototype.readEnvelope) } }, J_.prototype.MULTICURVE_PARSERS = { "http://www.opengis.net/gml": { curveMember: xu(J_.prototype.curveMemberParser), curveMembers: xu(J_.prototype.curveMemberParser) } }, J_.prototype.MULTISURFACE_PARSERS = { "http://www.opengis.net/gml": { surfaceMember: xu(J_.prototype.surfaceMemberParser), surfaceMembers: xu(J_.prototype.surfaceMemberParser) } }, J_.prototype.CURVEMEMBER_PARSERS = { "http://www.opengis.net/gml": { LineString: xu(O_.prototype.readLineString), Curve: xu(J_.prototype.readCurve) } }, J_.prototype.SURFACEMEMBER_PARSERS = { "http://www.opengis.net/gml": { Polygon: xu(O_.prototype.readPolygon), Surface: xu(J_.prototype.readSurface) } }, J_.prototype.SURFACE_PARSERS = { "http://www.opengis.net/gml": { patches: vu(J_.prototype.readPatch) } }, J_.prototype.CURVE_PARSERS = { "http://www.opengis.net/gml": { segments: vu(J_.prototype.readSegment) } }, J_.prototype.ENVELOPE_PARSERS = { "http://www.opengis.net/gml": { lowerCorner: xu(J_.prototype.readFlatPosList), upperCorner: xu(J_.prototype.readFlatPosList) } }, J_.prototype.PATCHES_PARSERS = { "http://www.opengis.net/gml": { PolygonPatch: vu(J_.prototype.readPolygonPatch) } }, J_.prototype.SEGMENTS_PARSERS = { "http://www.opengis.net/gml": { LineStringSegment: yu(J_.prototype.readLineStringSegment) } }, O_.prototype.RING_PARSERS = { "http://www.opengis.net/gml": { LinearRing: vu(O_.prototype.readFlatLinearRing), Ring: vu(J_.prototype.readFlatCurveRing) } }, J_.prototype.writeFeatures, J_.prototype.RING_SERIALIZERS = { "http://www.opengis.net/gml": { exterior: Eu(J_.prototype.writeRing), interior: Eu(J_.prototype.writeRing) } }, J_.prototype.ENVELOPE_SERIALIZERS = { "http://www.opengis.net/gml": { lowerCorner: Eu(K_), upperCorner: Eu(K_) } }, J_.prototype.SURFACEORPOLYGONMEMBER_SERIALIZERS = { "http://www.opengis.net/gml": { surfaceMember: Eu(J_.prototype.writeSurfaceOrPolygonMember), polygonMember: Eu(J_.prototype.writeSurfaceOrPolygonMember) } }, J_.prototype.POINTMEMBER_SERIALIZERS = { "http://www.opengis.net/gml": { pointMember: Eu(J_.prototype.writePointMember) } }, J_.prototype.LINESTRINGORCURVEMEMBER_SERIALIZERS = { "http://www.opengis.net/gml": { lineStringMember: Eu(J_.prototype.writeLineStringOrCurveMember), curveMember: Eu(J_.prototype.writeLineStringOrCurveMember) } }, J_.prototype.GEOMETRY_SERIALIZERS = { "http://www.opengis.net/gml": { Curve: Eu(J_.prototype.writeCurveOrLineString), MultiCurve: Eu(J_.prototype.writeMultiCurveOrLineString), Point: Eu(J_.prototype.writePoint), MultiPoint: Eu(J_.prototype.writeMultiPoint), LineString: Eu(J_.prototype.writeCurveOrLineString), MultiLineString: Eu(J_.prototype.writeMultiCurveOrLineString), LinearRing: Eu(J_.prototype.writeLinearRing), Polygon: Eu(J_.prototype.writeSurfaceOrPolygon), MultiPolygon: Eu(J_.prototype.writeMultiSurfaceOrPolygon), Surface: Eu(J_.prototype.writeSurfaceOrPolygon), MultiSurface: Eu(J_.prototype.writeMultiSurfaceOrPolygon), Envelope: Eu(J_.prototype.writeEnvelope) } };
      const Q_ = J_;
      Q_.prototype.writeFeatures, Q_.prototype.writeFeaturesNode;
      class ty extends J_ {
        constructor(t2) {
          super(t2 = t2 || {}), this.schemaLocation = t2.schemaLocation ? t2.schemaLocation : this.namespace + " http://schemas.opengis.net/gml/3.2.1/gml.xsd";
        }
      }
      ty.prototype.namespace = "http://www.opengis.net/gml/3.2", ty.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = { "http://www.opengis.net/gml/3.2": { pos: vu(J_.prototype.readFlatPos), posList: vu(J_.prototype.readFlatPosList), coordinates: vu(H_.prototype.readFlatCoordinates) } }, ty.prototype.FLAT_LINEAR_RINGS_PARSERS = { "http://www.opengis.net/gml/3.2": { interior: J_.prototype.interiorParser, exterior: J_.prototype.exteriorParser } }, ty.prototype.GEOMETRY_PARSERS = { "http://www.opengis.net/gml/3.2": { Point: vu(O_.prototype.readPoint), MultiPoint: vu(O_.prototype.readMultiPoint), LineString: vu(O_.prototype.readLineString), MultiLineString: vu(O_.prototype.readMultiLineString), LinearRing: vu(O_.prototype.readLinearRing), Polygon: vu(O_.prototype.readPolygon), MultiPolygon: vu(O_.prototype.readMultiPolygon), Surface: vu(ty.prototype.readSurface), MultiSurface: vu(J_.prototype.readMultiSurface), Curve: vu(ty.prototype.readCurve), MultiCurve: vu(J_.prototype.readMultiCurve), Envelope: vu(ty.prototype.readEnvelope) } }, ty.prototype.MULTICURVE_PARSERS = { "http://www.opengis.net/gml/3.2": { curveMember: xu(J_.prototype.curveMemberParser), curveMembers: xu(J_.prototype.curveMemberParser) } }, ty.prototype.MULTISURFACE_PARSERS = { "http://www.opengis.net/gml/3.2": { surfaceMember: xu(J_.prototype.surfaceMemberParser), surfaceMembers: xu(J_.prototype.surfaceMemberParser) } }, ty.prototype.CURVEMEMBER_PARSERS = { "http://www.opengis.net/gml/3.2": { LineString: xu(O_.prototype.readLineString), Curve: xu(J_.prototype.readCurve) } }, ty.prototype.SURFACEMEMBER_PARSERS = { "http://www.opengis.net/gml/3.2": { Polygon: xu(O_.prototype.readPolygon), Surface: xu(J_.prototype.readSurface) } }, ty.prototype.SURFACE_PARSERS = { "http://www.opengis.net/gml/3.2": { patches: vu(J_.prototype.readPatch) } }, ty.prototype.CURVE_PARSERS = { "http://www.opengis.net/gml/3.2": { segments: vu(J_.prototype.readSegment) } }, ty.prototype.ENVELOPE_PARSERS = { "http://www.opengis.net/gml/3.2": { lowerCorner: xu(J_.prototype.readFlatPosList), upperCorner: xu(J_.prototype.readFlatPosList) } }, ty.prototype.PATCHES_PARSERS = { "http://www.opengis.net/gml/3.2": { PolygonPatch: vu(J_.prototype.readPolygonPatch) } }, ty.prototype.SEGMENTS_PARSERS = { "http://www.opengis.net/gml/3.2": { LineStringSegment: yu(J_.prototype.readLineStringSegment) } }, ty.prototype.MULTIPOINT_PARSERS = { "http://www.opengis.net/gml/3.2": { pointMember: xu(O_.prototype.pointMemberParser), pointMembers: xu(O_.prototype.pointMemberParser) } }, ty.prototype.MULTILINESTRING_PARSERS = { "http://www.opengis.net/gml/3.2": { lineStringMember: xu(O_.prototype.lineStringMemberParser), lineStringMembers: xu(O_.prototype.lineStringMemberParser) } }, ty.prototype.MULTIPOLYGON_PARSERS = { "http://www.opengis.net/gml/3.2": { polygonMember: xu(O_.prototype.polygonMemberParser), polygonMembers: xu(O_.prototype.polygonMemberParser) } }, ty.prototype.POINTMEMBER_PARSERS = { "http://www.opengis.net/gml/3.2": { Point: xu(O_.prototype.readFlatCoordinatesFromNode) } }, ty.prototype.LINESTRINGMEMBER_PARSERS = { "http://www.opengis.net/gml/3.2": { LineString: xu(O_.prototype.readLineString) } }, ty.prototype.POLYGONMEMBER_PARSERS = { "http://www.opengis.net/gml/3.2": { Polygon: xu(O_.prototype.readPolygon) } }, ty.prototype.RING_PARSERS = { "http://www.opengis.net/gml/3.2": { LinearRing: vu(O_.prototype.readFlatLinearRing), Ring: vu(ty.prototype.readFlatCurveRing) } }, ty.prototype.RING_SERIALIZERS = { "http://www.opengis.net/gml/3.2": { exterior: Eu(J_.prototype.writeRing), interior: Eu(J_.prototype.writeRing) } }, ty.prototype.ENVELOPE_SERIALIZERS = { "http://www.opengis.net/gml/3.2": { lowerCorner: Eu(K_), upperCorner: Eu(K_) } }, ty.prototype.SURFACEORPOLYGONMEMBER_SERIALIZERS = { "http://www.opengis.net/gml/3.2": { surfaceMember: Eu(J_.prototype.writeSurfaceOrPolygonMember), polygonMember: Eu(J_.prototype.writeSurfaceOrPolygonMember) } }, ty.prototype.POINTMEMBER_SERIALIZERS = { "http://www.opengis.net/gml/3.2": { pointMember: Eu(J_.prototype.writePointMember) } }, ty.prototype.LINESTRINGORCURVEMEMBER_SERIALIZERS = { "http://www.opengis.net/gml/3.2": { lineStringMember: Eu(J_.prototype.writeLineStringOrCurveMember), curveMember: Eu(J_.prototype.writeLineStringOrCurveMember) } }, ty.prototype.GEOMETRY_SERIALIZERS = { "http://www.opengis.net/gml/3.2": { Curve: Eu(J_.prototype.writeCurveOrLineString), MultiCurve: Eu(J_.prototype.writeMultiCurveOrLineString), Point: Eu(ty.prototype.writePoint), MultiPoint: Eu(J_.prototype.writeMultiPoint), LineString: Eu(J_.prototype.writeCurveOrLineString), MultiLineString: Eu(J_.prototype.writeMultiCurveOrLineString), LinearRing: Eu(J_.prototype.writeLinearRing), Polygon: Eu(J_.prototype.writeSurfaceOrPolygon), MultiPolygon: Eu(J_.prototype.writeMultiSurfaceOrPolygon), Surface: Eu(J_.prototype.writeSurfaceOrPolygon), MultiSurface: Eu(J_.prototype.writeMultiSurfaceOrPolygon), Envelope: Eu(J_.prototype.writeEnvelope) } };
      const ey = [null, "http://www.topografix.com/GPX/1/0", "http://www.topografix.com/GPX/1/1"], iy = { rte: Iy, trk: Ly, wpt: My }, ny = Pu(ey, { rte: xu(Iy), trk: xu(Ly), wpt: xu(My) }), ry = Pu(ey, { text: wu(z_, "linkText"), type: wu(z_, "linkType") }), sy = Pu(ey, { rte: Eu(function(t2, e2, i2) {
        const n2 = i2[0], r2 = e2.getProperties(), s2 = { node: t2 };
        s2.properties = r2;
        const o2 = e2.getGeometry();
        if ("LineString" == o2.getType()) {
          const t3 = Qp(o2, true, n2);
          s2.geometryLayout = t3.getLayout(), r2.rtept = t3.getCoordinates();
        }
        const a2 = i2[i2.length - 1].node, l2 = fy[a2.namespaceURI], h2 = Ru(r2, l2);
        Fu(s2, py, bu, h2, i2, l2);
      }), trk: Eu(function(t2, e2, i2) {
        const n2 = i2[0], r2 = e2.getProperties(), s2 = { node: t2 };
        s2.properties = r2;
        const o2 = e2.getGeometry();
        if ("MultiLineString" == o2.getType()) {
          const t3 = Qp(o2, true, n2);
          r2.trkseg = t3.getLineStrings();
        }
        const a2 = i2[i2.length - 1].node, l2 = _y[a2.namespaceURI], h2 = Ru(r2, l2);
        Fu(s2, yy, bu, h2, i2, l2);
      }), wpt: Eu(function(t2, e2, i2) {
        const n2 = i2[0], r2 = i2[i2.length - 1];
        r2.properties = e2.getProperties();
        const s2 = e2.getGeometry();
        if ("Point" == s2.getType()) {
          const e3 = Qp(s2, true, n2);
          r2.geometryLayout = e3.getLayout(), Ay(t2, e3.getCoordinates(), i2);
        }
      }) });
      const oy = Pu(ey, { name: wu(z_), cmt: wu(z_), desc: wu(z_), src: wu(z_), link: Ry, number: wu(B_), extensions: Py, type: wu(z_), rtept: function(t2, e2) {
        const i2 = Lu({}, ay, t2, e2);
        if (i2) {
          const n2 = e2[e2.length - 1], r2 = n2.flatCoordinates, s2 = n2.layoutOptions;
          Cy(r2, s2, t2, i2);
        }
      } }), ay = Pu(ey, { ele: wu(G_), time: wu(k_) }), ly = Pu(ey, { name: wu(z_), cmt: wu(z_), desc: wu(z_), src: wu(z_), link: Ry, number: wu(B_), type: wu(z_), extensions: Py, trkseg: function(t2, e2) {
        const i2 = e2[e2.length - 1];
        Iu(hy, t2, e2);
        const n2 = i2.flatCoordinates;
        i2.ends.push(n2.length);
      } }), hy = Pu(ey, { trkpt: function(t2, e2) {
        const i2 = Lu({}, cy, t2, e2);
        if (i2) {
          const n2 = e2[e2.length - 1], r2 = n2.flatCoordinates, s2 = n2.layoutOptions;
          Cy(r2, s2, t2, i2);
        }
      } }), cy = Pu(ey, { ele: wu(G_), time: wu(k_) }), uy = Pu(ey, { ele: wu(G_), time: wu(k_), magvar: wu(G_), geoidheight: wu(G_), name: wu(z_), cmt: wu(z_), desc: wu(z_), src: wu(z_), link: Ry, sym: wu(z_), type: wu(z_), fix: wu(z_), sat: wu(B_), hdop: wu(G_), vdop: wu(G_), pdop: wu(G_), ageofdgpsdata: wu(G_), dgpsid: wu(B_), extensions: Py }), dy = ["text", "type"], gy = Pu(ey, { text: Eu(K_), type: Eu(K_) }), fy = Pu(ey, ["name", "cmt", "desc", "src", "link", "number", "type", "rtept"]), py = Pu(ey, { name: Eu(K_), cmt: Eu(K_), desc: Eu(K_), src: Eu(K_), link: Eu(Fy), number: Eu(Y_), type: Eu(K_), rtept: Tu(Eu(Ay)) }), my = Pu(ey, ["ele", "time"]), _y = Pu(ey, ["name", "cmt", "desc", "src", "link", "number", "type", "trkseg"]), yy = Pu(ey, { name: Eu(K_), cmt: Eu(K_), desc: Eu(K_), src: Eu(K_), link: Eu(Fy), number: Eu(Y_), type: Eu(K_), trkseg: Tu(Eu(function(t2, e2, i2) {
        const n2 = { node: t2 };
        n2.geometryLayout = e2.getLayout(), n2.properties = {}, Fu(n2, vy, xy, e2.getCoordinates(), i2);
      })) }), xy = Cu("trkpt"), vy = Pu(ey, { trkpt: Eu(Ay) }), Sy = Pu(ey, ["ele", "time", "magvar", "geoidheight", "name", "cmt", "desc", "src", "link", "sym", "type", "fix", "sat", "hdop", "vdop", "pdop", "ageofdgpsdata", "dgpsid"]), wy = Pu(ey, { ele: Eu(Z_), time: Eu(W_), magvar: Eu(Z_), geoidheight: Eu(Z_), name: Eu(K_), cmt: Eu(K_), desc: Eu(K_), src: Eu(K_), link: Eu(Fy), sym: Eu(K_), type: Eu(K_), fix: Eu(K_), sat: Eu(Y_), hdop: Eu(Z_), vdop: Eu(Z_), pdop: Eu(Z_), ageofdgpsdata: Eu(Z_), dgpsid: Eu(Y_) }), Ey = { Point: "wpt", LineString: "rte", MultiLineString: "trk" };
      function Ty(t2, e2, i2) {
        const n2 = t2.getGeometry();
        if (n2) {
          const t3 = Ey[n2.getType()];
          if (t3) {
            return du(e2[e2.length - 1].node.namespaceURI, t3);
          }
        }
      }
      function Cy(t2, e2, i2, n2) {
        return t2.push(parseFloat(i2.getAttribute("lon")), parseFloat(i2.getAttribute("lat"))), "ele" in n2 ? (t2.push(n2.ele), delete n2.ele, e2.hasZ = true) : t2.push(0), "time" in n2 ? (t2.push(n2.time), delete n2.time, e2.hasM = true) : t2.push(0), t2;
      }
      function by(t2, e2, i2) {
        let n2 = "XY", r2 = 2;
        if (t2.hasZ && t2.hasM ? (n2 = "XYZM", r2 = 4) : t2.hasZ ? (n2 = "XYZ", r2 = 3) : t2.hasM && (n2 = "XYM", r2 = 3), 4 !== r2) {
          for (let i3 = 0, n3 = e2.length / 4; i3 < n3; i3++)
            e2[i3 * r2] = e2[4 * i3], e2[i3 * r2 + 1] = e2[4 * i3 + 1], t2.hasZ && (e2[i3 * r2 + 2] = e2[4 * i3 + 2]), t2.hasM && (e2[i3 * r2 + 2] = e2[4 * i3 + 3]);
          if (e2.length = e2.length / 4 * r2, i2)
            for (let t3 = 0, e3 = i2.length; t3 < e3; t3++)
              i2[t3] = i2[t3] / 4 * r2;
        }
        return n2;
      }
      function Ry(t2, e2) {
        const i2 = e2[e2.length - 1], n2 = t2.getAttribute("href");
        null !== n2 && (i2.link = n2), Iu(ry, t2, e2);
      }
      function Py(t2, e2) {
        e2[e2.length - 1].extensionsNode_ = t2;
      }
      function Iy(t2, e2) {
        const i2 = e2[0], n2 = Lu({ flatCoordinates: [], layoutOptions: {} }, oy, t2, e2);
        if (!n2)
          return;
        const r2 = n2.flatCoordinates;
        delete n2.flatCoordinates;
        const s2 = n2.layoutOptions;
        delete n2.layoutOptions;
        const o2 = by(s2, r2), a2 = new Op(r2, o2);
        Qp(a2, false, i2);
        const l2 = new lt(a2);
        return l2.setProperties(n2, true), l2;
      }
      function Ly(t2, e2) {
        const i2 = e2[0], n2 = Lu({ flatCoordinates: [], ends: [], layoutOptions: {} }, ly, t2, e2);
        if (!n2)
          return;
        const r2 = n2.flatCoordinates;
        delete n2.flatCoordinates;
        const s2 = n2.ends;
        delete n2.ends;
        const o2 = n2.layoutOptions;
        delete n2.layoutOptions;
        const a2 = by(o2, r2, s2), l2 = new Np(r2, a2, s2);
        Qp(l2, false, i2);
        const h2 = new lt(l2);
        return h2.setProperties(n2, true), h2;
      }
      function My(t2, e2) {
        const i2 = e2[0], n2 = Lu({}, uy, t2, e2);
        if (!n2)
          return;
        const r2 = {}, s2 = Cy([], r2, t2, n2), o2 = by(r2, s2), a2 = new Wn(s2, o2);
        Qp(a2, false, i2);
        const l2 = new lt(a2);
        return l2.setProperties(n2, true), l2;
      }
      function Fy(t2, e2, i2) {
        t2.setAttribute("href", e2);
        const n2 = i2[i2.length - 1].properties, r2 = [n2.linkText, n2.linkType];
        Fu({ node: t2 }, gy, bu, r2, i2, dy);
      }
      function Ay(t2, e2, i2) {
        const n2 = i2[i2.length - 1], r2 = n2.node.namespaceURI, s2 = n2.properties;
        t2.setAttributeNS(null, "lat", String(e2[1])), t2.setAttributeNS(null, "lon", String(e2[0]));
        switch (n2.geometryLayout) {
          case "XYZM":
            0 !== e2[3] && (s2.time = e2[3]);
          case "XYZ":
            0 !== e2[2] && (s2.ele = e2[2]);
            break;
          case "XYM":
            0 !== e2[2] && (s2.time = e2[2]);
        }
        const o2 = "rtept" == t2.nodeName ? my[r2] : Sy[r2], a2 = Ru(s2, o2);
        Fu({ node: t2, properties: s2 }, wy, bu, a2, i2, o2);
      }
      function Oy(t2, e2) {
        if (!t2)
          return null;
        let i2;
        switch (t2.type) {
          case "Point":
            i2 = function(t3) {
              return new Wn(t3.coordinates);
            }(t2);
            break;
          case "LineString":
            i2 = function(t3) {
              return new Op(t3.coordinates);
            }(t2);
            break;
          case "Polygon":
            i2 = function(t3) {
              return new ur(t3.coordinates);
            }(t2);
            break;
          case "MultiPoint":
            i2 = function(t3) {
              return new Dp(t3.coordinates);
            }(t2);
            break;
          case "MultiLineString":
            i2 = function(t3) {
              return new Np(t3.coordinates);
            }(t2);
            break;
          case "MultiPolygon":
            i2 = function(t3) {
              return new Gp(t3.coordinates);
            }(t2);
            break;
          case "GeometryCollection":
            i2 = function(t3, e3) {
              const i3 = t3.geometries.map(function(t4) {
                return Oy(t4, e3);
              });
              return new Ip(i3);
            }(t2);
            break;
          default:
            throw new Error("Unsupported GeoJSON type: " + t2.type);
        }
        return Qp(i2, false, e2);
      }
      function Ny(t2, e2) {
        const i2 = (t2 = Qp(t2, true, e2)).getType();
        let n2;
        switch (i2) {
          case "Point":
            n2 = function(t3, e3) {
              return { type: "Point", coordinates: t3.getCoordinates() };
            }(t2);
            break;
          case "LineString":
            n2 = function(t3, e3) {
              return { type: "LineString", coordinates: t3.getCoordinates() };
            }(t2);
            break;
          case "Polygon":
            n2 = function(t3, e3) {
              let i3;
              e3 && (i3 = e3.rightHanded);
              return { type: "Polygon", coordinates: t3.getCoordinates(i3) };
            }(t2, e2);
            break;
          case "MultiPoint":
            n2 = function(t3, e3) {
              return { type: "MultiPoint", coordinates: t3.getCoordinates() };
            }(t2);
            break;
          case "MultiLineString":
            n2 = function(t3, e3) {
              return { type: "MultiLineString", coordinates: t3.getCoordinates() };
            }(t2);
            break;
          case "MultiPolygon":
            n2 = function(t3, e3) {
              let i3;
              e3 && (i3 = e3.rightHanded);
              return { type: "MultiPolygon", coordinates: t3.getCoordinates(i3) };
            }(t2, e2);
            break;
          case "GeometryCollection":
            n2 = function(t3, e3) {
              delete (e3 = Object.assign({}, e3)).featureProjection;
              return { type: "GeometryCollection", geometries: t3.getGeometriesArray().map(function(t4) {
                return Ny(t4, e3);
              }) };
            }(t2, e2);
            break;
          case "Circle":
            n2 = { type: "GeometryCollection", geometries: [] };
            break;
          default:
            throw new Error("Unsupported geometry type: " + i2);
        }
        return n2;
      }
      class Dy extends Jp {
        constructor() {
          super();
        }
        getType() {
          return "text";
        }
        readFeature(t2, e2) {
          return this.readFeatureFromText(ky(t2), this.adaptOptions(e2));
        }
        readFeatureFromText(t2, e2) {
          return B();
        }
        readFeatures(t2, e2) {
          return this.readFeaturesFromText(ky(t2), this.adaptOptions(e2));
        }
        readFeaturesFromText(t2, e2) {
          return B();
        }
        readGeometry(t2, e2) {
          return this.readGeometryFromText(ky(t2), this.adaptOptions(e2));
        }
        readGeometryFromText(t2, e2) {
          return B();
        }
        readProjection(t2) {
          return this.readProjectionFromText(ky(t2));
        }
        readProjectionFromText(t2) {
          return this.dataProjection;
        }
        writeFeature(t2, e2) {
          return this.writeFeatureText(t2, this.adaptOptions(e2));
        }
        writeFeatureText(t2, e2) {
          return B();
        }
        writeFeatures(t2, e2) {
          return this.writeFeaturesText(t2, this.adaptOptions(e2));
        }
        writeFeaturesText(t2, e2) {
          return B();
        }
        writeGeometry(t2, e2) {
          return this.writeGeometryText(t2, this.adaptOptions(e2));
        }
        writeGeometryText(t2, e2) {
          return B();
        }
      }
      function ky(t2) {
        return "string" == typeof t2 ? t2 : "";
      }
      const Gy = /^B(\d{2})(\d{2})(\d{2})(\d{2})(\d{5})([NS])(\d{3})(\d{5})([EW])([AV])(\d{5})(\d{5})/, jy = /^H.([A-Z]{3}).*?:(.*)/, By = /^HFDTE(\d{2})(\d{2})(\d{2})/, Uy = /\r\n|\r|\n/;
      const zy = ["http://www.google.com/kml/ext/2.2"], Xy = [null, "http://earth.google.com/kml/2.0", "http://earth.google.com/kml/2.1", "http://earth.google.com/kml/2.2", "http://www.opengis.net/kml/2.2"], Vy = { fraction: "fraction", pixels: "pixels", insetPixels: "pixels" }, Wy = Pu(Xy, { ExtendedData: Yx, Region: Kx, MultiGeometry: wu(Gx, "geometry"), LineString: wu(Nx, "geometry"), LinearRing: wu(Dx, "geometry"), Point: wu(jx, "geometry"), Polygon: wu(Ux, "geometry"), Style: wu(Xx), StyleMap: function(t2, e2) {
        const i2 = Sx.call(this, t2, e2);
        if (!i2)
          return;
        const n2 = e2[e2.length - 1];
        Array.isArray(i2) ? n2.Style = i2 : "string" == typeof i2 ? n2.styleUrl = i2 : at(false, 38);
      }, address: wu(z_), description: wu(z_), name: wu(z_), open: wu(N_), phoneNumber: wu(z_), styleUrl: wu(yx), visibility: wu(N_) }, Pu(zy, { MultiTrack: wu(function(t2, e2) {
        const i2 = Lu([], Px, t2, e2);
        if (!i2)
          return;
        return new Np(i2);
      }, "geometry"), Track: wu(Lx, "geometry") })), Zy = Pu(Xy, { ExtendedData: Yx, Region: Kx, Link: function(t2, e2) {
        Iu(Yy, t2, e2);
      }, address: wu(z_), description: wu(z_), name: wu(z_), open: wu(N_), phoneNumber: wu(z_), visibility: wu(N_) }), Yy = Pu(Xy, { href: wu(_x) }), Ky = Pu(Xy, { LatLonAltBox: function(t2, e2) {
        const i2 = Lu({}, $x, t2, e2);
        if (!i2)
          return;
        const n2 = e2[e2.length - 1], r2 = [parseFloat(i2.west), parseFloat(i2.south), parseFloat(i2.east), parseFloat(i2.north)];
        n2.extent = r2, n2.altitudeMode = i2.altitudeMode, n2.minAltitude = parseFloat(i2.minAltitude), n2.maxAltitude = parseFloat(i2.maxAltitude);
      }, Lod: function(t2, e2) {
        const i2 = Lu({}, Jx, t2, e2);
        if (!i2)
          return;
        const n2 = e2[e2.length - 1];
        n2.minLodPixels = parseFloat(i2.minLodPixels), n2.maxLodPixels = parseFloat(i2.maxLodPixels), n2.minFadeExtent = parseFloat(i2.minFadeExtent), n2.maxFadeExtent = parseFloat(i2.maxFadeExtent);
      } }), qy = Pu(Xy, ["Document", "Placemark"]), Hy = Pu(Xy, { Document: Eu(function(t2, e2, i2) {
        Fu({ node: t2 }, nv, rv, e2, i2, void 0, this);
      }), Placemark: Eu(Pv) });
      let $y, Jy, Qy, tx, ex, ix, nx = null;
      let rx, sx = null;
      let ox, ax = null;
      let lx = null;
      let hx = null;
      let cx, ux = null;
      function dx(t2) {
        return 32 / Math.min(t2[0], t2[1]);
      }
      function gx(t2) {
        return t2;
      }
      function fx(t2, e2, i2) {
        return Array.isArray(t2) ? t2 : "string" == typeof t2 ? fx(i2[t2], e2, i2) : e2;
      }
      function px(t2) {
        const e2 = gu(t2, false), i2 = /^\s*#?\s*([0-9A-Fa-f]{8})\s*$/.exec(e2);
        if (i2) {
          const t3 = i2[1];
          return [parseInt(t3.substr(6, 2), 16), parseInt(t3.substr(4, 2), 16), parseInt(t3.substr(2, 2), 16), parseInt(t3.substr(0, 2), 16) / 255];
        }
      }
      function mx(t2) {
        let e2 = gu(t2, false);
        const i2 = [];
        e2 = e2.replace(/\s*,\s*/g, ",");
        const n2 = /^\s*([+\-]?\d*\.?\d+(?:e[+\-]?\d+)?),([+\-]?\d*\.?\d+(?:e[+\-]?\d+)?)(?:\s+|,|$)(?:([+\-]?\d*\.?\d+(?:e[+\-]?\d+)?)(?:\s+|$))?\s*/i;
        let r2;
        for (; r2 = n2.exec(e2); ) {
          const t3 = parseFloat(r2[1]), n3 = parseFloat(r2[2]), s2 = r2[3] ? parseFloat(r2[3]) : 0;
          i2.push(t3, n3, s2), e2 = e2.substr(r2[0].length);
        }
        if ("" === e2)
          return i2;
      }
      function _x(t2) {
        const e2 = gu(t2, false).trim();
        let i2 = t2.baseURI;
        if (i2 && "about:blank" != i2 || (i2 = window.location.href), i2) {
          return new URL(e2, i2).href;
        }
        return e2;
      }
      function yx(t2) {
        const e2 = gu(t2, false).trim().replace(/^(?!.*#)/, "#");
        let i2 = t2.baseURI;
        if (i2 && "about:blank" != i2 || (i2 = window.location.href), i2) {
          return new URL(e2, i2).href;
        }
        return e2;
      }
      function xx(t2) {
        return G_(t2);
      }
      const vx = Pu(Xy, { Pair: function(t2, e2) {
        const i2 = Lu({}, qx, t2, e2, this);
        if (!i2)
          return;
        const n2 = i2.key;
        if (n2 && "normal" == n2) {
          const t3 = i2.styleUrl;
          t3 && (e2[e2.length - 1] = t3);
          const n3 = i2.Style;
          n3 && (e2[e2.length - 1] = n3);
        }
      } });
      function Sx(t2, e2) {
        return Lu(void 0, vx, t2, e2, this);
      }
      const wx = Pu(Xy, { Icon: wu(function(t2, e2) {
        const i2 = Lu({}, Mx, t2, e2);
        return i2 || null;
      }), color: wu(px), heading: wu(G_), hotSpot: wu(function(t2) {
        const e2 = t2.getAttribute("xunits"), i2 = t2.getAttribute("yunits");
        let n2;
        return n2 = "insetPixels" !== e2 ? "insetPixels" !== i2 ? "bottom-left" : "top-left" : "insetPixels" !== i2 ? "bottom-right" : "top-right", { x: parseFloat(t2.getAttribute("x")), xunits: Vy[e2], y: parseFloat(t2.getAttribute("y")), yunits: Vy[i2], origin: n2 };
      }), scale: wu(xx) });
      const Ex = Pu(Xy, { color: wu(px), scale: wu(xx) });
      const Tx = Pu(Xy, { color: wu(px), width: wu(G_) });
      const Cx = Pu(Xy, { color: wu(px), fill: wu(N_), outline: wu(N_) });
      const bx = Pu(Xy, { coordinates: vu(mx) });
      function Rx(t2, e2) {
        return Lu(null, bx, t2, e2);
      }
      const Px = Pu(zy, { Track: xu(Lx) });
      const Ix = Pu(Xy, { when: function(t2, e2) {
        const i2 = e2[e2.length - 1].whens, n2 = gu(t2, false), r2 = Date.parse(n2);
        i2.push(isNaN(r2) ? 0 : r2);
      } }, Pu(zy, { coord: function(t2, e2) {
        const i2 = e2[e2.length - 1].coordinates, n2 = gu(t2, false), r2 = /^\s*([+\-]?\d+(?:\.\d*)?(?:e[+\-]?\d*)?)\s+([+\-]?\d+(?:\.\d*)?(?:e[+\-]?\d*)?)\s+([+\-]?\d+(?:\.\d*)?(?:e[+\-]?\d*)?)\s*$/i.exec(n2);
        if (r2) {
          const t3 = parseFloat(r2[1]), e3 = parseFloat(r2[2]), n3 = parseFloat(r2[3]);
          i2.push([t3, e3, n3]);
        } else
          i2.push([]);
      } }));
      function Lx(t2, e2) {
        const i2 = Lu({ coordinates: [], whens: [] }, Ix, t2, e2);
        if (!i2)
          return;
        const n2 = [], r2 = i2.coordinates, s2 = i2.whens;
        for (let t3 = 0, e3 = Math.min(r2.length, s2.length); t3 < e3; ++t3)
          3 == r2[t3].length && n2.push(r2[t3][0], r2[t3][1], r2[t3][2], s2[t3]);
        return new Op(n2, "XYZM");
      }
      const Mx = Pu(Xy, { href: wu(_x) }, Pu(zy, { x: wu(G_), y: wu(G_), w: wu(G_), h: wu(G_) }));
      const Fx = Pu(Xy, { coordinates: vu(mx) });
      function Ax(t2, e2) {
        return Lu(null, Fx, t2, e2);
      }
      const Ox = Pu(Xy, { extrude: wu(N_), tessellate: wu(N_), altitudeMode: wu(z_) });
      function Nx(t2, e2) {
        const i2 = Lu({}, Ox, t2, e2), n2 = Ax(t2, e2);
        if (n2) {
          const t3 = new Op(n2, "XYZ");
          return t3.setProperties(i2, true), t3;
        }
      }
      function Dx(t2, e2) {
        const i2 = Lu({}, Ox, t2, e2), n2 = Ax(t2, e2);
        if (n2) {
          const t3 = new ur(n2, "XYZ", [n2.length]);
          return t3.setProperties(i2, true), t3;
        }
      }
      const kx = Pu(Xy, { LineString: xu(Nx), LinearRing: xu(Dx), MultiGeometry: xu(Gx), Point: xu(jx), Polygon: xu(Ux) });
      function Gx(t2, e2) {
        const i2 = Lu([], kx, t2, e2);
        if (!i2)
          return null;
        if (0 === i2.length)
          return new Ip(i2);
        let n2, r2 = true;
        const s2 = i2[0].getType();
        let o2;
        for (let t3 = 1, e3 = i2.length; t3 < e3; ++t3)
          if (o2 = i2[t3], o2.getType() != s2) {
            r2 = false;
            break;
          }
        if (r2) {
          let t3, e3;
          if ("Point" == s2) {
            const r3 = i2[0];
            t3 = r3.getLayout(), e3 = r3.getFlatCoordinates();
            for (let t4 = 1, n3 = i2.length; t4 < n3; ++t4)
              o2 = i2[t4], c(e3, o2.getFlatCoordinates());
            n2 = new Dp(e3, t3), Vx(n2, i2);
          } else
            "LineString" == s2 ? (n2 = new Np(i2), Vx(n2, i2)) : "Polygon" == s2 ? (n2 = new Gp(i2), Vx(n2, i2)) : "GeometryCollection" == s2 ? n2 = new Ip(i2) : at(false, 37);
        } else
          n2 = new Ip(i2);
        return n2;
      }
      function jx(t2, e2) {
        const i2 = Lu({}, Ox, t2, e2), n2 = Ax(t2, e2);
        if (n2) {
          const t3 = new Wn(n2, "XYZ");
          return t3.setProperties(i2, true), t3;
        }
      }
      const Bx = Pu(Xy, { innerBoundaryIs: function(t2, e2) {
        const i2 = Lu([], Qx, t2, e2);
        if (i2.length > 0) {
          e2[e2.length - 1].push(...i2);
        }
      }, outerBoundaryIs: function(t2, e2) {
        const i2 = Lu(void 0, tv, t2, e2);
        if (i2) {
          e2[e2.length - 1][0] = i2;
        }
      } });
      function Ux(t2, e2) {
        const i2 = Lu({}, Ox, t2, e2), n2 = Lu([null], Bx, t2, e2);
        if (n2 && n2[0]) {
          const t3 = n2[0], e3 = [t3.length];
          for (let i3 = 1, r3 = n2.length; i3 < r3; ++i3)
            c(t3, n2[i3]), e3.push(t3.length);
          const r2 = new ur(t3, "XYZ", e3);
          return r2.setProperties(i2, true), r2;
        }
      }
      const zx = Pu(Xy, { IconStyle: function(t2, e2) {
        const i2 = Lu({}, wx, t2, e2);
        if (!i2)
          return;
        const n2 = e2[e2.length - 1], r2 = "Icon" in i2 ? i2.Icon : {}, s2 = !("Icon" in i2) || Object.keys(r2).length > 0;
        let o2;
        const a2 = r2.href;
        let l2, h2, c2;
        a2 ? o2 = a2 : s2 && (o2 = ix);
        let u2 = "bottom-left";
        const d2 = i2.hotSpot;
        let g2;
        d2 ? (l2 = [d2.x, d2.y], h2 = d2.xunits, c2 = d2.yunits, u2 = d2.origin) : /^https?:\/\/maps\.(?:google|gstatic)\.com\//.test(o2) && (o2.includes("pushpin") ? (l2 = Jy, h2 = Qy, c2 = tx) : o2.includes("arrow-reverse") ? (l2 = [54, 42], h2 = Qy, c2 = tx) : o2.includes("paddle") && (l2 = [32, 1], h2 = Qy, c2 = tx));
        const f2 = r2.x, p2 = r2.y;
        let m2;
        void 0 !== f2 && void 0 !== p2 && (g2 = [f2, p2]);
        const _2 = r2.w, y2 = r2.h;
        let x2;
        void 0 !== _2 && void 0 !== y2 && (m2 = [_2, y2]);
        const v2 = i2.heading;
        void 0 !== v2 && (x2 = ai(v2));
        const S2 = i2.scale, w2 = i2.color;
        if (s2) {
          o2 == ix && (m2 = ex);
          const t3 = new lg({ anchor: l2, anchorOrigin: u2, anchorXUnits: h2, anchorYUnits: c2, crossOrigin: this.crossOrigin_, offset: g2, offsetOrigin: "bottom-left", rotation: x2, scale: S2, size: m2, src: this.iconUrlFunction_(o2), color: w2 }), e3 = t3.getScaleArray()[0], i3 = t3.getSize();
          if (null === i3) {
            const i4 = t3.getImageState();
            if (i4 === Pr || i4 === Ir) {
              const n3 = function() {
                const i5 = t3.getImageState();
                if (i5 !== Pr && i5 !== Ir) {
                  const i6 = t3.getSize();
                  if (i6 && 2 == i6.length) {
                    const n4 = dx(i6);
                    t3.setScale(e3 * n4);
                  }
                  t3.unlistenImageChange(n3);
                }
              };
              t3.listenImageChange(n3), i4 === Pr && t3.load();
            }
          } else if (2 == i3.length) {
            const n3 = dx(i3);
            t3.setScale(e3 * n3);
          }
          n2.imageStyle = t3;
        } else
          n2.imageStyle = rx;
      }, LabelStyle: function(t2, e2) {
        const i2 = Lu({}, Ex, t2, e2);
        if (!i2)
          return;
        const n2 = e2[e2.length - 1], r2 = new mg({ fill: new rg({ color: "color" in i2 ? i2.color : $y }), scale: i2.scale });
        n2.textStyle = r2;
      }, LineStyle: function(t2, e2) {
        const i2 = Lu({}, Tx, t2, e2);
        if (!i2)
          return;
        const n2 = e2[e2.length - 1], r2 = new hg({ color: "color" in i2 ? i2.color : $y, width: "width" in i2 ? i2.width : 1 });
        n2.strokeStyle = r2;
      }, PolyStyle: function(t2, e2) {
        const i2 = Lu({}, Cx, t2, e2);
        if (!i2)
          return;
        const n2 = e2[e2.length - 1], r2 = new rg({ color: "color" in i2 ? i2.color : $y });
        n2.fillStyle = r2;
        const s2 = i2.fill;
        void 0 !== s2 && (n2.fill = s2);
        const o2 = i2.outline;
        void 0 !== o2 && (n2.outline = o2);
      } });
      function Xx(t2, e2) {
        const i2 = Lu({}, zx, t2, e2, this);
        if (!i2)
          return null;
        let n2 = "fillStyle" in i2 ? i2.fillStyle : nx;
        const r2 = i2.fill;
        let s2;
        void 0 === r2 || r2 || (n2 = null), "imageStyle" in i2 ? i2.imageStyle != rx && (s2 = i2.imageStyle) : s2 = sx;
        const o2 = "textStyle" in i2 ? i2.textStyle : lx, a2 = "strokeStyle" in i2 ? i2.strokeStyle : ax, l2 = i2.outline;
        return void 0 === l2 || l2 ? [new cg({ fill: n2, image: s2, stroke: a2, text: o2, zIndex: void 0 })] : [new cg({ geometry: function(t3) {
          const e3 = t3.getGeometry(), i3 = e3.getType();
          if ("GeometryCollection" === i3) {
            return new Ip(e3.getGeometriesArrayRecursive().filter(function(t4) {
              const e4 = t4.getType();
              return "Polygon" !== e4 && "MultiPolygon" !== e4;
            }));
          }
          if ("Polygon" !== i3 && "MultiPolygon" !== i3)
            return e3;
        }, fill: n2, image: s2, stroke: a2, text: o2, zIndex: void 0 }), new cg({ geometry: function(t3) {
          const e3 = t3.getGeometry(), i3 = e3.getType();
          if ("GeometryCollection" === i3) {
            return new Ip(e3.getGeometriesArrayRecursive().filter(function(t4) {
              const e4 = t4.getType();
              return "Polygon" === e4 || "MultiPolygon" === e4;
            }));
          }
          if ("Polygon" === i3 || "MultiPolygon" === i3)
            return e3;
        }, fill: n2, stroke: null, zIndex: void 0 })];
      }
      function Vx(t2, e2) {
        const i2 = e2.length, n2 = new Array(e2.length), r2 = new Array(e2.length), s2 = new Array(e2.length);
        let o2, a2, l2;
        o2 = false, a2 = false, l2 = false;
        for (let t3 = 0; t3 < i2; ++t3) {
          const i3 = e2[t3];
          n2[t3] = i3.get("extrude"), r2[t3] = i3.get("tessellate"), s2[t3] = i3.get("altitudeMode"), o2 = o2 || void 0 !== n2[t3], a2 = a2 || void 0 !== r2[t3], l2 = l2 || s2[t3];
        }
        o2 && t2.set("extrude", n2), a2 && t2.set("tessellate", r2), l2 && t2.set("altitudeMode", s2);
      }
      const Wx = Pu(Xy, { displayName: wu(z_), value: wu(z_) });
      const Zx = Pu(Xy, { Data: function(t2, e2) {
        const i2 = t2.getAttribute("name");
        Iu(Wx, t2, e2);
        const n2 = e2[e2.length - 1];
        i2 && n2.displayName ? n2[i2] = { value: n2.value, displayName: n2.displayName, toString: function() {
          return n2.value;
        } } : null !== i2 ? n2[i2] = n2.value : null !== n2.displayName && (n2[n2.displayName] = n2.value), delete n2.value;
      }, SchemaData: function(t2, e2) {
        Iu(Hx, t2, e2);
      } });
      function Yx(t2, e2) {
        Iu(Zx, t2, e2);
      }
      function Kx(t2, e2) {
        Iu(Ky, t2, e2);
      }
      const qx = Pu(Xy, { Style: wu(Xx), key: wu(z_), styleUrl: wu(yx) });
      const Hx = Pu(Xy, { SimpleData: function(t2, e2) {
        const i2 = t2.getAttribute("name");
        if (null !== i2) {
          const n2 = z_(t2);
          e2[e2.length - 1][i2] = n2;
        }
      } });
      const $x = Pu(Xy, { altitudeMode: wu(z_), minAltitude: wu(G_), maxAltitude: wu(G_), north: wu(G_), south: wu(G_), east: wu(G_), west: wu(G_) });
      const Jx = Pu(Xy, { minLodPixels: wu(G_), maxLodPixels: wu(G_), minFadeExtent: wu(G_), maxFadeExtent: wu(G_) });
      const Qx = Pu(Xy, { LinearRing: xu(Rx) });
      const tv = Pu(Xy, { LinearRing: vu(Rx) });
      function ev(t2, e2) {
        const i2 = $r(e2), n2 = [255 * (4 == i2.length ? i2[3] : 1), i2[2], i2[1], i2[0]];
        for (let t3 = 0; t3 < 4; ++t3) {
          const e3 = Math.floor(n2[t3]).toString(16);
          n2[t3] = 1 == e3.length ? "0" + e3 : e3;
        }
        K_(t2, n2.join(""));
      }
      const iv = Pu(Xy, { Data: Eu(function(t2, e2, i2) {
        t2.setAttribute("name", e2.name);
        const n2 = { node: t2 }, r2 = e2.value;
        "object" == typeof r2 ? (null !== r2 && r2.displayName && Fu(n2, iv, bu, [r2.displayName], i2, ["displayName"]), null !== r2 && r2.value && Fu(n2, iv, bu, [r2.value], i2, ["value"])) : Fu(n2, iv, bu, [r2], i2, ["value"]);
      }), value: Eu(function(t2, e2) {
        K_(t2, e2);
      }), displayName: Eu(function(t2, e2) {
        V_(t2, e2);
      }) });
      const nv = Pu(Xy, { Placemark: Eu(Pv) }), rv = function(t2, e2, i2) {
        return du(e2[e2.length - 1].node.namespaceURI, "Placemark");
      };
      const sv = Cu("Data");
      const ov = Pu(Xy, ["href"], Pu(zy, ["x", "y", "w", "h"])), av = Pu(Xy, { href: Eu(K_) }, Pu(zy, { x: Eu(Z_), y: Eu(Z_), w: Eu(Z_), h: Eu(Z_) })), lv = function(t2, e2, i2) {
        return du(zy[0], "gx:" + i2);
      };
      const hv = Pu(Xy, ["scale", "heading", "Icon", "color", "hotSpot"]), cv = Pu(Xy, { Icon: Eu(function(t2, e2, i2) {
        const n2 = { node: t2 }, r2 = i2[i2.length - 1].node;
        let s2 = ov[r2.namespaceURI], o2 = Ru(e2, s2);
        Fu(n2, av, bu, o2, i2, s2), s2 = ov[zy[0]], o2 = Ru(e2, s2), Fu(n2, av, lv, o2, i2, s2);
      }), color: Eu(ev), heading: Eu(Z_), hotSpot: Eu(function(t2, e2) {
        t2.setAttribute("x", String(e2.x)), t2.setAttribute("y", String(e2.y)), t2.setAttribute("xunits", e2.xunits), t2.setAttribute("yunits", e2.yunits);
      }), scale: Eu(Gv) });
      const uv = Pu(Xy, ["color", "scale"]), dv = Pu(Xy, { color: Eu(ev), scale: Eu(Gv) });
      const gv = Pu(Xy, ["color", "width"]), fv = Pu(Xy, { color: Eu(ev), width: Eu(Z_) });
      const pv = { Point: "Point", LineString: "LineString", LinearRing: "LinearRing", Polygon: "Polygon", MultiPoint: "MultiGeometry", MultiLineString: "MultiGeometry", MultiPolygon: "MultiGeometry", GeometryCollection: "MultiGeometry" }, mv = function(t2, e2, i2) {
        if (t2) {
          return du(e2[e2.length - 1].node.namespaceURI, pv[t2.getType()]);
        }
      }, _v = Cu("Point"), yv = Cu("LineString"), xv = Cu("LinearRing"), vv = Cu("Polygon"), Sv = Pu(Xy, { LineString: Eu(Mv), Point: Eu(Mv), Polygon: Eu(Dv), GeometryCollection: Eu(wv) });
      function wv(t2, e2, i2) {
        const n2 = { node: t2 }, r2 = e2.getType();
        let s2, o2 = [];
        "GeometryCollection" === r2 ? (e2.getGeometriesArrayRecursive().forEach(function(t3) {
          const e3 = t3.getType();
          "MultiPoint" === e3 ? o2 = o2.concat(t3.getPoints()) : "MultiLineString" === e3 ? o2 = o2.concat(t3.getLineStrings()) : "MultiPolygon" === e3 ? o2 = o2.concat(t3.getPolygons()) : "Point" === e3 || "LineString" === e3 || "Polygon" === e3 ? o2.push(t3) : at(false, 39);
        }), s2 = mv) : "MultiPoint" === r2 ? (o2 = e2.getPoints(), s2 = _v) : "MultiLineString" === r2 ? (o2 = e2.getLineStrings(), s2 = yv) : "MultiPolygon" === r2 ? (o2 = e2.getPolygons(), s2 = vv) : at(false, 39), Fu(n2, Sv, s2, o2, i2);
      }
      const Ev = Pu(Xy, { LinearRing: Eu(Mv) });
      function Tv(t2, e2, i2) {
        Fu({ node: t2 }, Ev, xv, [e2], i2);
      }
      const Cv = Pu(Xy, { ExtendedData: Eu(function(t2, e2, i2) {
        const n2 = { node: t2 }, r2 = e2.names, s2 = e2.values, o2 = r2.length;
        for (let t3 = 0; t3 < o2; t3++)
          Fu(n2, iv, sv, [{ name: r2[t3], value: s2[t3] }], i2);
      }), MultiGeometry: Eu(wv), LineString: Eu(Mv), LinearRing: Eu(Mv), Point: Eu(Mv), Polygon: Eu(Dv), Style: Eu(function(t2, e2, i2) {
        const n2 = { node: t2 }, r2 = {};
        if (e2.pointStyles.length) {
          const t3 = e2.pointStyles[0].getText();
          t3 && (r2.LabelStyle = t3);
          const i3 = e2.pointStyles[0].getImage();
          i3 && "function" == typeof i3.getSrc && (r2.IconStyle = i3);
        }
        if (e2.lineStyles.length) {
          const t3 = e2.lineStyles[0].getStroke();
          t3 && (r2.LineStyle = t3);
        }
        if (e2.polyStyles.length) {
          const t3 = e2.polyStyles[0].getStroke();
          t3 && !r2.LineStyle && (r2.LineStyle = t3), r2.PolyStyle = e2.polyStyles[0];
        }
        const s2 = i2[i2.length - 1].node, o2 = jv[s2.namespaceURI], a2 = Ru(r2, o2);
        Fu(n2, Bv, bu, a2, i2, o2);
      }), address: Eu(K_), description: Eu(K_), name: Eu(K_), open: Eu(X_), phoneNumber: Eu(K_), styleUrl: Eu(K_), visibility: Eu(X_) }), bv = Pu(Xy, ["name", "open", "visibility", "address", "phoneNumber", "description", "styleUrl", "Style"]), Rv = Cu("ExtendedData");
      function Pv(t2, e2, i2) {
        const n2 = { node: t2 };
        e2.getId() && t2.setAttribute("id", e2.getId());
        const r2 = e2.getProperties(), s2 = { address: 1, description: 1, name: 1, open: 1, phoneNumber: 1, styleUrl: 1, visibility: 1 };
        s2[e2.getGeometryName()] = 1;
        const o2 = Object.keys(r2 || {}).sort().filter(function(t3) {
          return !s2[t3];
        }), a2 = e2.getStyleFunction();
        if (a2) {
          const t3 = a2(e2, 0);
          if (t3) {
            const i3 = Array.isArray(t3) ? t3 : [t3];
            let n3 = i3;
            if (e2.getGeometry() && (n3 = i3.filter(function(t4) {
              const i4 = t4.getGeometryFunction()(e2);
              if (i4) {
                const t5 = i4.getType();
                return "GeometryCollection" === t5 ? i4.getGeometriesArrayRecursive().filter(function(t6) {
                  const e3 = t6.getType();
                  return "Point" === e3 || "MultiPoint" === e3;
                }).length : "Point" === t5 || "MultiPoint" === t5;
              }
            })), this.writeStyles_) {
              let t4 = i3, s3 = i3;
              e2.getGeometry() && (t4 = i3.filter(function(t5) {
                const i4 = t5.getGeometryFunction()(e2);
                if (i4) {
                  const t6 = i4.getType();
                  return "GeometryCollection" === t6 ? i4.getGeometriesArrayRecursive().filter(function(t7) {
                    const e3 = t7.getType();
                    return "LineString" === e3 || "MultiLineString" === e3;
                  }).length : "LineString" === t6 || "MultiLineString" === t6;
                }
              }), s3 = i3.filter(function(t5) {
                const i4 = t5.getGeometryFunction()(e2);
                if (i4) {
                  const t6 = i4.getType();
                  return "GeometryCollection" === t6 ? i4.getGeometriesArrayRecursive().filter(function(t7) {
                    const e3 = t7.getType();
                    return "Polygon" === e3 || "MultiPolygon" === e3;
                  }).length : "Polygon" === t6 || "MultiPolygon" === t6;
                }
              })), r2.Style = { pointStyles: n3, lineStyles: t4, polyStyles: s3 };
            }
            if (n3.length && void 0 === r2.name) {
              const t4 = n3[0].getText();
              t4 && (r2.name = t4.getText());
            }
          }
        }
        const l2 = i2[i2.length - 1].node, h2 = bv[l2.namespaceURI], c2 = Ru(r2, h2);
        if (Fu(n2, Cv, bu, c2, i2, h2), o2.length > 0) {
          const t3 = Ru(r2, o2);
          Fu(n2, Cv, Rv, [{ names: o2, values: t3 }], i2);
        }
        const u2 = i2[0];
        let d2 = e2.getGeometry();
        d2 && (d2 = Qp(d2, true, u2)), Fu(n2, Cv, mv, [d2], i2);
      }
      const Iv = Pu(Xy, ["extrude", "tessellate", "altitudeMode", "coordinates"]), Lv = Pu(Xy, { extrude: Eu(X_), tessellate: Eu(X_), altitudeMode: Eu(K_), coordinates: Eu(function(t2, e2, i2) {
        const n2 = i2[i2.length - 1], r2 = n2.layout, s2 = n2.stride;
        let o2;
        "XY" == r2 || "XYM" == r2 ? o2 = 2 : "XYZ" == r2 || "XYZM" == r2 ? o2 = 3 : at(false, 34);
        const a2 = e2.length;
        let l2 = "";
        if (a2 > 0) {
          l2 += e2[0];
          for (let t3 = 1; t3 < o2; ++t3)
            l2 += "," + e2[t3];
          for (let t3 = s2; t3 < a2; t3 += s2) {
            l2 += " " + e2[t3];
            for (let i3 = 1; i3 < o2; ++i3)
              l2 += "," + e2[t3 + i3];
          }
        }
        K_(t2, l2);
      }) });
      function Mv(t2, e2, i2) {
        const n2 = e2.getFlatCoordinates(), r2 = { node: t2 };
        r2.layout = e2.getLayout(), r2.stride = e2.getStride();
        const s2 = e2.getProperties();
        s2.coordinates = n2;
        const o2 = i2[i2.length - 1].node, a2 = Iv[o2.namespaceURI], l2 = Ru(s2, a2);
        Fu(r2, Lv, bu, l2, i2, a2);
      }
      const Fv = Pu(Xy, ["color", "fill", "outline"]), Av = Pu(Xy, { outerBoundaryIs: Eu(Tv), innerBoundaryIs: Eu(Tv) }), Ov = Cu("innerBoundaryIs"), Nv = Cu("outerBoundaryIs");
      function Dv(t2, e2, i2) {
        const n2 = e2.getLinearRings(), r2 = n2.shift(), s2 = { node: t2 };
        Fu(s2, Av, Ov, n2, i2), Fu(s2, Av, Nv, [r2], i2);
      }
      const kv = Pu(Xy, { color: Eu(ev), fill: Eu(X_), outline: Eu(X_) });
      function Gv(t2, e2) {
        Z_(t2, Math.round(1e6 * e2) / 1e6);
      }
      const jv = Pu(Xy, ["IconStyle", "LabelStyle", "LineStyle", "PolyStyle"]), Bv = Pu(Xy, { IconStyle: Eu(function(t2, e2, i2) {
        const n2 = { node: t2 }, r2 = {}, s2 = e2.getSrc(), o2 = e2.getSize(), a2 = e2.getImageSize(), l2 = { href: s2 };
        if (o2) {
          l2.w = o2[0], l2.h = o2[1];
          const t3 = e2.getAnchor(), i3 = e2.getOrigin();
          if (i3 && a2 && 0 !== i3[0] && i3[1] !== o2[1] && (l2.x = i3[0], l2.y = a2[1] - (i3[1] + o2[1])), t3 && (t3[0] !== o2[0] / 2 || t3[1] !== o2[1] / 2)) {
            const e3 = { x: t3[0], xunits: "pixels", y: o2[1] - t3[1], yunits: "pixels" };
            r2.hotSpot = e3;
          }
        }
        r2.Icon = l2;
        let h2 = e2.getScaleArray()[0], c2 = o2;
        if (null === c2 && (c2 = ex), 2 == c2.length) {
          h2 /= dx(c2);
        }
        1 !== h2 && (r2.scale = h2);
        const u2 = e2.getRotation();
        0 !== u2 && (r2.heading = u2);
        const d2 = e2.getColor();
        d2 && (r2.color = d2);
        const g2 = i2[i2.length - 1].node, f2 = hv[g2.namespaceURI], p2 = Ru(r2, f2);
        Fu(n2, cv, bu, p2, i2, f2);
      }), LabelStyle: Eu(function(t2, e2, i2) {
        const n2 = { node: t2 }, r2 = {}, s2 = e2.getFill();
        s2 && (r2.color = s2.getColor());
        const o2 = e2.getScale();
        o2 && 1 !== o2 && (r2.scale = o2);
        const a2 = i2[i2.length - 1].node, l2 = uv[a2.namespaceURI], h2 = Ru(r2, l2);
        Fu(n2, dv, bu, h2, i2, l2);
      }), LineStyle: Eu(function(t2, e2, i2) {
        const n2 = { node: t2 }, r2 = { color: e2.getColor(), width: Number(e2.getWidth()) || 1 }, s2 = i2[i2.length - 1].node, o2 = gv[s2.namespaceURI], a2 = Ru(r2, o2);
        Fu(n2, fv, bu, a2, i2, o2);
      }), PolyStyle: Eu(function(t2, e2, i2) {
        const n2 = { node: t2 }, r2 = e2.getFill(), s2 = e2.getStroke(), o2 = { color: r2 ? r2.getColor() : void 0, fill: !!r2 && void 0, outline: !!s2 && void 0 }, a2 = i2[i2.length - 1].node, l2 = Fv[a2.namespaceURI], h2 = Ru(o2, l2);
        Fu(n2, kv, bu, h2, i2, l2);
      }) });
      const Uv = [null], zv = Pu(Uv, { nd: function(t2, e2) {
        e2[e2.length - 1].ndrefs.push(t2.getAttribute("ref"));
      }, tag: Wv }), Xv = Pu(Uv, { node: function(t2, e2) {
        const i2 = e2[0], n2 = e2[e2.length - 1], r2 = t2.getAttribute("id"), s2 = [parseFloat(t2.getAttribute("lon")), parseFloat(t2.getAttribute("lat"))];
        n2.nodes[r2] = s2;
        const o2 = Lu({ tags: {} }, Vv, t2, e2);
        if (!x(o2.tags)) {
          const t3 = new Wn(s2);
          Qp(t3, false, i2);
          const e3 = new lt(t3);
          void 0 !== r2 && e3.setId(r2), e3.setProperties(o2.tags, true), n2.features.push(e3);
        }
      }, way: function(t2, e2) {
        const i2 = Lu({ id: t2.getAttribute("id"), ndrefs: [], tags: {} }, zv, t2, e2);
        e2[e2.length - 1].ways.push(i2);
      } });
      const Vv = Pu(Uv, { tag: Wv });
      function Wv(t2, e2) {
        e2[e2.length - 1].tags[t2.getAttribute("k")] = t2.getAttribute("v");
      }
      class Zv {
        read(t2) {
          if (t2) {
            if ("string" == typeof t2) {
              const e2 = _u(t2);
              return this.readFromDocument(e2);
            }
            return pu(t2) ? this.readFromDocument(t2) : this.readFromNode(t2);
          }
          return null;
        }
        readFromDocument(t2) {
          for (let e2 = t2.firstChild; e2; e2 = e2.nextSibling)
            if (e2.nodeType == Node.ELEMENT_NODE)
              return this.readFromNode(e2);
          return null;
        }
        readFromNode(t2) {
        }
      }
      function Yv(t2) {
        return t2.getAttributeNS("http://www.w3.org/1999/xlink", "href");
      }
      const Kv = [null, "http://www.opengis.net/ows/1.1"], qv = Pu(Kv, { ServiceIdentification: wu(function(t2, e2) {
        return Lu({}, lS, t2, e2);
      }), ServiceProvider: wu(function(t2, e2) {
        return Lu({}, hS, t2, e2);
      }), OperationsMetadata: wu(function(t2, e2) {
        return Lu({}, rS, t2, e2);
      }) });
      class Hv extends Zv {
        constructor() {
          super();
        }
        readFromNode(t2) {
          const e2 = Lu({}, qv, t2, []);
          return e2 || null;
        }
      }
      const $v = Pu(Kv, { DeliveryPoint: wu(z_), City: wu(z_), AdministrativeArea: wu(z_), PostalCode: wu(z_), Country: wu(z_), ElectronicMailAddress: wu(z_) }), Jv = Pu(Kv, { Value: Su(function(t2, e2) {
        return z_(t2);
      }) }), Qv = Pu(Kv, { AllowedValues: wu(function(t2, e2) {
        return Lu({}, Jv, t2, e2);
      }) }), tS = Pu(Kv, { Phone: wu(function(t2, e2) {
        return Lu({}, sS, t2, e2);
      }), Address: wu(function(t2, e2) {
        return Lu({}, $v, t2, e2);
      }) }), eS = Pu(Kv, { HTTP: wu(function(t2, e2) {
        return Lu({}, iS, t2, e2);
      }) }), iS = Pu(Kv, { Get: Su(function(t2, e2) {
        const i2 = Yv(t2);
        if (!i2)
          return;
        return Lu({ href: i2 }, oS, t2, e2);
      }), Post: void 0 }), nS = Pu(Kv, { DCP: wu(function(t2, e2) {
        return Lu({}, eS, t2, e2);
      }) }), rS = Pu(Kv, { Operation: function(t2, e2) {
        const i2 = t2.getAttribute("name"), n2 = Lu({}, nS, t2, e2);
        if (!n2)
          return;
        e2[e2.length - 1][i2] = n2;
      } }), sS = Pu(Kv, { Voice: wu(z_), Facsimile: wu(z_) }), oS = Pu(Kv, { Constraint: Su(function(t2, e2) {
        const i2 = t2.getAttribute("name");
        if (!i2)
          return;
        return Lu({ name: i2 }, Qv, t2, e2);
      }) }), aS = Pu(Kv, { IndividualName: wu(z_), PositionName: wu(z_), ContactInfo: wu(function(t2, e2) {
        return Lu({}, tS, t2, e2);
      }) }), lS = Pu(Kv, { Abstract: wu(z_), AccessConstraints: wu(z_), Fees: wu(z_), Title: wu(z_), ServiceTypeVersion: wu(z_), ServiceType: wu(z_) }), hS = Pu(Kv, { ProviderName: wu(z_), ProviderSite: wu(Yv), ServiceContact: wu(function(t2, e2) {
        return Lu({}, aS, t2, e2);
      }) });
      function cS(t2, e2, i2) {
        let n2;
        i2 = i2 || 1e5;
        const r2 = new Array(e2);
        for (n2 = 0; n2 < e2; ++n2)
          r2[n2] = 0;
        for (let i3 = 0, s2 = t2.length; i3 < s2; )
          for (n2 = 0; n2 < e2; ++n2, ++i3) {
            const e3 = t2[i3], s3 = e3 - r2[n2];
            r2[n2] = e3, t2[i3] = s3;
          }
        return dS(t2, i2);
      }
      function uS(t2, e2, i2) {
        let n2;
        i2 = i2 || 1e5;
        const r2 = new Array(e2);
        for (n2 = 0; n2 < e2; ++n2)
          r2[n2] = 0;
        const s2 = gS(t2, i2);
        for (let t3 = 0, i3 = s2.length; t3 < i3; )
          for (n2 = 0; n2 < e2; ++n2, ++t3)
            r2[n2] += s2[t3], s2[t3] = r2[n2];
        return s2;
      }
      function dS(t2, e2) {
        e2 = e2 || 1e5;
        for (let i2 = 0, n2 = t2.length; i2 < n2; ++i2)
          t2[i2] = Math.round(t2[i2] * e2);
        return fS(t2);
      }
      function gS(t2, e2) {
        e2 = e2 || 1e5;
        const i2 = pS(t2);
        for (let t3 = 0, n2 = i2.length; t3 < n2; ++t3)
          i2[t3] /= e2;
        return i2;
      }
      function fS(t2) {
        for (let e2 = 0, i2 = t2.length; e2 < i2; ++e2) {
          const i3 = t2[e2];
          t2[e2] = i3 < 0 ? ~(i3 << 1) : i3 << 1;
        }
        return mS(t2);
      }
      function pS(t2) {
        const e2 = _S(t2);
        for (let t3 = 0, i2 = e2.length; t3 < i2; ++t3) {
          const i3 = e2[t3];
          e2[t3] = 1 & i3 ? ~(i3 >> 1) : i3 >> 1;
        }
        return e2;
      }
      function mS(t2) {
        let e2 = "";
        for (let i2 = 0, n2 = t2.length; i2 < n2; ++i2)
          e2 += yS(t2[i2]);
        return e2;
      }
      function _S(t2) {
        const e2 = [];
        let i2 = 0, n2 = 0;
        for (let r2 = 0, s2 = t2.length; r2 < s2; ++r2) {
          const s3 = t2.charCodeAt(r2) - 63;
          i2 |= (31 & s3) << n2, s3 < 32 ? (e2.push(i2), i2 = 0, n2 = 0) : n2 += 5;
        }
        return e2;
      }
      function yS(t2) {
        let e2, i2 = "";
        for (; t2 >= 32; )
          e2 = 63 + (32 | 31 & t2), i2 += String.fromCharCode(e2), t2 >>= 5;
        return e2 = t2 + 63, i2 += String.fromCharCode(e2), i2;
      }
      const xS = { Point: function(t2, e2, i2) {
        const n2 = t2.coordinates;
        e2 && i2 && TS(n2, e2, i2);
        return new Wn(n2);
      }, LineString: function(t2, e2) {
        const i2 = vS(t2.arcs, e2);
        return new Op(i2);
      }, Polygon: function(t2, e2) {
        const i2 = [];
        for (let n2 = 0, r2 = t2.arcs.length; n2 < r2; ++n2)
          i2[n2] = vS(t2.arcs[n2], e2);
        return new ur(i2);
      }, MultiPoint: function(t2, e2, i2) {
        const n2 = t2.coordinates;
        if (e2 && i2)
          for (let t3 = 0, r2 = n2.length; t3 < r2; ++t3)
            TS(n2[t3], e2, i2);
        return new Dp(n2);
      }, MultiLineString: function(t2, e2) {
        const i2 = [];
        for (let n2 = 0, r2 = t2.arcs.length; n2 < r2; ++n2)
          i2[n2] = vS(t2.arcs[n2], e2);
        return new Np(i2);
      }, MultiPolygon: function(t2, e2) {
        const i2 = [];
        for (let n2 = 0, r2 = t2.arcs.length; n2 < r2; ++n2) {
          const r3 = t2.arcs[n2], s2 = [];
          for (let t3 = 0, i3 = r3.length; t3 < i3; ++t3)
            s2[t3] = vS(r3[t3], e2);
          i2[n2] = s2;
        }
        return new Gp(i2);
      } };
      function vS(t2, e2) {
        const i2 = [];
        let n2;
        for (let r2 = 0, s2 = t2.length; r2 < s2; ++r2)
          if (n2 = t2[r2], r2 > 0 && i2.pop(), n2 >= 0) {
            const t3 = e2[n2];
            for (let e3 = 0, n3 = t3.length; e3 < n3; ++e3)
              i2.push(t3[e3].slice(0));
          } else {
            const t3 = e2[~n2];
            for (let e3 = t3.length - 1; e3 >= 0; --e3)
              i2.push(t3[e3].slice(0));
          }
        return i2;
      }
      function SS(t2, e2, i2, n2, r2, s2, o2) {
        const a2 = t2.geometries, l2 = [];
        for (let t3 = 0, h2 = a2.length; t3 < h2; ++t3)
          l2[t3] = wS(a2[t3], e2, i2, n2, r2, s2, o2);
        return l2;
      }
      function wS(t2, e2, i2, n2, r2, s2, o2) {
        let a2 = null;
        const l2 = t2.type;
        if (l2) {
          const r3 = xS[l2];
          a2 = "Point" === l2 || "MultiPoint" === l2 ? r3(t2, i2, n2) : r3(t2, e2), a2 = Qp(a2, false, o2);
        }
        const h2 = new lt({ geometry: a2 });
        void 0 !== t2.id && h2.setId(t2.id);
        let c2 = t2.properties;
        return r2 && (c2 || (c2 = {}), c2[r2] = s2), c2 && h2.setProperties(c2, true), h2;
      }
      function ES(t2, e2, i2) {
        let n2 = 0, r2 = 0;
        for (let s2 = 0, o2 = t2.length; s2 < o2; ++s2) {
          const o3 = t2[s2];
          n2 += o3[0], r2 += o3[1], o3[0] = n2, o3[1] = r2, TS(o3, e2, i2);
        }
      }
      function TS(t2, e2, i2) {
        t2[0] = t2[0] * e2[0] + i2[0], t2[1] = t2[1] * e2[1] + i2[1];
      }
      class CS {
        constructor(t2) {
          this.tagName_ = t2;
        }
        getTagName() {
          return this.tagName_;
        }
      }
      class bS extends CS {
        constructor(t2, e2) {
          super(t2), this.conditions = e2, at(this.conditions.length >= 2, 57);
        }
      }
      class RS extends bS {
        constructor(t2) {
          super("And", Array.prototype.slice.call(arguments));
        }
      }
      class PS extends CS {
        constructor(t2, e2, i2) {
          if (super("BBOX"), this.geometryName = t2, this.extent = e2, 4 !== e2.length)
            throw new Error("Expected an extent with four values ([minX, minY, maxX, maxY])");
          this.srsName = i2;
        }
      }
      class IS extends CS {
        constructor(t2, e2, i2, n2) {
          super(t2), this.geometryName = e2 || "the_geom", this.geometry = i2, this.srsName = n2;
        }
      }
      class LS extends IS {
        constructor(t2, e2, i2) {
          super("Contains", t2, e2, i2);
        }
      }
      class MS extends IS {
        constructor(t2, e2, i2, n2, r2) {
          super("DWithin", t2, e2, r2), this.distance = i2, this.unit = n2;
        }
      }
      class FS extends IS {
        constructor(t2, e2, i2) {
          super("Disjoint", t2, e2, i2);
        }
      }
      class AS extends CS {
        constructor(t2, e2) {
          super(t2), this.propertyName = e2;
        }
      }
      class OS extends AS {
        constructor(t2, e2, i2) {
          super("During", t2), this.begin = e2, this.end = i2;
        }
      }
      class NS extends AS {
        constructor(t2, e2, i2, n2) {
          super(t2, e2), this.expression = i2, this.matchCase = n2;
        }
      }
      class DS extends NS {
        constructor(t2, e2, i2) {
          super("PropertyIsEqualTo", t2, e2, i2);
        }
      }
      class kS extends NS {
        constructor(t2, e2) {
          super("PropertyIsGreaterThan", t2, e2);
        }
      }
      class GS extends NS {
        constructor(t2, e2) {
          super("PropertyIsGreaterThanOrEqualTo", t2, e2);
        }
      }
      class jS extends IS {
        constructor(t2, e2, i2) {
          super("Intersects", t2, e2, i2);
        }
      }
      class BS extends AS {
        constructor(t2, e2, i2) {
          super("PropertyIsBetween", t2), this.lowerBoundary = e2, this.upperBoundary = i2;
        }
      }
      class US extends AS {
        constructor(t2, e2, i2, n2, r2, s2) {
          super("PropertyIsLike", t2), this.pattern = e2, this.wildCard = void 0 !== i2 ? i2 : "*", this.singleChar = void 0 !== n2 ? n2 : ".", this.escapeChar = void 0 !== r2 ? r2 : "!", this.matchCase = s2;
        }
      }
      class zS extends AS {
        constructor(t2) {
          super("PropertyIsNull", t2);
        }
      }
      class XS extends NS {
        constructor(t2, e2) {
          super("PropertyIsLessThan", t2, e2);
        }
      }
      class VS extends NS {
        constructor(t2, e2) {
          super("PropertyIsLessThanOrEqualTo", t2, e2);
        }
      }
      class WS extends CS {
        constructor(t2) {
          super("Not"), this.condition = t2;
        }
      }
      class ZS extends NS {
        constructor(t2, e2, i2) {
          super("PropertyIsNotEqualTo", t2, e2, i2);
        }
      }
      class YS extends bS {
        constructor(t2) {
          super("Or", Array.prototype.slice.call(arguments));
        }
      }
      class KS extends CS {
        constructor(t2) {
          super("ResourceId"), this.rid = t2;
        }
      }
      class qS extends IS {
        constructor(t2, e2, i2) {
          super("Within", t2, e2, i2);
        }
      }
      function HS(t2) {
        const e2 = [null].concat(Array.prototype.slice.call(arguments));
        return new (Function.prototype.bind.apply(RS, e2))();
      }
      function $S(t2, e2, i2) {
        return new PS(t2, e2, i2);
      }
      const JS = { "http://www.opengis.net/gml": { boundedBy: wu(O_.prototype.readExtentElement, "bounds") }, "http://www.opengis.net/wfs/2.0": { member: xu(O_.prototype.readFeaturesInternal) } }, QS = { "http://www.opengis.net/wfs": { totalInserted: wu(B_), totalUpdated: wu(B_), totalDeleted: wu(B_) }, "http://www.opengis.net/wfs/2.0": { totalInserted: wu(B_), totalUpdated: wu(B_), totalDeleted: wu(B_) } }, tw = { "http://www.opengis.net/wfs": { TransactionSummary: wu(uw, "transactionSummary"), InsertResults: wu(pw, "insertIds") }, "http://www.opengis.net/wfs/2.0": { TransactionSummary: wu(uw, "transactionSummary"), InsertResults: wu(pw, "insertIds") } }, ew = { "http://www.opengis.net/wfs": { PropertyName: Eu(K_) }, "http://www.opengis.net/wfs/2.0": { PropertyName: Eu(K_) } }, iw = { "http://www.opengis.net/wfs": { Insert: Eu(mw), Update: Eu(vw), Delete: Eu(xw), Property: Eu(Sw), Native: Eu(ww) }, "http://www.opengis.net/wfs/2.0": { Insert: Eu(mw), Update: Eu(vw), Delete: Eu(xw), Property: Eu(Sw), Native: Eu(ww) } }, nw = "feature", rw = "http://www.w3.org/2000/xmlns/", sw = { "2.0.0": "http://www.opengis.net/ogc/1.1", "1.1.0": "http://www.opengis.net/ogc", "1.0.0": "http://www.opengis.net/ogc" }, ow = { "2.0.0": "http://www.opengis.net/wfs/2.0", "1.1.0": "http://www.opengis.net/wfs", "1.0.0": "http://www.opengis.net/wfs" }, aw = { "2.0.0": "http://www.opengis.net/fes/2.0", "1.1.0": "http://www.opengis.net/fes", "1.0.0": "http://www.opengis.net/fes" }, lw = { "2.0.0": "http://www.opengis.net/wfs/2.0 http://schemas.opengis.net/wfs/2.0/wfs.xsd", "1.1.0": "http://www.opengis.net/wfs http://schemas.opengis.net/wfs/1.1.0/wfs.xsd", "1.0.0": "http://www.opengis.net/wfs http://schemas.opengis.net/wfs/1.0.0/wfs.xsd" }, hw = { "2.0.0": ty, "1.1.0": J_, "1.0.0": H_ };
      function cw(t2, e2, i2, n2) {
        Fu(n2, iw, Cu(t2), e2, i2);
      }
      function uw(t2, e2) {
        return Lu({}, QS, t2, e2);
      }
      const dw = { "http://www.opengis.net/ogc": { FeatureId: xu(function(t2, e2) {
        return t2.getAttribute("fid");
      }) }, "http://www.opengis.net/ogc/1.1": { FeatureId: xu(function(t2, e2) {
        return t2.getAttribute("fid");
      }) } };
      function gw(t2, e2) {
        Iu(dw, t2, e2);
      }
      const fw = { "http://www.opengis.net/wfs": { Feature: gw }, "http://www.opengis.net/wfs/2.0": { Feature: gw } };
      function pw(t2, e2) {
        return Lu([], fw, t2, e2);
      }
      function mw(t2, e2, i2) {
        const n2 = i2[i2.length - 1], r2 = n2.featureType, s2 = n2.featureNS, o2 = n2.gmlVersion, a2 = du(s2, r2);
        t2.appendChild(a2), 2 === o2 ? H_.prototype.writeFeatureElement(a2, e2, i2) : 3 === o2 ? J_.prototype.writeFeatureElement(a2, e2, i2) : ty.prototype.writeFeatureElement(a2, e2, i2);
      }
      function _w(t2, e2, i2) {
        const n2 = i2[i2.length - 1].version, r2 = sw[n2], s2 = du(r2, "Filter"), o2 = du(r2, "FeatureId");
        s2.appendChild(o2), o2.setAttribute("fid", e2), t2.appendChild(s2);
      }
      function yw(t2, e2) {
        const i2 = (t2 = t2 || nw) + ":";
        return e2.startsWith(i2) ? e2 : i2 + e2;
      }
      function xw(t2, e2, i2) {
        const n2 = i2[i2.length - 1];
        at(void 0 !== e2.getId(), 26);
        const r2 = n2.featureType, s2 = n2.featurePrefix, o2 = n2.featureNS, a2 = yw(s2, r2);
        t2.setAttribute("typeName", a2), t2.setAttributeNS(rw, "xmlns:" + s2, o2);
        const l2 = e2.getId();
        void 0 !== l2 && _w(t2, l2, i2);
      }
      function vw(t2, e2, i2) {
        const n2 = i2[i2.length - 1];
        at(void 0 !== e2.getId(), 27);
        const r2 = n2.version, s2 = n2.featureType, o2 = n2.featurePrefix, a2 = n2.featureNS, l2 = yw(o2, s2), h2 = e2.getGeometryName();
        t2.setAttribute("typeName", l2), t2.setAttributeNS(rw, "xmlns:" + o2, a2);
        const c2 = e2.getId();
        if (void 0 !== c2) {
          const s3 = e2.getKeys(), o3 = [];
          for (let t3 = 0, i3 = s3.length; t3 < i3; t3++) {
            const i4 = e2.get(s3[t3]);
            if (void 0 !== i4) {
              let e3 = s3[t3];
              i4 && "function" == typeof i4.getSimplifiedGeometry && (e3 = h2), o3.push({ name: e3, value: i4 });
            }
          }
          Fu({ version: r2, gmlVersion: n2.gmlVersion, node: t2, hasZ: n2.hasZ, srsName: n2.srsName }, iw, Cu("Property"), o3, i2), _w(t2, c2, i2);
        }
      }
      function Sw(t2, e2, i2) {
        const n2 = i2[i2.length - 1], r2 = n2.version, s2 = ow[r2], o2 = du(s2, "Name"), a2 = n2.gmlVersion;
        if (t2.appendChild(o2), K_(o2, e2.name), void 0 !== e2.value && null !== e2.value) {
          const n3 = du(s2, "Value");
          t2.appendChild(n3), e2.value && "function" == typeof e2.value.getSimplifiedGeometry ? 2 === a2 ? H_.prototype.writeGeometryElement(n3, e2.value, i2) : 3 === a2 ? J_.prototype.writeGeometryElement(n3, e2.value, i2) : ty.prototype.writeGeometryElement(n3, e2.value, i2) : K_(n3, e2.value);
        }
      }
      function ww(t2, e2, i2) {
        e2.vendorId && t2.setAttribute("vendorId", e2.vendorId), void 0 !== e2.safeToIgnore && t2.setAttribute("safeToIgnore", String(e2.safeToIgnore)), void 0 !== e2.value && K_(t2, e2.value);
      }
      const Ew = { "http://www.opengis.net/wfs": { Query: Eu(Tw) }, "http://www.opengis.net/wfs/2.0": { Query: Eu(Tw) }, "http://www.opengis.net/ogc": { During: Eu(Iw), And: Eu(Lw), Or: Eu(Lw), Not: Eu(Mw), BBOX: Eu(bw), Contains: Eu(Rw), Intersects: Eu(Rw), Within: Eu(Rw), DWithin: Eu(Pw), PropertyIsEqualTo: Eu(Fw), PropertyIsNotEqualTo: Eu(Fw), PropertyIsLessThan: Eu(Fw), PropertyIsLessThanOrEqualTo: Eu(Fw), PropertyIsGreaterThan: Eu(Fw), PropertyIsGreaterThanOrEqualTo: Eu(Fw), PropertyIsNull: Eu(Aw), PropertyIsBetween: Eu(Ow), PropertyIsLike: Eu(Nw) }, "http://www.opengis.net/fes/2.0": { During: Eu(Iw), And: Eu(Lw), Or: Eu(Lw), Not: Eu(Mw), BBOX: Eu(bw), Contains: Eu(Rw), Disjoint: Eu(Rw), Intersects: Eu(Rw), ResourceId: Eu(function(t2, e2, i2) {
        t2.setAttribute("rid", e2.rid);
      }), Within: Eu(Rw), DWithin: Eu(Pw), PropertyIsEqualTo: Eu(Fw), PropertyIsNotEqualTo: Eu(Fw), PropertyIsLessThan: Eu(Fw), PropertyIsLessThanOrEqualTo: Eu(Fw), PropertyIsGreaterThan: Eu(Fw), PropertyIsGreaterThanOrEqualTo: Eu(Fw), PropertyIsNull: Eu(Aw), PropertyIsBetween: Eu(Ow), PropertyIsLike: Eu(Nw) } };
      function Tw(t2, e2, i2) {
        const n2 = i2[i2.length - 1], r2 = n2.version, s2 = n2.featurePrefix, o2 = n2.featureNS, a2 = n2.propertyNames, l2 = n2.srsName;
        let h2, c2;
        h2 = s2 ? yw(s2, e2) : e2, c2 = "2.0.0" === r2 ? "typeNames" : "typeName", t2.setAttribute(c2, h2), l2 && t2.setAttribute("srsName", l2), o2 && t2.setAttributeNS(rw, "xmlns:" + s2, o2);
        const u2 = Object.assign({}, n2);
        u2.node = t2, Fu(u2, ew, Cu("PropertyName"), a2, i2);
        const d2 = n2.filter;
        if (d2) {
          const e3 = du(Uw(r2), "Filter");
          t2.appendChild(e3), Cw(e3, d2, i2);
        }
      }
      function Cw(t2, e2, i2) {
        const n2 = i2[i2.length - 1], r2 = { node: t2 };
        Object.assign(r2, { context: n2 }), Fu(r2, Ew, Cu(e2.getTagName()), [e2], i2);
      }
      function bw(t2, e2, i2) {
        const n2 = i2[i2.length - 1], r2 = n2.context.version;
        n2.srsName = e2.srsName;
        const s2 = hw[r2];
        Gw(r2, t2, e2.geometryName), s2.prototype.writeGeometryElement(t2, e2.extent, i2);
      }
      function Rw(t2, e2, i2) {
        const n2 = i2[i2.length - 1], r2 = n2.context.version;
        n2.srsName = e2.srsName;
        const s2 = hw[r2];
        Gw(r2, t2, e2.geometryName), s2.prototype.writeGeometryElement(t2, e2.geometry, i2);
      }
      function Pw(t2, e2, i2) {
        const n2 = i2[i2.length - 1].context.version;
        Rw(t2, e2, i2);
        const r2 = du(Uw(n2), "Distance");
        K_(r2, e2.distance.toString()), "2.0.0" === n2 ? r2.setAttribute("uom", e2.unit) : r2.setAttribute("units", e2.unit), t2.appendChild(r2);
      }
      function Iw(t2, e2, i2) {
        const n2 = i2[i2.length - 1].context.version;
        Dw(aw[n2], "ValueReference", t2, e2.propertyName);
        const r2 = du(F_, "TimePeriod");
        t2.appendChild(r2);
        const s2 = du(F_, "begin");
        r2.appendChild(s2), jw(s2, e2.begin);
        const o2 = du(F_, "end");
        r2.appendChild(o2), jw(o2, e2.end);
      }
      function Lw(t2, e2, i2) {
        const n2 = i2[i2.length - 1].context, r2 = { node: t2 };
        Object.assign(r2, { context: n2 });
        const s2 = e2.conditions;
        for (let t3 = 0, e3 = s2.length; t3 < e3; ++t3) {
          const e4 = s2[t3];
          Fu(r2, Ew, Cu(e4.getTagName()), [e4], i2);
        }
      }
      function Mw(t2, e2, i2) {
        const n2 = i2[i2.length - 1].context, r2 = { node: t2 };
        Object.assign(r2, { context: n2 });
        const s2 = e2.condition;
        Fu(r2, Ew, Cu(s2.getTagName()), [s2], i2);
      }
      function Fw(t2, e2, i2) {
        const n2 = i2[i2.length - 1].context.version;
        void 0 !== e2.matchCase && t2.setAttribute("matchCase", e2.matchCase.toString()), Gw(n2, t2, e2.propertyName), kw(n2, t2, "" + e2.expression);
      }
      function Aw(t2, e2, i2) {
        Gw(i2[i2.length - 1].context.version, t2, e2.propertyName);
      }
      function Ow(t2, e2, i2) {
        const n2 = i2[i2.length - 1].context.version, r2 = Uw(n2);
        Gw(n2, t2, e2.propertyName);
        const s2 = du(r2, "LowerBoundary");
        t2.appendChild(s2), kw(n2, s2, "" + e2.lowerBoundary);
        const o2 = du(r2, "UpperBoundary");
        t2.appendChild(o2), kw(n2, o2, "" + e2.upperBoundary);
      }
      function Nw(t2, e2, i2) {
        const n2 = i2[i2.length - 1].context.version;
        t2.setAttribute("wildCard", e2.wildCard), t2.setAttribute("singleChar", e2.singleChar), t2.setAttribute("escapeChar", e2.escapeChar), void 0 !== e2.matchCase && t2.setAttribute("matchCase", e2.matchCase.toString()), Gw(n2, t2, e2.propertyName), kw(n2, t2, "" + e2.pattern);
      }
      function Dw(t2, e2, i2, n2) {
        const r2 = du(t2, e2);
        K_(r2, n2), i2.appendChild(r2);
      }
      function kw(t2, e2, i2) {
        Dw(Uw(t2), "Literal", e2, i2);
      }
      function Gw(t2, e2, i2) {
        "2.0.0" === t2 ? Dw(aw[t2], "ValueReference", e2, i2) : Dw(sw[t2], "PropertyName", e2, i2);
      }
      function jw(t2, e2) {
        const i2 = du(F_, "TimeInstant");
        t2.appendChild(i2);
        const n2 = du(F_, "timePosition");
        i2.appendChild(n2), K_(n2, e2);
      }
      function Bw(t2, e2, i2) {
        const n2 = i2[i2.length - 1], r2 = Object.assign({}, n2);
        r2.node = t2, Fu(r2, Ew, Cu("Query"), e2, i2);
      }
      function Uw(t2) {
        let e2;
        return e2 = "2.0.0" === t2 ? aw[t2] : sw[t2], e2;
      }
      const zw = 1, Xw = 2, Vw = 3, Ww = 4, Zw = 5, Yw = 6, Kw = 7, qw = 15, Hw = 16, $w = 17;
      class Jw {
        constructor(t2) {
          this.view_ = t2, this.pos_ = 0, this.initialized_ = false, this.isLittleEndian_ = false, this.hasZ_ = false, this.hasM_ = false, this.srid_ = null, this.layout_ = "XY";
        }
        readUint8() {
          return this.view_.getUint8(this.pos_++);
        }
        readUint32(t2) {
          return this.view_.getUint32((this.pos_ += 4) - 4, void 0 !== t2 ? t2 : this.isLittleEndian_);
        }
        readDouble(t2) {
          return this.view_.getFloat64((this.pos_ += 8) - 8, void 0 !== t2 ? t2 : this.isLittleEndian_);
        }
        readPoint() {
          const t2 = [];
          return t2.push(this.readDouble()), t2.push(this.readDouble()), this.hasZ_ && t2.push(this.readDouble()), this.hasM_ && t2.push(this.readDouble()), t2;
        }
        readLineString() {
          const t2 = this.readUint32(), e2 = [];
          for (let i2 = 0; i2 < t2; i2++)
            e2.push(this.readPoint());
          return e2;
        }
        readPolygon() {
          const t2 = this.readUint32(), e2 = [];
          for (let i2 = 0; i2 < t2; i2++)
            e2.push(this.readLineString());
          return e2;
        }
        readWkbHeader(t2) {
          const e2 = this.readUint8() > 0, i2 = this.readUint32(e2), n2 = Math.floor((268435455 & i2) / 1e3), r2 = Boolean(2147483648 & i2) || 1 === n2 || 3 === n2, s2 = Boolean(1073741824 & i2) || 2 === n2 || 3 === n2, o2 = Boolean(536870912 & i2), a2 = (268435455 & i2) % 1e3, l2 = ["XY", r2 ? "Z" : "", s2 ? "M" : ""].join(""), h2 = o2 ? this.readUint32(e2) : null;
          if (void 0 !== t2 && t2 !== a2)
            throw new Error("Unexpected WKB geometry type " + a2);
          if (this.initialized_) {
            if (this.isLittleEndian_ !== e2)
              throw new Error("Inconsistent endian");
            if (this.layout_ !== l2)
              throw new Error("Inconsistent geometry layout");
            if (h2 && this.srid_ !== h2)
              throw new Error("Inconsistent coordinate system (SRID)");
          } else
            this.isLittleEndian_ = e2, this.hasZ_ = r2, this.hasM_ = s2, this.layout_ = l2, this.srid_ = h2, this.initialized_ = true;
          return a2;
        }
        readWkbPayload(t2) {
          switch (t2) {
            case zw:
              return this.readPoint();
            case Xw:
              return this.readLineString();
            case Vw:
            case $w:
              return this.readPolygon();
            case Ww:
              return this.readMultiPoint();
            case Zw:
              return this.readMultiLineString();
            case Yw:
            case qw:
            case Hw:
              return this.readMultiPolygon();
            case Kw:
              return this.readGeometryCollection();
            default:
              throw new Error("Unsupported WKB geometry type " + t2 + " is found");
          }
        }
        readWkbBlock(t2) {
          return this.readWkbPayload(this.readWkbHeader(t2));
        }
        readWkbCollection(t2, e2) {
          const i2 = this.readUint32(), n2 = [];
          for (let r2 = 0; r2 < i2; r2++) {
            const i3 = t2.call(this, e2);
            i3 && n2.push(i3);
          }
          return n2;
        }
        readMultiPoint() {
          return this.readWkbCollection(this.readWkbBlock, zw);
        }
        readMultiLineString() {
          return this.readWkbCollection(this.readWkbBlock, Xw);
        }
        readMultiPolygon() {
          return this.readWkbCollection(this.readWkbBlock, Vw);
        }
        readGeometryCollection() {
          return this.readWkbCollection(this.readGeometry);
        }
        readGeometry() {
          const t2 = this.readWkbHeader(), e2 = this.readWkbPayload(t2);
          switch (t2) {
            case zw:
              return new Wn(e2, this.layout_);
            case Xw:
              return new Op(e2, this.layout_);
            case Vw:
            case $w:
              return new ur(e2, this.layout_);
            case Ww:
              return new Dp(e2, this.layout_);
            case Zw:
              return new Np(e2, this.layout_);
            case Yw:
            case qw:
            case Hw:
              return new Gp(e2, this.layout_);
            case Kw:
              return new Ip(e2);
            default:
              return null;
          }
        }
        getSrid() {
          return this.srid_;
        }
      }
      class Qw {
        constructor(t2) {
          t2 = t2 || {}, this.layout_ = t2.layout, this.isLittleEndian_ = false !== t2.littleEndian, this.isEWKB_ = false !== t2.ewkb, this.writeQueue_ = [], this.nodata_ = Object.assign({ X: 0, Y: 0, Z: 0, M: 0 }, t2.nodata);
        }
        writeUint8(t2) {
          this.writeQueue_.push([1, t2]);
        }
        writeUint32(t2) {
          this.writeQueue_.push([4, t2]);
        }
        writeDouble(t2) {
          this.writeQueue_.push([8, t2]);
        }
        writePoint(t2, e2) {
          const i2 = Object.assign.apply(null, e2.split("").map((e3, i3) => ({ [e3]: t2[i3] })));
          for (const t3 of this.layout_)
            this.writeDouble(t3 in i2 ? i2[t3] : this.nodata_[t3]);
        }
        writeLineString(t2, e2) {
          this.writeUint32(t2.length);
          for (let i2 = 0; i2 < t2.length; i2++)
            this.writePoint(t2[i2], e2);
        }
        writePolygon(t2, e2) {
          this.writeUint32(t2.length);
          for (let i2 = 0; i2 < t2.length; i2++)
            this.writeLineString(t2[i2], e2);
        }
        writeWkbHeader(t2, e2) {
          t2 %= 1e3, this.layout_.includes("Z") && (t2 += this.isEWKB_ ? 2147483648 : 1e3), this.layout_.includes("M") && (t2 += this.isEWKB_ ? 1073741824 : 2e3), this.isEWKB_ && Number.isInteger(e2) && (t2 |= 536870912), this.writeUint8(this.isLittleEndian_ ? 1 : 0), this.writeUint32(t2), this.isEWKB_ && Number.isInteger(e2) && this.writeUint32(e2);
        }
        writeMultiPoint(t2, e2) {
          this.writeUint32(t2.length);
          for (let i2 = 0; i2 < t2.length; i2++)
            this.writeWkbHeader(1), this.writePoint(t2[i2], e2);
        }
        writeMultiLineString(t2, e2) {
          this.writeUint32(t2.length);
          for (let i2 = 0; i2 < t2.length; i2++)
            this.writeWkbHeader(2), this.writeLineString(t2[i2], e2);
        }
        writeMultiPolygon(t2, e2) {
          this.writeUint32(t2.length);
          for (let i2 = 0; i2 < t2.length; i2++)
            this.writeWkbHeader(3), this.writePolygon(t2[i2], e2);
        }
        writeGeometryCollection(t2) {
          this.writeUint32(t2.length);
          for (let e2 = 0; e2 < t2.length; e2++)
            this.writeGeometry(t2[e2]);
        }
        findMinimumLayout(t2, e2 = "XYZM") {
          if (t2 instanceof _n)
            return (i2 = t2.getLayout()) === (n2 = e2) ? i2 : "XYZM" === i2 ? n2 : "XYZM" === n2 ? i2 : "XY";
          var i2, n2;
          if (t2 instanceof Ip) {
            const i3 = t2.getGeometriesArray();
            for (let t3 = 0; t3 < i3.length && "XY" !== e2; t3++)
              e2 = this.findMinimumLayout(i3[t3], e2);
          }
          return e2;
        }
        writeGeometry(t2, e2) {
          const i2 = { Point: zw, LineString: Xw, Polygon: Vw, MultiPoint: Ww, MultiLineString: Zw, MultiPolygon: Yw, GeometryCollection: Kw }, n2 = t2.getType(), r2 = i2[n2];
          if (!r2)
            throw new Error("GeometryType " + n2 + " is not supported");
          if (this.layout_ || (this.layout_ = this.findMinimumLayout(t2)), this.writeWkbHeader(r2, e2), t2 instanceof _n) {
            ({ Point: this.writePoint, LineString: this.writeLineString, Polygon: this.writePolygon, MultiPoint: this.writeMultiPoint, MultiLineString: this.writeMultiLineString, MultiPolygon: this.writeMultiPolygon })[n2].call(this, t2.getCoordinates(), t2.getLayout());
          } else
            t2 instanceof Ip && this.writeGeometryCollection(t2.getGeometriesArray());
        }
        getBuffer() {
          const t2 = this.writeQueue_.reduce((t3, e3) => t3 + e3[0], 0), e2 = new ArrayBuffer(t2), i2 = new DataView(e2);
          let n2 = 0;
          return this.writeQueue_.forEach((t3) => {
            switch (t3[0]) {
              case 1:
                i2.setUint8(n2, t3[1]);
                break;
              case 4:
                i2.setUint32(n2, t3[1], this.isLittleEndian_);
                break;
              case 8:
                i2.setFloat64(n2, t3[1], this.isLittleEndian_);
            }
            n2 += t3[0];
          }), e2;
        }
      }
      function tE(t2) {
        return "string" == typeof t2 ? function(t3) {
          const e2 = new Uint8Array(t3.length / 2);
          for (let i2 = 0; i2 < t3.length / 2; i2++)
            e2[i2] = parseInt(t3.substr(2 * i2, 2), 16);
          return new DataView(e2.buffer);
        }(t2) : ArrayBuffer.isView(t2) ? t2 instanceof DataView ? t2 : new DataView(t2.buffer, t2.byteOffset, t2.byteLength) : t2 instanceof ArrayBuffer ? new DataView(t2) : null;
      }
      const eE = { POINT: Wn, LINESTRING: Op, POLYGON: ur, MULTIPOINT: Dp, MULTILINESTRING: Np, MULTIPOLYGON: Gp }, iE = "EMPTY", nE = 0, rE = 1, sE = 2, oE = 3, aE = 4, lE = 5, hE = 6, cE = { Point: "POINT", LineString: "LINESTRING", Polygon: "POLYGON", MultiPoint: "MULTIPOINT", MultiLineString: "MULTILINESTRING", MultiPolygon: "MULTIPOLYGON", GeometryCollection: "GEOMETRYCOLLECTION", Circle: "CIRCLE" };
      class uE {
        constructor(t2) {
          this.wkt = t2, this.index_ = -1;
        }
        isAlpha_(t2) {
          return t2 >= "a" && t2 <= "z" || t2 >= "A" && t2 <= "Z";
        }
        isNumeric_(t2, e2) {
          return e2 = void 0 !== e2 && e2, t2 >= "0" && t2 <= "9" || "." == t2 && !e2;
        }
        isWhiteSpace_(t2) {
          return " " == t2 || "	" == t2 || "\r" == t2 || "\n" == t2;
        }
        nextChar_() {
          return this.wkt.charAt(++this.index_);
        }
        nextToken() {
          const t2 = this.nextChar_(), e2 = this.index_;
          let i2, n2 = t2;
          if ("(" == t2)
            i2 = sE;
          else if ("," == t2)
            i2 = lE;
          else if (")" == t2)
            i2 = oE;
          else if (this.isNumeric_(t2) || "-" == t2)
            i2 = aE, n2 = this.readNumber_();
          else if (this.isAlpha_(t2))
            i2 = rE, n2 = this.readText_();
          else {
            if (this.isWhiteSpace_(t2))
              return this.nextToken();
            if ("" !== t2)
              throw new Error("Unexpected character: " + t2);
            i2 = hE;
          }
          return { position: e2, value: n2, type: i2 };
        }
        readNumber_() {
          let t2;
          const e2 = this.index_;
          let i2 = false, n2 = false;
          do {
            "." == t2 ? i2 = true : "e" != t2 && "E" != t2 || (n2 = true), t2 = this.nextChar_();
          } while (this.isNumeric_(t2, i2) || !n2 && ("e" == t2 || "E" == t2) || n2 && ("-" == t2 || "+" == t2));
          return parseFloat(this.wkt.substring(e2, this.index_--));
        }
        readText_() {
          let t2;
          const e2 = this.index_;
          do {
            t2 = this.nextChar_();
          } while (this.isAlpha_(t2));
          return this.wkt.substring(e2, this.index_--).toUpperCase();
        }
      }
      class dE {
        constructor(t2) {
          this.lexer_ = t2, this.token_ = { position: 0, type: nE }, this.layout_ = "XY";
        }
        consume_() {
          this.token_ = this.lexer_.nextToken();
        }
        isTokenType(t2) {
          return this.token_.type == t2;
        }
        match(t2) {
          const e2 = this.isTokenType(t2);
          return e2 && this.consume_(), e2;
        }
        parse() {
          return this.consume_(), this.parseGeometry_();
        }
        parseGeometryLayout_() {
          let t2 = "XY";
          const e2 = this.token_;
          if (this.isTokenType(rE)) {
            const i2 = e2.value;
            "Z" === i2 ? t2 = "XYZ" : "M" === i2 ? t2 = "XYM" : "ZM" === i2 && (t2 = "XYZM"), "XY" !== t2 && this.consume_();
          }
          return t2;
        }
        parseGeometryCollectionText_() {
          if (this.match(sE)) {
            const t2 = [];
            do {
              t2.push(this.parseGeometry_());
            } while (this.match(lE));
            if (this.match(oE))
              return t2;
          }
          throw new Error(this.formatErrorMessage_());
        }
        parsePointText_() {
          if (this.match(sE)) {
            const t2 = this.parsePoint_();
            if (this.match(oE))
              return t2;
          }
          throw new Error(this.formatErrorMessage_());
        }
        parseLineStringText_() {
          if (this.match(sE)) {
            const t2 = this.parsePointList_();
            if (this.match(oE))
              return t2;
          }
          throw new Error(this.formatErrorMessage_());
        }
        parsePolygonText_() {
          if (this.match(sE)) {
            const t2 = this.parseLineStringTextList_();
            if (this.match(oE))
              return t2;
          }
          throw new Error(this.formatErrorMessage_());
        }
        parseMultiPointText_() {
          if (this.match(sE)) {
            let t2;
            if (t2 = this.token_.type == sE ? this.parsePointTextList_() : this.parsePointList_(), this.match(oE))
              return t2;
          }
          throw new Error(this.formatErrorMessage_());
        }
        parseMultiLineStringText_() {
          if (this.match(sE)) {
            const t2 = this.parseLineStringTextList_();
            if (this.match(oE))
              return t2;
          }
          throw new Error(this.formatErrorMessage_());
        }
        parseMultiPolygonText_() {
          if (this.match(sE)) {
            const t2 = this.parsePolygonTextList_();
            if (this.match(oE))
              return t2;
          }
          throw new Error(this.formatErrorMessage_());
        }
        parsePoint_() {
          const t2 = [], e2 = this.layout_.length;
          for (let i2 = 0; i2 < e2; ++i2) {
            const e3 = this.token_;
            if (!this.match(aE))
              break;
            t2.push(e3.value);
          }
          if (t2.length == e2)
            return t2;
          throw new Error(this.formatErrorMessage_());
        }
        parsePointList_() {
          const t2 = [this.parsePoint_()];
          for (; this.match(lE); )
            t2.push(this.parsePoint_());
          return t2;
        }
        parsePointTextList_() {
          const t2 = [this.parsePointText_()];
          for (; this.match(lE); )
            t2.push(this.parsePointText_());
          return t2;
        }
        parseLineStringTextList_() {
          const t2 = [this.parseLineStringText_()];
          for (; this.match(lE); )
            t2.push(this.parseLineStringText_());
          return t2;
        }
        parsePolygonTextList_() {
          const t2 = [this.parsePolygonText_()];
          for (; this.match(lE); )
            t2.push(this.parsePolygonText_());
          return t2;
        }
        isEmptyGeometry_() {
          const t2 = this.isTokenType(rE) && this.token_.value == iE;
          return t2 && this.consume_(), t2;
        }
        formatErrorMessage_() {
          return "Unexpected `" + this.token_.value + "` at position " + this.token_.position + " in `" + this.lexer_.wkt + "`";
        }
        parseGeometry_() {
          const t2 = this.token_;
          if (this.match(rE)) {
            const e2 = t2.value;
            this.layout_ = this.parseGeometryLayout_();
            const i2 = this.isEmptyGeometry_();
            if ("GEOMETRYCOLLECTION" == e2) {
              if (i2)
                return new Ip([]);
              const t3 = this.parseGeometryCollectionText_();
              return new Ip(t3);
            }
            {
              const t3 = eE[e2];
              if (!t3)
                throw new Error("Invalid geometry type: " + e2);
              let n2;
              if (i2)
                n2 = "POINT" == e2 ? [NaN, NaN] : [];
              else
                switch (e2) {
                  case "POINT":
                    n2 = this.parsePointText_();
                    break;
                  case "LINESTRING":
                    n2 = this.parseLineStringText_();
                    break;
                  case "POLYGON":
                    n2 = this.parsePolygonText_();
                    break;
                  case "MULTIPOINT":
                    n2 = this.parseMultiPointText_();
                    break;
                  case "MULTILINESTRING":
                    n2 = this.parseMultiLineStringText_();
                    break;
                  case "MULTIPOLYGON":
                    n2 = this.parseMultiPolygonText_();
                }
              return new t3(n2, this.layout_);
            }
          }
          throw new Error(this.formatErrorMessage_());
        }
      }
      function gE(t2) {
        const e2 = t2.getCoordinates();
        return 0 === e2.length ? "" : e2.join(" ");
      }
      function fE(t2) {
        const e2 = t2.getCoordinates(), i2 = [];
        for (let t3 = 0, n2 = e2.length; t3 < n2; ++t3)
          i2.push(e2[t3].join(" "));
        return i2.join(",");
      }
      function pE(t2) {
        const e2 = [], i2 = t2.getLinearRings();
        for (let t3 = 0, n2 = i2.length; t3 < n2; ++t3)
          e2.push("(" + fE(i2[t3]) + ")");
        return e2.join(",");
      }
      const mE = { Point: gE, LineString: fE, Polygon: pE, MultiPoint: function(t2) {
        const e2 = [], i2 = t2.getPoints();
        for (let t3 = 0, n2 = i2.length; t3 < n2; ++t3)
          e2.push("(" + gE(i2[t3]) + ")");
        return e2.join(",");
      }, MultiLineString: function(t2) {
        const e2 = [], i2 = t2.getLineStrings();
        for (let t3 = 0, n2 = i2.length; t3 < n2; ++t3)
          e2.push("(" + fE(i2[t3]) + ")");
        return e2.join(",");
      }, MultiPolygon: function(t2) {
        const e2 = [], i2 = t2.getPolygons();
        for (let t3 = 0, n2 = i2.length; t3 < n2; ++t3)
          e2.push("(" + pE(i2[t3]) + ")");
        return e2.join(",");
      }, GeometryCollection: function(t2) {
        const e2 = [], i2 = t2.getGeometries();
        for (let t3 = 0, n2 = i2.length; t3 < n2; ++t3)
          e2.push(_E(i2[t3]));
        return e2.join(",");
      } };
      function _E(t2) {
        const e2 = t2.getType(), i2 = (0, mE[e2])(t2);
        let n2 = cE[e2];
        if ("function" == typeof t2.getFlatCoordinates) {
          const e3 = function(t3) {
            const e4 = t3.getLayout();
            let i3 = "";
            return "XYZ" !== e4 && "XYZM" !== e4 || (i3 += "Z"), "XYM" !== e4 && "XYZM" !== e4 || (i3 += "M"), i3;
          }(t2);
          e3.length > 0 && (n2 += " " + e3);
        }
        return 0 === i2.length ? n2 + " " + iE : n2 + "(" + i2 + ")";
      }
      const yE = [null, "http://www.opengis.net/wms"], xE = Pu(yE, { Service: wu(function(t2, e2) {
        return Lu({}, SE, t2, e2);
      }), Capability: wu(function(t2, e2) {
        return Lu({}, vE, t2, e2);
      }) }), vE = Pu(yE, { Request: wu(function(t2, e2) {
        return Lu({}, IE, t2, e2);
      }), Exception: wu(function(t2, e2) {
        return Lu([], CE, t2, e2);
      }), Layer: wu(function(t2, e2) {
        const i2 = Lu({}, bE, t2, e2);
        if (void 0 === i2.Layer)
          return Object.assign(i2, DE(t2, e2));
        return i2;
      }) });
      const SE = Pu(yE, { Name: wu(z_), Title: wu(z_), Abstract: wu(z_), KeywordList: wu(BE), OnlineResource: wu(Yv), ContactInformation: wu(function(t2, e2) {
        return Lu({}, wE, t2, e2);
      }), Fees: wu(z_), AccessConstraints: wu(z_), LayerLimit: wu(B_), MaxWidth: wu(B_), MaxHeight: wu(B_) }), wE = Pu(yE, { ContactPersonPrimary: wu(function(t2, e2) {
        return Lu({}, EE, t2, e2);
      }), ContactPosition: wu(z_), ContactAddress: wu(function(t2, e2) {
        return Lu({}, TE, t2, e2);
      }), ContactVoiceTelephone: wu(z_), ContactFacsimileTelephone: wu(z_), ContactElectronicMailAddress: wu(z_) }), EE = Pu(yE, { ContactPerson: wu(z_), ContactOrganization: wu(z_) }), TE = Pu(yE, { AddressType: wu(z_), Address: wu(z_), City: wu(z_), StateOrProvince: wu(z_), PostCode: wu(z_), Country: wu(z_) }), CE = Pu(yE, { Format: xu(z_) }), bE = Pu(yE, { Name: wu(z_), Title: wu(z_), Abstract: wu(z_), KeywordList: wu(BE), CRS: Su(z_), EX_GeographicBoundingBox: wu(function(t2, e2) {
        const i2 = Lu({}, PE, t2, e2);
        if (!i2)
          return;
        const n2 = i2.westBoundLongitude, r2 = i2.southBoundLatitude, s2 = i2.eastBoundLongitude, o2 = i2.northBoundLatitude;
        if (void 0 === n2 || void 0 === r2 || void 0 === s2 || void 0 === o2)
          return;
        return [n2, r2, s2, o2];
      }), BoundingBox: Su(function(t2, e2) {
        const i2 = [j_(t2.getAttribute("minx")), j_(t2.getAttribute("miny")), j_(t2.getAttribute("maxx")), j_(t2.getAttribute("maxy"))], n2 = [j_(t2.getAttribute("resx")), j_(t2.getAttribute("resy"))];
        return { crs: t2.getAttribute("CRS"), extent: i2, res: n2 };
      }), Dimension: Su(function(t2, e2) {
        return { name: t2.getAttribute("name"), units: t2.getAttribute("units"), unitSymbol: t2.getAttribute("unitSymbol"), default: t2.getAttribute("default"), multipleValues: D_(t2.getAttribute("multipleValues")), nearestValue: D_(t2.getAttribute("nearestValue")), current: D_(t2.getAttribute("current")), values: z_(t2) };
      }), Attribution: wu(function(t2, e2) {
        return Lu({}, RE, t2, e2);
      }), AuthorityURL: Su(function(t2, e2) {
        const i2 = kE(t2, e2);
        if (i2)
          return i2.name = t2.getAttribute("name"), i2;
        return;
      }), Identifier: Su(z_), MetadataURL: Su(function(t2, e2) {
        const i2 = kE(t2, e2);
        if (i2)
          return i2.type = t2.getAttribute("type"), i2;
        return;
      }), DataURL: Su(kE), FeatureListURL: Su(kE), Style: Su(function(t2, e2) {
        return Lu({}, AE, t2, e2);
      }), MinScaleDenominator: wu(G_), MaxScaleDenominator: wu(G_), Layer: Su(DE) }), RE = Pu(yE, { Title: wu(z_), OnlineResource: wu(Yv), LogoURL: wu(jE) }), PE = Pu(yE, { westBoundLongitude: wu(G_), eastBoundLongitude: wu(G_), southBoundLatitude: wu(G_), northBoundLatitude: wu(G_) }), IE = Pu(yE, { GetCapabilities: wu(GE), GetMap: wu(GE), GetFeatureInfo: wu(GE) }), LE = Pu(yE, { Format: Su(z_), DCPType: Su(function(t2, e2) {
        return Lu({}, ME, t2, e2);
      }) }), ME = Pu(yE, { HTTP: wu(function(t2, e2) {
        return Lu({}, FE, t2, e2);
      }) }), FE = Pu(yE, { Get: wu(kE), Post: wu(kE) }), AE = Pu(yE, { Name: wu(z_), Title: wu(z_), Abstract: wu(z_), LegendURL: Su(jE), StyleSheetURL: wu(kE), StyleURL: wu(kE) }), OE = Pu(yE, { Format: wu(z_), OnlineResource: wu(Yv) }), NE = Pu(yE, { Keyword: xu(z_) });
      function DE(t2, e2) {
        const i2 = e2[e2.length - 1], n2 = Lu({}, bE, t2, e2);
        if (!n2)
          return;
        let r2 = D_(t2.getAttribute("queryable"));
        void 0 === r2 && (r2 = i2.queryable), n2.queryable = void 0 !== r2 && r2;
        let s2 = U_(t2.getAttribute("cascaded"));
        void 0 === s2 && (s2 = i2.cascaded), n2.cascaded = s2;
        let o2 = D_(t2.getAttribute("opaque"));
        void 0 === o2 && (o2 = i2.opaque), n2.opaque = void 0 !== o2 && o2;
        let a2 = D_(t2.getAttribute("noSubsets"));
        void 0 === a2 && (a2 = i2.noSubsets), n2.noSubsets = void 0 !== a2 && a2;
        let l2 = j_(t2.getAttribute("fixedWidth"));
        l2 || (l2 = i2.fixedWidth), n2.fixedWidth = l2;
        let h2 = j_(t2.getAttribute("fixedHeight"));
        h2 || (h2 = i2.fixedHeight), n2.fixedHeight = h2;
        ["Style", "CRS", "AuthorityURL"].forEach(function(t3) {
          if (t3 in i2) {
            const e3 = n2[t3] || [];
            n2[t3] = e3.concat(i2[t3]);
          }
        });
        return ["EX_GeographicBoundingBox", "BoundingBox", "Dimension", "Attribution", "MinScaleDenominator", "MaxScaleDenominator"].forEach(function(t3) {
          if (!(t3 in n2)) {
            const e3 = i2[t3];
            n2[t3] = e3;
          }
        }), n2;
      }
      function kE(t2, e2) {
        return Lu({}, OE, t2, e2);
      }
      function GE(t2, e2) {
        return Lu({}, LE, t2, e2);
      }
      function jE(t2, e2) {
        const i2 = kE(t2, e2);
        if (i2) {
          const e3 = [U_(t2.getAttribute("width")), U_(t2.getAttribute("height"))];
          return i2.size = e3, i2;
        }
      }
      function BE(t2, e2) {
        return Lu([], NE, t2, e2);
      }
      const UE = [null, "http://www.opengis.net/wmts/1.0"], zE = [null, "http://www.opengis.net/ows/1.1"], XE = Pu(UE, { Contents: wu(function(t2, e2) {
        return Lu({}, VE, t2, e2);
      }) });
      const VE = Pu(UE, { Layer: Su(function(t2, e2) {
        return Lu({}, WE, t2, e2);
      }), TileMatrixSet: Su(function(t2, e2) {
        return Lu({}, JE, t2, e2);
      }) }), WE = Pu(UE, { Style: Su(function(t2, e2) {
        const i2 = Lu({}, ZE, t2, e2);
        if (!i2)
          return;
        const n2 = "true" === t2.getAttribute("isDefault");
        return i2.isDefault = n2, i2;
      }), Format: Su(z_), TileMatrixSetLink: Su(function(t2, e2) {
        return Lu({}, YE, t2, e2);
      }), Dimension: Su(function(t2, e2) {
        return Lu({}, HE, t2, e2);
      }), ResourceURL: Su(function(t2, e2) {
        const i2 = t2.getAttribute("format"), n2 = t2.getAttribute("template"), r2 = t2.getAttribute("resourceType"), s2 = {};
        i2 && (s2.format = i2);
        n2 && (s2.template = n2);
        r2 && (s2.resourceType = r2);
        return s2;
      }) }, Pu(zE, { Title: wu(z_), Abstract: wu(z_), WGS84BoundingBox: wu(tT), Identifier: wu(z_) })), ZE = Pu(UE, { LegendURL: Su(function(t2, e2) {
        const i2 = {};
        return i2.format = t2.getAttribute("format"), i2.href = Yv(t2), i2;
      }) }, Pu(zE, { Title: wu(z_), Identifier: wu(z_) })), YE = Pu(UE, { TileMatrixSet: wu(z_), TileMatrixSetLimits: wu(function(t2, e2) {
        return Lu([], KE, t2, e2);
      }) }), KE = Pu(UE, { TileMatrixLimits: xu(function(t2, e2) {
        return Lu({}, qE, t2, e2);
      }) }), qE = Pu(UE, { TileMatrix: wu(z_), MinTileRow: wu(B_), MaxTileRow: wu(B_), MinTileCol: wu(B_), MaxTileCol: wu(B_) }), HE = Pu(UE, { Default: wu(z_), Value: Su(z_) }, Pu(zE, { Identifier: wu(z_) })), $E = Pu(zE, { LowerCorner: xu(eT), UpperCorner: xu(eT) }), JE = Pu(UE, { WellKnownScaleSet: wu(z_), TileMatrix: Su(function(t2, e2) {
        return Lu({}, QE, t2, e2);
      }) }, Pu(zE, { SupportedCRS: wu(z_), Identifier: wu(z_), BoundingBox: wu(tT) })), QE = Pu(UE, { TopLeftCorner: wu(eT), ScaleDenominator: wu(G_), TileWidth: wu(B_), TileHeight: wu(B_), MatrixWidth: wu(B_), MatrixHeight: wu(B_) }, Pu(zE, { Identifier: wu(z_) }));
      function tT(t2, e2) {
        const i2 = Lu([], $E, t2, e2);
        if (2 == i2.length)
          return zt(i2);
      }
      function eT(t2, e2) {
        const i2 = z_(t2).split(/\s+/);
        if (!i2 || 2 != i2.length)
          return;
        const n2 = +i2[0], r2 = +i2[1];
        return isNaN(n2) || isNaN(r2) ? void 0 : [n2, r2];
      }
      const iT = ["fullscreenchange", "webkitfullscreenchange", "MSFullscreenChange"], nT = "enterfullscreen", rT = "leavefullscreen";
      function sT(t2) {
        const e2 = t2.body;
        return !!(e2.webkitRequestFullscreen || e2.requestFullscreen && t2.fullscreenEnabled);
      }
      function oT(t2) {
        return !(!t2.webkitIsFullScreen && !t2.fullscreenElement);
      }
      function aT(t2) {
        t2.requestFullscreen ? t2.requestFullscreen() : t2.webkitRequestFullscreen && t2.webkitRequestFullscreen();
      }
      const lT = "projection", hT = "coordinateFormat";
      const cT = 0.75, uT = 0.1;
      const dT = "units", gT = [1, 2, 5], fT = 25.4 / 0.28;
      const pT = 0, mT = 1;
      var _T = {};
      return _T.AssertionError = e, _T.Collection = q, _T.Collection.CollectionEvent = K, _T.DataTile = ot, _T.Disposable = s, _T.Feature = lt, _T.Feature.createStyleFunction = ht, _T.Geolocation = class extends V {
        constructor(t2) {
          super(), this.on, this.once, this.un, t2 = t2 || {}, this.position_ = null, this.transform_ = Gi, this.watchId_ = void 0, this.addChangeListener(wr, this.handleProjectionChanged_), this.addChangeListener(Tr, this.handleTrackingChanged_), void 0 !== t2.projection && this.setProjection(t2.projection), void 0 !== t2.trackingOptions && this.setTrackingOptions(t2.trackingOptions), this.setTracking(void 0 !== t2.tracking && t2.tracking);
        }
        disposeInternal() {
          this.setTracking(false), super.disposeInternal();
        }
        handleProjectionChanged_() {
          const t2 = this.getProjection();
          t2 && (this.transform_ = qi(Ui("EPSG:4326"), t2), this.position_ && this.set(Sr, this.transform_(this.position_)));
        }
        handleTrackingChanged_() {
          if ("geolocation" in navigator) {
            const t2 = this.getTracking();
            t2 && void 0 === this.watchId_ ? this.watchId_ = navigator.geolocation.watchPosition(this.positionChange_.bind(this), this.positionError_.bind(this), this.getTrackingOptions()) : t2 || void 0 === this.watchId_ || (navigator.geolocation.clearWatch(this.watchId_), this.watchId_ = void 0);
          }
        }
        positionChange_(t2) {
          const e2 = t2.coords;
          this.set(mr, e2.accuracy), this.set(yr, null === e2.altitude ? void 0 : e2.altitude), this.set(xr, null === e2.altitudeAccuracy ? void 0 : e2.altitudeAccuracy), this.set(vr, null === e2.heading ? void 0 : ai(e2.heading)), this.position_ ? (this.position_[0] = e2.longitude, this.position_[1] = e2.latitude) : this.position_ = [e2.longitude, e2.latitude];
          const i2 = this.transform_(this.position_);
          this.set(Sr, i2), this.set(Er, null === e2.speed ? void 0 : e2.speed);
          const n2 = dr(this.position_, e2.accuracy);
          n2.applyTransform(this.transform_), this.set(_r, n2), this.changed();
        }
        positionError_(t2) {
          this.dispatchEvent(new br(t2));
        }
        getAccuracy() {
          return this.get(mr);
        }
        getAccuracyGeometry() {
          return this.get(_r) || null;
        }
        getAltitude() {
          return this.get(yr);
        }
        getAltitudeAccuracy() {
          return this.get(xr);
        }
        getHeading() {
          return this.get(vr);
        }
        getPosition() {
          return this.get(Sr);
        }
        getProjection() {
          return this.get(wr);
        }
        getSpeed() {
          return this.get(Er);
        }
        getTracking() {
          return this.get(Tr);
        }
        getTrackingOptions() {
          return this.get(Cr);
        }
        setProjection(t2) {
          this.set(wr, Ui(t2));
        }
        setTracking(t2) {
          this.set(Tr, t2);
        }
        setTrackingOptions(t2) {
          this.set(Cr, t2);
        }
      }, _T.Image = Ar, _T.Image.listenImage = Or, _T.ImageBase = Rr, _T.ImageCanvas = Nr, _T.ImageTile = Vr, _T.Kinetic = Wr, _T.Map = Ya, _T.MapBrowserEvent = oo, _T.MapBrowserEventHandler = go, _T.MapEvent = so, _T.Object = V, _T.Object.ObjectEvent = X, _T.Observable = G, _T.Observable.unByKey = j, _T.Overlay = Qa, _T.Tile = st, _T.TileCache = ll, _T.TileQueue = Co, _T.TileQueue.getTilePriority = bo, _T.TileRange = hl, _T.TileRange.createOrUpdate = cl, _T.VectorRenderTile = dl, _T.VectorTile = gl, _T.View = zo, _T.View.createCenterConstraint = Vo, _T.View.createResolutionConstraint = Wo, _T.View.createRotationConstraint = Zo, _T.View.isNoopAnimation = Yo, _T.array = {}, _T.array.binarySearch = o, _T.array.equals = u, _T.array.extend = c, _T.array.isSorted = d, _T.array.linearFindNearest = l, _T.array.numberSafeCompareFunction = a, _T.array.remove = function(t2, e2) {
        const i2 = t2.indexOf(e2), n2 = i2 > -1;
        return n2 && t2.splice(i2, 1), n2;
      }, _T.array.reverseSubArray = h, _T.array.stableSort = function(t2, e2) {
        const i2 = t2.length, n2 = Array(t2.length);
        let r2;
        for (r2 = 0; r2 < i2; r2++)
          n2[r2] = { index: r2, value: t2[r2] };
        for (n2.sort(function(t3, i3) {
          return e2(t3.value, i3.value) || t3.index - i3.index;
        }), r2 = 0; r2 < t2.length; r2++)
          t2[r2] = n2[r2].value;
      }, _T.asserts = {}, _T.asserts.assert = at, _T.centerconstraint = {}, _T.centerconstraint.createExtent = Mo, _T.centerconstraint.none = Fo, _T.color = {}, _T.color.asArray = $r, _T.color.asString = Kr, _T.color.fromString = Hr, _T.color.isStringColor = ts, _T.color.normalize = Jr, _T.color.toString = Qr, _T.colorlike = {}, _T.colorlike.asColorLike = fl, _T.control = {}, _T.control.Attribution = Ho, _T.control.Control = qo, _T.control.FullScreen = class extends qo {
        constructor(t2) {
          t2 = t2 || {}, super({ element: document.createElement("div"), target: t2.target }), this.on, this.once, this.un, this.keys_ = void 0 !== t2.keys && t2.keys, this.source_ = t2.source, this.isInFullscreen_ = false, this.boundHandleMapTargetChange_ = this.handleMapTargetChange_.bind(this), this.cssClassName_ = void 0 !== t2.className ? t2.className : "ol-full-screen", this.documentListeners_ = [], this.activeClassName_ = void 0 !== t2.activeClassName ? t2.activeClassName.split(" ") : [this.cssClassName_ + "-true"], this.inactiveClassName_ = void 0 !== t2.inactiveClassName ? t2.inactiveClassName.split(" ") : [this.cssClassName_ + "-false"];
          const e2 = void 0 !== t2.label ? t2.label : "\u2922";
          this.labelNode_ = "string" == typeof e2 ? document.createTextNode(e2) : e2;
          const i2 = void 0 !== t2.labelActive ? t2.labelActive : "\xD7";
          this.labelActiveNode_ = "string" == typeof i2 ? document.createTextNode(i2) : i2;
          const n2 = t2.tipLabel ? t2.tipLabel : "Toggle full-screen";
          this.button_ = document.createElement("button"), this.button_.title = n2, this.button_.setAttribute("type", "button"), this.button_.appendChild(this.labelNode_), this.button_.addEventListener(T, this.handleClick_.bind(this), false), this.setClassName_(this.button_, this.isInFullscreen_), this.element.className = `${this.cssClassName_} ol-unselectable ol-control`, this.element.appendChild(this.button_);
        }
        handleClick_(t2) {
          t2.preventDefault(), this.handleFullScreen_();
        }
        handleFullScreen_() {
          const t2 = this.getMap();
          if (!t2)
            return;
          const e2 = t2.getOwnerDocument();
          if (sT(e2))
            if (oT(e2))
              !function(t3) {
                t3.exitFullscreen ? t3.exitFullscreen() : t3.webkitExitFullscreen && t3.webkitExitFullscreen();
              }(e2);
            else {
              let i2;
              i2 = this.source_ ? "string" == typeof this.source_ ? e2.getElementById(this.source_) : this.source_ : t2.getTargetElement(), this.keys_ ? function(t3) {
                t3.webkitRequestFullscreen ? t3.webkitRequestFullscreen() : aT(t3);
              }(i2) : aT(i2);
            }
        }
        handleFullScreenChange_() {
          const t2 = this.getMap();
          if (!t2)
            return;
          const e2 = this.isInFullscreen_;
          this.isInFullscreen_ = oT(t2.getOwnerDocument()), e2 !== this.isInFullscreen_ && (this.setClassName_(this.button_, this.isInFullscreen_), this.isInFullscreen_ ? (Br(this.labelActiveNode_, this.labelNode_), this.dispatchEvent(nT)) : (Br(this.labelNode_, this.labelActiveNode_), this.dispatchEvent(rT)), t2.updateSize());
        }
        setClassName_(t2, e2) {
          e2 ? (t2.classList.remove(...this.inactiveClassName_), t2.classList.add(...this.activeClassName_)) : (t2.classList.remove(...this.activeClassName_), t2.classList.add(...this.inactiveClassName_));
        }
        setMap(t2) {
          const e2 = this.getMap();
          e2 && e2.removeChangeListener(So, this.boundHandleMapTargetChange_), super.setMap(t2), this.handleMapTargetChange_(), t2 && t2.addChangeListener(So, this.boundHandleMapTargetChange_);
        }
        handleMapTargetChange_() {
          const t2 = this.documentListeners_;
          for (let e3 = 0, i2 = t2.length; e3 < i2; ++e3)
            k(t2[e3]);
          t2.length = 0;
          const e2 = this.getMap();
          if (e2) {
            const i2 = e2.getOwnerDocument();
            sT(i2) ? this.element.classList.remove(Ps) : this.element.classList.add(Ps);
            for (let e3 = 0, n2 = iT.length; e3 < n2; ++e3)
              t2.push(N(i2, iT[e3], this.handleFullScreenChange_, this));
            this.handleFullScreenChange_();
          }
        }
      }, _T.control.MousePosition = class extends qo {
        constructor(t2) {
          t2 = t2 || {};
          const e2 = document.createElement("div");
          e2.className = void 0 !== t2.className ? t2.className : "ol-mouse-position", super({ element: e2, render: t2.render, target: t2.target }), this.on, this.once, this.un, this.addChangeListener(lT, this.handleProjectionChanged_), t2.coordinateFormat && this.setCoordinateFormat(t2.coordinateFormat), t2.projection && this.setProjection(t2.projection), this.renderOnMouseOut_ = void 0 !== t2.placeholder, this.placeholder_ = this.renderOnMouseOut_ ? t2.placeholder : "&#160;", this.renderedHTML_ = e2.innerHTML, this.mapProjection_ = null, this.transform_ = null;
        }
        handleProjectionChanged_() {
          this.transform_ = null;
        }
        getCoordinateFormat() {
          return this.get(hT);
        }
        getProjection() {
          return this.get(lT);
        }
        handleMouseMove(t2) {
          const e2 = this.getMap();
          this.updateHTML_(e2.getEventPixel(t2));
        }
        handleMouseOut(t2) {
          this.updateHTML_(null);
        }
        setMap(t2) {
          if (super.setMap(t2), t2) {
            const e2 = t2.getViewport();
            this.listenerKeys.push(N(e2, lo, this.handleMouseMove, this)), this.renderOnMouseOut_ && this.listenerKeys.push(N(e2, uo, this.handleMouseOut, this)), this.updateHTML_(null);
          }
        }
        setCoordinateFormat(t2) {
          this.set(hT, t2);
        }
        setProjection(t2) {
          this.set(lT, Ui(t2));
        }
        updateHTML_(t2) {
          let e2 = this.placeholder_;
          if (t2 && this.mapProjection_) {
            if (!this.transform_) {
              const t3 = this.getProjection();
              this.transform_ = t3 ? qi(this.mapProjection_, t3) : Gi;
            }
            const i2 = this.getMap().getCoordinateFromPixelInternal(t2);
            if (i2) {
              const t3 = en();
              t3 && (this.transform_ = qi(this.mapProjection_, t3)), this.transform_(i2, i2);
              const n2 = this.getCoordinateFormat();
              e2 = n2 ? n2(i2) : i2.toString();
            }
          }
          this.renderedHTML_ && e2 === this.renderedHTML_ || (this.element.innerHTML = e2, this.renderedHTML_ = e2);
        }
        render(t2) {
          const e2 = t2.frameState;
          e2 ? this.mapProjection_ != e2.viewState.projection && (this.mapProjection_ = e2.viewState.projection, this.transform_ = null) : this.mapProjection_ = null;
        }
      }, _T.control.OverviewMap = class extends qo {
        constructor(t2) {
          t2 = t2 || {}, super({ element: document.createElement("div"), render: t2.render, target: t2.target }), this.boundHandleRotationChanged_ = this.handleRotationChanged_.bind(this), this.collapsed_ = void 0 === t2.collapsed || t2.collapsed, this.collapsible_ = void 0 === t2.collapsible || t2.collapsible, this.collapsible_ || (this.collapsed_ = false), this.rotateWithView_ = void 0 !== t2.rotateWithView && t2.rotateWithView, this.viewExtent_ = void 0;
          const e2 = void 0 !== t2.className ? t2.className : "ol-overviewmap", i2 = void 0 !== t2.tipLabel ? t2.tipLabel : "Overview map", n2 = void 0 !== t2.collapseLabel ? t2.collapseLabel : "\u2039";
          "string" == typeof n2 ? (this.collapseLabel_ = document.createElement("span"), this.collapseLabel_.textContent = n2) : this.collapseLabel_ = n2;
          const r2 = void 0 !== t2.label ? t2.label : "\u203A";
          "string" == typeof r2 ? (this.label_ = document.createElement("span"), this.label_.textContent = r2) : this.label_ = r2;
          const s2 = this.collapsible_ && !this.collapsed_ ? this.collapseLabel_ : this.label_, o2 = document.createElement("button");
          o2.setAttribute("type", "button"), o2.title = i2, o2.appendChild(s2), o2.addEventListener(T, this.handleClick_.bind(this), false), this.ovmapDiv_ = document.createElement("div"), this.ovmapDiv_.className = "ol-overviewmap-map", this.view_ = t2.view;
          const a2 = new Ya({ view: t2.view, controls: new q(), interactions: new q() });
          this.ovmap_ = a2, t2.layers && t2.layers.forEach(function(t3) {
            a2.addLayer(t3);
          });
          const l2 = document.createElement("div");
          l2.className = "ol-overviewmap-box", l2.style.boxSizing = "border-box", this.boxOverlay_ = new Qa({ position: [0, 0], positioning: "center-center", element: l2 }), this.ovmap_.addOverlay(this.boxOverlay_);
          const h2 = e2 + " ol-unselectable " + Is + (this.collapsed_ && this.collapsible_ ? " ol-collapsed" : "") + (this.collapsible_ ? "" : " ol-uncollapsible"), c2 = this.element;
          c2.className = h2, c2.appendChild(this.ovmapDiv_), c2.appendChild(o2);
          const u2 = this, d2 = this.boxOverlay_, g2 = this.boxOverlay_.getElement(), f2 = function(t3) {
            const e3 = { clientX: (i3 = t3).clientX, clientY: i3.clientY };
            var i3;
            const n3 = a2.getEventCoordinateInternal(e3);
            d2.setPosition(n3);
          }, p2 = function(t3) {
            const e3 = a2.getEventCoordinateInternal(t3);
            u2.getMap().getView().setCenterInternal(e3), window.removeEventListener("mousemove", f2), window.removeEventListener("mouseup", p2);
          };
          g2.addEventListener("mousedown", function() {
            window.addEventListener("mousemove", f2), window.addEventListener("mouseup", p2);
          });
        }
        setMap(t2) {
          const e2 = this.getMap();
          if (t2 !== e2) {
            if (e2) {
              const t3 = e2.getView();
              t3 && this.unbindView_(t3), this.ovmap_.setTarget(null);
            }
            if (super.setMap(t2), t2) {
              this.ovmap_.setTarget(this.ovmapDiv_), this.listenerKeys.push(N(t2, r, this.handleMapPropertyChange_, this));
              const e3 = t2.getView();
              e3 && (this.bindView_(e3), e3.isDef() && (this.ovmap_.updateSize(), this.resetExtent_())), this.ovmap_.isRendered() || this.updateBoxAfterOvmapIsRendered_();
            }
          }
        }
        handleMapPropertyChange_(t2) {
          if (t2.key === wo) {
            const e2 = t2.oldValue;
            e2 && this.unbindView_(e2);
            const i2 = this.getMap().getView();
            this.bindView_(i2);
          } else
            this.ovmap_.isRendered() || t2.key !== So && t2.key !== vo || this.ovmap_.updateSize();
        }
        bindView_(t2) {
          if (!this.view_) {
            const e2 = new zo({ projection: t2.getProjection() });
            this.ovmap_.setView(e2);
          }
          t2.addChangeListener(Io.ROTATION, this.boundHandleRotationChanged_), this.handleRotationChanged_();
        }
        unbindView_(t2) {
          t2.removeChangeListener(Io.ROTATION, this.boundHandleRotationChanged_);
        }
        handleRotationChanged_() {
          this.rotateWithView_ && this.ovmap_.getView().setRotation(this.getMap().getView().getRotation());
        }
        validateExtent_() {
          const t2 = this.getMap(), e2 = this.ovmap_;
          if (!t2.isRendered() || !e2.isRendered())
            return;
          const i2 = t2.getSize(), n2 = t2.getView().calculateExtentInternal(i2);
          if (this.viewExtent_ && ee(n2, this.viewExtent_))
            return;
          this.viewExtent_ = n2;
          const r2 = e2.getSize(), s2 = e2.getView().calculateExtentInternal(r2), o2 = e2.getPixelFromCoordinateInternal(xe(n2)), a2 = e2.getPixelFromCoordinateInternal(de(n2)), l2 = Math.abs(o2[0] - a2[0]), h2 = Math.abs(o2[1] - a2[1]), c2 = r2[0], u2 = r2[1];
          l2 < c2 * uT || h2 < u2 * uT || l2 > c2 * cT || h2 > u2 * cT ? this.resetExtent_() : Yt(s2, n2) || this.recenter_();
        }
        resetExtent_() {
          const t2 = this.getMap(), e2 = this.ovmap_, i2 = t2.getSize(), n2 = t2.getView().calculateExtentInternal(i2), r2 = e2.getView(), s2 = Math.log(7.5) / Math.LN2;
          Ce(n2, 1 / (Math.pow(2, s2 / 2) * uT)), r2.fitInternal(gr(n2));
        }
        recenter_() {
          const t2 = this.getMap(), e2 = this.ovmap_, i2 = t2.getView();
          e2.getView().setCenterInternal(i2.getCenterInternal());
        }
        updateBox_() {
          const t2 = this.getMap(), e2 = this.ovmap_;
          if (!t2.isRendered() || !e2.isRendered())
            return;
          const i2 = t2.getSize(), n2 = t2.getView(), r2 = e2.getView(), s2 = this.rotateWithView_ ? 0 : -n2.getRotation(), o2 = this.boxOverlay_, a2 = this.boxOverlay_.getElement(), l2 = n2.getCenterInternal(), h2 = n2.getResolution(), c2 = r2.getResolution(), u2 = i2[0] * h2 / c2, d2 = i2[1] * h2 / c2;
          if (o2.setPosition(l2), a2) {
            a2.style.width = u2 + "px", a2.style.height = d2 + "px";
            const t3 = "rotate(" + s2 + "rad)";
            a2.style.transform = t3;
          }
        }
        updateBoxAfterOvmapIsRendered_() {
          this.ovmapPostrenderKey_ || (this.ovmapPostrenderKey_ = D(this.ovmap_, fo, function(t2) {
            delete this.ovmapPostrenderKey_, this.updateBox_();
          }, this));
        }
        handleClick_(t2) {
          t2.preventDefault(), this.handleToggle_();
        }
        handleToggle_() {
          this.element.classList.toggle(Ls), this.collapsed_ ? Br(this.collapseLabel_, this.label_) : Br(this.label_, this.collapseLabel_), this.collapsed_ = !this.collapsed_;
          const t2 = this.ovmap_;
          if (!this.collapsed_) {
            if (t2.isRendered())
              return this.viewExtent_ = void 0, void t2.render();
            t2.updateSize(), this.resetExtent_(), this.updateBoxAfterOvmapIsRendered_();
          }
        }
        getCollapsible() {
          return this.collapsible_;
        }
        setCollapsible(t2) {
          this.collapsible_ !== t2 && (this.collapsible_ = t2, this.element.classList.toggle("ol-uncollapsible"), !t2 && this.collapsed_ && this.handleToggle_());
        }
        setCollapsed(t2) {
          this.collapsible_ && this.collapsed_ !== t2 && this.handleToggle_();
        }
        getCollapsed() {
          return this.collapsed_;
        }
        getRotateWithView() {
          return this.rotateWithView_;
        }
        setRotateWithView(t2) {
          this.rotateWithView_ !== t2 && (this.rotateWithView_ = t2, 0 !== this.getMap().getView().getRotation() && (this.rotateWithView_ ? this.handleRotationChanged_() : this.ovmap_.getView().setRotation(0), this.viewExtent_ = void 0, this.validateExtent_(), this.updateBox_()));
        }
        getOverviewMap() {
          return this.ovmap_;
        }
        render(t2) {
          this.validateExtent_(), this.updateBox_();
        }
      }, _T.control.Rotate = $o, _T.control.ScaleLine = class extends qo {
        constructor(t2) {
          t2 = t2 || {};
          const e2 = document.createElement("div");
          e2.style.pointerEvents = "none", super({ element: e2, render: t2.render, target: t2.target }), this.on, this.once, this.un;
          const i2 = void 0 !== t2.className ? t2.className : t2.bar ? "ol-scale-bar" : "ol-scale-line";
          this.innerElement_ = document.createElement("div"), this.innerElement_.className = i2 + "-inner", this.element.className = i2 + " " + Rs, this.element.appendChild(this.innerElement_), this.viewState_ = null, this.minWidth_ = void 0 !== t2.minWidth ? t2.minWidth : 64, this.maxWidth_ = t2.maxWidth, this.renderedVisible_ = false, this.renderedWidth_ = void 0, this.renderedHTML_ = "", this.addChangeListener(dT, this.handleUnitsChanged_), this.setUnits(t2.units || "metric"), this.scaleBar_ = t2.bar || false, this.scaleBarSteps_ = t2.steps || 4, this.scaleBarText_ = t2.text || false, this.dpi_ = t2.dpi || void 0;
        }
        getUnits() {
          return this.get(dT);
        }
        handleUnitsChanged_() {
          this.updateElement_();
        }
        setUnits(t2) {
          this.set(dT, t2);
        }
        setDpi(t2) {
          this.dpi_ = t2;
        }
        updateElement_() {
          const t2 = this.viewState_;
          if (!t2)
            return void (this.renderedVisible_ && (this.element.style.display = "none", this.renderedVisible_ = false));
          const e2 = t2.center, i2 = t2.projection, n2 = this.getUnits(), r2 = "degrees" == n2 ? "degrees" : "m";
          let s2 = zi(i2, t2.resolution, e2, r2);
          const o2 = this.minWidth_ * (this.dpi_ || fT) / fT, a2 = void 0 !== this.maxWidth_ ? this.maxWidth_ * (this.dpi_ || fT) / fT : void 0;
          let l2 = o2 * s2, h2 = "";
          if ("degrees" == n2) {
            const t3 = Fe.degrees;
            l2 *= t3, l2 < t3 / 60 ? (h2 = "\u2033", s2 *= 3600) : l2 < t3 ? (h2 = "\u2032", s2 *= 60) : h2 = "\xB0";
          } else
            "imperial" == n2 ? l2 < 0.9144 ? (h2 = "in", s2 /= 0.0254) : l2 < 1609.344 ? (h2 = "ft", s2 /= 0.3048) : (h2 = "mi", s2 /= 1609.344) : "nautical" == n2 ? (s2 /= 1852, h2 = "NM") : "metric" == n2 ? l2 < 1e-3 ? (h2 = "\u03BCm", s2 *= 1e6) : l2 < 1 ? (h2 = "mm", s2 *= 1e3) : l2 < 1e3 ? h2 = "m" : (h2 = "km", s2 /= 1e3) : "us" == n2 ? l2 < 0.9144 ? (h2 = "in", s2 *= 39.37) : l2 < 1609.344 ? (h2 = "ft", s2 /= 0.30480061) : (h2 = "mi", s2 /= 1609.3472) : at(false, 33);
          let c2, u2, d2, g2, f2, p2, m2 = 3 * Math.floor(Math.log(o2 * s2) / Math.log(10));
          for (; ; ) {
            d2 = Math.floor(m2 / 3);
            const t3 = Math.pow(10, d2);
            if (c2 = gT[(m2 % 3 + 3) % 3] * t3, u2 = Math.round(c2 / s2), isNaN(u2))
              return this.element.style.display = "none", void (this.renderedVisible_ = false);
            if (void 0 !== a2 && u2 >= a2) {
              c2 = g2, u2 = f2, d2 = p2;
              break;
            }
            if (u2 >= o2)
              break;
            g2 = c2, f2 = u2, p2 = d2, ++m2;
          }
          const _2 = this.scaleBar_ ? this.createScaleBar(u2, c2, h2) : c2.toFixed(d2 < 0 ? -d2 : 0) + " " + h2;
          this.renderedHTML_ != _2 && (this.innerElement_.innerHTML = _2, this.renderedHTML_ = _2), this.renderedWidth_ != u2 && (this.innerElement_.style.width = u2 + "px", this.renderedWidth_ = u2), this.renderedVisible_ || (this.element.style.display = "", this.renderedVisible_ = true);
        }
        createScaleBar(t2, e2, i2) {
          const n2 = this.getScaleForResolution(), r2 = n2 < 1 ? Math.round(1 / n2).toLocaleString() + " : 1" : "1 : " + Math.round(n2).toLocaleString(), s2 = this.scaleBarSteps_, o2 = t2 / s2, a2 = [this.createMarker("absolute")];
          for (let n3 = 0; n3 < s2; ++n3) {
            const r3 = n3 % 2 == 0 ? "ol-scale-singlebar-odd" : "ol-scale-singlebar-even";
            a2.push(`<div><div class="ol-scale-singlebar ${r3}" style="width: ${o2}px;"></div>` + this.createMarker("relative") + (n3 % 2 == 0 || 2 === s2 ? this.createStepText(n3, t2, false, e2, i2) : "") + "</div>");
          }
          a2.push(this.createStepText(s2, t2, true, e2, i2));
          return (this.scaleBarText_ ? `<div class="ol-scale-text" style="width: ${t2}px;">` + r2 + "</div>" : "") + a2.join("");
        }
        createMarker(t2) {
          return `<div class="ol-scale-step-marker" style="position: ${t2}; top: ${"absolute" === t2 ? 3 : -10}px;"></div>`;
        }
        createStepText(t2, e2, i2, n2, r2) {
          const s2 = (0 === t2 ? 0 : Math.round(n2 / this.scaleBarSteps_ * t2 * 100) / 100) + (0 === t2 ? "" : " " + r2);
          return `<div class="ol-scale-step-text" style="margin-left: ${0 === t2 ? -3 : e2 / this.scaleBarSteps_ * -1}px;text-align: ${0 === t2 ? "left" : "center"};min-width: ${0 === t2 ? 0 : e2 / this.scaleBarSteps_ * 2}px;left: ${i2 ? e2 + "px" : "unset"};">` + s2 + "</div>";
        }
        getScaleForResolution() {
          return zi(this.viewState_.projection, this.viewState_.resolution, this.viewState_.center, "m") * (1e3 / 25.4) * (this.dpi_ || fT);
        }
        render(t2) {
          const e2 = t2.frameState;
          this.viewState_ = e2 ? e2.viewState : null, this.updateElement_();
        }
      }, _T.control.Zoom = Jo, _T.control.ZoomSlider = class extends qo {
        constructor(t2) {
          t2 = t2 || {}, super({ element: document.createElement("div"), render: t2.render }), this.dragListenerKeys_ = [], this.currentResolution_ = void 0, this.direction_ = pT, this.dragging_, this.heightLimit_ = 0, this.widthLimit_ = 0, this.startX_, this.startY_, this.thumbSize_ = null, this.sliderInitialized_ = false, this.duration_ = void 0 !== t2.duration ? t2.duration : 200;
          const e2 = void 0 !== t2.className ? t2.className : "ol-zoomslider", i2 = document.createElement("button");
          i2.setAttribute("type", "button"), i2.className = e2 + "-thumb " + Rs;
          const r2 = this.element;
          r2.className = e2 + " ol-unselectable " + Is, r2.appendChild(i2), r2.addEventListener(ho, this.handleDraggerStart_.bind(this), false), r2.addEventListener(lo, this.handleDraggerDrag_.bind(this), false), r2.addEventListener(co, this.handleDraggerEnd_.bind(this), false), r2.addEventListener(T, this.handleContainerClick_.bind(this), false), i2.addEventListener(T, n, false);
        }
        setMap(t2) {
          super.setMap(t2), t2 && t2.render();
        }
        initSlider_() {
          const t2 = this.element;
          let e2 = t2.offsetWidth, i2 = t2.offsetHeight;
          if (0 === e2 && 0 === i2)
            return this.sliderInitialized_ = false;
          const n2 = getComputedStyle(t2);
          e2 -= parseFloat(n2.paddingRight) + parseFloat(n2.paddingLeft), i2 -= parseFloat(n2.paddingTop) + parseFloat(n2.paddingBottom);
          const r2 = t2.firstElementChild, s2 = getComputedStyle(r2), o2 = r2.offsetWidth + parseFloat(s2.marginRight) + parseFloat(s2.marginLeft), a2 = r2.offsetHeight + parseFloat(s2.marginTop) + parseFloat(s2.marginBottom);
          return this.thumbSize_ = [o2, a2], e2 > i2 ? (this.direction_ = mT, this.widthLimit_ = e2 - o2) : (this.direction_ = pT, this.heightLimit_ = i2 - a2), this.sliderInitialized_ = true;
        }
        handleContainerClick_(t2) {
          const e2 = this.getMap().getView(), i2 = this.getRelativePosition_(t2.offsetX - this.thumbSize_[0] / 2, t2.offsetY - this.thumbSize_[1] / 2), n2 = this.getResolutionForPosition_(i2), r2 = e2.getConstrainedZoom(e2.getZoomForResolution(n2));
          e2.animateInternal({ zoom: r2, duration: this.duration_, easing: it });
        }
        handleDraggerStart_(t2) {
          if (!this.dragging_ && t2.target === this.element.firstElementChild) {
            const e2 = this.element.firstElementChild;
            if (this.getMap().getView().beginInteraction(), this.startX_ = t2.clientX - parseFloat(e2.style.left), this.startY_ = t2.clientY - parseFloat(e2.style.top), this.dragging_ = true, 0 === this.dragListenerKeys_.length) {
              const t3 = this.handleDraggerDrag_, e3 = this.handleDraggerEnd_, i2 = this.getMap().getOwnerDocument();
              this.dragListenerKeys_.push(N(i2, lo, t3, this), N(i2, co, e3, this));
            }
          }
        }
        handleDraggerDrag_(t2) {
          if (this.dragging_) {
            const e2 = t2.clientX - this.startX_, i2 = t2.clientY - this.startY_, n2 = this.getRelativePosition_(e2, i2);
            this.currentResolution_ = this.getResolutionForPosition_(n2), this.getMap().getView().setResolution(this.currentResolution_);
          }
        }
        handleDraggerEnd_(t2) {
          if (this.dragging_) {
            this.getMap().getView().endInteraction(), this.dragging_ = false, this.startX_ = void 0, this.startY_ = void 0, this.dragListenerKeys_.forEach(k), this.dragListenerKeys_.length = 0;
          }
        }
        setThumbPosition_(t2) {
          const e2 = this.getPositionForResolution_(t2), i2 = this.element.firstElementChild;
          this.direction_ == mT ? i2.style.left = this.widthLimit_ * e2 + "px" : i2.style.top = this.heightLimit_ * e2 + "px";
        }
        getRelativePosition_(t2, e2) {
          let i2;
          return i2 = this.direction_ === mT ? t2 / this.widthLimit_ : e2 / this.heightLimit_, ii(i2, 0, 1);
        }
        getResolutionForPosition_(t2) {
          return this.getMap().getView().getResolutionForValueFunction()(1 - t2);
        }
        getPositionForResolution_(t2) {
          return ii(1 - this.getMap().getView().getValueForResolutionFunction()(t2), 0, 1);
        }
        render(t2) {
          if (!t2.frameState)
            return;
          if (!this.sliderInitialized_ && !this.initSlider_())
            return;
          const e2 = t2.frameState.viewState.resolution;
          this.currentResolution_ = e2, this.setThumbPosition_(e2);
        }
      }, _T.control.ZoomToExtent = class extends qo {
        constructor(t2) {
          t2 = t2 || {}, super({ element: document.createElement("div"), target: t2.target }), this.extent = t2.extent ? t2.extent : null;
          const e2 = void 0 !== t2.className ? t2.className : "ol-zoom-extent", i2 = void 0 !== t2.label ? t2.label : "E", n2 = void 0 !== t2.tipLabel ? t2.tipLabel : "Fit to extent", r2 = document.createElement("button");
          r2.setAttribute("type", "button"), r2.title = n2, r2.appendChild("string" == typeof i2 ? document.createTextNode(i2) : i2), r2.addEventListener(T, this.handleClick_.bind(this), false);
          const s2 = e2 + " ol-unselectable " + Is, o2 = this.element;
          o2.className = s2, o2.appendChild(r2);
        }
        handleClick_(t2) {
          t2.preventDefault(), this.handleZoomToExtent();
        }
        handleZoomToExtent() {
          const t2 = this.getMap().getView(), e2 = this.extent ? this.extent : t2.getProjection().getExtent();
          t2.fitInternal(gr(e2));
        }
      }, _T.control.defaults = {}, _T.control.defaults.defaults = Qo, _T.coordinate = {}, _T.coordinate.add = mi, _T.coordinate.closestOnCircle = _i, _T.coordinate.closestOnSegment = yi, _T.coordinate.createStringXY = function(t2) {
        return function(e2) {
          return Ri(e2, t2);
        };
      }, _T.coordinate.degreesToStringHDMS = xi, _T.coordinate.distance = Ci, _T.coordinate.equals = Si, _T.coordinate.format = vi, _T.coordinate.getWorldsAway = Ii, _T.coordinate.rotate = wi, _T.coordinate.scale = Ei, _T.coordinate.squaredDistance = Ti, _T.coordinate.squaredDistanceToSegment = bi, _T.coordinate.toStringHDMS = function(t2, e2) {
        return t2 ? xi("NS", t2[1], e2) + " " + xi("EW", t2[0], e2) : "";
      }, _T.coordinate.toStringXY = Ri, _T.coordinate.wrapX = Pi, _T.css = {}, _T.css.CLASS_COLLAPSED = Ls, _T.css.CLASS_CONTROL = Is, _T.css.CLASS_HIDDEN = Cs, _T.css.CLASS_SELECTABLE = bs, _T.css.CLASS_UNSELECTABLE = Rs, _T.css.CLASS_UNSUPPORTED = Ps, _T.css.getFontParameters = As, _T.dom = {}, _T.dom.createCanvasContext2D = Dr, _T.dom.outerHeight = jr, _T.dom.outerWidth = Gr, _T.dom.releaseCanvas = kr, _T.dom.removeChildren = zr, _T.dom.removeNode = Ur, _T.dom.replaceChildren = Xr, _T.dom.replaceNode = Br, _T.easing = {}, _T.easing.easeIn = et, _T.easing.easeOut = it, _T.easing.inAndOut = nt, _T.easing.linear = rt, _T.easing.upAndDown = function(t2) {
        return t2 < 0.5 ? nt(2 * t2) : 1 - nt(2 * (t2 - 0.5));
      }, _T.events = {}, _T.events.Event = i, _T.events.Event.preventDefault = function(t2) {
        t2.preventDefault();
      }, _T.events.Event.stopPropagation = n, _T.events.Target = v, _T.events.condition = {}, _T.events.condition.all = aa, _T.events.condition.altKeyOnly = la, _T.events.condition.altShiftKeysOnly = ha, _T.events.condition.always = da, _T.events.condition.click = function(t2) {
        return t2.type == ao.CLICK;
      }, _T.events.condition.doubleClick = function(t2) {
        return t2.type == ao.DBLCLICK;
      }, _T.events.condition.focus = ca, _T.events.condition.focusWithTabindex = ua, _T.events.condition.mouseActionButton = ga, _T.events.condition.mouseOnly = xa, _T.events.condition.never = fa, _T.events.condition.noModifierKeys = ma, _T.events.condition.penOnly = function(t2) {
        const e2 = t2.originalEvent;
        return at(void 0 !== e2, 56), "pen" === e2.pointerType;
      }, _T.events.condition.platformModifierKeyOnly = function(t2) {
        const e2 = t2.originalEvent;
        return !e2.altKey && (pt ? e2.metaKey : e2.ctrlKey) && !e2.shiftKey;
      }, _T.events.condition.pointerMove = function(t2) {
        return "pointermove" == t2.type;
      }, _T.events.condition.primaryAction = va, _T.events.condition.shiftKeyOnly = _a, _T.events.condition.singleClick = pa, _T.events.condition.targetNotEditable = ya, _T.events.condition.touchOnly = function(t2) {
        const e2 = t2.originalEvent;
        return at(void 0 !== e2, 56), "touch" === e2.pointerType;
      }, _T.events.listen = N, _T.events.listenOnce = D, _T.events.unlistenByKey = k, _T.extent = {}, _T.extent.applyTransform = Re, _T.extent.approximatelyEquals = ie, _T.extent.boundingExtent = zt, _T.extent.buffer = Xt, _T.extent.clone = Vt, _T.extent.closestSquaredDistanceXY = Wt, _T.extent.containsCoordinate = Zt, _T.extent.containsExtent = Yt, _T.extent.containsXY = Kt, _T.extent.coordinateRelationship = qt, _T.extent.createEmpty = Ht, _T.extent.createOrUpdate = $t, _T.extent.createOrUpdateEmpty = Jt, _T.extent.createOrUpdateFromCoordinate = Qt, _T.extent.createOrUpdateFromCoordinates = function(t2, e2) {
        return se(Jt(e2), t2);
      }, _T.extent.createOrUpdateFromFlatCoordinates = te, _T.extent.createOrUpdateFromRings = function(t2, e2) {
        return ae(Jt(e2), t2);
      }, _T.extent.equals = ee, _T.extent.extend = ne, _T.extent.extendCoordinate = re, _T.extent.extendCoordinates = se, _T.extent.extendFlatCoordinates = oe, _T.extent.extendRings = ae, _T.extent.extendXY = le, _T.extent.forEachCorner = he, _T.extent.getArea = ce, _T.extent.getBottomLeft = ue, _T.extent.getBottomRight = de, _T.extent.getCenter = ge, _T.extent.getCorner = fe, _T.extent.getEnlargedArea = function(t2, e2) {
        const i2 = Math.min(t2[0], e2[0]), n2 = Math.min(t2[1], e2[1]);
        return (Math.max(t2[2], e2[2]) - i2) * (Math.max(t2[3], e2[3]) - n2);
      }, _T.extent.getForViewAndSize = pe, _T.extent.getHeight = _e, _T.extent.getIntersection = ye, _T.extent.getIntersectionArea = function(t2, e2) {
        return ce(ye(t2, e2));
      }, _T.extent.getMargin = function(t2) {
        return Se(t2) + _e(t2);
      }, _T.extent.getRotatedViewport = me, _T.extent.getSize = function(t2) {
        return [t2[2] - t2[0], t2[3] - t2[1]];
      }, _T.extent.getTopLeft = xe, _T.extent.getTopRight = ve, _T.extent.getWidth = Se, _T.extent.intersects = we, _T.extent.intersectsSegment = be, _T.extent.isEmpty = Ee, _T.extent.returnOrUpdate = Te, _T.extent.scaleFromCenter = Ce, _T.extent.wrapAndSliceX = Ie, _T.extent.wrapX = Pe, _T.featureloader = {}, _T.featureloader.loadFeaturesXhr = _l, _T.featureloader.setWithCredentials = function(t2) {
        ml = t2;
      }, _T.featureloader.xhr = yl, _T.format = {}, _T.format.EsriJSON = class extends E_ {
        constructor(t2) {
          t2 = t2 || {}, super(), this.geometryName_ = t2.geometryName;
        }
        readFeatureFromObject(t2, e2, i2) {
          const n2 = t2, r2 = R_(n2.geometry, e2), s2 = new lt();
          if (this.geometryName_ && s2.setGeometryName(this.geometryName_), s2.setGeometry(r2), n2.attributes) {
            s2.setProperties(n2.attributes, true);
            const t3 = n2.attributes[i2];
            void 0 !== t3 && s2.setId(t3);
          }
          return s2;
        }
        readFeaturesFromObject(t2, e2) {
          if (e2 = e2 || {}, t2.features) {
            const i2 = [], n2 = t2.features;
            for (let r2 = 0, s2 = n2.length; r2 < s2; ++r2)
              i2.push(this.readFeatureFromObject(n2[r2], e2, t2.objectIdFieldName));
            return i2;
          }
          return [this.readFeatureFromObject(t2, e2)];
        }
        readGeometryFromObject(t2, e2) {
          return R_(t2, e2);
        }
        readProjectionFromObject(t2) {
          if (t2.spatialReference && void 0 !== t2.spatialReference.wkid) {
            return Ui("EPSG:" + t2.spatialReference.wkid);
          }
          return null;
        }
        writeGeometryObject(t2, e2) {
          return L_(t2, this.adaptOptions(e2));
        }
        writeFeatureObject(t2, e2) {
          e2 = this.adaptOptions(e2);
          const i2 = {};
          if (!t2.hasProperties())
            return i2.attributes = {}, i2;
          const n2 = t2.getProperties(), r2 = t2.getGeometry();
          if (r2) {
            i2.geometry = L_(r2, e2);
            const s2 = e2 && (e2.dataProjection || e2.featureProjection);
            s2 && (i2.geometry.spatialReference = { wkid: Number(Ui(s2).getCode().split(":").pop()) }), delete n2[t2.getGeometryName()];
          }
          return x(n2) ? i2.attributes = {} : i2.attributes = n2, i2;
        }
        writeFeaturesObject(t2, e2) {
          e2 = this.adaptOptions(e2);
          const i2 = [];
          for (let n2 = 0, r2 = t2.length; n2 < r2; ++n2)
            i2.push(this.writeFeatureObject(t2[n2], e2));
          return { features: i2 };
        }
      }, _T.format.Feature = Jp, _T.format.Feature.transformExtentWithOptions = tm, _T.format.Feature.transformGeometryWithOptions = Qp, _T.format.GML = Q_, _T.format.GML2 = H_, _T.format.GML3 = J_, _T.format.GML32 = ty, _T.format.GMLBase = O_, _T.format.GMLBase.GMLNS = F_, _T.format.GPX = class extends M_ {
        constructor(t2) {
          super(), t2 = t2 || {}, this.dataProjection = Ui("EPSG:4326"), this.readExtensions_ = t2.readExtensions;
        }
        handleReadExtensions_(t2) {
          t2 || (t2 = []);
          for (let e2 = 0, i2 = t2.length; e2 < i2; ++e2) {
            const i3 = t2[e2];
            if (this.readExtensions_) {
              const t3 = i3.get("extensionsNode_") || null;
              this.readExtensions_(i3, t3);
            }
            i3.set("extensionsNode_", void 0);
          }
        }
        readFeatureFromNode(t2, e2) {
          if (!ey.includes(t2.namespaceURI))
            return null;
          const i2 = iy[t2.localName];
          if (!i2)
            return null;
          const n2 = i2(t2, [this.getReadOptions(t2, e2)]);
          return n2 ? (this.handleReadExtensions_([n2]), n2) : null;
        }
        readFeaturesFromNode(t2, e2) {
          if (!ey.includes(t2.namespaceURI))
            return [];
          if ("gpx" == t2.localName) {
            const i2 = Lu([], ny, t2, [this.getReadOptions(t2, e2)]);
            return i2 ? (this.handleReadExtensions_(i2), i2) : [];
          }
          return [];
        }
        writeFeaturesNode(t2, e2) {
          e2 = this.adaptOptions(e2);
          const i2 = du("http://www.topografix.com/GPX/1/1", "gpx");
          return i2.setAttributeNS("http://www.w3.org/2000/xmlns/", "xmlns:xsi", uu), i2.setAttributeNS(uu, "xsi:schemaLocation", "http://www.topografix.com/GPX/1/1 http://www.topografix.com/GPX/1/1/gpx.xsd"), i2.setAttribute("version", "1.1"), i2.setAttribute("creator", "OpenLayers"), Fu({ node: i2 }, sy, Ty, t2, [e2]), i2;
        }
      }, _T.format.GeoJSON = class extends E_ {
        constructor(t2) {
          t2 = t2 || {}, super(), this.dataProjection = Ui(t2.dataProjection ? t2.dataProjection : "EPSG:4326"), t2.featureProjection && (this.defaultFeatureProjection = Ui(t2.featureProjection)), this.geometryName_ = t2.geometryName, this.extractGeometryName_ = t2.extractGeometryName, this.supportedMediaTypes = ["application/geo+json", "application/vnd.geo+json"];
        }
        readFeatureFromObject(t2, e2) {
          let i2 = null;
          i2 = "Feature" === t2.type ? t2 : { type: "Feature", geometry: t2, properties: null };
          const n2 = Oy(i2.geometry, e2), r2 = new lt();
          return this.geometryName_ ? r2.setGeometryName(this.geometryName_) : this.extractGeometryName_ && "geometry_name" in i2 !== void 0 && r2.setGeometryName(i2.geometry_name), r2.setGeometry(n2), "id" in i2 && r2.setId(i2.id), i2.properties && r2.setProperties(i2.properties, true), r2;
        }
        readFeaturesFromObject(t2, e2) {
          let i2 = null;
          if ("FeatureCollection" === t2.type) {
            i2 = [];
            const n2 = t2.features;
            for (let t3 = 0, r2 = n2.length; t3 < r2; ++t3)
              i2.push(this.readFeatureFromObject(n2[t3], e2));
          } else
            i2 = [this.readFeatureFromObject(t2, e2)];
          return i2;
        }
        readGeometryFromObject(t2, e2) {
          return Oy(t2, e2);
        }
        readProjectionFromObject(t2) {
          const e2 = t2.crs;
          let i2;
          return e2 ? "name" == e2.type ? i2 = Ui(e2.properties.name) : "EPSG" === e2.type ? i2 = Ui("EPSG:" + e2.properties.code) : at(false, 36) : i2 = this.dataProjection, i2;
        }
        writeFeatureObject(t2, e2) {
          e2 = this.adaptOptions(e2);
          const i2 = { type: "Feature", geometry: null, properties: null }, n2 = t2.getId();
          if (void 0 !== n2 && (i2.id = n2), !t2.hasProperties())
            return i2;
          const r2 = t2.getProperties(), s2 = t2.getGeometry();
          return s2 && (i2.geometry = Ny(s2, e2), delete r2[t2.getGeometryName()]), x(r2) || (i2.properties = r2), i2;
        }
        writeFeaturesObject(t2, e2) {
          e2 = this.adaptOptions(e2);
          const i2 = [];
          for (let n2 = 0, r2 = t2.length; n2 < r2; ++n2)
            i2.push(this.writeFeatureObject(t2[n2], e2));
          return { type: "FeatureCollection", features: i2 };
        }
        writeGeometryObject(t2, e2) {
          return Ny(t2, this.adaptOptions(e2));
        }
      }, _T.format.IGC = class extends Dy {
        constructor(t2) {
          super(), t2 = t2 || {}, this.dataProjection = Ui("EPSG:4326"), this.altitudeMode_ = t2.altitudeMode ? t2.altitudeMode : "none";
        }
        readFeatureFromText(t2, e2) {
          const i2 = this.altitudeMode_, n2 = t2.split(Uy), r2 = {}, s2 = [];
          let o2, a2, l2 = 2e3, h2 = 0, c2 = 1, u2 = -1;
          for (o2 = 0, a2 = n2.length; o2 < a2; ++o2) {
            const t3 = n2[o2];
            let e3;
            if ("B" == t3.charAt(0)) {
              if (e3 = Gy.exec(t3), e3) {
                const t4 = parseInt(e3[1], 10), n3 = parseInt(e3[2], 10), r3 = parseInt(e3[3], 10);
                let o3 = parseInt(e3[4], 10) + parseInt(e3[5], 10) / 6e4;
                "S" == e3[6] && (o3 = -o3);
                let a3 = parseInt(e3[7], 10) + parseInt(e3[8], 10) / 6e4;
                if ("W" == e3[9] && (a3 = -a3), s2.push(a3, o3), "none" != i2) {
                  let t5;
                  t5 = "gps" == i2 ? parseInt(e3[11], 10) : "barometric" == i2 ? parseInt(e3[12], 10) : 0, s2.push(t5);
                }
                let d3 = Date.UTC(l2, h2, c2, t4, n3, r3);
                d3 < u2 && (d3 = Date.UTC(l2, h2, c2 + 1, t4, n3, r3)), s2.push(d3 / 1e3), u2 = d3;
              }
            } else
              "H" == t3.charAt(0) && (e3 = By.exec(t3), e3 ? (c2 = parseInt(e3[1], 10), h2 = parseInt(e3[2], 10) - 1, l2 = 2e3 + parseInt(e3[3], 10)) : (e3 = jy.exec(t3), e3 && (r2[e3[1]] = e3[2].trim())));
          }
          if (0 === s2.length)
            return null;
          const d2 = new Op(s2, "none" == i2 ? "XYM" : "XYZM"), g2 = new lt(Qp(d2, false, e2));
          return g2.setProperties(r2, true), g2;
        }
        readFeaturesFromText(t2, e2) {
          const i2 = this.readFeatureFromText(t2, e2);
          return i2 ? [i2] : [];
        }
      }, _T.format.IIIFInfo = class {
        constructor(t2) {
          this.setImageInfo(t2);
        }
        setImageInfo(t2) {
          this.imageInfo = "string" == typeof t2 ? JSON.parse(t2) : t2;
        }
        getImageApiVersion() {
          if (void 0 === this.imageInfo)
            return;
          let t2 = this.imageInfo["@context"] || "ol-no-context";
          "string" == typeof t2 && (t2 = [t2]);
          for (let e2 = 0; e2 < t2.length; e2++)
            switch (t2[e2]) {
              case "http://library.stanford.edu/iiif/image-api/1.1/context.json":
              case "http://iiif.io/api/image/1/context.json":
                return rc;
              case "http://iiif.io/api/image/2/context.json":
                return sc;
              case "http://iiif.io/api/image/3/context.json":
                return oc;
              case "ol-no-context":
                if (this.getComplianceLevelEntryFromProfile(rc) && this.imageInfo.identifier)
                  return rc;
            }
          at(false, 61);
        }
        getComplianceLevelEntryFromProfile(t2) {
          if (void 0 !== this.imageInfo && void 0 !== this.imageInfo.profile)
            switch (void 0 === t2 && (t2 = this.getImageApiVersion()), t2) {
              case rc:
                if (lc.test(this.imageInfo.profile))
                  return this.imageInfo.profile;
                break;
              case oc:
                if (cc.test(this.imageInfo.profile))
                  return this.imageInfo.profile;
                break;
              case sc:
                if ("string" == typeof this.imageInfo.profile && hc.test(this.imageInfo.profile))
                  return this.imageInfo.profile;
                if (Array.isArray(this.imageInfo.profile) && this.imageInfo.profile.length > 0 && "string" == typeof this.imageInfo.profile[0] && hc.test(this.imageInfo.profile[0]))
                  return this.imageInfo.profile[0];
            }
        }
        getComplianceLevelFromProfile(t2) {
          const e2 = this.getComplianceLevelEntryFromProfile(t2);
          if (void 0 === e2)
            return;
          const i2 = e2.match(/level[0-2](?:\.json)?$/g);
          return Array.isArray(i2) ? i2[0].replace(".json", "") : void 0;
        }
        getComplianceLevelSupportedFeatures() {
          if (void 0 === this.imageInfo)
            return;
          const t2 = this.getImageApiVersion(), e2 = this.getComplianceLevelFromProfile(t2);
          return void 0 === e2 ? ac.none.none : ac[t2][e2];
        }
        getTileSourceOptions(t2) {
          const e2 = t2 || {}, i2 = this.getImageApiVersion();
          if (void 0 === i2)
            return;
          const n2 = void 0 === i2 ? void 0 : uc[i2](this);
          return void 0 !== n2 ? { url: n2.url, version: i2, size: [this.imageInfo.width, this.imageInfo.height], sizes: n2.sizes, format: void 0 !== e2.format && n2.formats.includes(e2.format) ? e2.format : void 0 !== n2.preferredFormat ? n2.preferredFormat : "jpg", supports: n2.supports, quality: e2.quality && n2.qualities.includes(e2.quality) ? e2.quality : n2.qualities.includes("native") ? "native" : "default", resolutions: Array.isArray(n2.resolutions) ? n2.resolutions.sort(function(t3, e3) {
            return e3 - t3;
          }) : void 0, tileSize: n2.tileSize } : void 0;
        }
      }, _T.format.JSONFeature = E_, _T.format.KML = class extends M_ {
        constructor(t2) {
          super(), t2 = t2 || {}, ux || ($y = [255, 255, 255, 1], nx = new rg({ color: $y }), Jy = [20, 2], Qy = "pixels", tx = "pixels", ex = [64, 64], ix = "https://maps.google.com/mapfiles/kml/pushpin/ylw-pushpin.png", sx = new lg({ anchor: Jy, anchorOrigin: "bottom-left", anchorXUnits: Qy, anchorYUnits: tx, crossOrigin: "anonymous", rotation: 0, scale: dx(ex), size: ex, src: ix }), rx = "NO_IMAGE", ax = new hg({ color: $y, width: 1 }), ox = new hg({ color: [51, 51, 51, 1], width: 2 }), lx = new mg({ font: "bold 16px Helvetica", fill: nx, stroke: ox, scale: 0.8 }), hx = new cg({ fill: nx, image: sx, text: lx, stroke: ax, zIndex: 0 }), ux = [hx]), this.dataProjection = Ui("EPSG:4326"), this.defaultStyle_ = t2.defaultStyle ? t2.defaultStyle : ux, this.extractStyles_ = void 0 === t2.extractStyles || t2.extractStyles, this.writeStyles_ = void 0 === t2.writeStyles || t2.writeStyles, this.sharedStyles_ = {}, this.showPointNames_ = void 0 === t2.showPointNames || t2.showPointNames, this.crossOrigin_ = void 0 !== t2.crossOrigin ? t2.crossOrigin : "anonymous", this.iconUrlFunction_ = t2.iconUrlFunction ? t2.iconUrlFunction : gx, this.supportedMediaTypes = ["application/vnd.google-earth.kml+xml"];
        }
        readDocumentOrFolder_(t2, e2) {
          const i2 = Lu([], Pu(Xy, { Document: yu(this.readDocumentOrFolder_, this), Folder: yu(this.readDocumentOrFolder_, this), Placemark: xu(this.readPlacemark_, this), Style: this.readSharedStyle_.bind(this), StyleMap: this.readSharedStyleMap_.bind(this) }), t2, e2, this);
          return i2 || void 0;
        }
        readPlacemark_(t2, e2) {
          const i2 = Lu({ geometry: null }, Wy, t2, e2, this);
          if (!i2)
            return;
          const n2 = new lt(), r2 = t2.getAttribute("id");
          null !== r2 && n2.setId(r2);
          const s2 = e2[0], o2 = i2.geometry;
          if (o2 && Qp(o2, false, s2), n2.setGeometry(o2), delete i2.geometry, this.extractStyles_) {
            const t3 = function(t4, e3, i3, n3, r3) {
              return function(s3, o3) {
                let a2 = r3, l2 = "", h2 = [];
                if (a2) {
                  const t5 = s3.getGeometry();
                  if (t5)
                    if (t5 instanceof Ip)
                      h2 = t5.getGeometriesArrayRecursive().filter(function(t6) {
                        const e4 = t6.getType();
                        return "Point" === e4 || "MultiPoint" === e4;
                      }), a2 = h2.length > 0;
                    else {
                      const e4 = t5.getType();
                      a2 = "Point" === e4 || "MultiPoint" === e4;
                    }
                }
                a2 && (l2 = s3.get("name"), a2 = a2 && !!l2, a2 && /&[^&]+;/.test(l2) && (cx || (cx = document.createElement("textarea")), cx.innerHTML = l2, l2 = cx.value));
                let c2 = i3;
                if (t4 ? c2 = t4 : e3 && (c2 = fx(e3, i3, n3)), a2) {
                  const t5 = function(t6, e4) {
                    const i4 = [0, 0];
                    let n4 = "start";
                    const r4 = t6.getImage();
                    if (r4) {
                      const t7 = r4.getSize();
                      if (t7 && 2 == t7.length) {
                        const e5 = r4.getScaleArray(), s5 = r4.getAnchor();
                        i4[0] = e5[0] * (t7[0] - s5[0]), i4[1] = e5[1] * (t7[1] / 2 - s5[1]), n4 = "left";
                      }
                    }
                    let s4 = t6.getText();
                    s4 ? (s4 = s4.clone(), s4.setFont(s4.getFont() || lx.getFont()), s4.setScale(s4.getScale() || lx.getScale()), s4.setFill(s4.getFill() || lx.getFill()), s4.setStroke(s4.getStroke() || ox)) : s4 = lx.clone();
                    s4.setText(e4), s4.setOffsetX(i4[0]), s4.setOffsetY(i4[1]), s4.setTextAlign(n4);
                    return new cg({ image: r4, text: s4 });
                  }(c2[0], l2);
                  if (h2.length > 0) {
                    t5.setGeometry(new Ip(h2));
                    return [t5, new cg({ geometry: c2[0].getGeometry(), image: null, fill: c2[0].getFill(), stroke: c2[0].getStroke(), text: null })].concat(c2.slice(1));
                  }
                  return t5;
                }
                return c2;
              };
            }(i2.Style, i2.styleUrl, this.defaultStyle_, this.sharedStyles_, this.showPointNames_);
            n2.setStyle(t3);
          }
          return delete i2.Style, n2.setProperties(i2, true), n2;
        }
        readSharedStyle_(t2, e2) {
          const i2 = t2.getAttribute("id");
          if (null !== i2) {
            const n2 = Xx.call(this, t2, e2);
            if (n2) {
              let e3, r2 = t2.baseURI;
              if (r2 && "about:blank" != r2 || (r2 = window.location.href), r2) {
                e3 = new URL("#" + i2, r2).href;
              } else
                e3 = "#" + i2;
              this.sharedStyles_[e3] = n2;
            }
          }
        }
        readSharedStyleMap_(t2, e2) {
          const i2 = t2.getAttribute("id");
          if (null === i2)
            return;
          const n2 = Sx.call(this, t2, e2);
          if (!n2)
            return;
          let r2, s2 = t2.baseURI;
          if (s2 && "about:blank" != s2 || (s2 = window.location.href), s2) {
            r2 = new URL("#" + i2, s2).href;
          } else
            r2 = "#" + i2;
          this.sharedStyles_[r2] = n2;
        }
        readFeatureFromNode(t2, e2) {
          if (!Xy.includes(t2.namespaceURI))
            return null;
          const i2 = this.readPlacemark_(t2, [this.getReadOptions(t2, e2)]);
          return i2 || null;
        }
        readFeaturesFromNode(t2, e2) {
          if (!Xy.includes(t2.namespaceURI))
            return [];
          let i2;
          const n2 = t2.localName;
          if ("Document" == n2 || "Folder" == n2)
            return i2 = this.readDocumentOrFolder_(t2, [this.getReadOptions(t2, e2)]), i2 || [];
          if ("Placemark" == n2) {
            const i3 = this.readPlacemark_(t2, [this.getReadOptions(t2, e2)]);
            return i3 ? [i3] : [];
          }
          if ("kml" == n2) {
            i2 = [];
            for (let n3 = t2.firstElementChild; n3; n3 = n3.nextElementSibling) {
              const t3 = this.readFeaturesFromNode(n3, e2);
              t3 && c(i2, t3);
            }
            return i2;
          }
          return [];
        }
        readName(t2) {
          if (t2) {
            if ("string" == typeof t2) {
              const e2 = _u(t2);
              return this.readNameFromDocument(e2);
            }
            return pu(t2) ? this.readNameFromDocument(t2) : this.readNameFromNode(t2);
          }
        }
        readNameFromDocument(t2) {
          for (let e2 = t2.firstChild; e2; e2 = e2.nextSibling)
            if (e2.nodeType == Node.ELEMENT_NODE) {
              const t3 = this.readNameFromNode(e2);
              if (t3)
                return t3;
            }
        }
        readNameFromNode(t2) {
          for (let e2 = t2.firstElementChild; e2; e2 = e2.nextElementSibling)
            if (Xy.includes(e2.namespaceURI) && "name" == e2.localName)
              return z_(e2);
          for (let e2 = t2.firstElementChild; e2; e2 = e2.nextElementSibling) {
            const t3 = e2.localName;
            if (Xy.includes(e2.namespaceURI) && ("Document" == t3 || "Folder" == t3 || "Placemark" == t3 || "kml" == t3)) {
              const t4 = this.readNameFromNode(e2);
              if (t4)
                return t4;
            }
          }
        }
        readNetworkLinks(t2) {
          const e2 = [];
          if ("string" == typeof t2) {
            const i2 = _u(t2);
            c(e2, this.readNetworkLinksFromDocument(i2));
          } else
            pu(t2) ? c(e2, this.readNetworkLinksFromDocument(t2)) : c(e2, this.readNetworkLinksFromNode(t2));
          return e2;
        }
        readNetworkLinksFromDocument(t2) {
          const e2 = [];
          for (let i2 = t2.firstChild; i2; i2 = i2.nextSibling)
            i2.nodeType == Node.ELEMENT_NODE && c(e2, this.readNetworkLinksFromNode(i2));
          return e2;
        }
        readNetworkLinksFromNode(t2) {
          const e2 = [];
          for (let i2 = t2.firstElementChild; i2; i2 = i2.nextElementSibling)
            if (Xy.includes(i2.namespaceURI) && "NetworkLink" == i2.localName) {
              const t3 = Lu({}, Zy, i2, []);
              e2.push(t3);
            }
          for (let i2 = t2.firstElementChild; i2; i2 = i2.nextElementSibling) {
            const t3 = i2.localName;
            !Xy.includes(i2.namespaceURI) || "Document" != t3 && "Folder" != t3 && "kml" != t3 || c(e2, this.readNetworkLinksFromNode(i2));
          }
          return e2;
        }
        readRegion(t2) {
          const e2 = [];
          if ("string" == typeof t2) {
            const i2 = _u(t2);
            c(e2, this.readRegionFromDocument(i2));
          } else
            pu(t2) ? c(e2, this.readRegionFromDocument(t2)) : c(e2, this.readRegionFromNode(t2));
          return e2;
        }
        readRegionFromDocument(t2) {
          const e2 = [];
          for (let i2 = t2.firstChild; i2; i2 = i2.nextSibling)
            i2.nodeType == Node.ELEMENT_NODE && c(e2, this.readRegionFromNode(i2));
          return e2;
        }
        readRegionFromNode(t2) {
          const e2 = [];
          for (let i2 = t2.firstElementChild; i2; i2 = i2.nextElementSibling)
            if (Xy.includes(i2.namespaceURI) && "Region" == i2.localName) {
              const t3 = Lu({}, Ky, i2, []);
              e2.push(t3);
            }
          for (let i2 = t2.firstElementChild; i2; i2 = i2.nextElementSibling) {
            const t3 = i2.localName;
            !Xy.includes(i2.namespaceURI) || "Document" != t3 && "Folder" != t3 && "kml" != t3 || c(e2, this.readRegionFromNode(i2));
          }
          return e2;
        }
        writeFeaturesNode(t2, e2) {
          e2 = this.adaptOptions(e2);
          const i2 = du(Xy[4], "kml"), n2 = "http://www.w3.org/2000/xmlns/";
          i2.setAttributeNS(n2, "xmlns:gx", zy[0]), i2.setAttributeNS(n2, "xmlns:xsi", uu), i2.setAttributeNS(uu, "xsi:schemaLocation", "http://www.opengis.net/kml/2.2 https://developers.google.com/kml/schema/kml22gx.xsd");
          const r2 = { node: i2 }, s2 = {};
          t2.length > 1 ? s2.Document = t2 : 1 == t2.length && (s2.Placemark = t2[0]);
          const o2 = qy[i2.namespaceURI], a2 = Ru(s2, o2);
          return Fu(r2, Hy, bu, a2, [e2], o2, this), i2;
        }
      }, _T.format.KML.getDefaultFillStyle = function() {
        return nx;
      }, _T.format.KML.getDefaultImageStyle = function() {
        return sx;
      }, _T.format.KML.getDefaultStrokeStyle = function() {
        return ax;
      }, _T.format.KML.getDefaultStyle = function() {
        return hx;
      }, _T.format.KML.getDefaultStyleArray = function() {
        return ux;
      }, _T.format.KML.getDefaultTextStyle = function() {
        return lx;
      }, _T.format.KML.readFlatCoordinates = mx, _T.format.MVT = Em, _T.format.OSMXML = class extends M_ {
        constructor() {
          super(), this.dataProjection = Ui("EPSG:4326");
        }
        readFeaturesFromNode(t2, e2) {
          if (e2 = this.getReadOptions(t2, e2), "osm" == t2.localName) {
            const i2 = Lu({ nodes: {}, ways: [], features: [] }, Xv, t2, [e2]);
            for (let t3 = 0; t3 < i2.ways.length; t3++) {
              const n2 = i2.ways[t3], r2 = [];
              for (let t4 = 0, e3 = n2.ndrefs.length; t4 < e3; t4++) {
                c(r2, i2.nodes[n2.ndrefs[t4]]);
              }
              let s2;
              s2 = n2.ndrefs[0] == n2.ndrefs[n2.ndrefs.length - 1] ? new ur(r2, "XY", [r2.length]) : new Op(r2, "XY"), Qp(s2, false, e2);
              const o2 = new lt(s2);
              void 0 !== n2.id && o2.setId(n2.id), o2.setProperties(n2.tags, true), i2.features.push(o2);
            }
            if (i2.features)
              return i2.features;
          }
          return [];
        }
      }, _T.format.OWS = Hv, _T.format.Polyline = class extends Dy {
        constructor(t2) {
          super(), t2 = t2 || {}, this.dataProjection = Ui("EPSG:4326"), this.factor_ = t2.factor ? t2.factor : 1e5, this.geometryLayout_ = t2.geometryLayout ? t2.geometryLayout : "XY";
        }
        readFeatureFromText(t2, e2) {
          const i2 = this.readGeometryFromText(t2, e2);
          return new lt(i2);
        }
        readFeaturesFromText(t2, e2) {
          return [this.readFeatureFromText(t2, e2)];
        }
        readGeometryFromText(t2, e2) {
          const i2 = yn(this.geometryLayout_), n2 = uS(t2, i2, this.factor_);
          w_(n2, 0, n2.length, i2, n2);
          const r2 = Gn(n2, 0, n2.length, i2);
          return Qp(new Op(r2, this.geometryLayout_), false, this.adaptOptions(e2));
        }
        writeFeatureText(t2, e2) {
          const i2 = t2.getGeometry();
          return i2 ? this.writeGeometryText(i2, e2) : (at(false, 40), "");
        }
        writeFeaturesText(t2, e2) {
          return this.writeFeatureText(t2[0], e2);
        }
        writeGeometryText(t2, e2) {
          const i2 = (t2 = Qp(t2, true, this.adaptOptions(e2))).getFlatCoordinates(), n2 = t2.getStride();
          return w_(i2, 0, i2.length, n2, i2), cS(i2, n2, this.factor_);
        }
      }, _T.format.Polyline.decodeDeltas = uS, _T.format.Polyline.decodeFloats = gS, _T.format.Polyline.decodeSignedIntegers = pS, _T.format.Polyline.decodeUnsignedIntegers = _S, _T.format.Polyline.encodeDeltas = cS, _T.format.Polyline.encodeFloats = dS, _T.format.Polyline.encodeSignedIntegers = fS, _T.format.Polyline.encodeUnsignedInteger = yS, _T.format.Polyline.encodeUnsignedIntegers = mS, _T.format.TextFeature = Dy, _T.format.TopoJSON = class extends E_ {
        constructor(t2) {
          super(), t2 = t2 || {}, this.layerName_ = t2.layerName, this.layers_ = t2.layers ? t2.layers : null, this.dataProjection = Ui(t2.dataProjection ? t2.dataProjection : "EPSG:4326");
        }
        readFeaturesFromObject(t2, e2) {
          if ("Topology" == t2.type) {
            const i2 = t2;
            let n2, r2 = null, s2 = null;
            i2.transform && (n2 = i2.transform, r2 = n2.scale, s2 = n2.translate);
            const o2 = i2.arcs;
            n2 && function(t3, e3, i3) {
              for (let n3 = 0, r3 = t3.length; n3 < r3; ++n3)
                ES(t3[n3], e3, i3);
            }(o2, r2, s2);
            const a2 = [], l2 = i2.objects, h2 = this.layerName_;
            let c2;
            for (const t3 in l2)
              this.layers_ && !this.layers_.includes(t3) || ("GeometryCollection" === l2[t3].type ? (c2 = l2[t3], a2.push.apply(a2, SS(c2, o2, r2, s2, h2, t3, e2))) : (c2 = l2[t3], a2.push(wS(c2, o2, r2, s2, h2, t3, e2))));
            return a2;
          }
          return [];
        }
        readProjectionFromObject(t2) {
          return this.dataProjection;
        }
      }, _T.format.WFS = class extends M_ {
        constructor(t2) {
          super(), t2 = t2 || {}, this.version_ = t2.version ? t2.version : "1.1.0", this.featureType_ = t2.featureType, this.featureNS_ = t2.featureNS, this.gmlFormat_ = t2.gmlFormat ? t2.gmlFormat : new hw[this.version_](), this.schemaLocation_ = t2.schemaLocation ? t2.schemaLocation : lw[this.version_];
        }
        getFeatureType() {
          return this.featureType_;
        }
        setFeatureType(t2) {
          this.featureType_ = t2;
        }
        readFeaturesFromNode(t2, e2) {
          const i2 = { node: t2 };
          Object.assign(i2, { featureType: this.featureType_, featureNS: this.featureNS_ }), Object.assign(i2, this.getReadOptions(t2, e2 || {}));
          const n2 = [i2];
          let r2;
          r2 = "2.0.0" === this.version_ ? JS : this.gmlFormat_.FEATURE_COLLECTION_PARSERS;
          let s2 = Lu([], r2, t2, n2, this.gmlFormat_);
          return s2 || (s2 = []), s2;
        }
        readTransactionResponse(t2) {
          if (t2) {
            if ("string" == typeof t2) {
              const e2 = _u(t2);
              return this.readTransactionResponseFromDocument(e2);
            }
            return pu(t2) ? this.readTransactionResponseFromDocument(t2) : this.readTransactionResponseFromNode(t2);
          }
        }
        readFeatureCollectionMetadata(t2) {
          if (t2) {
            if ("string" == typeof t2) {
              const e2 = _u(t2);
              return this.readFeatureCollectionMetadataFromDocument(e2);
            }
            return pu(t2) ? this.readFeatureCollectionMetadataFromDocument(t2) : this.readFeatureCollectionMetadataFromNode(t2);
          }
        }
        readFeatureCollectionMetadataFromDocument(t2) {
          for (let e2 = t2.firstChild; e2; e2 = e2.nextSibling)
            if (e2.nodeType == Node.ELEMENT_NODE)
              return this.readFeatureCollectionMetadataFromNode(e2);
        }
        readFeatureCollectionMetadataFromNode(t2) {
          const e2 = {}, i2 = U_(t2.getAttribute("numberOfFeatures"));
          return e2.numberOfFeatures = i2, Lu(e2, JS, t2, [], this.gmlFormat_);
        }
        readTransactionResponseFromDocument(t2) {
          for (let e2 = t2.firstChild; e2; e2 = e2.nextSibling)
            if (e2.nodeType == Node.ELEMENT_NODE)
              return this.readTransactionResponseFromNode(e2);
        }
        readTransactionResponseFromNode(t2) {
          return Lu({}, tw, t2, []);
        }
        writeGetFeature(t2) {
          const e2 = du(ow[this.version_], "GetFeature");
          e2.setAttribute("service", "WFS"), e2.setAttribute("version", this.version_), t2.handle && e2.setAttribute("handle", t2.handle), t2.outputFormat && e2.setAttribute("outputFormat", t2.outputFormat), void 0 !== t2.maxFeatures && e2.setAttribute("maxFeatures", String(t2.maxFeatures)), t2.resultType && e2.setAttribute("resultType", t2.resultType), void 0 !== t2.startIndex && e2.setAttribute("startIndex", String(t2.startIndex)), void 0 !== t2.count && e2.setAttribute("count", String(t2.count)), void 0 !== t2.viewParams && e2.setAttribute("viewParams", t2.viewParams), e2.setAttributeNS(uu, "xsi:schemaLocation", this.schemaLocation_);
          const i2 = { node: e2 };
          if (Object.assign(i2, { version: this.version_, srsName: t2.srsName, featureNS: t2.featureNS ? t2.featureNS : this.featureNS_, featurePrefix: t2.featurePrefix, propertyNames: t2.propertyNames ? t2.propertyNames : [] }), at(Array.isArray(t2.featureTypes), 11), "string" == typeof t2.featureTypes[0]) {
            let n2 = t2.filter;
            t2.bbox && (at(t2.geometryName, 12), n2 = this.combineBboxAndFilter(t2.geometryName, t2.bbox, t2.srsName, n2)), Object.assign(i2, { geometryName: t2.geometryName, filter: n2 }), Bw(e2, t2.featureTypes, [i2]);
          } else
            t2.featureTypes.forEach((n2) => {
              const r2 = this.combineBboxAndFilter(n2.geometryName, n2.bbox, t2.srsName, t2.filter);
              Object.assign(i2, { geometryName: n2.geometryName, filter: r2 }), Bw(e2, [n2.name], [i2]);
            });
          return e2;
        }
        combineBboxAndFilter(t2, e2, i2, n2) {
          const r2 = $S(t2, e2, i2);
          return n2 ? HS(n2, r2) : r2;
        }
        writeTransaction(t2, e2, i2, n2) {
          const r2 = [], s2 = n2.version ? n2.version : this.version_, o2 = du(ow[s2], "Transaction");
          let a2;
          o2.setAttribute("service", "WFS"), o2.setAttribute("version", s2), n2 && (a2 = n2.gmlOptions ? n2.gmlOptions : {}, n2.handle && o2.setAttribute("handle", n2.handle)), o2.setAttributeNS(uu, "xsi:schemaLocation", lw[s2]);
          const l2 = function(t3, e3, i3, n3) {
            const r3 = n3.featurePrefix ? n3.featurePrefix : nw;
            let s3;
            "1.0.0" === i3 ? s3 = 2 : "1.1.0" === i3 ? s3 = 3 : "2.0.0" === i3 && (s3 = 3.2);
            return Object.assign({ node: t3 }, { version: i3, featureNS: n3.featureNS, featureType: n3.featureType, featurePrefix: r3, gmlVersion: s3, hasZ: n3.hasZ, srsName: n3.srsName }, e3);
          }(o2, a2, s2, n2);
          return t2 && cw("Insert", t2, r2, l2), e2 && cw("Update", e2, r2, l2), i2 && cw("Delete", i2, r2, l2), n2.nativeElements && cw("Native", n2.nativeElements, r2, l2), o2;
        }
        readProjectionFromDocument(t2) {
          for (let e2 = t2.firstChild; e2; e2 = e2.nextSibling)
            if (e2.nodeType == Node.ELEMENT_NODE)
              return this.readProjectionFromNode(e2);
          return null;
        }
        readProjectionFromNode(t2) {
          if (t2.firstElementChild && t2.firstElementChild.firstElementChild) {
            for (let e2 = (t2 = t2.firstElementChild.firstElementChild).firstElementChild; e2; e2 = e2.nextElementSibling)
              if (0 !== e2.childNodes.length && (1 !== e2.childNodes.length || 3 !== e2.firstChild.nodeType)) {
                const t3 = [{}];
                return this.gmlFormat_.readGeometryElement(e2, t3), Ui(t3.pop().srsName);
              }
          }
          return null;
        }
      }, _T.format.WFS.writeFilter = function(t2, e2) {
        const i2 = du(Uw(e2 = e2 || "1.1.0"), "Filter"), n2 = { node: i2 };
        return Object.assign(n2, { version: e2, filter: t2 }), Cw(i2, t2, [n2]), i2;
      }, _T.format.WKB = class extends Jp {
        constructor(t2) {
          super(), t2 = t2 || {}, this.splitCollection = Boolean(t2.splitCollection), this.viewCache_ = null, this.hex_ = false !== t2.hex, this.littleEndian_ = false !== t2.littleEndian, this.ewkb_ = false !== t2.ewkb, this.layout_ = t2.geometryLayout, this.nodataZ_ = t2.nodataZ || 0, this.nodataM_ = t2.nodataM || 0, this.srid_ = t2.srid;
        }
        getType() {
          return this.hex_ ? "text" : "arraybuffer";
        }
        readFeature(t2, e2) {
          return new lt({ geometry: this.readGeometry(t2, e2) });
        }
        readFeatures(t2, e2) {
          let i2 = [];
          const n2 = this.readGeometry(t2, e2);
          return i2 = this.splitCollection && n2 instanceof Ip ? n2.getGeometriesArray() : [n2], i2.map((t3) => new lt({ geometry: t3 }));
        }
        readGeometry(t2, e2) {
          const i2 = tE(t2);
          if (!i2)
            return null;
          const n2 = new Jw(i2).readGeometry();
          return this.viewCache_ = i2, e2 = this.getReadOptions(t2, e2), this.viewCache_ = null, Qp(n2, false, e2);
        }
        readProjection(t2) {
          const e2 = this.viewCache_ || tE(t2);
          if (!e2)
            return;
          const i2 = new Jw(e2);
          return i2.readWkbHeader(), i2.getSrid() && Ui("EPSG:" + i2.getSrid()) || void 0;
        }
        writeFeature(t2, e2) {
          return this.writeGeometry(t2.getGeometry(), e2);
        }
        writeFeatures(t2, e2) {
          return this.writeGeometry(new Ip(t2.map((t3) => t3.getGeometry())), e2);
        }
        writeGeometry(t2, e2) {
          e2 = this.adaptOptions(e2);
          const i2 = new Qw({ layout: this.layout_, littleEndian: this.littleEndian_, ewkb: this.ewkb_, nodata: { Z: this.nodataZ_, M: this.nodataM_ } });
          let n2 = Number.isInteger(this.srid_) ? Number(this.srid_) : null;
          if (false !== this.srid_ && !Number.isInteger(this.srid_)) {
            const t3 = e2.dataProjection && Ui(e2.dataProjection);
            if (t3) {
              const e3 = t3.getCode();
              e3.startsWith("EPSG:") && (n2 = Number(e3.substring(5)));
            }
          }
          i2.writeGeometry(Qp(t2, true, e2), n2);
          const r2 = i2.getBuffer();
          return this.hex_ ? function(t3) {
            const e3 = new Uint8Array(t3);
            return Array.from(e3.values()).map((t4) => (t4 < 16 ? "0" : "") + Number(t4).toString(16).toUpperCase()).join("");
          }(r2) : r2;
        }
      }, _T.format.WKT = class extends Dy {
        constructor(t2) {
          super(), t2 = t2 || {}, this.splitCollection_ = void 0 !== t2.splitCollection && t2.splitCollection;
        }
        parse_(t2) {
          const e2 = new uE(t2);
          return new dE(e2).parse();
        }
        readFeatureFromText(t2, e2) {
          const i2 = this.readGeometryFromText(t2, e2), n2 = new lt();
          return n2.setGeometry(i2), n2;
        }
        readFeaturesFromText(t2, e2) {
          let i2 = [];
          const n2 = this.readGeometryFromText(t2, e2);
          i2 = this.splitCollection_ && "GeometryCollection" == n2.getType() ? n2.getGeometriesArray() : [n2];
          const r2 = [];
          for (let t3 = 0, e3 = i2.length; t3 < e3; ++t3) {
            const e4 = new lt();
            e4.setGeometry(i2[t3]), r2.push(e4);
          }
          return r2;
        }
        readGeometryFromText(t2, e2) {
          return Qp(this.parse_(t2), false, e2);
        }
        writeFeatureText(t2, e2) {
          const i2 = t2.getGeometry();
          return i2 ? this.writeGeometryText(i2, e2) : "";
        }
        writeFeaturesText(t2, e2) {
          if (1 == t2.length)
            return this.writeFeatureText(t2[0], e2);
          const i2 = [];
          for (let e3 = 0, n3 = t2.length; e3 < n3; ++e3)
            i2.push(t2[e3].getGeometry());
          const n2 = new Ip(i2);
          return this.writeGeometryText(n2, e2);
        }
        writeGeometryText(t2, e2) {
          return _E(Qp(t2, true, e2));
        }
      }, _T.format.WMSCapabilities = class extends Zv {
        constructor() {
          super(), this.version = void 0;
        }
        readFromNode(t2) {
          this.version = t2.getAttribute("version").trim();
          const e2 = Lu({ version: this.version }, xE, t2, []);
          return e2 || null;
        }
      }, _T.format.WMSGetFeatureInfo = class extends M_ {
        constructor(t2) {
          super(), t2 = t2 || {}, this.featureNS_ = "http://mapserver.gis.umn.edu/mapserver", this.gmlFormat_ = new H_(), this.layers_ = t2.layers ? t2.layers : null;
        }
        getLayers() {
          return this.layers_;
        }
        setLayers(t2) {
          this.layers_ = t2;
        }
        readFeatures_(t2, e2) {
          t2.setAttribute("namespaceURI", this.featureNS_);
          const i2 = t2.localName;
          let n2 = [];
          if (0 === t2.childNodes.length)
            return n2;
          if ("msGMLOutput" == i2)
            for (let i3 = 0, r2 = t2.childNodes.length; i3 < r2; i3++) {
              const r3 = t2.childNodes[i3];
              if (r3.nodeType !== Node.ELEMENT_NODE)
                continue;
              const s2 = r3, o2 = e2[0], a2 = "_layer", l2 = s2.localName.replace(a2, "");
              if (this.layers_ && !this.layers_.includes(l2))
                continue;
              const h2 = l2 + "_feature";
              o2.featureType = h2, o2.featureNS = this.featureNS_;
              const u2 = {};
              u2[h2] = xu(this.gmlFormat_.readFeatureElement, this.gmlFormat_);
              const d2 = Pu([o2.featureNS, null], u2);
              s2.setAttribute("namespaceURI", this.featureNS_);
              const g2 = Lu([], d2, s2, e2, this.gmlFormat_);
              g2 && c(n2, g2);
            }
          if ("FeatureCollection" == i2) {
            const e3 = Lu([], this.gmlFormat_.FEATURE_COLLECTION_PARSERS, t2, [{}], this.gmlFormat_);
            e3 && (n2 = e3);
          }
          return n2;
        }
        readFeaturesFromNode(t2, e2) {
          const i2 = {};
          return e2 && Object.assign(i2, this.getReadOptions(t2, e2)), this.readFeatures_(t2, [i2]);
        }
      }, _T.format.WMTSCapabilities = class extends Zv {
        constructor() {
          super(), this.owsParser_ = new Hv();
        }
        readFromNode(t2) {
          let e2 = t2.getAttribute("version");
          e2 && (e2 = e2.trim());
          let i2 = this.owsParser_.readFromNode(t2);
          return i2 ? (i2.version = e2, i2 = Lu(i2, XE, t2, []), i2 || null) : null;
        }
      }, _T.format.XML = Zv, _T.format.XMLFeature = M_, _T.format.filter = {}, _T.format.filter.And = RS, _T.format.filter.Bbox = PS, _T.format.filter.Comparison = AS, _T.format.filter.ComparisonBinary = NS, _T.format.filter.Contains = LS, _T.format.filter.DWithin = MS, _T.format.filter.Disjoint = FS, _T.format.filter.During = OS, _T.format.filter.EqualTo = DS, _T.format.filter.Filter = CS, _T.format.filter.GreaterThan = kS, _T.format.filter.GreaterThanOrEqualTo = GS, _T.format.filter.Intersects = jS, _T.format.filter.IsBetween = BS, _T.format.filter.IsLike = US, _T.format.filter.IsNull = zS, _T.format.filter.LessThan = XS, _T.format.filter.LessThanOrEqualTo = VS, _T.format.filter.LogicalNary = bS, _T.format.filter.Not = WS, _T.format.filter.NotEqualTo = ZS, _T.format.filter.Or = YS, _T.format.filter.ResourceId = KS, _T.format.filter.Spatial = IS, _T.format.filter.Within = qS, _T.format.filter.and = HS, _T.format.filter.bbox = $S, _T.format.filter.between = function(t2, e2, i2) {
        return new BS(t2, e2, i2);
      }, _T.format.filter.contains = function(t2, e2, i2) {
        return new LS(t2, e2, i2);
      }, _T.format.filter.disjoint = function(t2, e2, i2) {
        return new FS(t2, e2, i2);
      }, _T.format.filter.during = function(t2, e2, i2) {
        return new OS(t2, e2, i2);
      }, _T.format.filter.dwithin = function(t2, e2, i2, n2, r2) {
        return new MS(t2, e2, i2, n2, r2);
      }, _T.format.filter.equalTo = function(t2, e2, i2) {
        return new DS(t2, e2, i2);
      }, _T.format.filter.greaterThan = function(t2, e2) {
        return new kS(t2, e2);
      }, _T.format.filter.greaterThanOrEqualTo = function(t2, e2) {
        return new GS(t2, e2);
      }, _T.format.filter.intersects = function(t2, e2, i2) {
        return new jS(t2, e2, i2);
      }, _T.format.filter.isNull = function(t2) {
        return new zS(t2);
      }, _T.format.filter.lessThan = function(t2, e2) {
        return new XS(t2, e2);
      }, _T.format.filter.lessThanOrEqualTo = function(t2, e2) {
        return new VS(t2, e2);
      }, _T.format.filter.like = function(t2, e2, i2, n2, r2, s2) {
        return new US(t2, e2, i2, n2, r2, s2);
      }, _T.format.filter.not = function(t2) {
        return new WS(t2);
      }, _T.format.filter.notEqualTo = function(t2, e2, i2) {
        return new ZS(t2, e2, i2);
      }, _T.format.filter.or = function(t2) {
        const e2 = [null].concat(Array.prototype.slice.call(arguments));
        return new (Function.prototype.bind.apply(YS, e2))();
      }, _T.format.filter.resourceId = function(t2) {
        return new KS(t2);
      }, _T.format.filter.within = function(t2, e2, i2) {
        return new qS(t2, e2, i2);
      }, _T.format.xlink = {}, _T.format.xlink.readHref = Yv, _T.format.xsd = {}, _T.format.xsd.readBoolean = N_, _T.format.xsd.readBooleanString = D_, _T.format.xsd.readDateTime = k_, _T.format.xsd.readDecimal = G_, _T.format.xsd.readDecimalString = j_, _T.format.xsd.readNonNegativeIntegerString = U_, _T.format.xsd.readPositiveInteger = B_, _T.format.xsd.readString = z_, _T.format.xsd.writeBooleanTextNode = X_, _T.format.xsd.writeCDATASection = V_, _T.format.xsd.writeDateTimeTextNode = W_, _T.format.xsd.writeDecimalTextNode = Z_, _T.format.xsd.writeNonNegativeIntegerTextNode = Y_, _T.format.xsd.writeStringTextNode = K_, _T.functions = {}, _T.functions.FALSE = f, _T.functions.TRUE = g, _T.functions.VOID = p, _T.functions.memoizeOne = m, _T.functions.toPromise = _, _T.geom = {}, _T.geom.Circle = Pp, _T.geom.Geometry = mn, _T.geom.GeometryCollection = Ip, _T.geom.LineString = Op, _T.geom.LinearRing = Vn, _T.geom.MultiLineString = Np, _T.geom.MultiPoint = Dp, _T.geom.MultiPolygon = Gp, _T.geom.Point = Wn, _T.geom.Polygon = ur, _T.geom.Polygon.circular = dr, _T.geom.Polygon.fromCircle = fr, _T.geom.Polygon.fromExtent = gr, _T.geom.Polygon.makeRegular = pr, _T.geom.SimpleGeometry = _n, _T.geom.SimpleGeometry.getStrideForLayout = yn, _T.geom.SimpleGeometry.transformGeom2D = xn, _T.geom.flat = {}, _T.geom.flat.area = {}, _T.geom.flat.area.linearRing = Un, _T.geom.flat.area.linearRings = zn, _T.geom.flat.area.linearRingss = Xn, _T.geom.flat.center = {}, _T.geom.flat.center.linearRingss = kp, _T.geom.flat.closest = {}, _T.geom.flat.closest.arrayMaxSquaredDelta = wn, _T.geom.flat.closest.assignClosestArrayPoint = Cn, _T.geom.flat.closest.assignClosestMultiArrayPoint = bn, _T.geom.flat.closest.assignClosestPoint = Tn, _T.geom.flat.closest.maxSquaredDelta = Sn, _T.geom.flat.closest.multiArrayMaxSquaredDelta = En, _T.geom.flat.contains = {}, _T.geom.flat.contains.linearRingContainsExtent = Zn, _T.geom.flat.contains.linearRingContainsXY = Yn, _T.geom.flat.contains.linearRingsContainsXY = Kn, _T.geom.flat.contains.linearRingssContainsXY = qn, _T.geom.flat.deflate = {}, _T.geom.flat.deflate.deflateCoordinate = Rn, _T.geom.flat.deflate.deflateCoordinates = Pn, _T.geom.flat.deflate.deflateCoordinatesArray = In, _T.geom.flat.deflate.deflateMultiCoordinatesArray = Ln, _T.geom.flat.flip = {}, _T.geom.flat.flip.flipXY = w_, _T.geom.flat.geodesic = {}, _T.geom.flat.geodesic.greatCircleArc = function(t2, e2, i2, n2, r2, s2) {
        const o2 = Ui("EPSG:4326"), a2 = Math.cos(ai(e2)), l2 = Math.sin(ai(e2)), h2 = Math.cos(ai(n2)), c2 = Math.sin(ai(n2)), u2 = Math.cos(ai(i2 - t2)), d2 = Math.sin(ai(i2 - t2)), g2 = l2 * c2 + a2 * h2 * u2;
        return Xp(function(e3) {
          if (1 <= g2)
            return [i2, n2];
          const r3 = e3 * Math.acos(g2), s3 = Math.cos(r3), o3 = Math.sin(r3), f2 = d2 * h2, p2 = a2 * c2 - l2 * h2 * u2, m2 = Math.atan2(f2, p2), _2 = Math.asin(l2 * s3 + a2 * o3 * Math.cos(m2));
          return [oi(ai(t2) + Math.atan2(Math.sin(m2) * o3 * a2, s3 - l2 * Math.sin(_2))), oi(_2)];
        }, Hi(o2, r2), s2);
      }, _T.geom.flat.geodesic.meridian = Vp, _T.geom.flat.geodesic.parallel = Wp, _T.geom.flat.inflate = {}, _T.geom.flat.inflate.inflateCoordinates = Gn, _T.geom.flat.inflate.inflateCoordinatesArray = jn, _T.geom.flat.inflate.inflateMultiCoordinatesArray = Bn, _T.geom.flat.interiorpoint = {}, _T.geom.flat.interiorpoint.getInteriorPointOfArray = Hn, _T.geom.flat.interiorpoint.getInteriorPointsOfMultiArray = $n, _T.geom.flat.interpolate = {}, _T.geom.flat.interpolate.interpolatePoint = Mp, _T.geom.flat.interpolate.lineStringCoordinateAtM = Fp, _T.geom.flat.interpolate.lineStringsCoordinateAtM = Ap, _T.geom.flat.intersectsextent = {}, _T.geom.flat.intersectsextent.intersectsLineString = Qn, _T.geom.flat.intersectsextent.intersectsLineStringArray = tr, _T.geom.flat.intersectsextent.intersectsLinearRing = er, _T.geom.flat.intersectsextent.intersectsLinearRingArray = ir, _T.geom.flat.intersectsextent.intersectsLinearRingMultiArray = nr, _T.geom.flat.length = {}, _T.geom.flat.length.lineStringLength = sp, _T.geom.flat.length.linearRingLength = function(t2, e2, i2, n2) {
        let r2 = sp(t2, e2, i2, n2);
        const s2 = t2[i2 - n2] - t2[e2], o2 = t2[i2 - n2 + 1] - t2[e2 + 1];
        return r2 += Math.sqrt(s2 * s2 + o2 * o2), r2;
      }, _T.geom.flat.orient = {}, _T.geom.flat.orient.inflateEnds = cr, _T.geom.flat.orient.linearRingIsClockwise = sr, _T.geom.flat.orient.linearRingsAreOriented = or, _T.geom.flat.orient.linearRingssAreOriented = ar, _T.geom.flat.orient.orientLinearRings = lr, _T.geom.flat.orient.orientLinearRingsArray = hr, _T.geom.flat.reverse = {}, _T.geom.flat.reverse.coordinates = rr, _T.geom.flat.segments = {}, _T.geom.flat.segments.forEach = Jn, _T.geom.flat.simplify = {}, _T.geom.flat.simplify.douglasPeucker = Mn, _T.geom.flat.simplify.douglasPeuckerArray = Fn, _T.geom.flat.simplify.douglasPeuckerMultiArray = function(t2, e2, i2, n2, r2, s2, o2, a2) {
        for (let l2 = 0, h2 = i2.length; l2 < h2; ++l2) {
          const h3 = i2[l2], c2 = [];
          o2 = Fn(t2, e2, h3, n2, r2, s2, o2, c2), a2.push(c2), e2 = h3[h3.length - 1];
        }
        return o2;
      }, _T.geom.flat.simplify.quantize = Nn, _T.geom.flat.simplify.quantizeArray = Dn, _T.geom.flat.simplify.quantizeMultiArray = kn, _T.geom.flat.simplify.radialDistance = An, _T.geom.flat.simplify.simplifyLineString = function(t2, e2, i2, n2, r2, s2, o2) {
        return o2 = void 0 !== o2 ? o2 : [], s2 || (i2 = An(t2, e2, i2, n2, r2, o2, 0), t2 = o2, e2 = 0, n2 = 2), o2.length = Mn(t2, e2, i2, n2, r2, o2, 0), o2;
      }, _T.geom.flat.simplify.snap = On, _T.geom.flat.straightchunk = {}, _T.geom.flat.straightchunk.matchingChunk = Qf, _T.geom.flat.textpath = {}, _T.geom.flat.textpath.drawTextOnPath = rp, _T.geom.flat.topology = {}, _T.geom.flat.topology.lineStringIsClosed = function(t2, e2, i2, n2) {
        const r2 = i2 - n2;
        return t2[e2] === t2[r2] && t2[e2 + 1] === t2[r2 + 1] && (i2 - e2) / n2 > 3 && !!Un(t2, e2, i2, n2);
      }, _T.geom.flat.transform = {}, _T.geom.flat.transform.rotate = dn, _T.geom.flat.transform.scale = gn, _T.geom.flat.transform.transform2D = un, _T.geom.flat.transform.translate = fn, _T.has = {}, _T.has.DEVICE_PIXEL_RATIO = mt, _T.has.FIREFOX = ut, _T.has.IMAGE_DECODE = yt, _T.has.MAC = pt, _T.has.PASSIVE_EVENT_LISTENERS = xt, _T.has.SAFARI = dt, _T.has.SAFARI_BUG_237906 = gt, _T.has.WEBKIT = ft, _T.has.WORKER_OFFSCREEN_CANVAS = _t, _T.interaction = {}, _T.interaction.DoubleClickZoom = ra, _T.interaction.DragAndDrop = class extends ea {
        constructor(t2) {
          t2 = t2 || {}, super({ handleEvent: g }), this.on, this.once, this.un, this.readAsBuffer_ = false, this.formats_ = [];
          const e2 = t2.formatConstructors ? t2.formatConstructors : [];
          for (let t3 = 0, i2 = e2.length; t3 < i2; ++t3) {
            let i3 = e2[t3];
            "function" == typeof i3 && (i3 = new i3()), this.formats_.push(i3), this.readAsBuffer_ = this.readAsBuffer_ || "arraybuffer" === i3.getType();
          }
          this.projection_ = t2.projection ? Ui(t2.projection) : null, this.dropListenKeys_ = null, this.source_ = t2.source || null, this.target = t2.target ? t2.target : null;
        }
        handleResult_(t2, e2) {
          const i2 = e2.target.result, n2 = this.getMap();
          let r2, s2 = this.projection_;
          if (!s2 && (s2 = en(), !s2)) {
            s2 = n2.getView().getProjection();
          }
          const o2 = this.formats_;
          for (let e3 = 0, n3 = o2.length; e3 < n3; ++e3) {
            const n4 = o2[e3];
            let a2 = i2;
            this.readAsBuffer_ && "arraybuffer" !== n4.getType() && (void 0 === r2 && (r2 = new TextDecoder().decode(i2)), a2 = r2);
            const l2 = this.tryReadFeatures_(n4, a2, { featureProjection: s2 });
            if (l2 && l2.length > 0) {
              this.source_ && (this.source_.clear(), this.source_.addFeatures(l2)), this.dispatchEvent(new Am(Fm, t2, l2, s2));
              break;
            }
          }
        }
        registerListeners_() {
          const t2 = this.getMap();
          if (t2) {
            const e2 = this.target ? this.target : t2.getViewport();
            this.dropListenKeys_ = [N(e2, P, this.handleDrop, this), N(e2, b, this.handleStop, this), N(e2, R, this.handleStop, this), N(e2, P, this.handleStop, this)];
          }
        }
        setActive(t2) {
          !this.getActive() && t2 && this.registerListeners_(), this.getActive() && !t2 && this.unregisterListeners_(), super.setActive(t2);
        }
        setMap(t2) {
          this.unregisterListeners_(), super.setMap(t2), this.getActive() && this.registerListeners_();
        }
        tryReadFeatures_(t2, e2, i2) {
          try {
            return t2.readFeatures(e2, i2);
          } catch (t3) {
            return null;
          }
        }
        unregisterListeners_() {
          this.dropListenKeys_ && (this.dropListenKeys_.forEach(k), this.dropListenKeys_ = null);
        }
        handleDrop(t2) {
          const e2 = t2.dataTransfer.files;
          for (let t3 = 0, i2 = e2.length; t3 < i2; ++t3) {
            const i3 = e2.item(t3), n2 = new FileReader();
            n2.addEventListener(M, this.handleResult_.bind(this, i3)), this.readAsBuffer_ ? n2.readAsArrayBuffer(i3) : n2.readAsText(i3);
          }
        }
        handleStop(t2) {
          t2.stopPropagation(), t2.preventDefault(), t2.dataTransfer.dropEffect = "copy";
        }
      }, _T.interaction.DragAndDrop.DragAndDropEvent = Am, _T.interaction.DragBox = Ia, _T.interaction.DragBox.DragBoxEvent = Pa, _T.interaction.DragPan = Sa, _T.interaction.DragRotate = wa, _T.interaction.DragRotateAndZoom = class extends sa {
        constructor(t2) {
          super(t2 = t2 || {}), this.condition_ = t2.condition ? t2.condition : _a, this.lastAngle_ = void 0, this.lastMagnitude_ = void 0, this.lastScaleDelta_ = 0, this.duration_ = void 0 !== t2.duration ? t2.duration : 400;
        }
        handleDragEvent(t2) {
          if (!xa(t2))
            return;
          const e2 = t2.map, i2 = e2.getSize(), n2 = t2.pixel, r2 = n2[0] - i2[0] / 2, s2 = i2[1] / 2 - n2[1], o2 = Math.atan2(s2, r2), a2 = Math.sqrt(r2 * r2 + s2 * s2), l2 = e2.getView();
          if (void 0 !== this.lastAngle_) {
            const t3 = this.lastAngle_ - o2;
            l2.adjustRotationInternal(t3);
          }
          this.lastAngle_ = o2, void 0 !== this.lastMagnitude_ && l2.adjustResolutionInternal(this.lastMagnitude_ / a2), void 0 !== this.lastMagnitude_ && (this.lastScaleDelta_ = this.lastMagnitude_ / a2), this.lastMagnitude_ = a2;
        }
        handleUpEvent(t2) {
          if (!xa(t2))
            return true;
          const e2 = t2.map.getView(), i2 = this.lastScaleDelta_ > 1 ? 1 : -1;
          return e2.endInteraction(this.duration_, i2), this.lastScaleDelta_ = 0, false;
        }
        handleDownEvent(t2) {
          return !!xa(t2) && (!!this.condition_(t2) && (t2.map.getView().beginInteraction(), this.lastAngle_ = void 0, this.lastMagnitude_ = void 0, true));
        }
      }, _T.interaction.DragZoom = La, _T.interaction.Draw = class extends sa {
        constructor(t2) {
          const e2 = t2;
          e2.stopDown || (e2.stopDown = f), super(e2), this.on, this.once, this.un, this.shouldHandle_ = false, this.downPx_ = null, this.downTimeout_, this.lastDragTime_, this.pointerType_, this.freehand_ = false, this.source_ = t2.source ? t2.source : null, this.features_ = t2.features ? t2.features : null, this.snapTolerance_ = t2.snapTolerance ? t2.snapTolerance : 12, this.type_ = t2.type, this.mode_ = function(t3) {
            switch (t3) {
              case "Point":
              case "MultiPoint":
                return "Point";
              case "LineString":
              case "MultiLineString":
                return "LineString";
              case "Polygon":
              case "MultiPolygon":
                return "Polygon";
              case "Circle":
                return "Circle";
              default:
                throw new Error("Invalid type: " + t3);
            }
          }(this.type_), this.stopClick_ = !!t2.stopClick, this.minPoints_ = t2.minPoints ? t2.minPoints : "Polygon" === this.mode_ ? 3 : 2, this.maxPoints_ = "Circle" === this.mode_ ? 2 : t2.maxPoints ? t2.maxPoints : 1 / 0, this.finishCondition_ = t2.finishCondition ? t2.finishCondition : g, this.geometryLayout_ = t2.geometryLayout ? t2.geometryLayout : "XY";
          let i2 = t2.geometryFunction;
          if (!i2) {
            const t3 = this.mode_;
            if ("Circle" === t3)
              i2 = function(t4, e3, i3) {
                const n2 = e3 || new Pp([NaN, NaN]), r2 = rn(t4[0], i3), s2 = Ti(r2, rn(t4[t4.length - 1], i3));
                n2.setCenterAndRadius(r2, Math.sqrt(s2), this.geometryLayout_);
                const o2 = en();
                return o2 && n2.transform(i3, o2), n2;
              };
            else {
              let e3;
              "Point" === t3 ? e3 = Wn : "LineString" === t3 ? e3 = Op : "Polygon" === t3 && (e3 = ur), i2 = function(i3, n2, r2) {
                return n2 ? "Polygon" === t3 ? i3[0].length ? n2.setCoordinates([i3[0].concat([i3[0][0]])], this.geometryLayout_) : n2.setCoordinates([], this.geometryLayout_) : n2.setCoordinates(i3, this.geometryLayout_) : n2 = new e3(i3, this.geometryLayout_), n2;
              };
            }
          }
          this.geometryFunction_ = i2, this.dragVertexDelay_ = void 0 !== t2.dragVertexDelay ? t2.dragVertexDelay : 500, this.finishCoordinate_ = null, this.sketchFeature_ = null, this.sketchPoint_ = null, this.sketchCoords_ = null, this.sketchLine_ = null, this.sketchLineCoords_ = null, this.squaredClickTolerance_ = t2.clickTolerance ? t2.clickTolerance * t2.clickTolerance : 36, this.overlay_ = new zp({ source: new zh({ useSpatialIndex: false, wrapX: !!t2.wrapX && t2.wrapX }), style: t2.style ? t2.style : Ym(), updateWhileInteracting: true }), this.geometryName_ = t2.geometryName, this.condition_ = t2.condition ? t2.condition : ma, this.freehandCondition_, t2.freehand ? this.freehandCondition_ = da : this.freehandCondition_ = t2.freehandCondition ? t2.freehandCondition : _a, this.traceCondition_, this.setTrace(t2.trace || false), this.traceState_ = { active: false }, this.traceSource_ = t2.traceSource || t2.source || null, this.addChangeListener(ta, this.updateState_);
        }
        setTrace(t2) {
          let e2;
          e2 = t2 ? true === t2 ? da : t2 : fa, this.traceCondition_ = e2;
        }
        setMap(t2) {
          super.setMap(t2), this.updateState_();
        }
        getOverlay() {
          return this.overlay_;
        }
        handleEvent(t2) {
          t2.originalEvent.type === E && t2.originalEvent.preventDefault(), this.freehand_ = "Point" !== this.mode_ && this.freehandCondition_(t2);
          let e2 = t2.type === ao.POINTERMOVE, i2 = true;
          if (!this.freehand_ && this.lastDragTime_ && t2.type === ao.POINTERDRAG) {
            Date.now() - this.lastDragTime_ >= this.dragVertexDelay_ ? (this.downPx_ = t2.pixel, this.shouldHandle_ = !this.freehand_, e2 = true) : this.lastDragTime_ = void 0, this.shouldHandle_ && void 0 !== this.downTimeout_ && (clearTimeout(this.downTimeout_), this.downTimeout_ = void 0);
          }
          return this.freehand_ && t2.type === ao.POINTERDRAG && null !== this.sketchFeature_ ? (this.addToDrawing_(t2.coordinate), i2 = false) : this.freehand_ && t2.type === ao.POINTERDOWN ? i2 = false : e2 && this.getPointerCount() < 2 ? (i2 = t2.type === ao.POINTERMOVE, i2 && this.freehand_ ? (this.handlePointerMove_(t2), this.shouldHandle_ && t2.originalEvent.preventDefault()) : ("mouse" === t2.originalEvent.pointerType || t2.type === ao.POINTERDRAG && void 0 === this.downTimeout_) && this.handlePointerMove_(t2)) : t2.type === ao.DBLCLICK && (i2 = false), super.handleEvent(t2) && i2;
        }
        handleDownEvent(t2) {
          return this.shouldHandle_ = !this.freehand_, this.freehand_ ? (this.downPx_ = t2.pixel, this.finishCoordinate_ || this.startDrawing_(t2.coordinate), true) : this.condition_(t2) ? (this.lastDragTime_ = Date.now(), this.downTimeout_ = setTimeout(function() {
            this.handlePointerMove_(new oo(ao.POINTERMOVE, t2.map, t2.originalEvent, false, t2.frameState));
          }.bind(this), this.dragVertexDelay_), this.downPx_ = t2.pixel, true) : (this.lastDragTime_ = void 0, false);
        }
        deactivateTrace_() {
          this.traceState_ = { active: false };
        }
        toggleTraceState_(t2) {
          if (!this.traceSource_ || !this.traceCondition_(t2))
            return;
          if (this.traceState_.active)
            return void this.deactivateTrace_();
          const e2 = this.getMap(), i2 = zt([e2.getCoordinateFromPixel([t2.pixel[0] - this.snapTolerance_, t2.pixel[1] + this.snapTolerance_]), e2.getCoordinateFromPixel([t2.pixel[0] + this.snapTolerance_, t2.pixel[1] - this.snapTolerance_])]), n2 = this.traceSource_.getFeaturesInExtent(i2);
          if (0 === n2.length)
            return;
          const r2 = function(t3, e3) {
            const i3 = [];
            for (let n3 = 0; n3 < e3.length; ++n3)
              Um(t3, e3[n3].getGeometry(), i3);
            return i3;
          }(t2.coordinate, n2);
          r2.length && (this.traceState_ = { active: true, startPx: t2.pixel.slice(), targets: r2, targetIndex: -1 });
        }
        addOrRemoveTracedCoordinates_(t2, e2) {
          const i2 = t2.startIndex <= t2.endIndex;
          i2 === t2.startIndex <= e2 ? i2 && e2 > t2.endIndex || !i2 && e2 < t2.endIndex ? this.addTracedCoordinates_(t2, t2.endIndex, e2) : (i2 && e2 < t2.endIndex || !i2 && e2 > t2.endIndex) && this.removeTracedCoordinates_(e2, t2.endIndex) : (this.removeTracedCoordinates_(t2.startIndex, t2.endIndex), this.addTracedCoordinates_(t2, t2.startIndex, e2));
        }
        removeTracedCoordinates_(t2, e2) {
          if (t2 === e2)
            return;
          let i2 = 0;
          if (t2 < e2) {
            const n2 = Math.ceil(t2);
            let r2 = Math.floor(e2);
            r2 === e2 && (r2 -= 1), i2 = r2 - n2 + 1;
          } else {
            const n2 = Math.floor(t2);
            let r2 = Math.ceil(e2);
            r2 === e2 && (r2 += 1), i2 = n2 - r2 + 1;
          }
          i2 > 0 && this.removeLastPoints_(i2);
        }
        addTracedCoordinates_(t2, e2, i2) {
          if (e2 === i2)
            return;
          const n2 = [];
          if (e2 < i2) {
            const r2 = Math.ceil(e2);
            let s2 = Math.floor(i2);
            s2 === i2 && (s2 -= 1);
            for (let e3 = r2; e3 <= s2; ++e3)
              n2.push(jm(t2.coordinates, e3));
          } else {
            const r2 = Math.floor(e2);
            let s2 = Math.ceil(i2);
            s2 === i2 && (s2 += 1);
            for (let e3 = r2; e3 >= s2; --e3)
              n2.push(jm(t2.coordinates, e3));
          }
          n2.length && this.appendCoordinates(n2);
        }
        updateTrace_(t2) {
          const e2 = this.traceState_;
          if (!e2.active)
            return;
          if (-1 === e2.targetIndex && Ci(e2.startPx, t2.pixel) < this.snapTolerance_)
            return;
          const i2 = function(t3, e3, i3, n3) {
            const r3 = t3[0], s3 = t3[1];
            let o2 = 1 / 0, a2 = -1, l2 = NaN;
            for (let t4 = 0; t4 < e3.targets.length; ++t4) {
              const i4 = e3.targets[t4], n4 = i4.coordinates;
              let h3, c3 = 1 / 0;
              for (let t5 = 0; t5 < n4.length - 1; ++t5) {
                const e4 = Wm(r3, s3, n4[t5], n4[t5 + 1]);
                e4.squaredDistance < c3 && (c3 = e4.squaredDistance, h3 = t5 + e4.along);
              }
              c3 < o2 && (o2 = c3, i4.ring && e3.targetIndex === t4 && (i4.endIndex > i4.startIndex ? h3 < i4.startIndex && (h3 += n4.length) : i4.endIndex < i4.startIndex && h3 > i4.startIndex && (h3 -= n4.length)), l2 = h3, a2 = t4);
            }
            const h2 = e3.targets[a2];
            let c2 = h2.ring;
            if (e3.targetIndex === a2 && c2) {
              const t4 = Zm(h2.coordinates, l2);
              Ci(i3.getPixelFromCoordinate(t4), e3.startPx) > n3 && (c2 = false);
            }
            if (c2) {
              const t4 = h2.coordinates, e4 = t4.length, i4 = h2.startIndex, n4 = l2;
              if (i4 < n4) {
                const r4 = Bm(t4, i4, n4);
                Bm(t4, i4, n4 - e4) < r4 && (l2 -= e4);
              } else {
                const r4 = Bm(t4, i4, n4);
                Bm(t4, i4, n4 + e4) < r4 && (l2 += e4);
              }
            }
            return zm.index = a2, zm.endIndex = l2, zm;
          }(t2.coordinate, e2, this.getMap(), this.snapTolerance_);
          if (e2.targetIndex !== i2.index) {
            if (-1 !== e2.targetIndex) {
              const t4 = e2.targets[e2.targetIndex];
              this.removeTracedCoordinates_(t4.startIndex, t4.endIndex);
            }
            const t3 = e2.targets[i2.index];
            this.addTracedCoordinates_(t3, t3.startIndex, i2.endIndex);
          } else {
            const t3 = e2.targets[e2.targetIndex];
            this.addOrRemoveTracedCoordinates_(t3, i2.endIndex);
          }
          e2.targetIndex = i2.index;
          const n2 = e2.targets[e2.targetIndex];
          n2.endIndex = i2.endIndex;
          const r2 = Zm(n2.coordinates, n2.endIndex), s2 = this.getMap().getPixelFromCoordinate(r2);
          t2.coordinate = r2, t2.pixel = [Math.round(s2[0]), Math.round(s2[1])];
        }
        handleUpEvent(t2) {
          let e2 = true;
          if (0 === this.getPointerCount()) {
            this.downTimeout_ && (clearTimeout(this.downTimeout_), this.downTimeout_ = void 0), this.handlePointerMove_(t2);
            const i2 = this.traceState_.active;
            if (this.toggleTraceState_(t2), this.shouldHandle_) {
              const n2 = !this.finishCoordinate_;
              n2 && this.startDrawing_(t2.coordinate), !n2 && this.freehand_ ? this.finishDrawing() : this.freehand_ || n2 && "Point" !== this.mode_ || (this.atFinish_(t2.pixel, i2) ? this.finishCondition_(t2) && this.finishDrawing() : this.addToDrawing_(t2.coordinate)), e2 = false;
            } else
              this.freehand_ && this.abortDrawing();
          }
          return !e2 && this.stopClick_ && t2.preventDefault(), e2;
        }
        handlePointerMove_(t2) {
          if (this.pointerType_ = t2.originalEvent.pointerType, this.downPx_ && (!this.freehand_ && this.shouldHandle_ || this.freehand_ && !this.shouldHandle_)) {
            const e2 = this.downPx_, i2 = t2.pixel, n2 = e2[0] - i2[0], r2 = e2[1] - i2[1], s2 = n2 * n2 + r2 * r2;
            if (this.shouldHandle_ = this.freehand_ ? s2 > this.squaredClickTolerance_ : s2 <= this.squaredClickTolerance_, !this.shouldHandle_)
              return;
          }
          this.finishCoordinate_ ? (this.updateTrace_(t2), this.modifyDrawing_(t2.coordinate)) : this.createOrUpdateSketchPoint_(t2.coordinate.slice());
        }
        atFinish_(t2, e2) {
          let i2 = false;
          if (this.sketchFeature_) {
            let n2 = false, r2 = [this.finishCoordinate_];
            const s2 = this.mode_;
            if ("Point" === s2)
              i2 = true;
            else if ("Circle" === s2)
              i2 = 2 === this.sketchCoords_.length;
            else if ("LineString" === s2)
              n2 = !e2 && this.sketchCoords_.length > this.minPoints_;
            else if ("Polygon" === s2) {
              const t3 = this.sketchCoords_;
              n2 = t3[0].length > this.minPoints_, r2 = [t3[0][0], t3[0][t3[0].length - 2]], r2 = e2 ? [t3[0][0]] : [t3[0][0], t3[0][t3[0].length - 2]];
            }
            if (n2) {
              const e3 = this.getMap();
              for (let n3 = 0, s3 = r2.length; n3 < s3; n3++) {
                const s4 = r2[n3], o2 = e3.getPixelFromCoordinate(s4), a2 = t2[0] - o2[0], l2 = t2[1] - o2[1], h2 = this.freehand_ ? 1 : this.snapTolerance_;
                if (i2 = Math.sqrt(a2 * a2 + l2 * l2) <= h2, i2) {
                  this.finishCoordinate_ = s4;
                  break;
                }
              }
            }
          }
          return i2;
        }
        createOrUpdateSketchPoint_(t2) {
          if (this.sketchPoint_) {
            this.sketchPoint_.getGeometry().setCoordinates(t2);
          } else
            this.sketchPoint_ = new lt(new Wn(t2)), this.updateSketchFeatures_();
        }
        createOrUpdateCustomSketchLine_(t2) {
          this.sketchLine_ || (this.sketchLine_ = new lt());
          const e2 = t2.getLinearRing(0);
          let i2 = this.sketchLine_.getGeometry();
          i2 ? (i2.setFlatCoordinates(e2.getLayout(), e2.getFlatCoordinates()), i2.changed()) : (i2 = new Op(e2.getFlatCoordinates(), e2.getLayout()), this.sketchLine_.setGeometry(i2));
        }
        startDrawing_(t2) {
          const e2 = this.getMap().getView().getProjection(), i2 = yn(this.geometryLayout_);
          for (; t2.length < i2; )
            t2.push(0);
          this.finishCoordinate_ = t2, "Point" === this.mode_ ? this.sketchCoords_ = t2.slice() : "Polygon" === this.mode_ ? (this.sketchCoords_ = [[t2.slice(), t2.slice()]], this.sketchLineCoords_ = this.sketchCoords_[0]) : this.sketchCoords_ = [t2.slice(), t2.slice()], this.sketchLineCoords_ && (this.sketchLine_ = new lt(new Op(this.sketchLineCoords_)));
          const n2 = this.geometryFunction_(this.sketchCoords_, void 0, e2);
          this.sketchFeature_ = new lt(), this.geometryName_ && this.sketchFeature_.setGeometryName(this.geometryName_), this.sketchFeature_.setGeometry(n2), this.updateSketchFeatures_(), this.dispatchEvent(new km(Om, this.sketchFeature_));
        }
        modifyDrawing_(t2) {
          const e2 = this.getMap(), i2 = this.sketchFeature_.getGeometry(), n2 = e2.getView().getProjection(), r2 = yn(this.geometryLayout_);
          let s2, o2;
          for (; t2.length < r2; )
            t2.push(0);
          if ("Point" === this.mode_ ? o2 = this.sketchCoords_ : "Polygon" === this.mode_ ? (s2 = this.sketchCoords_[0], o2 = s2[s2.length - 1], this.atFinish_(e2.getPixelFromCoordinate(t2)) && (t2 = this.finishCoordinate_.slice())) : (s2 = this.sketchCoords_, o2 = s2[s2.length - 1]), o2[0] = t2[0], o2[1] = t2[1], this.geometryFunction_(this.sketchCoords_, i2, n2), this.sketchPoint_) {
            this.sketchPoint_.getGeometry().setCoordinates(t2);
          }
          if ("Polygon" === i2.getType() && "Polygon" !== this.mode_)
            this.createOrUpdateCustomSketchLine_(i2);
          else if (this.sketchLineCoords_) {
            this.sketchLine_.getGeometry().setCoordinates(this.sketchLineCoords_);
          }
          this.updateSketchFeatures_();
        }
        addToDrawing_(t2) {
          const e2 = this.sketchFeature_.getGeometry(), i2 = this.getMap().getView().getProjection();
          let n2, r2;
          const s2 = this.mode_;
          "LineString" === s2 || "Circle" === s2 ? (this.finishCoordinate_ = t2.slice(), r2 = this.sketchCoords_, r2.length >= this.maxPoints_ && (this.freehand_ ? r2.pop() : n2 = true), r2.push(t2.slice()), this.geometryFunction_(r2, e2, i2)) : "Polygon" === s2 && (r2 = this.sketchCoords_[0], r2.length >= this.maxPoints_ && (this.freehand_ ? r2.pop() : n2 = true), r2.push(t2.slice()), n2 && (this.finishCoordinate_ = r2[0]), this.geometryFunction_(this.sketchCoords_, e2, i2)), this.createOrUpdateSketchPoint_(t2.slice()), this.updateSketchFeatures_(), n2 && this.finishDrawing();
        }
        removeLastPoints_(t2) {
          if (!this.sketchFeature_)
            return;
          const e2 = this.sketchFeature_.getGeometry(), i2 = this.getMap().getView().getProjection(), n2 = this.mode_;
          for (let r2 = 0; r2 < t2; ++r2) {
            let t3;
            if ("LineString" === n2 || "Circle" === n2) {
              if (t3 = this.sketchCoords_, t3.splice(-2, 1), t3.length >= 2) {
                this.finishCoordinate_ = t3[t3.length - 2].slice();
                const e3 = this.finishCoordinate_.slice();
                t3[t3.length - 1] = e3, this.createOrUpdateSketchPoint_(e3);
              }
              this.geometryFunction_(t3, e2, i2), "Polygon" === e2.getType() && this.sketchLine_ && this.createOrUpdateCustomSketchLine_(e2);
            } else if ("Polygon" === n2) {
              t3 = this.sketchCoords_[0], t3.splice(-2, 1);
              const n3 = this.sketchLine_.getGeometry();
              if (t3.length >= 2) {
                const e3 = t3[t3.length - 2].slice();
                t3[t3.length - 1] = e3, this.createOrUpdateSketchPoint_(e3);
              }
              n3.setCoordinates(t3), this.geometryFunction_(this.sketchCoords_, e2, i2);
            }
            if (1 === t3.length) {
              this.abortDrawing();
              break;
            }
          }
          this.updateSketchFeatures_();
        }
        removeLastPoint() {
          this.removeLastPoints_(1);
        }
        finishDrawing() {
          const t2 = this.abortDrawing_();
          if (!t2)
            return;
          let e2 = this.sketchCoords_;
          const i2 = t2.getGeometry(), n2 = this.getMap().getView().getProjection();
          "LineString" === this.mode_ ? (e2.pop(), this.geometryFunction_(e2, i2, n2)) : "Polygon" === this.mode_ && (e2[0].pop(), this.geometryFunction_(e2, i2, n2), e2 = i2.getCoordinates()), "MultiPoint" === this.type_ ? t2.setGeometry(new Dp([e2])) : "MultiLineString" === this.type_ ? t2.setGeometry(new Np([e2])) : "MultiPolygon" === this.type_ && t2.setGeometry(new Gp([e2])), this.dispatchEvent(new km(Nm, t2)), this.features_ && this.features_.push(t2), this.source_ && this.source_.addFeature(t2);
        }
        abortDrawing_() {
          this.finishCoordinate_ = null;
          const t2 = this.sketchFeature_;
          return this.sketchFeature_ = null, this.sketchPoint_ = null, this.sketchLine_ = null, this.overlay_.getSource().clear(true), this.deactivateTrace_(), t2;
        }
        abortDrawing() {
          const t2 = this.abortDrawing_();
          t2 && this.dispatchEvent(new km(Dm, t2));
        }
        appendCoordinates(t2) {
          const e2 = this.mode_, i2 = !this.sketchFeature_;
          let n2;
          if (i2 && this.startDrawing_(t2[0]), "LineString" === e2 || "Circle" === e2)
            n2 = this.sketchCoords_;
          else {
            if ("Polygon" !== e2)
              return;
            n2 = this.sketchCoords_ && this.sketchCoords_.length ? this.sketchCoords_[0] : [];
          }
          i2 && n2.shift(), n2.pop();
          for (let e3 = 0; e3 < t2.length; e3++)
            this.addToDrawing_(t2[e3]);
          const r2 = t2[t2.length - 1];
          this.addToDrawing_(r2), this.modifyDrawing_(r2);
        }
        extend(t2) {
          const e2 = t2.getGeometry();
          this.sketchFeature_ = t2, this.sketchCoords_ = e2.getCoordinates();
          const i2 = this.sketchCoords_[this.sketchCoords_.length - 1];
          this.finishCoordinate_ = i2.slice(), this.sketchCoords_.push(i2.slice()), this.sketchPoint_ = new lt(new Wn(i2)), this.updateSketchFeatures_(), this.dispatchEvent(new km(Om, this.sketchFeature_));
        }
        updateSketchFeatures_() {
          const t2 = [];
          this.sketchFeature_ && t2.push(this.sketchFeature_), this.sketchLine_ && t2.push(this.sketchLine_), this.sketchPoint_ && t2.push(this.sketchPoint_);
          const e2 = this.overlay_.getSource();
          e2.clear(true), e2.addFeatures(t2);
        }
        updateState_() {
          const t2 = this.getMap(), e2 = this.getActive();
          t2 && e2 || this.abortDrawing(), this.overlay_.setMap(e2 ? t2 : null);
        }
      }, _T.interaction.Draw.DrawEvent = km, _T.interaction.Draw.createBox = function() {
        return function(t2, e2, i2) {
          const n2 = zt([t2[0], t2[t2.length - 1]].map(function(t3) {
            return rn(t3, i2);
          })), r2 = [[ue(n2), de(n2), ve(n2), xe(n2), ue(n2)]];
          e2 ? e2.setCoordinates(r2) : e2 = new ur(r2);
          const s2 = en();
          return s2 && e2.transform(i2, s2), e2;
        };
      }, _T.interaction.Draw.createRegularPolygon = function(t2, e2) {
        return function(i2, n2, r2) {
          const s2 = rn(i2[0], r2), o2 = rn(i2[i2.length - 1], r2), a2 = Math.sqrt(Ti(s2, o2));
          n2 = n2 || fr(new Pp(s2), t2);
          let l2 = e2;
          if (!e2 && 0 !== e2) {
            const t3 = o2[0] - s2[0], e3 = o2[1] - s2[1];
            l2 = Math.atan2(e3, t3);
          }
          pr(n2, s2, a2, l2);
          const h2 = en();
          return h2 && n2.transform(r2, h2), n2;
        };
      }, _T.interaction.Extent = class extends sa {
        constructor(t2) {
          super(t2 = t2 || {}), this.on, this.once, this.un, this.condition_ = t2.condition ? t2.condition : da, this.extent_ = null, this.pointerHandler_ = null, this.pixelTolerance_ = void 0 !== t2.pixelTolerance ? t2.pixelTolerance : 10, this.snappedToVertex_ = false, this.extentFeature_ = null, this.vertexFeature_ = null, t2 || (t2 = {}), this.extentOverlay_ = new zp({ source: new zh({ useSpatialIndex: false, wrapX: !!t2.wrapX }), style: t2.boxStyle ? t2.boxStyle : Hm(), updateWhileAnimating: true, updateWhileInteracting: true }), this.vertexOverlay_ = new zp({ source: new zh({ useSpatialIndex: false, wrapX: !!t2.wrapX }), style: t2.pointerStyle ? t2.pointerStyle : $m(), updateWhileAnimating: true, updateWhileInteracting: true }), t2.extent && this.setExtent(t2.extent);
        }
        snapToVertex_(t2, e2) {
          const i2 = e2.getCoordinateFromPixelInternal(t2), n2 = function(t3, e3) {
            return bi(i2, t3) - bi(i2, e3);
          }, r2 = this.getExtentInternal();
          if (r2) {
            const s2 = function(t3) {
              return [[[t3[0], t3[1]], [t3[0], t3[3]]], [[t3[0], t3[3]], [t3[2], t3[3]]], [[t3[2], t3[3]], [t3[2], t3[1]]], [[t3[2], t3[1]], [t3[0], t3[1]]]];
            }(r2);
            s2.sort(n2);
            const o2 = s2[0];
            let a2 = yi(i2, o2);
            const l2 = e2.getPixelFromCoordinateInternal(a2);
            if (Ci(t2, l2) <= this.pixelTolerance_) {
              const t3 = e2.getPixelFromCoordinateInternal(o2[0]), i3 = e2.getPixelFromCoordinateInternal(o2[1]), n3 = Ti(l2, t3), r3 = Ti(l2, i3), s3 = Math.sqrt(Math.min(n3, r3));
              return this.snappedToVertex_ = s3 <= this.pixelTolerance_, this.snappedToVertex_ && (a2 = n3 > r3 ? o2[1] : o2[0]), a2;
            }
          }
          return null;
        }
        handlePointerMove_(t2) {
          const e2 = t2.pixel, i2 = t2.map;
          let n2 = this.snapToVertex_(e2, i2);
          n2 || (n2 = i2.getCoordinateFromPixelInternal(e2)), this.createOrUpdatePointerFeature_(n2);
        }
        createOrUpdateExtentFeature_(t2) {
          let e2 = this.extentFeature_;
          return e2 ? t2 ? e2.setGeometry(gr(t2)) : e2.setGeometry(void 0) : (e2 = new lt(t2 ? gr(t2) : {}), this.extentFeature_ = e2, this.extentOverlay_.getSource().addFeature(e2)), e2;
        }
        createOrUpdatePointerFeature_(t2) {
          let e2 = this.vertexFeature_;
          if (e2) {
            e2.getGeometry().setCoordinates(t2);
          } else
            e2 = new lt(new Wn(t2)), this.vertexFeature_ = e2, this.vertexOverlay_.getSource().addFeature(e2);
          return e2;
        }
        handleEvent(t2) {
          return !t2.originalEvent || !this.condition_(t2) || (t2.type != ao.POINTERMOVE || this.handlingDownUpSequence || this.handlePointerMove_(t2), super.handleEvent(t2), false);
        }
        handleDownEvent(t2) {
          const e2 = t2.pixel, i2 = t2.map, n2 = this.getExtentInternal();
          let r2 = this.snapToVertex_(e2, i2);
          const s2 = function(t3) {
            let e3 = null, i3 = null;
            return t3[0] == n2[0] ? e3 = n2[2] : t3[0] == n2[2] && (e3 = n2[0]), t3[1] == n2[1] ? i3 = n2[3] : t3[1] == n2[3] && (i3 = n2[1]), null !== e3 && null !== i3 ? [e3, i3] : null;
          };
          if (r2 && n2) {
            const t3 = r2[0] == n2[0] || r2[0] == n2[2] ? r2[0] : null, e3 = r2[1] == n2[1] || r2[1] == n2[3] ? r2[1] : null;
            null !== t3 && null !== e3 ? this.pointerHandler_ = Jm(s2(r2)) : null !== t3 ? this.pointerHandler_ = Qm(s2([t3, n2[1]]), s2([t3, n2[3]])) : null !== e3 && (this.pointerHandler_ = Qm(s2([n2[0], e3]), s2([n2[2], e3])));
          } else
            r2 = i2.getCoordinateFromPixelInternal(e2), this.setExtent([r2[0], r2[1], r2[0], r2[1]]), this.pointerHandler_ = Jm(r2);
          return true;
        }
        handleDragEvent(t2) {
          if (this.pointerHandler_) {
            const e2 = t2.coordinate;
            this.setExtent(this.pointerHandler_(e2)), this.createOrUpdatePointerFeature_(e2);
          }
        }
        handleUpEvent(t2) {
          this.pointerHandler_ = null;
          const e2 = this.getExtentInternal();
          return e2 && 0 !== ce(e2) || this.setExtent(null), false;
        }
        setMap(t2) {
          this.extentOverlay_.setMap(t2), this.vertexOverlay_.setMap(t2), super.setMap(t2);
        }
        getExtent() {
          return sn(this.getExtentInternal(), this.getMap().getView().getProjection());
        }
        getExtentInternal() {
          return this.extent_;
        }
        setExtent(t2) {
          this.extent_ = t2 || null, this.createOrUpdateExtentFeature_(t2), this.dispatchEvent(new qm(this.extent_));
        }
      }, _T.interaction.Extent.ExtentEvent = qm, _T.interaction.Interaction = ea, _T.interaction.Interaction.pan = ia, _T.interaction.Interaction.zoomByDelta = na, _T.interaction.KeyboardPan = Na, _T.interaction.KeyboardZoom = Da, _T.interaction.Link = class extends ea {
        constructor(t2) {
          let e2;
          super(), e2 = true === (t2 = Object.assign({ animate: true, replace: false, prefix: "" }, t2 || {})).animate ? { duration: 250 } : t2.animate ? t2.animate : null, this.animationOptions_ = e2, this.replace_ = t2.replace, this.prefix_ = t2.prefix, this.listenerKeys_ = [], this.initial_ = true, this.updateState_ = this.updateState_.bind(this);
        }
        getParamName_(t2) {
          return this.prefix_ ? this.prefix_ + t2 : t2;
        }
        get_(t2, e2) {
          return t2.get(this.getParamName_(e2));
        }
        set_(t2, e2, i2) {
          t2.set(this.getParamName_(e2), i2);
        }
        delete_(t2, e2) {
          t2.delete(this.getParamName_(e2));
        }
        setMap(t2) {
          const e2 = this.getMap();
          super.setMap(t2), t2 !== e2 && (e2 && this.unregisterListeners_(e2), t2 && (this.initial_ = true, this.updateState_(), this.registerListeners_(t2)));
        }
        registerListeners_(t2) {
          this.listenerKeys_.push(N(t2, mo, this.updateUrl_, this), N(t2.getLayerGroup(), S, this.updateUrl_, this), N(t2, "change:layergroup", this.handleChangeLayerGroup_, this)), this.replace_ || addEventListener("popstate", this.updateState_);
        }
        unregisterListeners_(t2) {
          for (let t3 = 0, e3 = this.listenerKeys_.length; t3 < e3; ++t3)
            k(this.listenerKeys_[t3]);
          this.listenerKeys_.length = 0, this.replace_ || removeEventListener("popstate", this.updateState_);
          const e2 = new URL(window.location.href), i2 = e2.searchParams;
          this.delete_(i2, "x"), this.delete_(i2, "y"), this.delete_(i2, "z"), this.delete_(i2, "r"), this.delete_(i2, "l"), window.history.replaceState(null, "", e2);
        }
        handleChangeLayerGroup_() {
          const t2 = this.getMap();
          t2 && (this.unregisterListeners_(t2), this.registerListeners_(t2), this.initial_ = true, this.updateUrl_());
        }
        updateState_() {
          const t2 = this.getMap();
          if (!t2)
            return;
          const e2 = t2.getView();
          if (!e2)
            return;
          const i2 = new URL(window.location.href).searchParams;
          let n2 = false;
          const r2 = {}, s2 = t_(this.get_(i2, "z"));
          i_(s2, e2.getZoom()) && (n2 = true, r2.zoom = s2);
          const o2 = t_(this.get_(i2, "r"));
          i_(o2, e2.getRotation()) && (n2 = true, r2.rotation = o2);
          const a2 = [t_(this.get_(i2, "x")), t_(this.get_(i2, "y"))];
          var l2, h2;
          l2 = a2, h2 = e2.getCenter(), (i_(l2[0], h2[0]) || i_(l2[1], h2[1])) && (n2 = true, r2.center = a2), n2 && (!this.initial_ && this.animationOptions_ ? e2.animate(Object.assign(r2, this.animationOptions_)) : (r2.center && e2.setCenter(r2.center), "zoom" in r2 && e2.setZoom(r2.zoom), "rotation" in r2 && e2.setRotation(r2.rotation)));
          const c2 = t2.getAllLayers(), u2 = this.get_(i2, "l");
          if (u2 && u2.length === c2.length)
            for (let t3 = 0, e3 = c2.length; t3 < e3; ++t3) {
              const e4 = parseInt(u2[t3]);
              if (!isNaN(e4)) {
                const i3 = Boolean(e4), n3 = c2[t3];
                n3.getVisible() !== i3 && n3.setVisible(i3);
              }
            }
        }
        updateUrl_() {
          const t2 = this.getMap();
          if (!t2)
            return;
          const e2 = t2.getView();
          if (!e2)
            return;
          const i2 = this.initial_;
          this.initial_ = false;
          const n2 = e2.getCenter(), r2 = e2.getZoom(), s2 = e2.getRotation(), o2 = t2.getAllLayers(), a2 = new Array(o2.length);
          for (let t3 = 0, e3 = o2.length; t3 < e3; ++t3)
            a2[t3] = o2[t3].getVisible() ? "1" : "0";
          const l2 = new URL(window.location.href), h2 = l2.searchParams;
          this.set_(h2, "x", e_(n2[0])), this.set_(h2, "y", e_(n2[1])), this.set_(h2, "z", e_(r2)), this.set_(h2, "r", e_(s2)), this.set_(h2, "l", a2.join("")), l2.href !== window.location.href && (i2 || this.replace_ ? window.history.replaceState(null, "", l2) : window.history.pushState(null, "", l2));
        }
      }, _T.interaction.Modify = class extends sa {
        constructor(t2) {
          let e2;
          if (super(t2), this.on, this.once, this.un, this.boundHandleFeatureChange_ = this.handleFeatureChange_.bind(this), this.condition_ = t2.condition ? t2.condition : va, this.defaultDeleteCondition_ = function(t3) {
            return la(t3) && pa(t3);
          }, this.deleteCondition_ = t2.deleteCondition ? t2.deleteCondition : this.defaultDeleteCondition_, this.insertVertexCondition_ = t2.insertVertexCondition ? t2.insertVertexCondition : da, this.vertexFeature_ = null, this.vertexSegments_ = null, this.lastPixel_ = [0, 0], this.ignoreNextSingleClick_ = false, this.featuresBeingModified_ = null, this.rBush_ = new Ah(), this.pixelTolerance_ = void 0 !== t2.pixelTolerance ? t2.pixelTolerance : 10, this.snappedToVertex_ = false, this.changingFeature_ = false, this.dragSegments_ = [], this.overlay_ = new zp({ source: new zh({ useSpatialIndex: false, wrapX: !!t2.wrapX }), style: t2.style ? t2.style : u_(), updateWhileAnimating: true, updateWhileInteracting: true }), this.SEGMENT_WRITERS_ = { Point: this.writePointGeometry_.bind(this), LineString: this.writeLineStringGeometry_.bind(this), LinearRing: this.writeLineStringGeometry_.bind(this), Polygon: this.writePolygonGeometry_.bind(this), MultiPoint: this.writeMultiPointGeometry_.bind(this), MultiLineString: this.writeMultiLineStringGeometry_.bind(this), MultiPolygon: this.writeMultiPolygonGeometry_.bind(this), Circle: this.writeCircleGeometry_.bind(this), GeometryCollection: this.writeGeometryCollectionGeometry_.bind(this) }, this.source_ = null, this.hitDetection_ = null, t2.features ? e2 = t2.features : t2.source && (this.source_ = t2.source, e2 = new q(this.source_.getFeatures()), this.source_.addEventListener(Oh, this.handleSourceAdd_.bind(this)), this.source_.addEventListener(kh, this.handleSourceRemove_.bind(this))), !e2)
            throw new Error("The modify interaction requires features, a source or a layer");
          t2.hitDetection && (this.hitDetection_ = t2.hitDetection), this.features_ = e2, this.features_.forEach(this.addFeature_.bind(this)), this.features_.addEventListener(W, this.handleFeatureAdd_.bind(this)), this.features_.addEventListener(Z, this.handleFeatureRemove_.bind(this)), this.lastPointerEvent_ = null, this.delta_ = [0, 0], this.snapToPointer_ = void 0 === t2.snapToPointer ? !this.hitDetection_ : t2.snapToPointer;
        }
        addFeature_(t2) {
          const e2 = t2.getGeometry();
          if (e2) {
            const i3 = this.SEGMENT_WRITERS_[e2.getType()];
            i3 && i3(t2, e2);
          }
          const i2 = this.getMap();
          i2 && i2.isRendered() && this.getActive() && this.handlePointerAtPixel_(this.lastPixel_, i2), t2.addEventListener(S, this.boundHandleFeatureChange_);
        }
        willModifyFeatures_(t2, e2) {
          if (!this.featuresBeingModified_) {
            this.featuresBeingModified_ = new q();
            const i2 = this.featuresBeingModified_.getArray();
            for (let t3 = 0, n2 = e2.length; t3 < n2; ++t3) {
              const n3 = e2[t3];
              for (let t4 = 0, e3 = n3.length; t4 < e3; ++t4) {
                const e4 = n3[t4].feature;
                e4 && !i2.includes(e4) && this.featuresBeingModified_.push(e4);
              }
            }
            0 === this.featuresBeingModified_.getLength() ? this.featuresBeingModified_ = null : this.dispatchEvent(new a_(s_, this.featuresBeingModified_, t2));
          }
        }
        removeFeature_(t2) {
          this.removeFeatureSegmentData_(t2), this.vertexFeature_ && 0 === this.features_.getLength() && (this.overlay_.getSource().removeFeature(this.vertexFeature_), this.vertexFeature_ = null), t2.removeEventListener(S, this.boundHandleFeatureChange_);
        }
        removeFeatureSegmentData_(t2) {
          const e2 = this.rBush_, i2 = [];
          e2.forEach(function(e3) {
            t2 === e3.feature && i2.push(e3);
          });
          for (let t3 = i2.length - 1; t3 >= 0; --t3) {
            const n2 = i2[t3];
            for (let t4 = this.dragSegments_.length - 1; t4 >= 0; --t4)
              this.dragSegments_[t4][0] === n2 && this.dragSegments_.splice(t4, 1);
            e2.remove(n2);
          }
        }
        setActive(t2) {
          this.vertexFeature_ && !t2 && (this.overlay_.getSource().removeFeature(this.vertexFeature_), this.vertexFeature_ = null), super.setActive(t2);
        }
        setMap(t2) {
          this.overlay_.setMap(t2), super.setMap(t2);
        }
        getOverlay() {
          return this.overlay_;
        }
        handleSourceAdd_(t2) {
          t2.feature && this.features_.push(t2.feature);
        }
        handleSourceRemove_(t2) {
          t2.feature && this.features_.remove(t2.feature);
        }
        handleFeatureAdd_(t2) {
          this.addFeature_(t2.element);
        }
        handleFeatureChange_(t2) {
          if (!this.changingFeature_) {
            const e2 = t2.target;
            this.removeFeature_(e2), this.addFeature_(e2);
          }
        }
        handleFeatureRemove_(t2) {
          this.removeFeature_(t2.element);
        }
        writePointGeometry_(t2, e2) {
          const i2 = e2.getCoordinates(), n2 = { feature: t2, geometry: e2, segment: [i2, i2] };
          this.rBush_.insert(e2.getExtent(), n2);
        }
        writeMultiPointGeometry_(t2, e2) {
          const i2 = e2.getCoordinates();
          for (let n2 = 0, r2 = i2.length; n2 < r2; ++n2) {
            const r3 = i2[n2], s2 = { feature: t2, geometry: e2, depth: [n2], index: n2, segment: [r3, r3] };
            this.rBush_.insert(e2.getExtent(), s2);
          }
        }
        writeLineStringGeometry_(t2, e2) {
          const i2 = e2.getCoordinates();
          for (let n2 = 0, r2 = i2.length - 1; n2 < r2; ++n2) {
            const r3 = i2.slice(n2, n2 + 2), s2 = { feature: t2, geometry: e2, index: n2, segment: r3 };
            this.rBush_.insert(zt(r3), s2);
          }
        }
        writeMultiLineStringGeometry_(t2, e2) {
          const i2 = e2.getCoordinates();
          for (let n2 = 0, r2 = i2.length; n2 < r2; ++n2) {
            const r3 = i2[n2];
            for (let i3 = 0, s2 = r3.length - 1; i3 < s2; ++i3) {
              const s3 = r3.slice(i3, i3 + 2), o2 = { feature: t2, geometry: e2, depth: [n2], index: i3, segment: s3 };
              this.rBush_.insert(zt(s3), o2);
            }
          }
        }
        writePolygonGeometry_(t2, e2) {
          const i2 = e2.getCoordinates();
          for (let n2 = 0, r2 = i2.length; n2 < r2; ++n2) {
            const r3 = i2[n2];
            for (let i3 = 0, s2 = r3.length - 1; i3 < s2; ++i3) {
              const s3 = r3.slice(i3, i3 + 2), o2 = { feature: t2, geometry: e2, depth: [n2], index: i3, segment: s3 };
              this.rBush_.insert(zt(s3), o2);
            }
          }
        }
        writeMultiPolygonGeometry_(t2, e2) {
          const i2 = e2.getCoordinates();
          for (let n2 = 0, r2 = i2.length; n2 < r2; ++n2) {
            const r3 = i2[n2];
            for (let i3 = 0, s2 = r3.length; i3 < s2; ++i3) {
              const s3 = r3[i3];
              for (let r4 = 0, o2 = s3.length - 1; r4 < o2; ++r4) {
                const o3 = s3.slice(r4, r4 + 2), a2 = { feature: t2, geometry: e2, depth: [i3, n2], index: r4, segment: o3 };
                this.rBush_.insert(zt(o3), a2);
              }
            }
          }
        }
        writeCircleGeometry_(t2, e2) {
          const i2 = e2.getCenter(), n2 = { feature: t2, geometry: e2, index: 0, segment: [i2, i2] }, r2 = { feature: t2, geometry: e2, index: 1, segment: [i2, i2] }, s2 = [n2, r2];
          n2.featureSegments = s2, r2.featureSegments = s2, this.rBush_.insert(Qt(i2), n2);
          let o2 = e2;
          const a2 = en();
          if (a2 && this.getMap()) {
            const t3 = this.getMap().getView().getProjection();
            o2 = o2.clone().transform(a2, t3), o2 = fr(o2).transform(t3, a2);
          }
          this.rBush_.insert(o2.getExtent(), r2);
        }
        writeGeometryCollectionGeometry_(t2, e2) {
          const i2 = e2.getGeometriesArray();
          for (let e3 = 0; e3 < i2.length; ++e3) {
            const n2 = i2[e3];
            (0, this.SEGMENT_WRITERS_[n2.getType()])(t2, n2);
          }
        }
        createOrUpdateVertexFeature_(t2, e2, i2) {
          let n2 = this.vertexFeature_;
          if (n2) {
            n2.getGeometry().setCoordinates(t2);
          } else
            n2 = new lt(new Wn(t2)), this.vertexFeature_ = n2, this.overlay_.getSource().addFeature(n2);
          return n2.set("features", e2), n2.set("geometries", i2), n2;
        }
        handleEvent(t2) {
          if (!t2.originalEvent)
            return true;
          let e2;
          return this.lastPointerEvent_ = t2, t2.map.getView().getInteracting() || t2.type != ao.POINTERMOVE || this.handlingDownUpSequence || this.handlePointerMove_(t2), this.vertexFeature_ && this.deleteCondition_(t2) && (e2 = !(t2.type != ao.SINGLECLICK || !this.ignoreNextSingleClick_) || this.removePoint()), t2.type == ao.SINGLECLICK && (this.ignoreNextSingleClick_ = false), super.handleEvent(t2) && !e2;
        }
        handleDragEvent(t2) {
          this.ignoreNextSingleClick_ = false, this.willModifyFeatures_(t2, this.dragSegments_);
          const e2 = [t2.coordinate[0] + this.delta_[0], t2.coordinate[1] + this.delta_[1]], i2 = [], n2 = [];
          for (let r2 = 0, s2 = this.dragSegments_.length; r2 < s2; ++r2) {
            const s3 = this.dragSegments_[r2], o2 = s3[0], a2 = o2.feature;
            i2.includes(a2) || i2.push(a2);
            const l2 = o2.geometry;
            n2.includes(l2) || n2.push(l2);
            const h2 = o2.depth;
            let c2;
            const u2 = o2.segment, d2 = s3[1];
            for (; e2.length < l2.getStride(); )
              e2.push(u2[d2][e2.length]);
            switch (l2.getType()) {
              case "Point":
                c2 = e2, u2[0] = e2, u2[1] = e2;
                break;
              case "MultiPoint":
                c2 = l2.getCoordinates(), c2[o2.index] = e2, u2[0] = e2, u2[1] = e2;
                break;
              case "LineString":
                c2 = l2.getCoordinates(), c2[o2.index + d2] = e2, u2[d2] = e2;
                break;
              case "MultiLineString":
              case "Polygon":
                c2 = l2.getCoordinates(), c2[h2[0]][o2.index + d2] = e2, u2[d2] = e2;
                break;
              case "MultiPolygon":
                c2 = l2.getCoordinates(), c2[h2[1]][h2[0]][o2.index + d2] = e2, u2[d2] = e2;
                break;
              case "Circle":
                if (u2[0] = e2, u2[1] = e2, 0 === o2.index)
                  this.changingFeature_ = true, l2.setCenter(e2), this.changingFeature_ = false;
                else {
                  this.changingFeature_ = true;
                  const i3 = t2.map.getView().getProjection();
                  let n3 = Ci(rn(l2.getCenter(), i3), rn(e2, i3));
                  const r3 = en();
                  if (r3) {
                    const t3 = l2.clone().transform(r3, i3);
                    t3.setRadius(n3), n3 = t3.transform(i3, r3).getRadius();
                  }
                  l2.setRadius(n3), this.changingFeature_ = false;
                }
            }
            c2 && this.setGeometryCoordinates_(l2, c2);
          }
          this.createOrUpdateVertexFeature_(e2, i2, n2);
        }
        handleDownEvent(t2) {
          if (!this.condition_(t2))
            return false;
          const e2 = t2.coordinate;
          this.handlePointerAtPixel_(t2.pixel, t2.map, e2), this.dragSegments_.length = 0, this.featuresBeingModified_ = null;
          const i2 = this.vertexFeature_;
          if (i2) {
            const n2 = t2.map.getView().getProjection(), r2 = [], s2 = i2.getGeometry().getCoordinates(), o2 = zt([s2]), a2 = this.rBush_.getInExtent(o2), l2 = {};
            a2.sort(l_);
            for (let i3 = 0, o3 = a2.length; i3 < o3; ++i3) {
              const o4 = a2[i3], h2 = o4.segment;
              let c2 = z(o4.geometry);
              const u2 = o4.depth;
              if (u2 && (c2 += "-" + u2.join("-")), l2[c2] || (l2[c2] = new Array(2)), "Circle" !== o4.geometry.getType() || 1 !== o4.index)
                if (!Si(h2[0], s2) || l2[c2][0])
                  if (!Si(h2[1], s2) || l2[c2][1])
                    z(h2) in this.vertexSegments_ && !l2[c2][0] && !l2[c2][1] && this.insertVertexCondition_(t2) && r2.push(o4);
                  else {
                    if (l2[c2][0] && 0 === l2[c2][0].index) {
                      let t3 = o4.geometry.getCoordinates();
                      switch (o4.geometry.getType()) {
                        case "LineString":
                        case "MultiLineString":
                          continue;
                        case "MultiPolygon":
                          t3 = t3[u2[1]];
                        case "Polygon":
                          if (o4.index !== t3[u2[0]].length - 2)
                            continue;
                      }
                    }
                    this.dragSegments_.push([o4, 1]), l2[c2][1] = o4;
                  }
                else
                  this.dragSegments_.push([o4, 0]), l2[c2][0] = o4;
              else {
                Si(c_(e2, o4, n2), s2) && !l2[c2][0] && (this.dragSegments_.push([o4, 0]), l2[c2][0] = o4);
              }
            }
            r2.length && this.willModifyFeatures_(t2, [r2]);
            for (let t3 = r2.length - 1; t3 >= 0; --t3)
              this.insertVertex_(r2[t3], s2);
          }
          return !!this.vertexFeature_;
        }
        handleUpEvent(t2) {
          for (let e2 = this.dragSegments_.length - 1; e2 >= 0; --e2) {
            const i2 = this.dragSegments_[e2][0], n2 = i2.geometry;
            if ("Circle" === n2.getType()) {
              const e3 = n2.getCenter(), r2 = i2.featureSegments[0], s2 = i2.featureSegments[1];
              r2.segment[0] = e3, r2.segment[1] = e3, s2.segment[0] = e3, s2.segment[1] = e3, this.rBush_.update(Qt(e3), r2);
              let o2 = n2;
              const a2 = en();
              if (a2) {
                const e4 = t2.map.getView().getProjection();
                o2 = o2.clone().transform(a2, e4), o2 = fr(o2).transform(e4, a2);
              }
              this.rBush_.update(o2.getExtent(), s2);
            } else
              this.rBush_.update(zt(i2.segment), i2);
          }
          return this.featuresBeingModified_ && (this.dispatchEvent(new a_(o_, this.featuresBeingModified_, t2)), this.featuresBeingModified_ = null), false;
        }
        handlePointerMove_(t2) {
          this.lastPixel_ = t2.pixel, this.handlePointerAtPixel_(t2.pixel, t2.map, t2.coordinate);
        }
        handlePointerAtPixel_(t2, e2, i2) {
          const n2 = i2 || e2.getCoordinateFromPixel(t2), r2 = e2.getView().getProjection(), s2 = function(t3, e3) {
            return h_(n2, t3, r2) - h_(n2, e3, r2);
          };
          let o2, a2;
          if (this.hitDetection_) {
            const i3 = "object" == typeof this.hitDetection_ ? (t3) => t3 === this.hitDetection_ : void 0;
            e2.forEachFeatureAtPixel(t2, (t3, e3, i4) => {
              if ("Point" === (i4 = i4 || t3.getGeometry()).getType() && this.features_.getArray().includes(t3)) {
                a2 = i4;
                const e4 = i4.getFlatCoordinates().slice(0, 2);
                o2 = [{ feature: t3, geometry: i4, segment: [e4, e4] }];
              }
              return true;
            }, { layerFilter: i3 });
          }
          if (!o2) {
            const t3 = sn(Xt(on(Qt(n2, n_), r2), e2.getView().getResolution() * this.pixelTolerance_, n_), r2);
            o2 = this.rBush_.getInExtent(t3);
          }
          if (o2 && o2.length > 0) {
            const i3 = o2.sort(s2)[0], l2 = i3.segment;
            let h2 = c_(n2, i3, r2);
            const c2 = e2.getPixelFromCoordinate(h2);
            let u2 = Ci(t2, c2);
            if (a2 || u2 <= this.pixelTolerance_) {
              const t3 = {};
              if (t3[z(l2)] = true, this.snapToPointer_ || (this.delta_[0] = h2[0] - n2[0], this.delta_[1] = h2[1] - n2[1]), "Circle" === i3.geometry.getType() && 1 === i3.index)
                this.snappedToVertex_ = true, this.createOrUpdateVertexFeature_(h2, [i3.feature], [i3.geometry]);
              else {
                const n3 = e2.getPixelFromCoordinate(l2[0]), r3 = e2.getPixelFromCoordinate(l2[1]), s3 = Ti(c2, n3), a3 = Ti(c2, r3);
                u2 = Math.sqrt(Math.min(s3, a3)), this.snappedToVertex_ = u2 <= this.pixelTolerance_, this.snappedToVertex_ && (h2 = s3 > a3 ? l2[1] : l2[0]), this.createOrUpdateVertexFeature_(h2, [i3.feature], [i3.geometry]);
                const d2 = {};
                d2[z(i3.geometry)] = true;
                for (let e3 = 1, i4 = o2.length; e3 < i4; ++e3) {
                  const i5 = o2[e3].segment;
                  if (!(Si(l2[0], i5[0]) && Si(l2[1], i5[1]) || Si(l2[0], i5[1]) && Si(l2[1], i5[0])))
                    break;
                  {
                    const n4 = z(o2[e3].geometry);
                    n4 in d2 || (d2[n4] = true, t3[z(i5)] = true);
                  }
                }
              }
              return void (this.vertexSegments_ = t3);
            }
          }
          this.vertexFeature_ && (this.overlay_.getSource().removeFeature(this.vertexFeature_), this.vertexFeature_ = null);
        }
        insertVertex_(t2, e2) {
          const i2 = t2.segment, n2 = t2.feature, r2 = t2.geometry, s2 = t2.depth, o2 = t2.index;
          let a2;
          for (; e2.length < r2.getStride(); )
            e2.push(0);
          switch (r2.getType()) {
            case "MultiLineString":
            case "Polygon":
              a2 = r2.getCoordinates(), a2[s2[0]].splice(o2 + 1, 0, e2);
              break;
            case "MultiPolygon":
              a2 = r2.getCoordinates(), a2[s2[1]][s2[0]].splice(o2 + 1, 0, e2);
              break;
            case "LineString":
              a2 = r2.getCoordinates(), a2.splice(o2 + 1, 0, e2);
              break;
            default:
              return;
          }
          this.setGeometryCoordinates_(r2, a2);
          const l2 = this.rBush_;
          l2.remove(t2), this.updateSegmentIndices_(r2, o2, s2, 1);
          const h2 = { segment: [i2[0], e2], feature: n2, geometry: r2, depth: s2, index: o2 };
          l2.insert(zt(h2.segment), h2), this.dragSegments_.push([h2, 1]);
          const c2 = { segment: [e2, i2[1]], feature: n2, geometry: r2, depth: s2, index: o2 + 1 };
          l2.insert(zt(c2.segment), c2), this.dragSegments_.push([c2, 0]), this.ignoreNextSingleClick_ = true;
        }
        removePoint() {
          if (this.lastPointerEvent_ && this.lastPointerEvent_.type != ao.POINTERDRAG) {
            const t2 = this.lastPointerEvent_;
            this.willModifyFeatures_(t2, this.dragSegments_);
            const e2 = this.removeVertex_();
            return this.featuresBeingModified_ && this.dispatchEvent(new a_(o_, this.featuresBeingModified_, t2)), this.featuresBeingModified_ = null, e2;
          }
          return false;
        }
        removeVertex_() {
          const t2 = this.dragSegments_, e2 = {};
          let i2, n2, r2, s2, o2, a2, l2, h2, c2, u2, d2, g2 = false;
          for (o2 = t2.length - 1; o2 >= 0; --o2)
            r2 = t2[o2], u2 = r2[0], d2 = z(u2.feature), u2.depth && (d2 += "-" + u2.depth.join("-")), d2 in e2 || (e2[d2] = {}), 0 === r2[1] ? (e2[d2].right = u2, e2[d2].index = u2.index) : 1 == r2[1] && (e2[d2].left = u2, e2[d2].index = u2.index + 1);
          for (d2 in e2) {
            switch (c2 = e2[d2].right, l2 = e2[d2].left, a2 = e2[d2].index, h2 = a2 - 1, u2 = void 0 !== l2 ? l2 : c2, h2 < 0 && (h2 = 0), s2 = u2.geometry, n2 = s2.getCoordinates(), i2 = n2, g2 = false, s2.getType()) {
              case "MultiLineString":
                n2[u2.depth[0]].length > 2 && (n2[u2.depth[0]].splice(a2, 1), g2 = true);
                break;
              case "LineString":
                n2.length > 2 && (n2.splice(a2, 1), g2 = true);
                break;
              case "MultiPolygon":
                i2 = i2[u2.depth[1]];
              case "Polygon":
                i2 = i2[u2.depth[0]], i2.length > 4 && (a2 == i2.length - 1 && (a2 = 0), i2.splice(a2, 1), g2 = true, 0 === a2 && (i2.pop(), i2.push(i2[0]), h2 = i2.length - 1));
            }
            if (g2) {
              this.setGeometryCoordinates_(s2, n2);
              const e3 = [];
              if (void 0 !== l2 && (this.rBush_.remove(l2), e3.push(l2.segment[0])), void 0 !== c2 && (this.rBush_.remove(c2), e3.push(c2.segment[1])), void 0 !== l2 && void 0 !== c2) {
                const t3 = { depth: u2.depth, feature: u2.feature, geometry: u2.geometry, index: h2, segment: e3 };
                this.rBush_.insert(zt(t3.segment), t3);
              }
              this.updateSegmentIndices_(s2, a2, u2.depth, -1), this.vertexFeature_ && (this.overlay_.getSource().removeFeature(this.vertexFeature_), this.vertexFeature_ = null), t2.length = 0;
            }
          }
          return g2;
        }
        setGeometryCoordinates_(t2, e2) {
          this.changingFeature_ = true, t2.setCoordinates(e2), this.changingFeature_ = false;
        }
        updateSegmentIndices_(t2, e2, i2, n2) {
          this.rBush_.forEachInExtent(t2.getExtent(), function(r2) {
            r2.geometry === t2 && (void 0 === i2 || void 0 === r2.depth || u(r2.depth, i2)) && r2.index > e2 && (r2.index += n2);
          });
        }
      }, _T.interaction.Modify.ModifyEvent = a_, _T.interaction.MouseWheelZoom = ka, _T.interaction.PinchRotate = Ga, _T.interaction.PinchZoom = ja, _T.interaction.Pointer = sa, _T.interaction.Pointer.centroid = oa, _T.interaction.Select = p_, _T.interaction.Select.SelectEvent = g_, _T.interaction.Snap = class extends sa {
        constructor(t2) {
          const e2 = t2 = t2 || {};
          e2.handleDownEvent || (e2.handleDownEvent = g), e2.stopDown || (e2.stopDown = f), super(e2), this.source_ = t2.source ? t2.source : null, this.vertex_ = void 0 === t2.vertex || t2.vertex, this.edge_ = void 0 === t2.edge || t2.edge, this.features_ = t2.features ? t2.features : null, this.featuresListenerKeys_ = [], this.featureChangeListenerKeys_ = {}, this.indexedFeaturesExtents_ = {}, this.pendingFeatures_ = {}, this.pixelTolerance_ = void 0 !== t2.pixelTolerance ? t2.pixelTolerance : 10, this.rBush_ = new Ah(), this.GEOMETRY_SEGMENTERS_ = { Point: this.segmentPointGeometry_.bind(this), LineString: this.segmentLineStringGeometry_.bind(this), LinearRing: this.segmentLineStringGeometry_.bind(this), Polygon: this.segmentPolygonGeometry_.bind(this), MultiPoint: this.segmentMultiPointGeometry_.bind(this), MultiLineString: this.segmentMultiLineStringGeometry_.bind(this), MultiPolygon: this.segmentMultiPolygonGeometry_.bind(this), GeometryCollection: this.segmentGeometryCollectionGeometry_.bind(this), Circle: this.segmentCircleGeometry_.bind(this) };
        }
        addFeature(t2, e2) {
          e2 = void 0 === e2 || e2;
          const i2 = z(t2), n2 = t2.getGeometry();
          if (n2) {
            const e3 = this.GEOMETRY_SEGMENTERS_[n2.getType()];
            if (e3) {
              this.indexedFeaturesExtents_[i2] = n2.getExtent([1 / 0, 1 / 0, -1 / 0, -1 / 0]);
              const r2 = [];
              if (e3(r2, n2), 1 === r2.length)
                this.rBush_.insert(zt(r2[0]), { feature: t2, segment: r2[0] });
              else if (r2.length > 1) {
                const e4 = r2.map((t3) => zt(t3)), i3 = r2.map((e5) => ({ feature: t2, segment: e5 }));
                this.rBush_.load(e4, i3);
              }
            }
          }
          e2 && (this.featureChangeListenerKeys_[i2] = N(t2, S, this.handleFeatureChange_, this));
        }
        forEachFeatureAdd_(t2) {
          this.addFeature(t2);
        }
        forEachFeatureRemove_(t2) {
          this.removeFeature(t2);
        }
        getFeatures_() {
          let t2;
          return this.features_ ? t2 = this.features_ : this.source_ && (t2 = this.source_.getFeatures()), t2;
        }
        handleEvent(t2) {
          const e2 = this.snapTo(t2.pixel, t2.coordinate, t2.map);
          return e2 && (t2.coordinate = e2.vertex.slice(0, 2), t2.pixel = e2.vertexPixel), super.handleEvent(t2);
        }
        handleFeatureAdd_(t2) {
          const e2 = m_(t2);
          this.addFeature(e2);
        }
        handleFeatureRemove_(t2) {
          const e2 = m_(t2);
          this.removeFeature(e2);
        }
        handleFeatureChange_(t2) {
          const e2 = t2.target;
          if (this.handlingDownUpSequence) {
            const t3 = z(e2);
            t3 in this.pendingFeatures_ || (this.pendingFeatures_[t3] = e2);
          } else
            this.updateFeature_(e2);
        }
        handleUpEvent(t2) {
          const e2 = Object.values(this.pendingFeatures_);
          return e2.length && (e2.forEach(this.updateFeature_.bind(this)), this.pendingFeatures_ = {}), false;
        }
        removeFeature(t2, e2) {
          const i2 = void 0 === e2 || e2, n2 = z(t2), r2 = this.indexedFeaturesExtents_[n2];
          if (r2) {
            const e3 = this.rBush_, i3 = [];
            e3.forEachInExtent(r2, function(e4) {
              t2 === e4.feature && i3.push(e4);
            });
            for (let t3 = i3.length - 1; t3 >= 0; --t3)
              e3.remove(i3[t3]);
          }
          i2 && (k(this.featureChangeListenerKeys_[n2]), delete this.featureChangeListenerKeys_[n2]);
        }
        setMap(t2) {
          const e2 = this.getMap(), i2 = this.featuresListenerKeys_, n2 = this.getFeatures_();
          e2 && (i2.forEach(k), i2.length = 0, n2.forEach(this.forEachFeatureRemove_.bind(this))), super.setMap(t2), t2 && (this.features_ ? i2.push(N(this.features_, W, this.handleFeatureAdd_, this), N(this.features_, Z, this.handleFeatureRemove_, this)) : this.source_ && i2.push(N(this.source_, Oh, this.handleFeatureAdd_, this), N(this.source_, kh, this.handleFeatureRemove_, this)), n2.forEach(this.forEachFeatureAdd_.bind(this)));
        }
        snapTo(t2, e2, i2) {
          const n2 = zt([i2.getCoordinateFromPixel([t2[0] - this.pixelTolerance_, t2[1] + this.pixelTolerance_]), i2.getCoordinateFromPixel([t2[0] + this.pixelTolerance_, t2[1] - this.pixelTolerance_])]), r2 = this.rBush_.getInExtent(n2), s2 = r2.length;
          if (0 === s2)
            return null;
          const o2 = i2.getView().getProjection(), a2 = rn(e2, o2);
          let l2, h2 = 1 / 0;
          const c2 = this.pixelTolerance_ * this.pixelTolerance_, u2 = () => {
            if (l2) {
              const e3 = i2.getPixelFromCoordinate(l2);
              if (Ti(t2, e3) <= c2)
                return { vertex: l2, vertexPixel: [Math.round(e3[0]), Math.round(e3[1])] };
            }
            return null;
          };
          if (this.vertex_) {
            for (let t4 = 0; t4 < s2; ++t4) {
              const e3 = r2[t4];
              "Circle" !== e3.feature.getGeometry().getType() && e3.segment.forEach((t5) => {
                const e4 = rn(t5, o2), i3 = Ti(a2, e4);
                i3 < h2 && (l2 = t5, h2 = i3);
              });
            }
            const t3 = u2();
            if (t3)
              return t3;
          }
          if (this.edge_) {
            for (let t4 = 0; t4 < s2; ++t4) {
              let e3 = null;
              const i3 = r2[t4];
              if ("Circle" === i3.feature.getGeometry().getType()) {
                let t5 = i3.feature.getGeometry();
                const n3 = en();
                n3 && (t5 = t5.clone().transform(n3, o2)), e3 = nn(_i(a2, t5), o2);
              } else {
                const [t5, n3] = i3.segment;
                n3 && (__[0] = rn(t5, o2), __[1] = rn(n3, o2), e3 = yi(a2, __));
              }
              if (e3) {
                const t5 = Ti(a2, e3);
                t5 < h2 && (l2 = e3, h2 = t5);
              }
            }
            const t3 = u2();
            if (t3)
              return t3;
          }
          return null;
        }
        updateFeature_(t2) {
          this.removeFeature(t2, false), this.addFeature(t2, false);
        }
        segmentCircleGeometry_(t2, e2) {
          const i2 = this.getMap().getView().getProjection();
          let n2 = e2;
          const r2 = en();
          r2 && (n2 = n2.clone().transform(r2, i2));
          const s2 = fr(n2);
          r2 && s2.transform(i2, r2);
          const o2 = s2.getCoordinates()[0];
          for (let e3 = 0, i3 = o2.length - 1; e3 < i3; ++e3)
            t2.push(o2.slice(e3, e3 + 2));
        }
        segmentGeometryCollectionGeometry_(t2, e2) {
          const i2 = e2.getGeometriesArray();
          for (let e3 = 0; e3 < i2.length; ++e3) {
            const n2 = this.GEOMETRY_SEGMENTERS_[i2[e3].getType()];
            n2 && n2(t2, i2[e3]);
          }
        }
        segmentLineStringGeometry_(t2, e2) {
          const i2 = e2.getCoordinates();
          for (let e3 = 0, n2 = i2.length - 1; e3 < n2; ++e3)
            t2.push(i2.slice(e3, e3 + 2));
        }
        segmentMultiLineStringGeometry_(t2, e2) {
          const i2 = e2.getCoordinates();
          for (let e3 = 0, n2 = i2.length; e3 < n2; ++e3) {
            const n3 = i2[e3];
            for (let e4 = 0, i3 = n3.length - 1; e4 < i3; ++e4)
              t2.push(n3.slice(e4, e4 + 2));
          }
        }
        segmentMultiPointGeometry_(t2, e2) {
          e2.getCoordinates().forEach((e3) => {
            t2.push([e3]);
          });
        }
        segmentMultiPolygonGeometry_(t2, e2) {
          const i2 = e2.getCoordinates();
          for (let e3 = 0, n2 = i2.length; e3 < n2; ++e3) {
            const n3 = i2[e3];
            for (let e4 = 0, i3 = n3.length; e4 < i3; ++e4) {
              const i4 = n3[e4];
              for (let e5 = 0, n4 = i4.length - 1; e5 < n4; ++e5)
                t2.push(i4.slice(e5, e5 + 2));
            }
          }
        }
        segmentPointGeometry_(t2, e2) {
          t2.push([e2.getCoordinates()]);
        }
        segmentPolygonGeometry_(t2, e2) {
          const i2 = e2.getCoordinates();
          for (let e3 = 0, n2 = i2.length; e3 < n2; ++e3) {
            const n3 = i2[e3];
            for (let e4 = 0, i3 = n3.length - 1; e4 < i3; ++e4)
              t2.push(n3.slice(e4, e4 + 2));
          }
        }
      }, _T.interaction.Translate = class extends sa {
        constructor(t2) {
          let e2;
          if (super(t2 = t2 || {}), this.on, this.once, this.un, this.lastCoordinate_ = null, this.startCoordinate_ = null, this.features_ = void 0 !== t2.features ? t2.features : null, t2.layers && !this.features_)
            if ("function" == typeof t2.layers)
              e2 = t2.layers;
            else {
              const i2 = t2.layers;
              e2 = function(t3) {
                return i2.includes(t3);
              };
            }
          else
            e2 = g;
          this.layerFilter_ = e2, this.filter_ = t2.filter && !this.features_ ? t2.filter : g, this.hitTolerance_ = t2.hitTolerance ? t2.hitTolerance : 0, this.condition_ = t2.condition ? t2.condition : da, this.lastFeature_ = null, this.addChangeListener(ta, this.handleActiveChanged_);
        }
        handleDownEvent(t2) {
          if (!t2.originalEvent || !this.condition_(t2))
            return false;
          if (this.lastFeature_ = this.featuresAtPixel_(t2.pixel, t2.map), !this.lastCoordinate_ && this.lastFeature_) {
            this.startCoordinate_ = t2.coordinate, this.lastCoordinate_ = t2.coordinate, this.handleMoveEvent(t2);
            const e2 = this.features_ || new q([this.lastFeature_]);
            return this.dispatchEvent(new S_(y_, e2, t2.coordinate, this.startCoordinate_, t2)), true;
          }
          return false;
        }
        handleUpEvent(t2) {
          if (this.lastCoordinate_) {
            this.lastCoordinate_ = null, this.handleMoveEvent(t2);
            const e2 = this.features_ || new q([this.lastFeature_]);
            return this.dispatchEvent(new S_(v_, e2, t2.coordinate, this.startCoordinate_, t2)), this.startCoordinate_ = null, true;
          }
          return false;
        }
        handleDragEvent(t2) {
          if (this.lastCoordinate_) {
            const e2 = t2.coordinate, i2 = e2[0] - this.lastCoordinate_[0], n2 = e2[1] - this.lastCoordinate_[1], r2 = this.features_ || new q([this.lastFeature_]);
            r2.forEach(function(t3) {
              const e3 = t3.getGeometry();
              e3.translate(i2, n2), t3.setGeometry(e3);
            }), this.lastCoordinate_ = e2, this.dispatchEvent(new S_(x_, r2, e2, this.startCoordinate_, t2));
          }
        }
        handleMoveEvent(t2) {
          const e2 = t2.map.getViewport();
          this.featuresAtPixel_(t2.pixel, t2.map) ? (e2.classList.remove(this.lastCoordinate_ ? "ol-grab" : "ol-grabbing"), e2.classList.add(this.lastCoordinate_ ? "ol-grabbing" : "ol-grab")) : e2.classList.remove("ol-grab", "ol-grabbing");
        }
        featuresAtPixel_(t2, e2) {
          return e2.forEachFeatureAtPixel(t2, function(t3, e3) {
            if (this.filter_(t3, e3) && (!this.features_ || this.features_.getArray().includes(t3)))
              return t3;
          }.bind(this), { layerFilter: this.layerFilter_, hitTolerance: this.hitTolerance_ });
        }
        getHitTolerance() {
          return this.hitTolerance_;
        }
        setHitTolerance(t2) {
          this.hitTolerance_ = t2;
        }
        setMap(t2) {
          const e2 = this.getMap();
          super.setMap(t2), this.updateState_(e2);
        }
        handleActiveChanged_() {
          this.updateState_(null);
        }
        updateState_(t2) {
          let e2 = this.getMap();
          const i2 = this.getActive();
          if ((!e2 || !i2) && (e2 = e2 || t2, e2)) {
            e2.getViewport().classList.remove("ol-grab", "ol-grabbing");
          }
        }
      }, _T.interaction.Translate.TranslateEvent = S_, _T.interaction.defaults = {}, _T.interaction.defaults.defaults = Ba, _T.layer = {}, _T.layer.Base = fs, _T.layer.BaseImage = Tc, _T.layer.BaseTile = Ac, _T.layer.BaseVector = Ig, _T.layer.Graticule = class extends zp {
        constructor(t2) {
          t2 = t2 || {};
          const e2 = Object.assign({ updateWhileAnimating: true, updateWhileInteracting: true, renderBuffer: 0 }, t2);
          delete e2.maxLines, delete e2.strokeStyle, delete e2.targetSize, delete e2.showLabels, delete e2.lonLabelFormatter, delete e2.latLabelFormatter, delete e2.lonLabelPosition, delete e2.latLabelPosition, delete e2.lonLabelStyle, delete e2.latLabelStyle, delete e2.intervals, super(e2), this.projection_ = null, this.maxLat_ = 1 / 0, this.maxLon_ = 1 / 0, this.minLat_ = -1 / 0, this.minLon_ = -1 / 0, this.maxX_ = 1 / 0, this.maxY_ = 1 / 0, this.minX_ = -1 / 0, this.minY_ = -1 / 0, this.targetSize_ = void 0 !== t2.targetSize ? t2.targetSize : 100, this.maxLines_ = void 0 !== t2.maxLines ? t2.maxLines : 100, this.meridians_ = [], this.parallels_ = [], this.strokeStyle_ = void 0 !== t2.strokeStyle ? t2.strokeStyle : Zp, this.fromLonLatTransform_ = void 0, this.toLonLatTransform_ = void 0, this.projectionCenterLonLat_ = null, this.bottomLeft_ = null, this.bottomRight_ = null, this.topLeft_ = null, this.topRight_ = null, this.meridiansLabels_ = null, this.parallelsLabels_ = null, t2.showLabels && (this.lonLabelFormatter_ = null == t2.lonLabelFormatter ? xi.bind(this, "EW") : t2.lonLabelFormatter, this.latLabelFormatter_ = null == t2.latLabelFormatter ? xi.bind(this, "NS") : t2.latLabelFormatter, this.lonLabelPosition_ = null == t2.lonLabelPosition ? 0 : t2.lonLabelPosition, this.latLabelPosition_ = null == t2.latLabelPosition ? 1 : t2.latLabelPosition, this.lonLabelStyleBase_ = new cg({ text: void 0 !== t2.lonLabelStyle ? t2.lonLabelStyle.clone() : new mg({ font: "12px Calibri,sans-serif", textBaseline: "bottom", fill: new rg({ color: "rgba(0,0,0,1)" }), stroke: new hg({ color: "rgba(255,255,255,1)", width: 3 }) }) }), this.lonLabelStyle_ = function(t3) {
            const e3 = t3.get("graticule_label");
            return this.lonLabelStyleBase_.getText().setText(e3), this.lonLabelStyleBase_;
          }.bind(this), this.latLabelStyleBase_ = new cg({ text: void 0 !== t2.latLabelStyle ? t2.latLabelStyle.clone() : new mg({ font: "12px Calibri,sans-serif", textAlign: "right", fill: new rg({ color: "rgba(0,0,0,1)" }), stroke: new hg({ color: "rgba(255,255,255,1)", width: 3 }) }) }), this.latLabelStyle_ = function(t3) {
            const e3 = t3.get("graticule_label");
            return this.latLabelStyleBase_.getText().setText(e3), this.latLabelStyleBase_;
          }.bind(this), this.meridiansLabels_ = [], this.parallelsLabels_ = [], this.addEventListener(ms, this.drawLabels_.bind(this))), this.intervals_ = void 0 !== t2.intervals ? t2.intervals : Yp, this.setSource(new zh({ loader: this.loaderFunction.bind(this), strategy: this.strategyFunction.bind(this), features: new q(), overlaps: false, useSpatialIndex: false, wrapX: t2.wrapX })), this.featurePool_ = [], this.lineStyle_ = new cg({ stroke: this.strokeStyle_ }), this.loadedExtent_ = null, this.renderedExtent_ = null, this.renderedResolution_ = null, this.setRenderOrder(null);
        }
        strategyFunction(t2, e2) {
          let i2 = t2.slice();
          return this.projection_ && this.getSource().getWrapX() && Pe(i2, this.projection_), this.loadedExtent_ && (ie(this.loadedExtent_, i2, e2) ? i2 = this.loadedExtent_.slice() : this.getSource().removeLoadedExtent(this.loadedExtent_)), [i2];
        }
        loaderFunction(t2, e2, i2) {
          this.loadedExtent_ = t2;
          const n2 = this.getSource(), r2 = ye(this.getExtent() || [-1 / 0, -1 / 0, 1 / 0, 1 / 0], t2);
          if (this.renderedExtent_ && ee(this.renderedExtent_, r2) && this.renderedResolution_ === e2)
            return;
          if (this.renderedExtent_ = r2, this.renderedResolution_ = e2, Ee(r2))
            return;
          const s2 = ge(r2), o2 = e2 * e2 / 4;
          (!this.projection_ || !Ki(this.projection_, i2)) && this.updateProjectionInfo_(i2), this.createGraticule_(r2, s2, e2, o2);
          let a2, l2 = this.meridians_.length + this.parallels_.length;
          for (this.meridiansLabels_ && (l2 += this.meridians_.length), this.parallelsLabels_ && (l2 += this.parallels_.length); l2 > this.featurePool_.length; )
            a2 = new lt(), this.featurePool_.push(a2);
          const h2 = n2.getFeaturesCollection();
          h2.clear();
          let c2, u2, d2 = 0;
          for (c2 = 0, u2 = this.meridians_.length; c2 < u2; ++c2)
            a2 = this.featurePool_[d2++], a2.setGeometry(this.meridians_[c2]), a2.setStyle(this.lineStyle_), h2.push(a2);
          for (c2 = 0, u2 = this.parallels_.length; c2 < u2; ++c2)
            a2 = this.featurePool_[d2++], a2.setGeometry(this.parallels_[c2]), a2.setStyle(this.lineStyle_), h2.push(a2);
        }
        addMeridian_(t2, e2, i2, n2, r2, s2) {
          const o2 = this.getMeridian_(t2, e2, i2, n2, s2);
          if (we(o2.getExtent(), r2)) {
            if (this.meridiansLabels_) {
              const e3 = this.lonLabelFormatter_(t2);
              s2 in this.meridiansLabels_ ? this.meridiansLabels_[s2].text = e3 : this.meridiansLabels_[s2] = { geom: new Wn([]), text: e3 };
            }
            this.meridians_[s2++] = o2;
          }
          return s2;
        }
        addParallel_(t2, e2, i2, n2, r2, s2) {
          const o2 = this.getParallel_(t2, e2, i2, n2, s2);
          if (we(o2.getExtent(), r2)) {
            if (this.parallelsLabels_) {
              const e3 = this.latLabelFormatter_(t2);
              s2 in this.parallelsLabels_ ? this.parallelsLabels_[s2].text = e3 : this.parallelsLabels_[s2] = { geom: new Wn([]), text: e3 };
            }
            this.parallels_[s2++] = o2;
          }
          return s2;
        }
        drawLabels_(t2) {
          const e2 = t2.frameState.viewState.rotation, i2 = t2.frameState.viewState.resolution, n2 = t2.frameState.size, r2 = t2.frameState.extent, s2 = ge(r2);
          let o2 = r2;
          if (e2) {
            const t3 = n2[0] * i2, e3 = n2[1] * i2;
            o2 = [s2[0] - t3 / 2, s2[1] - e3 / 2, s2[0] + t3 / 2, s2[1] + e3 / 2];
          }
          let a2 = 0, l2 = 0, h2 = this.latLabelPosition_ < 0.5;
          const c2 = this.projection_.getExtent(), u2 = Se(c2);
          if (this.getSource().getWrapX() && this.projection_.canWrapX() && !Yt(c2, r2)) {
            a2 = Math.floor((r2[0] - c2[0]) / u2), l2 = Math.ceil((r2[2] - c2[2]) / u2);
            h2 = h2 !== Math.abs(e2) > Math.PI / 2;
          }
          const d2 = Al(t2);
          for (let t3 = a2; t3 <= l2; ++t3) {
            let i3, n3, c3, g2, f2 = this.meridians_.length + this.parallels_.length;
            if (this.meridiansLabels_)
              for (n3 = 0, c3 = this.meridiansLabels_.length; n3 < c3; ++n3) {
                const a3 = this.meridians_[n3];
                if (e2 || 0 !== t3) {
                  const i4 = a3.clone();
                  i4.translate(t3 * u2, 0), i4.rotate(-e2, s2), g2 = this.getMeridianPoint_(i4, o2, n3), g2.rotate(e2, s2);
                } else
                  g2 = this.getMeridianPoint_(a3, r2, n3);
                i3 = this.featurePool_[f2++], i3.setGeometry(g2), i3.set("graticule_label", this.meridiansLabels_[n3].text), d2.drawFeature(i3, this.lonLabelStyle_(i3));
              }
            if (this.parallelsLabels_ && (t3 === a2 && h2 || t3 === l2 && !h2))
              for (n3 = 0, c3 = this.parallels_.length; n3 < c3; ++n3) {
                const a3 = this.parallels_[n3];
                if (e2 || 0 !== t3) {
                  const i4 = a3.clone();
                  i4.translate(t3 * u2, 0), i4.rotate(-e2, s2), g2 = this.getParallelPoint_(i4, o2, n3), g2.rotate(e2, s2);
                } else
                  g2 = this.getParallelPoint_(a3, r2, n3);
                i3 = this.featurePool_[f2++], i3.setGeometry(g2), i3.set("graticule_label", this.parallelsLabels_[n3].text), d2.drawFeature(i3, this.latLabelStyle_(i3));
              }
          }
        }
        createGraticule_(t2, e2, i2, n2) {
          const r2 = this.getInterval_(i2);
          if (-1 == r2)
            return this.meridians_.length = 0, this.parallels_.length = 0, this.meridiansLabels_ && (this.meridiansLabels_.length = 0), void (this.parallelsLabels_ && (this.parallelsLabels_.length = 0));
          let s2 = false;
          const o2 = this.projection_.getExtent(), a2 = Se(o2);
          this.getSource().getWrapX() && this.projection_.canWrapX() && !Yt(o2, t2) && (Se(t2) >= a2 ? (t2[0] = o2[0], t2[2] = o2[2]) : s2 = true);
          const l2 = [ii(e2[0], this.minX_, this.maxX_), ii(e2[1], this.minY_, this.maxY_)], h2 = this.toLonLatTransform_(l2);
          isNaN(h2[1]) && (h2[1] = Math.abs(this.maxLat_) >= Math.abs(this.minLat_) ? this.maxLat_ : this.minLat_);
          let c2 = ii(h2[0], this.minLon_, this.maxLon_), u2 = ii(h2[1], this.minLat_, this.maxLat_);
          const d2 = this.maxLines_;
          let g2, f2, p2, m2, _2 = t2;
          s2 || (_2 = [ii(t2[0], this.minX_, this.maxX_), ii(t2[1], this.minY_, this.maxY_), ii(t2[2], this.minX_, this.maxX_), ii(t2[3], this.minY_, this.maxY_)]);
          const y2 = Re(_2, this.toLonLatTransform_, void 0, 8);
          let x2 = y2[3], v2 = y2[2], S2 = y2[1], w2 = y2[0];
          if (s2 || (Zt(_2, this.bottomLeft_) && (w2 = this.minLon_, S2 = this.minLat_), Zt(_2, this.bottomRight_) && (v2 = this.maxLon_, S2 = this.minLat_), Zt(_2, this.topLeft_) && (w2 = this.minLon_, x2 = this.maxLat_), Zt(_2, this.topRight_) && (v2 = this.maxLon_, x2 = this.maxLat_), x2 = ii(x2, u2, this.maxLat_), v2 = ii(v2, c2, this.maxLon_), S2 = ii(S2, this.minLat_, u2), w2 = ii(w2, this.minLon_, c2)), c2 = Math.floor(c2 / r2) * r2, m2 = ii(c2, this.minLon_, this.maxLon_), f2 = this.addMeridian_(m2, S2, x2, n2, t2, 0), g2 = 0, s2)
            for (; (m2 -= r2) >= w2 && g2++ < d2; )
              f2 = this.addMeridian_(m2, S2, x2, n2, t2, f2);
          else
            for (; m2 != this.minLon_ && g2++ < d2; )
              m2 = Math.max(m2 - r2, this.minLon_), f2 = this.addMeridian_(m2, S2, x2, n2, t2, f2);
          if (m2 = ii(c2, this.minLon_, this.maxLon_), g2 = 0, s2)
            for (; (m2 += r2) <= v2 && g2++ < d2; )
              f2 = this.addMeridian_(m2, S2, x2, n2, t2, f2);
          else
            for (; m2 != this.maxLon_ && g2++ < d2; )
              m2 = Math.min(m2 + r2, this.maxLon_), f2 = this.addMeridian_(m2, S2, x2, n2, t2, f2);
          for (this.meridians_.length = f2, this.meridiansLabels_ && (this.meridiansLabels_.length = f2), u2 = Math.floor(u2 / r2) * r2, p2 = ii(u2, this.minLat_, this.maxLat_), f2 = this.addParallel_(p2, w2, v2, n2, t2, 0), g2 = 0; p2 != this.minLat_ && g2++ < d2; )
            p2 = Math.max(p2 - r2, this.minLat_), f2 = this.addParallel_(p2, w2, v2, n2, t2, f2);
          for (p2 = ii(u2, this.minLat_, this.maxLat_), g2 = 0; p2 != this.maxLat_ && g2++ < d2; )
            p2 = Math.min(p2 + r2, this.maxLat_), f2 = this.addParallel_(p2, w2, v2, n2, t2, f2);
          this.parallels_.length = f2, this.parallelsLabels_ && (this.parallelsLabels_.length = f2);
        }
        getInterval_(t2) {
          const e2 = this.projectionCenterLonLat_[0], i2 = this.projectionCenterLonLat_[1];
          let n2 = -1;
          const r2 = Math.pow(this.targetSize_ * t2, 2), s2 = [], o2 = [];
          for (let t3 = 0, a2 = this.intervals_.length; t3 < a2; ++t3) {
            const a3 = ii(this.intervals_[t3] / 2, 0, 90), l2 = ii(i2, -90 + a3, 90 - a3);
            s2[0] = e2 - a3, s2[1] = l2 - a3, o2[0] = e2 + a3, o2[1] = l2 + a3, this.fromLonLatTransform_(s2, s2), this.fromLonLatTransform_(o2, o2);
            if (Math.pow(o2[0] - s2[0], 2) + Math.pow(o2[1] - s2[1], 2) <= r2)
              break;
            n2 = this.intervals_[t3];
          }
          return n2;
        }
        getMeridian_(t2, e2, i2, n2, r2) {
          const s2 = Vp(t2, e2, i2, this.projection_, n2);
          let o2 = this.meridians_[r2];
          return o2 ? (o2.setFlatCoordinates("XY", s2), o2.changed()) : (o2 = new Op(s2, "XY"), this.meridians_[r2] = o2), o2;
        }
        getMeridianPoint_(t2, e2, i2) {
          const n2 = t2.getFlatCoordinates();
          let r2 = 1, s2 = n2.length - 1;
          n2[r2] > n2[s2] && (r2 = s2, s2 = 1);
          const o2 = Math.max(e2[1], n2[r2]), a2 = Math.min(e2[3], n2[s2]), l2 = ii(e2[1] + Math.abs(e2[1] - e2[3]) * this.lonLabelPosition_, o2, a2), h2 = [n2[r2 - 1] + (n2[s2 - 1] - n2[r2 - 1]) * (l2 - n2[r2]) / (n2[s2] - n2[r2]), l2], c2 = this.meridiansLabels_[i2].geom;
          return c2.setCoordinates(h2), c2;
        }
        getMeridians() {
          return this.meridians_;
        }
        getParallel_(t2, e2, i2, n2, r2) {
          const s2 = Wp(t2, e2, i2, this.projection_, n2);
          let o2 = this.parallels_[r2];
          return o2 ? (o2.setFlatCoordinates("XY", s2), o2.changed()) : o2 = new Op(s2, "XY"), o2;
        }
        getParallelPoint_(t2, e2, i2) {
          const n2 = t2.getFlatCoordinates();
          let r2 = 0, s2 = n2.length - 2;
          n2[r2] > n2[s2] && (r2 = s2, s2 = 0);
          const o2 = Math.max(e2[0], n2[r2]), a2 = Math.min(e2[2], n2[s2]), l2 = ii(e2[0] + Math.abs(e2[0] - e2[2]) * this.latLabelPosition_, o2, a2), h2 = [l2, n2[r2 + 1] + (n2[s2 + 1] - n2[r2 + 1]) * (l2 - n2[r2]) / (n2[s2] - n2[r2])], c2 = this.parallelsLabels_[i2].geom;
          return c2.setCoordinates(h2), c2;
        }
        getParallels() {
          return this.parallels_;
        }
        updateProjectionInfo_(t2) {
          const e2 = Ui("EPSG:4326"), i2 = t2.getWorldExtent();
          this.maxLat_ = i2[3], this.maxLon_ = i2[2], this.minLat_ = i2[1], this.minLon_ = i2[0];
          const n2 = Hi(t2, e2);
          if (this.minLon_ < this.maxLon_)
            this.toLonLatTransform_ = n2;
          else {
            const t3 = this.minLon_ + this.maxLon_ / 2;
            this.maxLon_ += 360, this.toLonLatTransform_ = function(e3, i3, r3) {
              const s2 = n2(e3, i3, r3 = r3 || 2);
              for (let e4 = 0, i4 = s2.length; e4 < i4; e4 += r3)
                s2[e4] < t3 && (s2[e4] += 360);
              return s2;
            };
          }
          this.fromLonLatTransform_ = Hi(e2, t2);
          const r2 = Re([this.minLon_, this.minLat_, this.maxLon_, this.maxLat_], this.fromLonLatTransform_, void 0, 8);
          this.minX_ = r2[0], this.maxX_ = r2[2], this.minY_ = r2[1], this.maxY_ = r2[3], this.bottomLeft_ = this.fromLonLatTransform_([this.minLon_, this.minLat_]), this.bottomRight_ = this.fromLonLatTransform_([this.maxLon_, this.minLat_]), this.topLeft_ = this.fromLonLatTransform_([this.minLon_, this.maxLat_]), this.topRight_ = this.fromLonLatTransform_([this.maxLon_, this.maxLat_]), this.projectionCenterLonLat_ = this.toLonLatTransform_(ge(t2.getExtent())), isNaN(this.projectionCenterLonLat_[1]) && (this.projectionCenterLonLat_[1] = Math.abs(this.maxLat_) >= Math.abs(this.minLat_) ? this.maxLat_ : this.minLat_), this.projection_ = t2;
        }
      }, _T.layer.Group = ro, _T.layer.Group.GroupEvent = io, _T.layer.Heatmap = class extends Ig {
        constructor(t2) {
          t2 = t2 || {};
          const e2 = Object.assign({}, t2);
          delete e2.gradient, delete e2.radius, delete e2.blur, delete e2.weight, super(e2), this.gradient_ = null, this.addChangeListener(qp, this.handleGradientChanged_), this.setGradient(t2.gradient ? t2.gradient : $p), this.setBlur(void 0 !== t2.blur ? t2.blur : 15), this.setRadius(void 0 !== t2.radius ? t2.radius : 8);
          const i2 = t2.weight ? t2.weight : "weight";
          this.weightFunction_ = "string" == typeof i2 ? function(t3) {
            return t3.get(i2);
          } : i2, this.setRenderOrder(null);
        }
        getBlur() {
          return this.get(Kp);
        }
        getGradient() {
          return this.get(qp);
        }
        getRadius() {
          return this.get(Hp);
        }
        handleGradientChanged_() {
          this.gradient_ = function(t2) {
            const e2 = 1, i2 = 256, n2 = Dr(e2, i2), r2 = n2.createLinearGradient(0, 0, e2, i2), s2 = 1 / (t2.length - 1);
            for (let e3 = 0, i3 = t2.length; e3 < i3; ++e3)
              r2.addColorStop(e3 * s2, t2[e3]);
            return n2.fillStyle = r2, n2.fillRect(0, 0, e2, i2), n2.canvas;
          }(this.getGradient());
        }
        setBlur(t2) {
          this.set(Kp, t2);
        }
        setGradient(t2) {
          this.set(qp, t2);
        }
        setRadius(t2) {
          this.set(Hp, t2);
        }
        createRenderer() {
          return new gf(this, { className: this.getClassName(), attributes: [{ name: "weight", callback: function(t2) {
            const e2 = this.weightFunction_(t2);
            return void 0 !== e2 ? ii(e2, 0, 1) : 1;
          }.bind(this) }], vertexShader: "\n        precision mediump float;\n        uniform mat4 u_projectionMatrix;\n        uniform mat4 u_offsetScaleMatrix;\n        uniform float u_size;\n        attribute vec2 a_position;\n        attribute float a_index;\n        attribute float a_weight;\n\n        varying vec2 v_texCoord;\n        varying float v_weight;\n\n        void main(void) {\n          mat4 offsetMatrix = u_offsetScaleMatrix;\n          float offsetX = a_index == 0.0 || a_index == 3.0 ? -u_size / 2.0 : u_size / 2.0;\n          float offsetY = a_index == 0.0 || a_index == 1.0 ? -u_size / 2.0 : u_size / 2.0;\n          vec4 offsets = offsetMatrix * vec4(offsetX, offsetY, 0.0, 0.0);\n          gl_Position = u_projectionMatrix * vec4(a_position, 0.0, 1.0) + offsets;\n          float u = a_index == 0.0 || a_index == 3.0 ? 0.0 : 1.0;\n          float v = a_index == 0.0 || a_index == 1.0 ? 0.0 : 1.0;\n          v_texCoord = vec2(u, v);\n          v_weight = a_weight;\n        }", fragmentShader: "\n        precision mediump float;\n        uniform float u_blurSlope;\n\n        varying vec2 v_texCoord;\n        varying float v_weight;\n\n        void main(void) {\n          vec2 texCoord = v_texCoord * 2.0 - vec2(1.0, 1.0);\n          float sqRadius = texCoord.x * texCoord.x + texCoord.y * texCoord.y;\n          float value = (1.0 - sqrt(sqRadius)) * u_blurSlope;\n          float alpha = smoothstep(0.0, 1.0, value) * v_weight;\n          gl_FragColor = vec4(alpha, alpha, alpha, alpha);\n        }", hitVertexShader: "\n        precision mediump float;\n        uniform mat4 u_projectionMatrix;\n        uniform mat4 u_offsetScaleMatrix;\n        uniform float u_size;\n        attribute vec2 a_position;\n        attribute float a_index;\n        attribute float a_weight;\n        attribute vec4 a_hitColor;\n\n        varying vec2 v_texCoord;\n        varying float v_weight;\n        varying vec4 v_hitColor;\n\n        void main(void) {\n          mat4 offsetMatrix = u_offsetScaleMatrix;\n          float offsetX = a_index == 0.0 || a_index == 3.0 ? -u_size / 2.0 : u_size / 2.0;\n          float offsetY = a_index == 0.0 || a_index == 1.0 ? -u_size / 2.0 : u_size / 2.0;\n          vec4 offsets = offsetMatrix * vec4(offsetX, offsetY, 0.0, 0.0);\n          gl_Position = u_projectionMatrix * vec4(a_position, 0.0, 1.0) + offsets;\n          float u = a_index == 0.0 || a_index == 3.0 ? 0.0 : 1.0;\n          float v = a_index == 0.0 || a_index == 1.0 ? 0.0 : 1.0;\n          v_texCoord = vec2(u, v);\n          v_hitColor = a_hitColor;\n          v_weight = a_weight;\n        }", hitFragmentShader: "\n        precision mediump float;\n        uniform float u_blurSlope;\n\n        varying vec2 v_texCoord;\n        varying float v_weight;\n        varying vec4 v_hitColor;\n\n        void main(void) {\n          vec2 texCoord = v_texCoord * 2.0 - vec2(1.0, 1.0);\n          float sqRadius = texCoord.x * texCoord.x + texCoord.y * texCoord.y;\n          float value = (1.0 - sqrt(sqRadius)) * u_blurSlope;\n          float alpha = smoothstep(0.0, 1.0, value) * v_weight;\n          if (alpha < 0.05) {\n            discard;\n          }\n\n          gl_FragColor = v_hitColor;\n        }", uniforms: { u_size: function() {
            return 2 * (this.get(Hp) + this.get(Kp));
          }.bind(this), u_blurSlope: function() {
            return this.get(Hp) / Math.max(1, this.get(Kp));
          }.bind(this) }, postProcesses: [{ fragmentShader: "\n            precision mediump float;\n\n            uniform sampler2D u_image;\n            uniform sampler2D u_gradientTexture;\n            uniform float u_opacity;\n\n            varying vec2 v_texCoord;\n\n            void main() {\n              vec4 color = texture2D(u_image, v_texCoord);\n              gl_FragColor.a = color.a * u_opacity;\n              gl_FragColor.rgb = texture2D(u_gradientTexture, vec2(0.5, color.a)).rgb;\n              gl_FragColor.rgb *= gl_FragColor.a;\n            }", uniforms: { u_gradientTexture: function() {
            return this.gradient_;
          }.bind(this), u_opacity: function() {
            return this.getOpacity();
          }.bind(this) } }] });
        }
        renderDeclutter() {
        }
      }, _T.layer.Image = Lc, _T.layer.Layer = vs, _T.layer.Layer.inView = Ss, _T.layer.MapboxVector = class extends Pm {
        constructor(t2) {
          const e2 = !("declutter" in t2) || t2.declutter, i2 = new Qc({ state: "loading", format: new Em() });
          super({ source: i2, background: t2.background, declutter: e2, className: t2.className, opacity: t2.opacity, visible: t2.visible, zIndex: t2.zIndex, minResolution: t2.minResolution, maxResolution: t2.maxResolution, minZoom: t2.minZoom, maxZoom: t2.maxZoom, renderOrder: t2.renderOrder, renderBuffer: t2.renderBuffer, renderMode: t2.renderMode, map: t2.map, updateWhileAnimating: t2.updateWhileAnimating, updateWhileInteracting: t2.updateWhileInteracting, preload: t2.preload, useInterimTilesOnError: t2.useInterimTilesOnError, properties: t2.properties }), t2.accessToken && (this.accessToken = t2.accessToken);
          const n2 = t2.styleUrl;
          olms.applyStyle(this, n2, t2.layers || t2.source, { accessToken: this.accessToken }).then(() => {
            i2.setState("ready");
          }).catch((t3) => {
            this.dispatchEvent(new Im(t3));
            this.getSource().setState("error");
          }), void 0 === this.getBackground() && olms.applyBackground(this, t2.styleUrl, { accessToken: this.accessToken });
        }
      }, _T.layer.Tile = Nc, _T.layer.Vector = zp, _T.layer.VectorImage = class extends Ig {
        constructor(t2) {
          t2 = t2 || {};
          const e2 = Object.assign({}, t2);
          delete e2.imageRatio, super(e2), this.imageRatio_ = void 0 !== t2.imageRatio ? t2.imageRatio : 1;
        }
        getImageRatio() {
          return this.imageRatio_;
        }
        createRenderer() {
          return new Tp(this);
        }
      }, _T.layer.VectorTile = Pm, _T.layer.WebGLPoints = class extends vs {
        constructor(t2) {
          super(Object.assign({}, t2)), this.parseResult_ = tg(t2.style), this.styleVariables_ = t2.style.variables || {}, this.hitDetectionDisabled_ = !!t2.disableHitDetection;
        }
        createRenderer() {
          return new gf(this, { vertexShader: this.parseResult_.builder.getSymbolVertexShader(), fragmentShader: this.parseResult_.builder.getSymbolFragmentShader(), hitVertexShader: !this.hitDetectionDisabled_ && this.parseResult_.builder.getSymbolVertexShader(true), hitFragmentShader: !this.hitDetectionDisabled_ && this.parseResult_.builder.getSymbolFragmentShader(true), uniforms: this.parseResult_.uniforms, attributes: this.parseResult_.attributes });
        }
        updateStyleVariables(t2) {
          Object.assign(this.styleVariables_, t2), this.changed();
        }
      }, _T.layer.WebGLTile = Mm, _T.loadingstrategy = {}, _T.loadingstrategy.all = xl, _T.loadingstrategy.bbox = function(t2, e2) {
        return [t2];
      }, _T.loadingstrategy.tile = function(t2) {
        return function(e2, i2, n2) {
          const r2 = t2.getZForResolution(ln(i2, n2)), s2 = t2.getTileRangeForExtentAndZ(on(e2, n2), r2), o2 = [], a2 = [r2, 0, 0];
          for (a2[1] = s2.minX; a2[1] <= s2.maxX; ++a2[1])
            for (a2[2] = s2.minY; a2[2] <= s2.maxY; ++a2[2])
              o2.push(sn(t2.getTileCoordExtent(a2), n2));
          return o2;
        };
      }, _T.math = {}, _T.math.ceil = gi, _T.math.clamp = ii, _T.math.floor = di, _T.math.lerp = hi, _T.math.modulo = li, _T.math.round = ui, _T.math.solveLinearSystem = si, _T.math.squaredDistance = ri, _T.math.squaredSegmentDistance = ni, _T.math.toDegrees = oi, _T.math.toFixed = ci, _T.math.toRadians = ai, _T.net = {}, _T.net.ClientError = wl, _T.net.ResponseError = Sl, _T.net.getJSON = El, _T.net.jsonp = vl, _T.net.overrideXHR = function(t2) {
        "undefined" != typeof XMLHttpRequest && (pl = XMLHttpRequest), global.XMLHttpRequest = t2;
      }, _T.net.resolveUrl = Tl, _T.net.restoreXHR = function() {
        global.XMLHttpRequest = pl;
      }, _T.obj = {}, _T.obj.clear = y, _T.obj.isEmpty = x, _T.proj = {}, _T.proj.Projection = Ae, _T.proj.Units = {}, _T.proj.Units.METERS_PER_UNIT = Fe, _T.proj.Units.fromCode = Me, _T.proj.addCommon = cn, _T.proj.addCoordinateTransforms = Yi, _T.proj.addEquivalentProjections = Xi, _T.proj.addEquivalentTransforms = Vi, _T.proj.addProjection = ji, _T.proj.addProjections = Bi, _T.proj.clearAllProjections = function() {
        qe(), Qe();
      }, _T.proj.clearUserProjection = function() {
        Qi = null;
      }, _T.proj.cloneTransform = ki, _T.proj.createProjection = Wi, _T.proj.createSafeCoordinateTransform = hn, _T.proj.createTransformFromCoordinateTransform = Zi, _T.proj.disableCoordinateWarning = Di, _T.proj.epsg3857 = {}, _T.proj.epsg3857.EXTENT = De, _T.proj.epsg3857.HALF_SIZE = Ne, _T.proj.epsg3857.MAX_SAFE_Y = Ge, _T.proj.epsg3857.PROJECTIONS = Be, _T.proj.epsg3857.RADIUS = Oe, _T.proj.epsg3857.WORLD_EXTENT = ke, _T.proj.epsg3857.fromEPSG4326 = Ue, _T.proj.epsg3857.toEPSG4326 = ze, _T.proj.epsg4326 = {}, _T.proj.epsg4326.EXTENT = Ve, _T.proj.epsg4326.METERS_PER_UNIT = We, _T.proj.epsg4326.PROJECTIONS = Ye, _T.proj.epsg4326.RADIUS = Xe, _T.proj.equivalent = Ki, _T.proj.fromLonLat = function(t2, e2) {
        return Di(), $i(t2, "EPSG:4326", void 0 !== e2 ? e2 : "EPSG:3857");
      }, _T.proj.fromUserCoordinate = rn, _T.proj.fromUserExtent = on, _T.proj.fromUserResolution = ln, _T.proj.get = Ui, _T.proj.getPointResolution = zi, _T.proj.getTransform = Hi, _T.proj.getTransformFromProjections = qi, _T.proj.getUserProjection = en, _T.proj.identityTransform = Gi, _T.proj.proj4 = {}, _T.proj.proj4.register = function(t2) {
        const e2 = Object.keys(t2.defs), i2 = e2.length;
        let n2, r2;
        for (n2 = 0; n2 < i2; ++n2) {
          const i3 = e2[n2];
          if (!Ui(i3)) {
            const e3 = t2.defs(i3);
            let n3 = e3.units;
            n3 || "longlat" !== e3.projName || (n3 = "degrees"), ji(new Ae({ code: i3, axisOrientation: e3.axis, metersPerUnit: e3.to_meter, units: n3 }));
          }
        }
        for (n2 = 0; n2 < i2; ++n2) {
          const s2 = e2[n2], o2 = Ui(s2);
          for (r2 = 0; r2 < i2; ++r2) {
            const i3 = e2[r2], n3 = Ui(i3);
            if (!ei(s2, i3))
              if (t2.defs[s2] === t2.defs[i3])
                Xi([o2, n3]);
              else {
                const e3 = t2(s2, i3);
                Yi(o2, n3, hn(o2, n3, e3.forward), hn(n3, o2, e3.inverse));
              }
          }
        }
      }, _T.proj.projections = {}, _T.proj.projections.add = $e, _T.proj.projections.clear = qe, _T.proj.projections.get = He, _T.proj.setUserProjection = tn, _T.proj.toLonLat = function(t2, e2) {
        const i2 = $i(t2, void 0 !== e2 ? e2 : "EPSG:3857", "EPSG:4326"), n2 = i2[0];
        return (n2 < -180 || n2 > 180) && (i2[0] = li(n2 + 180, 360) - 180), i2;
      }, _T.proj.toUserCoordinate = nn, _T.proj.toUserExtent = sn, _T.proj.toUserResolution = an, _T.proj.transform = $i, _T.proj.transformExtent = Ji, _T.proj.transformWithProjections = function(t2, e2, i2) {
        return qi(e2, i2)(t2);
      }, _T.proj.transforms = {}, _T.proj.transforms.add = ti, _T.proj.transforms.clear = Qe, _T.proj.transforms.get = ei, _T.proj.transforms.remove = function(t2, e2) {
        const i2 = t2.getCode(), n2 = e2.getCode(), r2 = Je[i2][n2];
        return delete Je[i2][n2], x(Je[i2]) && delete Je[i2], r2;
      }, _T.proj.useGeographic = function() {
        tn("EPSG:4326");
      }, _T.render = {}, _T.render.Box = Ea, _T.render.Event = Ts, _T.render.Feature = Bp, _T.render.Feature.toFeature = function(t2, e2) {
        const i2 = t2.getId(), n2 = Up(t2), r2 = t2.getProperties(), s2 = new lt();
        return void 0 !== e2 && s2.setGeometryName(e2), s2.setGeometry(n2), void 0 !== i2 && s2.setId(i2), s2.setProperties(r2, true), s2;
      }, _T.render.Feature.toGeometry = Up, _T.render.VectorContext = Cl, _T.render.canvas = {}, _T.render.canvas.Builder = qf, _T.render.canvas.BuilderGroup = np, _T.render.canvas.Executor = pp, _T.render.canvas.ExecutorGroup = _p, _T.render.canvas.ExecutorGroup.getPixelIndexArray = xp, _T.render.canvas.ImageBuilder = Hf, _T.render.canvas.Immediate = bl, _T.render.canvas.Instruction = {}, _T.render.canvas.Instruction.beginPathInstruction = Yf, _T.render.canvas.Instruction.closePathInstruction = Kf, _T.render.canvas.Instruction.fillInstruction = Wf, _T.render.canvas.Instruction.strokeInstruction = Zf, _T.render.canvas.LineStringBuilder = $f, _T.render.canvas.PolygonBuilder = Jf, _T.render.canvas.TextBuilder = ep, _T.render.canvas.checkedFonts = Vs, _T.render.canvas.defaultFillStyle = Ns, _T.render.canvas.defaultFont = Os, _T.render.canvas.defaultLineCap = Ds, _T.render.canvas.defaultLineDash = ks, _T.render.canvas.defaultLineDashOffset = 0, _T.render.canvas.defaultLineJoin = Gs, _T.render.canvas.defaultLineWidth = 1, _T.render.canvas.defaultMiterLimit = js, _T.render.canvas.defaultPadding = Xs, _T.render.canvas.defaultStrokeStyle = Bs, _T.render.canvas.defaultTextAlign = Us, _T.render.canvas.defaultTextBaseline = zs, _T.render.canvas.drawImageOrLabel = to, _T.render.canvas.getTextDimensions = Qs, _T.render.canvas.hitdetect = {}, _T.render.canvas.hitdetect.HIT_DETECT_RESOLUTION = vp, _T.render.canvas.hitdetect.createHitDetectionImageData = Sp, _T.render.canvas.hitdetect.hitDetect = wp, _T.render.canvas.measureAndCacheTextWidth = Js, _T.render.canvas.measureTextHeight = qs, _T.render.canvas.measureTextWidth = $s, _T.render.canvas.registerFont = Ks, _T.render.canvas.rotateAtOffset = function(t2, e2, i2, n2) {
        0 !== e2 && (t2.translate(i2, n2), t2.rotate(e2), t2.translate(-i2, -n2));
      }, _T.render.canvas.textHeights = Ys, _T.render.getRenderPixel = function(t2, e2) {
        return bt(t2.inversePixelTransform, e2.slice(0));
      }, _T.render.getVectorContext = Al, _T.render.toContext = function(t2, e2) {
        const i2 = t2.canvas, n2 = (e2 = e2 || {}).pixelRatio || mt, r2 = e2.size;
        r2 && (i2.width = r2[0] * n2, i2.height = r2[1] * n2, i2.style.width = r2[0] + "px", i2.style.height = r2[1] + "px");
        const s2 = [0, 0, i2.width, i2.height], o2 = Pt([1, 0, 0, 1, 0, 0], n2, n2);
        return new bl(t2, n2, s2, o2, 0);
      }, _T.render.webgl = {}, _T.render.webgl.BatchRenderer = pf, _T.render.webgl.LineStringBatchRenderer = _f, _T.render.webgl.MixedGeometryBatch = yf, _T.render.webgl.PointBatchRenderer = vf, _T.render.webgl.PolygonBatchRenderer = wf, _T.render.webgl.utils = {}, _T.render.webgl.utils.colorDecodeId = uf, _T.render.webgl.utils.colorEncodeId = cf, _T.render.webgl.utils.getBlankImageData = function() {
        const t2 = document.createElement("canvas").getContext("2d").createImageData(1, 1);
        return t2.data[0] = 255, t2.data[1] = 255, t2.data[2] = 255, t2.data[3] = 255, t2;
      }, _T.render.webgl.utils.writeLineSegmentToBuffers = function(t2, e2, i2, n2, r2, s2, o2, a2, l2, h2) {
        const c2 = 5 + a2.length, u2 = s2.length / c2, d2 = [t2[e2 + 0], t2[e2 + 1]], g2 = [t2[i2], t2[i2 + 1]], f2 = bt(h2, [...d2]), p2 = bt(h2, [...g2]);
        function m2(t3, e3, i3) {
          const n3 = 1e4;
          return Math.round(1500 * e3) + Math.round(1500 * i3) * n3 + t3 * n3 * n3;
        }
        function _2(t3, e3, i3) {
          const n3 = Math.sqrt((e3[0] - t3[0]) * (e3[0] - t3[0]) + (e3[1] - t3[1]) * (e3[1] - t3[1])), r3 = [(e3[0] - t3[0]) / n3, (e3[1] - t3[1]) / n3], s3 = [-r3[1], r3[0]], o3 = Math.sqrt((i3[0] - t3[0]) * (i3[0] - t3[0]) + (i3[1] - t3[1]) * (i3[1] - t3[1])), a3 = [(i3[0] - t3[0]) / o3, (i3[1] - t3[1]) / o3], l3 = 0 === n3 || 0 === o3 ? 0 : Math.acos(ii(a3[0] * r3[0] + a3[1] * r3[1], -1, 1));
          return a3[0] * s3[0] + a3[1] * s3[1] > 0 ? l3 : 2 * Math.PI - l3;
        }
        const y2 = null !== r2;
        let x2 = 0, v2 = 0;
        if (null !== n2) {
          x2 = _2(f2, p2, bt(h2, [...[t2[n2], t2[n2 + 1]]]));
        }
        if (y2) {
          v2 = _2(p2, f2, bt(h2, [...[t2[r2], t2[r2 + 1]]]));
        }
        s2.push(d2[0], d2[1], g2[0], g2[1], m2(0, x2, v2)), s2.push(...a2), s2.push(d2[0], d2[1], g2[0], g2[1], m2(1, x2, v2)), s2.push(...a2), s2.push(d2[0], d2[1], g2[0], g2[1], m2(2, x2, v2)), s2.push(...a2), s2.push(d2[0], d2[1], g2[0], g2[1], m2(3, x2, v2)), s2.push(...a2), o2.push(u2, u2 + 1, u2 + 2, u2 + 1, u2 + 3, u2 + 2);
      }, _T.render.webgl.utils.writePointFeatureToBuffers = function(t2, e2, i2, n2, r2, s2) {
        const o2 = 3 + r2, a2 = t2[e2 + 0], l2 = t2[e2 + 1], h2 = af;
        h2.length = r2;
        for (let i3 = 0; i3 < h2.length; i3++)
          h2[i3] = t2[e2 + 2 + i3];
        let c2 = s2 ? s2.vertexPosition : 0, u2 = s2 ? s2.indexPosition : 0;
        const d2 = c2 / o2;
        return hf(i2, c2, a2, l2, 0), h2.length && i2.set(h2, c2 + 3), c2 += o2, hf(i2, c2, a2, l2, 1), h2.length && i2.set(h2, c2 + 3), c2 += o2, hf(i2, c2, a2, l2, 2), h2.length && i2.set(h2, c2 + 3), c2 += o2, hf(i2, c2, a2, l2, 3), h2.length && i2.set(h2, c2 + 3), c2 += o2, n2[u2++] = d2, n2[u2++] = d2 + 1, n2[u2++] = d2 + 3, n2[u2++] = d2 + 1, n2[u2++] = d2 + 2, n2[u2++] = d2 + 3, lf.vertexPosition = c2, lf.indexPosition = u2, lf;
      }, _T.render.webgl.utils.writePolygonTrianglesToBuffers = function(t2, e2, i2, n2, r2) {
        const s2 = 2 + r2;
        let o2 = e2;
        const a2 = t2.slice(o2, o2 + r2);
        o2 += r2;
        const l2 = t2[o2++];
        let h2 = 0;
        const c2 = new Array(l2 - 1);
        for (let e3 = 0; e3 < l2; e3++)
          h2 += t2[o2++], e3 < l2 - 1 && (c2[e3] = h2);
        const u2 = t2.slice(o2, o2 + 2 * h2), d2 = Ag.exports(u2, c2, 2);
        for (let t3 = 0; t3 < d2.length; t3++)
          n2.push(d2[t3] + i2.length / s2);
        for (let t3 = 0; t3 < u2.length; t3 += 2)
          i2.push(u2[t3], u2[t3 + 1], ...a2);
        return o2 + 2 * h2;
      }, _T.renderer = {}, _T.renderer.Composite = eo, _T.renderer.Layer = Cc, _T.renderer.Map = ws, _T.renderer.canvas = {}, _T.renderer.canvas.ImageLayer = Ic, _T.renderer.canvas.Layer = Pc, _T.renderer.canvas.Layer.canvasPool = bc, _T.renderer.canvas.TileLayer = Oc, _T.renderer.canvas.VectorImageLayer = Tp, _T.renderer.canvas.VectorLayer = Ep, _T.renderer.canvas.VectorTileLayer = Rp, _T.renderer.vector = {}, _T.renderer.vector.defaultOrder = Pl, _T.renderer.vector.getSquaredTolerance = Il, _T.renderer.vector.getTolerance = Ll, _T.renderer.vector.renderFeature = Ml, _T.renderer.webgl = {}, _T.renderer.webgl.Layer = gd, _T.renderer.webgl.PointsLayer = gf, _T.renderer.webgl.TileLayer = wd, _T.renderer.webgl.TileLayer.Attributes = pd, _T.renderer.webgl.TileLayer.Uniforms = fd, _T.renderer.webgl.VectorLayer = class extends gd {
        constructor(t2, e2) {
          const i2 = e2.uniforms || {}, n2 = [1, 0, 0, 1, 0, 0];
          i2[Wu] = n2, super(t2, { uniforms: i2, postProcesses: e2.postProcesses }), this.sourceRevision_ = -1, this.previousExtent_ = [1 / 0, 1 / 0, -1 / 0, -1 / 0], this.currentTransform_ = n2;
          const r2 = { color: function() {
            return Ef("#ddd");
          }, opacity: function() {
            return 1;
          }, ...e2.fill && e2.fill.attributes }, s2 = { color: function() {
            return Ef("#eee");
          }, opacity: function() {
            return 1;
          }, width: function() {
            return 1.5;
          }, ...e2.stroke && e2.stroke.attributes }, o2 = { color: function() {
            return Ef("#eee");
          }, opacity: function() {
            return 1;
          }, ...e2.point && e2.point.attributes };
          this.fillVertexShader_ = e2.fill && e2.fill.vertexShader || Cf, this.fillFragmentShader_ = e2.fill && e2.fill.fragmentShader || bf, this.fillAttributes_ = Mf(r2), this.strokeVertexShader_ = e2.stroke && e2.stroke.vertexShader || Rf, this.strokeFragmentShader_ = e2.stroke && e2.stroke.fragmentShader || Pf, this.strokeAttributes_ = Mf(s2), this.pointVertexShader_ = e2.point && e2.point.vertexShader || If, this.pointFragmentShader_ = e2.point && e2.point.fragmentShader || Lf, this.pointAttributes_ = Mf(o2), this.worker_ = df(), this.batch_ = new yf();
          const a2 = this.getLayer().getSource();
          this.batch_.addFeatures(a2.getFeatures()), this.sourceListenKeys_ = [N(a2, Oh, this.handleSourceFeatureAdded_, this), N(a2, Nh, this.handleSourceFeatureChanged_, this), N(a2, kh, this.handleSourceFeatureDelete_, this), N(a2, Dh, this.handleSourceFeatureClear_, this)];
        }
        afterHelperCreated() {
          this.polygonRenderer_ = new wf(this.helper, this.worker_, this.fillVertexShader_, this.fillFragmentShader_, this.fillAttributes_), this.pointRenderer_ = new vf(this.helper, this.worker_, this.pointVertexShader_, this.pointFragmentShader_, this.pointAttributes_), this.lineStringRenderer_ = new _f(this.helper, this.worker_, this.strokeVertexShader_, this.strokeFragmentShader_, this.strokeAttributes_);
        }
        handleSourceFeatureAdded_(t2) {
          const e2 = t2.feature;
          this.batch_.addFeature(e2);
        }
        handleSourceFeatureChanged_(t2) {
          const e2 = t2.feature;
          this.batch_.changeFeature(e2);
        }
        handleSourceFeatureDelete_(t2) {
          const e2 = t2.feature;
          this.batch_.removeFeature(e2);
        }
        handleSourceFeatureClear_() {
          this.batch_.clear();
        }
        renderFrame(t2) {
          const e2 = this.helper.getGL();
          this.preRender(e2, t2);
          const i2 = this.getLayer().getSource(), n2 = t2.viewState.projection, r2 = i2.getWrapX() && n2.canWrapX(), s2 = n2.getExtent(), o2 = t2.extent, a2 = r2 ? Se(s2) : null, l2 = r2 ? Math.ceil((o2[2] - s2[2]) / a2) + 1 : 1;
          let h2 = r2 ? Math.floor((o2[0] - s2[0]) / a2) : 0;
          do {
            this.polygonRenderer_.render(this.batch_.polygonBatch, this.currentTransform_, t2, h2 * a2), this.lineStringRenderer_.render(this.batch_.lineStringBatch, this.currentTransform_, t2, h2 * a2), this.pointRenderer_.render(this.batch_.pointBatch, this.currentTransform_, t2, h2 * a2);
          } while (++h2 < l2);
          this.helper.finalizeDraw(t2);
          const c2 = this.helper.getCanvas(), u2 = t2.layerStatesArray[t2.layerIndex].opacity;
          return u2 !== parseFloat(c2.style.opacity) && (c2.style.opacity = String(u2)), this.postRender(e2, t2), c2;
        }
        prepareFrameInternal(t2) {
          const e2 = this.getLayer(), i2 = e2.getSource(), n2 = t2.viewState, r2 = !t2.viewHints[Ro] && !t2.viewHints[Po], s2 = !ee(this.previousExtent_, t2.extent), o2 = this.sourceRevision_ < i2.getRevision();
          if (o2 && (this.sourceRevision_ = i2.getRevision()), r2 && (s2 || o2)) {
            const r3 = n2.projection, s3 = n2.resolution, o3 = e2 instanceof Ig ? e2.getRenderBuffer() : 0, a2 = Xt(t2.extent, o3 * s3);
            i2.loadFeatures(a2, s3, r3), this.ready = false;
            let l2 = 3;
            const h2 = () => {
              l2--, this.ready = l2 <= 0, this.getLayer().changed();
            };
            this.polygonRenderer_.rebuild(this.batch_.polygonBatch, t2, "Polygon", h2), this.lineStringRenderer_.rebuild(this.batch_.lineStringBatch, t2, "LineString", h2), this.pointRenderer_.rebuild(this.batch_.pointBatch, t2, "Point", h2), this.previousExtent_ = t2.extent.slice();
          }
          return this.helper.makeProjectionTransform(t2, this.currentTransform_), this.helper.prepareDraw(t2), true;
        }
        forEachFeatureAtCoordinate(t2, e2, i2, n2, r2) {
        }
        disposeInternal() {
          this.worker_.terminate(), this.layer_ = null, this.sourceListenKeys_.forEach(function(t2) {
            k(t2);
          }), this.sourceListenKeys_ = null, super.disposeInternal();
        }
      }, _T.renderer.webgl.shaders = {}, _T.renderer.webgl.shaders.FILL_FRAGMENT_SHADER = bf, _T.renderer.webgl.shaders.FILL_VERTEX_SHADER = Cf, _T.renderer.webgl.shaders.POINT_FRAGMENT_SHADER = Lf, _T.renderer.webgl.shaders.POINT_VERTEX_SHADER = If, _T.renderer.webgl.shaders.STROKE_FRAGMENT_SHADER = Pf, _T.renderer.webgl.shaders.STROKE_VERTEX_SHADER = Rf, _T.renderer.webgl.shaders.packColor = Ef, _T.reproj = {}, _T.reproj.Image = gc, _T.reproj.Tile = zl, _T.reproj.Triangulation = Ul, _T.reproj.calculateSourceExtentResolution = jl, _T.reproj.calculateSourceResolution = Gl, _T.reproj.canvasPool = Nl, _T.reproj.common = {}, _T.reproj.common.ERROR_THRESHOLD = 0.5, _T.reproj.render = Bl, _T.resolutionconstraint = {}, _T.resolutionconstraint.createMinMaxResolution = ko, _T.resolutionconstraint.createSnapToPower = Do, _T.resolutionconstraint.createSnapToResolutions = No, _T.rotationconstraint = {}, _T.rotationconstraint.createSnapToN = Bo, _T.rotationconstraint.createSnapToZero = Uo, _T.rotationconstraint.disable = Go, _T.rotationconstraint.none = jo, _T.size = {}, _T.size.buffer = Ua, _T.size.hasArea = za, _T.size.scale = Xa, _T.size.toSize = Va, _T.source = {}, _T.source.BingMaps = class extends uh {
        constructor(t2) {
          const e2 = void 0 !== t2.hidpi && t2.hidpi;
          super({ cacheSize: t2.cacheSize, crossOrigin: "anonymous", interpolate: t2.interpolate, opaque: true, projection: Ui("EPSG:3857"), reprojectionErrorThreshold: t2.reprojectionErrorThreshold, state: "loading", tileLoadFunction: t2.tileLoadFunction, tilePixelRatio: e2 ? 2 : 1, wrapX: void 0 === t2.wrapX || t2.wrapX, transition: t2.transition, zDirection: t2.zDirection }), this.hidpi_ = e2, this.culture_ = void 0 !== t2.culture ? t2.culture : "en-us", this.maxZoom_ = void 0 !== t2.maxZoom ? t2.maxZoom : -1, this.apiKey_ = t2.key, this.imagerySet_ = t2.imagerySet;
          vl("https://dev.virtualearth.net/REST/v1/Imagery/Metadata/" + this.imagerySet_ + "?uriScheme=https&include=ImageryProviders&key=" + this.apiKey_ + "&c=" + this.culture_, this.handleImageryMetadataResponse.bind(this), void 0, "jsonp");
        }
        getApiKey() {
          return this.apiKey_;
        }
        getImagerySet() {
          return this.imagerySet_;
        }
        handleImageryMetadataResponse(t2) {
          if (200 != t2.statusCode || "OK" != t2.statusDescription || "ValidCredentials" != t2.authenticationResultCode || 1 != t2.resourceSets.length || 1 != t2.resourceSets[0].resources.length)
            return void this.setState("error");
          const e2 = t2.resourceSets[0].resources[0], i2 = -1 == this.maxZoom_ ? e2.zoomMax : this.maxZoom_, n2 = ih(this.getProjection()), r2 = this.hidpi_ ? 2 : 1, s2 = e2.imageWidth == e2.imageHeight ? e2.imageWidth / r2 : [e2.imageWidth / r2, e2.imageHeight / r2], o2 = Ql({ extent: n2, minZoom: e2.zoomMin, maxZoom: i2, tileSize: s2 });
          this.tileGrid = o2;
          const a2 = this.culture_, l2 = this.hidpi_;
          if (this.tileUrlFunction = ah(e2.imageUrlSubdomains.map(function(t3) {
            const i3 = [0, 0, 0], n3 = e2.imageUrl.replace("{subdomain}", t3).replace("{culture}", a2);
            return function(t4, e3, r3) {
              if (t4) {
                el(t4[0], t4[1], t4[2], i3);
                let e4 = n3;
                return l2 && (e4 += "&dpi=d1&device=mobile"), e4.replace("{quadkey}", gh(i3));
              }
            };
          })), e2.imageryProviders) {
            const t3 = qi(Ui("EPSG:4326"), this.getProjection());
            this.setAttributions(function(i3) {
              const n3 = [], r3 = i3.viewState, s3 = this.getTileGrid(), o3 = s3.getZForResolution(r3.resolution, this.zDirection), a3 = s3.getTileCoordForCoordAndZ(r3.center, o3)[0];
              return e2.imageryProviders.map(function(e3) {
                let r4 = false;
                const s4 = e3.coverageAreas;
                for (let e4 = 0, n4 = s4.length; e4 < n4; ++e4) {
                  const n5 = s4[e4];
                  if (a3 >= n5.zoomMin && a3 <= n5.zoomMax) {
                    const e5 = n5.bbox;
                    if (we(Re([e5[1], e5[0], e5[3], e5[2]], t3), i3.extent)) {
                      r4 = true;
                      break;
                    }
                  }
                }
                r4 && n3.push(e3.attribution);
              }), n3.push('<a class="ol-attribution-bing-tos" href="https://www.microsoft.com/maps/product/terms.html" target="_blank">Terms of Use</a>'), n3;
            }.bind(this));
          }
          this.setState("ready");
        }
      }, _T.source.BingMaps.quadKey = gh, _T.source.CartoDB = class extends fh {
        constructor(t2) {
          super({ attributions: t2.attributions, cacheSize: t2.cacheSize, crossOrigin: t2.crossOrigin, maxZoom: void 0 !== t2.maxZoom ? t2.maxZoom : 18, minZoom: t2.minZoom, projection: t2.projection, transition: t2.transition, wrapX: t2.wrapX, zDirection: t2.zDirection }), this.account_ = t2.account, this.mapId_ = t2.map || "", this.config_ = t2.config || {}, this.templateCache_ = {}, this.initializeMap_();
        }
        getConfig() {
          return this.config_;
        }
        updateConfig(t2) {
          Object.assign(this.config_, t2), this.initializeMap_();
        }
        setConfig(t2) {
          this.config_ = t2 || {}, this.initializeMap_();
        }
        initializeMap_() {
          const t2 = JSON.stringify(this.config_);
          if (this.templateCache_[t2])
            return void this.applyTemplate_(this.templateCache_[t2]);
          let e2 = "https://" + this.account_ + ".carto.com/api/v1/map";
          this.mapId_ && (e2 += "/named/" + this.mapId_);
          const i2 = new XMLHttpRequest();
          i2.addEventListener("load", this.handleInitResponse_.bind(this, t2)), i2.addEventListener("error", this.handleInitError_.bind(this)), i2.open("POST", e2), i2.setRequestHeader("Content-type", "application/json"), i2.send(JSON.stringify(this.config_));
        }
        handleInitResponse_(t2, e2) {
          const i2 = e2.target;
          if (!i2.status || i2.status >= 200 && i2.status < 300) {
            let e3;
            try {
              e3 = JSON.parse(i2.responseText);
            } catch (t3) {
              return void this.setState("error");
            }
            this.applyTemplate_(e3), this.templateCache_[t2] = e3, this.setState("ready");
          } else
            this.setState("error");
        }
        handleInitError_(t2) {
          this.setState("error");
        }
        applyTemplate_(t2) {
          const e2 = "https://" + t2.cdn_url.https + "/" + this.account_ + "/api/v1/map/" + t2.layergroupid + "/{z}/{x}/{y}.png";
          this.setUrl(e2);
        }
      }, _T.source.Cluster = class extends zh {
        constructor(t2) {
          super({ attributions: t2.attributions, wrapX: t2.wrapX }), this.resolution = void 0, this.distance = void 0 !== t2.distance ? t2.distance : 20, this.minDistance = t2.minDistance || 0, this.interpolationRatio = 0, this.features = [], this.geometryFunction = t2.geometryFunction || function(t3) {
            const e2 = t3.getGeometry();
            return at("Point" == e2.getType(), 10), e2;
          }, this.createCustomCluster_ = t2.createCluster, this.source = null, this.boundRefresh_ = this.refresh.bind(this), this.updateDistance(this.distance, this.minDistance), this.setSource(t2.source || null);
        }
        clear(t2) {
          this.features.length = 0, super.clear(t2);
        }
        getDistance() {
          return this.distance;
        }
        getSource() {
          return this.source;
        }
        loadFeatures(t2, e2, i2) {
          this.source.loadFeatures(t2, e2, i2), e2 !== this.resolution && (this.resolution = e2, this.refresh());
        }
        setDistance(t2) {
          this.updateDistance(t2, this.minDistance);
        }
        setMinDistance(t2) {
          this.updateDistance(this.distance, t2);
        }
        getMinDistance() {
          return this.minDistance;
        }
        setSource(t2) {
          this.source && this.source.removeEventListener(S, this.boundRefresh_), this.source = t2, t2 && t2.addEventListener(S, this.boundRefresh_), this.refresh();
        }
        refresh() {
          this.clear(), this.cluster(), this.addFeatures(this.features);
        }
        updateDistance(t2, e2) {
          const i2 = 0 === t2 ? 0 : Math.min(e2, t2) / t2, n2 = t2 !== this.distance || this.interpolationRatio !== i2;
          this.distance = t2, this.minDistance = e2, this.interpolationRatio = i2, n2 && this.refresh();
        }
        cluster() {
          if (void 0 === this.resolution || !this.source)
            return;
          const t2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], e2 = this.distance * this.resolution, i2 = this.source.getFeatures(), n2 = {};
          for (let r2 = 0, s2 = i2.length; r2 < s2; r2++) {
            const s3 = i2[r2];
            if (!(z(s3) in n2)) {
              const i3 = this.geometryFunction(s3);
              if (i3) {
                Qt(i3.getCoordinates(), t2), Xt(t2, e2, t2);
                const r3 = this.source.getFeaturesInExtent(t2).filter(function(t3) {
                  const e3 = z(t3);
                  return !(e3 in n2) && (n2[e3] = true, true);
                });
                this.features.push(this.createCluster(r3, t2));
              }
            }
          }
        }
        createCluster(t2, e2) {
          const i2 = [0, 0];
          for (let e3 = t2.length - 1; e3 >= 0; --e3) {
            const n3 = this.geometryFunction(t2[e3]);
            n3 ? mi(i2, n3.getCoordinates()) : t2.splice(e3, 1);
          }
          Ei(i2, 1 / t2.length);
          const n2 = ge(e2), r2 = this.interpolationRatio, s2 = new Wn([i2[0] * (1 - r2) + n2[0] * r2, i2[1] * (1 - r2) + n2[1] * r2]);
          return this.createCustomCluster_ ? this.createCustomCluster_(s2, t2) : new lt({ geometry: s2, features: t2 });
        }
      }, _T.source.DataTile = Xh, _T.source.GeoTIFF = ic, _T.source.IIIF = class extends uh {
        constructor(t2) {
          const e2 = t2 || {};
          let i2 = e2.url || "";
          i2 += i2.lastIndexOf("/") === i2.length - 1 || "" === i2 ? "" : "/";
          const n2 = e2.version || sc, r2 = e2.sizes || [], s2 = e2.size;
          at(null != s2 && Array.isArray(s2) && 2 == s2.length && !isNaN(s2[0]) && s2[0] > 0 && !isNaN(s2[1]) && s2[1] > 0, 60);
          const o2 = s2[0], a2 = s2[1], l2 = e2.tileSize, h2 = e2.tilePixelRatio || 1, c2 = e2.format || "jpg", u2 = e2.quality || (e2.version == rc ? "native" : "default");
          let d2 = e2.resolutions || [];
          const g2 = e2.supports || [], f2 = e2.extent || [0, -a2, o2, 0], p2 = null != r2 && Array.isArray(r2) && r2.length > 0, m2 = void 0 !== l2 && ("number" == typeof l2 && Number.isInteger(l2) && l2 > 0 || Array.isArray(l2) && l2.length > 0), _2 = null != g2 && Array.isArray(g2) && (g2.includes("regionByPx") || g2.includes("regionByPct")) && (g2.includes("sizeByWh") || g2.includes("sizeByH") || g2.includes("sizeByW") || g2.includes("sizeByPct"));
          let y2, x2, v2;
          if (d2.sort(function(t3, e3) {
            return e3 - t3;
          }), m2 || _2)
            if (null != l2 && ("number" == typeof l2 && Number.isInteger(l2) && l2 > 0 ? (y2 = l2, x2 = l2) : Array.isArray(l2) && l2.length > 0 && ((1 == l2.length || null == l2[1] && Number.isInteger(l2[0])) && (y2 = l2[0], x2 = l2[0]), 2 == l2.length && (Number.isInteger(l2[0]) && Number.isInteger(l2[1]) ? (y2 = l2[0], x2 = l2[1]) : null == l2[0] && Number.isInteger(l2[1]) && (y2 = l2[1], x2 = l2[1])))), void 0 !== y2 && void 0 !== x2 || (y2 = Lo, x2 = Lo), 0 == d2.length) {
              v2 = Math.max(Math.ceil(Math.log(o2 / y2) / Math.LN2), Math.ceil(Math.log(a2 / x2) / Math.LN2));
              for (let t3 = v2; t3 >= 0; t3--)
                d2.push(Math.pow(2, t3));
            } else {
              const t3 = Math.max(...d2);
              v2 = Math.round(Math.log(t3) / Math.LN2);
            }
          else if (y2 = o2, x2 = a2, d2 = [], p2) {
            r2.sort(function(t4, e3) {
              return t4[0] - e3[0];
            }), v2 = -1;
            const t3 = [];
            for (let e3 = 0; e3 < r2.length; e3++) {
              const i3 = o2 / r2[e3][0];
              d2.length > 0 && d2[d2.length - 1] == i3 ? t3.push(e3) : (d2.push(i3), v2++);
            }
            if (t3.length > 0)
              for (let e3 = 0; e3 < t3.length; e3++)
                r2.splice(t3[e3] - e3, 1);
          } else
            d2.push(1), r2.push([o2, a2]), v2 = 0;
          const S2 = new ql({ tileSize: [y2, x2], extent: f2, origin: xe(f2), resolutions: d2 }), w2 = nc.bind(null, Va(l2 || 256).map(function(t3) {
            return t3 * h2;
          }));
          super({ attributions: e2.attributions, attributionsCollapsible: e2.attributionsCollapsible, cacheSize: e2.cacheSize, crossOrigin: e2.crossOrigin, interpolate: e2.interpolate, projection: e2.projection, reprojectionErrorThreshold: e2.reprojectionErrorThreshold, state: e2.state, tileClass: w2, tileGrid: S2, tilePixelRatio: e2.tilePixelRatio, tileUrlFunction: function(t3, e3, s3) {
            let l3, h3;
            const f3 = t3[0];
            if (f3 > v2)
              return;
            const S3 = t3[1], w3 = t3[2], E2 = d2[f3];
            if (!(void 0 === S3 || void 0 === w3 || void 0 === E2 || S3 < 0 || Math.ceil(o2 / E2 / y2) <= S3 || w3 < 0 || Math.ceil(a2 / E2 / x2) <= w3)) {
              if (_2 || m2) {
                const t4 = S3 * y2 * E2, e4 = w3 * x2 * E2;
                let i3 = y2 * E2, r3 = x2 * E2, s4 = y2, c3 = x2;
                if (t4 + i3 > o2 && (i3 = o2 - t4), e4 + r3 > a2 && (r3 = a2 - e4), t4 + y2 * E2 > o2 && (s4 = Math.floor((o2 - t4 + E2 - 1) / E2)), e4 + x2 * E2 > a2 && (c3 = Math.floor((a2 - e4 + E2 - 1) / E2)), 0 == t4 && i3 == o2 && 0 == e4 && r3 == a2)
                  l3 = "full";
                else if (!_2 || g2.includes("regionByPx"))
                  l3 = t4 + "," + e4 + "," + i3 + "," + r3;
                else if (g2.includes("regionByPct")) {
                  l3 = "pct:" + dc(t4 / o2 * 100) + "," + dc(e4 / a2 * 100) + "," + dc(i3 / o2 * 100) + "," + dc(r3 / a2 * 100);
                }
                n2 != oc || _2 && !g2.includes("sizeByWh") ? !_2 || g2.includes("sizeByW") ? h3 = s4 + "," : g2.includes("sizeByH") ? h3 = "," + c3 : g2.includes("sizeByWh") ? h3 = s4 + "," + c3 : g2.includes("sizeByPct") && (h3 = "pct:" + dc(100 / E2)) : h3 = s4 + "," + c3;
              } else if (l3 = "full", p2) {
                const t4 = r2[f3][0], e4 = r2[f3][1];
                h3 = n2 == oc ? t4 == o2 && e4 == a2 ? "max" : t4 + "," + e4 : t4 == o2 ? "full" : t4 + ",";
              } else
                h3 = n2 == oc ? "max" : "full";
              return i2 + l3 + "/" + h3 + "/0/" + u2 + "." + c2;
            }
          }, transition: e2.transition }), this.zDirection = e2.zDirection;
        }
      }, _T.source.Image = yc, _T.source.Image.ImageSourceEvent = _c, _T.source.Image.defaultImageLoadFunction = xc, _T.source.ImageArcGISRest = class extends yc {
        constructor(t2) {
          super({ attributions: (t2 = t2 || {}).attributions, interpolate: t2.interpolate, projection: t2.projection, resolutions: t2.resolutions }), this.crossOrigin_ = void 0 !== t2.crossOrigin ? t2.crossOrigin : null, this.hidpi_ = void 0 === t2.hidpi || t2.hidpi, this.url_ = t2.url, this.imageLoadFunction_ = void 0 !== t2.imageLoadFunction ? t2.imageLoadFunction : xc, this.params_ = t2.params || {}, this.image_ = null, this.imageSize_ = [0, 0], this.renderedRevision_ = 0, this.ratio_ = void 0 !== t2.ratio ? t2.ratio : 1.5;
        }
        getParams() {
          return this.params_;
        }
        getImageInternal(t2, e2, i2, n2) {
          if (void 0 === this.url_)
            return null;
          e2 = this.findNearestResolution(e2), i2 = this.hidpi_ ? i2 : 1;
          const r2 = this.image_;
          if (r2 && this.renderedRevision_ == this.getRevision() && r2.getResolution() == e2 && r2.getPixelRatio() == i2 && Yt(r2.getExtent(), t2))
            return r2;
          const s2 = { F: "image", FORMAT: "PNG32", TRANSPARENT: true };
          Object.assign(s2, this.params_);
          const o2 = ((t2 = t2.slice())[0] + t2[2]) / 2, a2 = (t2[1] + t2[3]) / 2;
          if (1 != this.ratio_) {
            const e3 = this.ratio_ * Se(t2) / 2, i3 = this.ratio_ * _e(t2) / 2;
            t2[0] = o2 - e3, t2[1] = a2 - i3, t2[2] = o2 + e3, t2[3] = a2 + i3;
          }
          const l2 = e2 / i2, h2 = Math.ceil(Se(t2) / l2), c2 = Math.ceil(_e(t2) / l2);
          t2[0] = o2 - l2 * h2 / 2, t2[2] = o2 + l2 * h2 / 2, t2[1] = a2 - l2 * c2 / 2, t2[3] = a2 + l2 * c2 / 2, this.imageSize_[0] = h2, this.imageSize_[1] = c2;
          const u2 = this.getRequestUrl_(t2, this.imageSize_, i2, n2, s2);
          return this.image_ = new Ar(t2, e2, i2, u2, this.crossOrigin_, this.imageLoadFunction_), this.renderedRevision_ = this.getRevision(), this.image_.addEventListener(S, this.handleImageChange.bind(this)), this.image_;
        }
        getImageLoadFunction() {
          return this.imageLoadFunction_;
        }
        getRequestUrl_(t2, e2, i2, n2, r2) {
          const s2 = n2.getCode().split(/:(?=\d+$)/).pop();
          r2.SIZE = e2[0] + "," + e2[1], r2.BBOX = t2.join(","), r2.BBOXSR = s2, r2.IMAGESR = s2, r2.DPI = Math.round(90 * i2);
          const o2 = this.url_, a2 = o2.replace(/MapServer\/?$/, "MapServer/export").replace(/ImageServer\/?$/, "ImageServer/exportImage");
          return a2 == o2 && at(false, 50), vc(a2, r2);
        }
        getUrl() {
          return this.url_;
        }
        setImageLoadFunction(t2) {
          this.image_ = null, this.imageLoadFunction_ = t2, this.changed();
        }
        setUrl(t2) {
          t2 != this.url_ && (this.url_ = t2, this.image_ = null, this.changed());
        }
        updateParams(t2) {
          Object.assign(this.params_, t2), this.image_ = null, this.changed();
        }
      }, _T.source.ImageCanvas = class extends yc {
        constructor(t2) {
          super({ attributions: (t2 = t2 || {}).attributions, interpolate: t2.interpolate, projection: t2.projection, resolutions: t2.resolutions, state: t2.state }), this.canvasFunction_ = t2.canvasFunction, this.canvas_ = null, this.renderedRevision_ = 0, this.ratio_ = void 0 !== t2.ratio ? t2.ratio : 1.5;
        }
        getImageInternal(t2, e2, i2, n2) {
          e2 = this.findNearestResolution(e2);
          let r2 = this.canvas_;
          if (r2 && this.renderedRevision_ == this.getRevision() && r2.getResolution() == e2 && r2.getPixelRatio() == i2 && Yt(r2.getExtent(), t2))
            return r2;
          Ce(t2 = t2.slice(), this.ratio_);
          const s2 = [Se(t2) / e2 * i2, _e(t2) / e2 * i2], o2 = this.canvasFunction_.call(this, t2, e2, i2, s2, n2);
          return o2 && (r2 = new Nr(t2, e2, i2, o2)), this.canvas_ = r2, this.renderedRevision_ = this.getRevision(), r2;
        }
      }, _T.source.ImageMapGuide = class extends yc {
        constructor(t2) {
          super({ interpolate: t2.interpolate, projection: t2.projection, resolutions: t2.resolutions }), this.crossOrigin_ = void 0 !== t2.crossOrigin ? t2.crossOrigin : null, this.displayDpi_ = void 0 !== t2.displayDpi ? t2.displayDpi : 96, this.params_ = t2.params || {}, this.url_ = t2.url, this.imageLoadFunction_ = void 0 !== t2.imageLoadFunction ? t2.imageLoadFunction : xc, this.hidpi_ = void 0 === t2.hidpi || t2.hidpi, this.metersPerUnit_ = void 0 !== t2.metersPerUnit ? t2.metersPerUnit : 1, this.ratio_ = void 0 !== t2.ratio ? t2.ratio : 1, this.useOverlay_ = void 0 !== t2.useOverlay && t2.useOverlay, this.image_ = null, this.renderedRevision_ = 0;
        }
        getParams() {
          return this.params_;
        }
        getImageInternal(t2, e2, i2, n2) {
          e2 = this.findNearestResolution(e2), i2 = this.hidpi_ ? i2 : 1;
          let r2 = this.image_;
          if (r2 && this.renderedRevision_ == this.getRevision() && r2.getResolution() == e2 && r2.getPixelRatio() == i2 && Yt(r2.getExtent(), t2))
            return r2;
          1 != this.ratio_ && Ce(t2 = t2.slice(), this.ratio_);
          const s2 = [Se(t2) / e2 * i2, _e(t2) / e2 * i2];
          if (void 0 !== this.url_) {
            const o2 = this.getUrl(this.url_, this.params_, t2, s2, n2);
            r2 = new Ar(t2, e2, i2, o2, this.crossOrigin_, this.imageLoadFunction_), r2.addEventListener(S, this.handleImageChange.bind(this));
          } else
            r2 = null;
          return this.image_ = r2, this.renderedRevision_ = this.getRevision(), r2;
        }
        getImageLoadFunction() {
          return this.imageLoadFunction_;
        }
        updateParams(t2) {
          Object.assign(this.params_, t2), this.changed();
        }
        getUrl(t2, e2, i2, n2, r2) {
          const s2 = function(t3, e3, i3, n3) {
            const r3 = Se(t3), s3 = _e(t3), o3 = e3[0], a3 = e3[1], l2 = 0.0254 / n3;
            return a3 * r3 > o3 * s3 ? r3 * i3 / (o3 * l2) : s3 * i3 / (a3 * l2);
          }(i2, n2, this.metersPerUnit_, this.displayDpi_), o2 = ge(i2), a2 = { OPERATION: this.useOverlay_ ? "GETDYNAMICMAPOVERLAYIMAGE" : "GETMAPIMAGE", VERSION: "2.0.0", LOCALE: "en", CLIENTAGENT: "ol/source/ImageMapGuide source", CLIP: "1", SETDISPLAYDPI: this.displayDpi_, SETDISPLAYWIDTH: Math.round(n2[0]), SETDISPLAYHEIGHT: Math.round(n2[1]), SETVIEWSCALE: s2, SETVIEWCENTERX: o2[0], SETVIEWCENTERY: o2[1] };
          return Object.assign(a2, e2), vc(t2, a2);
        }
        setImageLoadFunction(t2) {
          this.image_ = null, this.imageLoadFunction_ = t2, this.changed();
        }
      }, _T.source.ImageStatic = class extends yc {
        constructor(t2) {
          const e2 = void 0 !== t2.crossOrigin ? t2.crossOrigin : null, i2 = void 0 !== t2.imageLoadFunction ? t2.imageLoadFunction : xc;
          super({ attributions: t2.attributions, interpolate: t2.interpolate, projection: Ui(t2.projection) }), this.url_ = t2.url, this.imageExtent_ = t2.imageExtent, this.image_ = new Ar(this.imageExtent_, void 0, 1, this.url_, e2, i2), this.imageSize_ = t2.imageSize ? t2.imageSize : null, this.image_.addEventListener(S, this.handleImageChange.bind(this));
        }
        getImageExtent() {
          return this.imageExtent_;
        }
        getImageInternal(t2, e2, i2, n2) {
          return we(t2, this.image_.getExtent()) ? this.image_ : null;
        }
        getUrl() {
          return this.url_;
        }
        handleImageChange(t2) {
          if (this.image_.getState() == Lr) {
            const t3 = this.image_.getExtent(), e2 = this.image_.getImage();
            let i2, n2;
            this.imageSize_ ? (i2 = this.imageSize_[0], n2 = this.imageSize_[1]) : (i2 = e2.width, n2 = e2.height);
            const r2 = Se(t3), s2 = _e(t3), o2 = r2 / i2, a2 = s2 / n2;
            let l2 = i2, h2 = n2;
            if (o2 > a2 ? l2 = Math.round(r2 / a2) : h2 = Math.round(s2 / o2), l2 !== i2 || h2 !== n2) {
              const t4 = Dr(l2, h2);
              this.getInterpolate() || (t4.imageSmoothingEnabled = false);
              const r3 = t4.canvas;
              t4.drawImage(e2, 0, 0, i2, n2, 0, 0, r3.width, r3.height), this.image_.setImage(r3);
            }
          }
          super.handleImageChange(t2);
        }
      }, _T.source.ImageWMS = class extends yc {
        constructor(t2) {
          super({ attributions: (t2 = t2 || {}).attributions, interpolate: t2.interpolate, projection: t2.projection, resolutions: t2.resolutions }), this.crossOrigin_ = void 0 !== t2.crossOrigin ? t2.crossOrigin : null, this.url_ = t2.url, this.imageLoadFunction_ = void 0 !== t2.imageLoadFunction ? t2.imageLoadFunction : xc, this.params_ = Object.assign({}, t2.params), this.v13_ = true, this.updateV13_(), this.serverType_ = t2.serverType, this.hidpi_ = void 0 === t2.hidpi || t2.hidpi, this.image_ = null, this.imageSize_ = [0, 0], this.renderedRevision_ = 0, this.ratio_ = void 0 !== t2.ratio ? t2.ratio : 1.5;
        }
        getFeatureInfoUrl(t2, e2, i2, n2) {
          if (void 0 === this.url_)
            return;
          const r2 = Ui(i2), s2 = this.getProjection();
          s2 && s2 !== r2 && (e2 = Gl(s2, r2, t2, e2), t2 = $i(t2, r2, s2));
          const o2 = pe(t2, e2, 0, wc), a2 = { SERVICE: "WMS", VERSION: Sc, REQUEST: "GetFeatureInfo", FORMAT: "image/png", TRANSPARENT: true, QUERY_LAYERS: this.params_.LAYERS };
          Object.assign(a2, this.params_, n2);
          const l2 = di((t2[0] - o2[0]) / e2, 4), h2 = di((o2[3] - t2[1]) / e2, 4);
          return a2[this.v13_ ? "I" : "X"] = l2, a2[this.v13_ ? "J" : "Y"] = h2, this.getRequestUrl_(o2, wc, 1, s2 || r2, a2);
        }
        getLegendUrl(t2, e2) {
          if (void 0 === this.url_)
            return;
          const i2 = { SERVICE: "WMS", VERSION: Sc, REQUEST: "GetLegendGraphic", FORMAT: "image/png" };
          if (void 0 === e2 || void 0 === e2.LAYER) {
            const t3 = this.params_.LAYERS;
            if (!(!Array.isArray(t3) || 1 === t3.length))
              return;
            i2.LAYER = t3;
          }
          if (void 0 !== t2) {
            const e3 = this.getProjection() ? this.getProjection().getMetersPerUnit() : 1, n2 = 28e-5;
            i2.SCALE = t2 * e3 / n2;
          }
          return Object.assign(i2, e2), vc(this.url_, i2);
        }
        getParams() {
          return this.params_;
        }
        getImageInternal(t2, e2, i2, n2) {
          if (void 0 === this.url_)
            return null;
          e2 = this.findNearestResolution(e2), 1 == i2 || this.hidpi_ && void 0 !== this.serverType_ || (i2 = 1);
          const r2 = e2 / i2, s2 = ge(t2), o2 = pe(s2, r2, 0, [gi(Se(t2) / r2, 4), gi(_e(t2) / r2, 4)]), a2 = pe(s2, r2, 0, [gi(this.ratio_ * Se(t2) / r2, 4), gi(this.ratio_ * _e(t2) / r2, 4)]), l2 = this.image_;
          if (l2 && this.renderedRevision_ == this.getRevision() && l2.getResolution() == e2 && l2.getPixelRatio() == i2 && Yt(l2.getExtent(), o2))
            return l2;
          const h2 = { SERVICE: "WMS", VERSION: Sc, REQUEST: "GetMap", FORMAT: "image/png", TRANSPARENT: true };
          Object.assign(h2, this.params_), this.imageSize_[0] = ui(Se(a2) / r2, 4), this.imageSize_[1] = ui(_e(a2) / r2, 4);
          const c2 = this.getRequestUrl_(a2, this.imageSize_, i2, n2, h2);
          return this.image_ = new Ar(a2, e2, i2, c2, this.crossOrigin_, this.imageLoadFunction_), this.renderedRevision_ = this.getRevision(), this.image_.addEventListener(S, this.handleImageChange.bind(this)), this.image_;
        }
        getImageLoadFunction() {
          return this.imageLoadFunction_;
        }
        getRequestUrl_(t2, e2, i2, n2, r2) {
          if (at(void 0 !== this.url_, 9), r2[this.v13_ ? "CRS" : "SRS"] = n2.getCode(), "STYLES" in this.params_ || (r2.STYLES = ""), 1 != i2)
            switch (this.serverType_) {
              case "geoserver":
                const t3 = 90 * i2 + 0.5 | 0;
                "FORMAT_OPTIONS" in r2 ? r2.FORMAT_OPTIONS += ";dpi:" + t3 : r2.FORMAT_OPTIONS = "dpi:" + t3;
                break;
              case "mapserver":
                r2.MAP_RESOLUTION = 90 * i2;
                break;
              case "carmentaserver":
              case "qgis":
                r2.DPI = 90 * i2;
                break;
              default:
                at(false, 8);
            }
          r2.WIDTH = e2[0], r2.HEIGHT = e2[1];
          const s2 = n2.getAxisOrientation();
          let o2;
          return o2 = this.v13_ && "ne" == s2.substr(0, 2) ? [t2[1], t2[0], t2[3], t2[2]] : t2, r2.BBOX = o2.join(","), vc(this.url_, r2);
        }
        getUrl() {
          return this.url_;
        }
        setImageLoadFunction(t2) {
          this.image_ = null, this.imageLoadFunction_ = t2, this.changed();
        }
        setUrl(t2) {
          t2 != this.url_ && (this.url_ = t2, this.image_ = null, this.changed());
        }
        updateParams(t2) {
          Object.assign(this.params_, t2), this.updateV13_(), this.image_ = null, this.changed();
        }
        updateV13_() {
          const t2 = this.params_.VERSION || Sc;
          this.v13_ = pi(t2, "1.3") >= 0;
        }
      }, _T.source.OGCMapTile = class extends uh {
        constructor(t2) {
          super({ attributions: t2.attributions, cacheSize: t2.cacheSize, crossOrigin: t2.crossOrigin, interpolate: t2.interpolate, projection: t2.projection, reprojectionErrorThreshold: t2.reprojectionErrorThreshold, state: "loading", tileLoadFunction: t2.tileLoadFunction, wrapX: void 0 === t2.wrapX || t2.wrapX, transition: t2.transition });
          Rg({ url: t2.url, projection: this.getProjection(), mediaType: t2.mediaType, context: t2.context || null }).then(this.handleTileSetInfo_.bind(this)).catch(this.handleError_.bind(this));
        }
        handleTileSetInfo_(t2) {
          this.tileGrid = t2.grid, this.setTileUrlFunction(t2.urlFunction, t2.urlTemplate), this.setState("ready");
        }
        handleError_(t2) {
          console.error(t2), this.setState("error");
        }
      }, _T.source.OGCVectorTile = class extends Qc {
        constructor(t2) {
          super({ attributions: t2.attributions, attributionsCollapsible: t2.attributionsCollapsible, cacheSize: t2.cacheSize, format: t2.format, overlaps: t2.overlaps, projection: t2.projection, tileClass: t2.tileClass, transition: t2.transition, wrapX: t2.wrapX, zDirection: t2.zDirection, state: "loading" });
          Rg({ url: t2.url, projection: this.getProjection(), mediaType: t2.mediaType, supportedMediaTypes: t2.format.supportedMediaTypes, context: t2.context || null }).then(this.handleTileSetInfo_.bind(this)).catch(this.handleError_.bind(this));
        }
        handleTileSetInfo_(t2) {
          this.tileGrid = t2.grid, this.setTileUrlFunction(t2.urlFunction, t2.urlTemplate), this.setState("ready");
        }
        handleError_(t2) {
          console.error(t2), this.setState("error");
        }
      }, _T.source.OSM = class extends fh {
        constructor(t2) {
          let e2;
          e2 = void 0 !== (t2 = t2 || {}).attributions ? t2.attributions : [Ec];
          const i2 = void 0 !== t2.crossOrigin ? t2.crossOrigin : "anonymous", n2 = void 0 !== t2.url ? t2.url : "https://tile.openstreetmap.org/{z}/{x}/{y}.png";
          super({ attributions: e2, attributionsCollapsible: false, cacheSize: t2.cacheSize, crossOrigin: i2, interpolate: t2.interpolate, maxZoom: void 0 !== t2.maxZoom ? t2.maxZoom : 19, opaque: void 0 === t2.opaque || t2.opaque, reprojectionErrorThreshold: t2.reprojectionErrorThreshold, tileLoadFunction: t2.tileLoadFunction, transition: t2.transition, url: n2, wrapX: t2.wrapX, zDirection: t2.zDirection });
        }
      }, _T.source.OSM.ATTRIBUTION = Ec, _T.source.Raster = Wc, _T.source.Raster.Processor = Uc, _T.source.Raster.RasterSourceEvent = Vc, _T.source.Raster.newImageData = Gc, _T.source.Source = Zl, _T.source.Stamen = class extends fh {
        constructor(t2) {
          const e2 = t2.layer.indexOf("-"), i2 = -1 == e2 ? t2.layer : t2.layer.slice(0, e2), n2 = $c[i2], r2 = Hc[t2.layer], s2 = void 0 !== t2.url ? t2.url : "https://stamen-tiles-{a-d}.a.ssl.fastly.net/" + t2.layer + "/{z}/{x}/{y}." + r2.extension;
          super({ attributions: qc, cacheSize: t2.cacheSize, crossOrigin: "anonymous", interpolate: t2.interpolate, maxZoom: null != t2.maxZoom ? t2.maxZoom : n2.maxZoom, minZoom: null != t2.minZoom ? t2.minZoom : n2.minZoom, opaque: r2.opaque, reprojectionErrorThreshold: t2.reprojectionErrorThreshold, tileLoadFunction: t2.tileLoadFunction, transition: t2.transition, url: s2, wrapX: t2.wrapX, zDirection: t2.zDirection });
        }
      }, _T.source.Tile = nh, _T.source.Tile.TileSourceEvent = rh, _T.source.TileArcGISRest = class extends uh {
        constructor(t2) {
          super({ attributions: (t2 = t2 || {}).attributions, cacheSize: t2.cacheSize, crossOrigin: t2.crossOrigin, interpolate: t2.interpolate, projection: t2.projection, reprojectionErrorThreshold: t2.reprojectionErrorThreshold, tileGrid: t2.tileGrid, tileLoadFunction: t2.tileLoadFunction, url: t2.url, urls: t2.urls, wrapX: void 0 === t2.wrapX || t2.wrapX, transition: t2.transition, zDirection: t2.zDirection }), this.params_ = t2.params || {}, this.hidpi_ = void 0 === t2.hidpi || t2.hidpi, this.tmpExtent_ = [1 / 0, 1 / 0, -1 / 0, -1 / 0], this.setKey(this.getKeyForParams_());
        }
        getKeyForParams_() {
          let t2 = 0;
          const e2 = [];
          for (const i2 in this.params_)
            e2[t2++] = i2 + "-" + this.params_[i2];
          return e2.join("/");
        }
        getParams() {
          return this.params_;
        }
        getRequestUrl_(t2, e2, i2, n2, r2, s2) {
          const o2 = this.urls;
          if (!o2)
            return;
          const a2 = r2.getCode().split(/:(?=\d+$)/).pop();
          let l2;
          if (s2.SIZE = e2[0] + "," + e2[1], s2.BBOX = i2.join(","), s2.BBOXSR = a2, s2.IMAGESR = a2, s2.DPI = Math.round(s2.DPI ? s2.DPI * n2 : 90 * n2), 1 == o2.length)
            l2 = o2[0];
          else {
            l2 = o2[li(ol2(t2), o2.length)];
          }
          return vc(l2.replace(/MapServer\/?$/, "MapServer/export").replace(/ImageServer\/?$/, "ImageServer/exportImage"), s2);
        }
        getTilePixelRatio(t2) {
          return this.hidpi_ ? t2 : 1;
        }
        updateParams(t2) {
          Object.assign(this.params_, t2), this.setKey(this.getKeyForParams_());
        }
        tileUrlFunction(t2, e2, i2) {
          let n2 = this.getTileGrid();
          if (n2 || (n2 = this.getTileGridForProjection(i2)), n2.getResolutions().length <= t2[0])
            return;
          1 == e2 || this.hidpi_ || (e2 = 1);
          const r2 = n2.getTileCoordExtent(t2, this.tmpExtent_);
          let s2 = Va(n2.getTileSize(t2[0]), this.tmpSize);
          1 != e2 && (s2 = Xa(s2, e2, this.tmpSize));
          const o2 = { F: "image", FORMAT: "PNG32", TRANSPARENT: true };
          return Object.assign(o2, this.params_), this.getRequestUrl_(t2, s2, r2, e2, i2, o2);
        }
      }, _T.source.TileDebug = class extends fh {
        constructor(t2) {
          super({ opaque: false, projection: (t2 = t2 || {}).projection, tileGrid: t2.tileGrid, wrapX: void 0 === t2.wrapX || t2.wrapX, zDirection: t2.zDirection, url: t2.template || "z:{z} x:{x} y:{y}", tileLoadFunction: (t3, e2) => {
            const i2 = t3.getTileCoord()[0], n2 = Va(this.tileGrid.getTileSize(i2)), r2 = Dr(n2[0], n2[1]);
            r2.strokeStyle = "grey", r2.strokeRect(0.5, 0.5, n2[0] + 0.5, n2[1] + 0.5), r2.fillStyle = "grey", r2.strokeStyle = "white", r2.textAlign = "center", r2.textBaseline = "middle", r2.font = "24px sans-serif", r2.lineWidth = 4, r2.strokeText(e2, n2[0] / 2, n2[1] / 2, n2[0]), r2.fillText(e2, n2[0] / 2, n2[1] / 2, n2[0]), t3.setImage(r2.canvas);
          } });
        }
      }, _T.source.TileImage = uh, _T.source.TileJSON = class extends uh {
        constructor(t2) {
          if (super({ attributions: t2.attributions, cacheSize: t2.cacheSize, crossOrigin: t2.crossOrigin, interpolate: t2.interpolate, projection: Ui("EPSG:3857"), reprojectionErrorThreshold: t2.reprojectionErrorThreshold, state: "loading", tileLoadFunction: t2.tileLoadFunction, wrapX: void 0 === t2.wrapX || t2.wrapX, transition: t2.transition, zDirection: t2.zDirection }), this.tileJSON_ = null, this.tileSize_ = t2.tileSize, t2.url)
            if (t2.jsonp)
              vl(t2.url, this.handleTileJSONResponse.bind(this), this.handleTileJSONError.bind(this));
            else {
              const e2 = new XMLHttpRequest();
              e2.addEventListener("load", this.onXHRLoad_.bind(this)), e2.addEventListener("error", this.onXHRError_.bind(this)), e2.open("GET", t2.url), e2.send();
            }
          else
            t2.tileJSON ? this.handleTileJSONResponse(t2.tileJSON) : at(false, 51);
        }
        onXHRLoad_(t2) {
          const e2 = t2.target;
          if (!e2.status || e2.status >= 200 && e2.status < 300) {
            let t3;
            try {
              t3 = JSON.parse(e2.responseText);
            } catch (t4) {
              return void this.handleTileJSONError();
            }
            this.handleTileJSONResponse(t3);
          } else
            this.handleTileJSONError();
        }
        onXHRError_(t2) {
          this.handleTileJSONError();
        }
        getTileJSON() {
          return this.tileJSON_;
        }
        handleTileJSONResponse(t2) {
          const e2 = Ui("EPSG:4326"), i2 = this.getProjection();
          let n2;
          if (void 0 !== t2.bounds) {
            const r3 = qi(e2, i2);
            n2 = Re(t2.bounds, r3);
          }
          const r2 = ih(i2), s2 = t2.minzoom || 0, o2 = Ql({ extent: r2, maxZoom: t2.maxzoom || 22, minZoom: s2, tileSize: this.tileSize_ });
          if (this.tileGrid = o2, this.tileUrlFunction = oh(t2.tiles, o2), t2.attribution && !this.getAttributions()) {
            const e3 = void 0 !== n2 ? n2 : r2;
            this.setAttributions(function(i3) {
              return we(e3, i3.extent) ? [t2.attribution] : null;
            });
          }
          this.tileJSON_ = t2, this.setState("ready");
        }
        handleTileJSONError() {
          this.setState("error");
        }
      }, _T.source.TileWMS = class extends uh {
        constructor(t2) {
          t2 = t2 || {};
          const e2 = Object.assign({}, t2.params), i2 = !("TRANSPARENT" in e2) || e2.TRANSPARENT;
          super({ attributions: t2.attributions, attributionsCollapsible: t2.attributionsCollapsible, cacheSize: t2.cacheSize, crossOrigin: t2.crossOrigin, interpolate: t2.interpolate, opaque: !i2, projection: t2.projection, reprojectionErrorThreshold: t2.reprojectionErrorThreshold, tileClass: t2.tileClass, tileGrid: t2.tileGrid, tileLoadFunction: t2.tileLoadFunction, url: t2.url, urls: t2.urls, wrapX: void 0 === t2.wrapX || t2.wrapX, transition: t2.transition, zDirection: t2.zDirection }), this.gutter_ = void 0 !== t2.gutter ? t2.gutter : 0, this.params_ = e2, this.v13_ = true, this.serverType_ = t2.serverType, this.hidpi_ = void 0 === t2.hidpi || t2.hidpi, this.tmpExtent_ = [1 / 0, 1 / 0, -1 / 0, -1 / 0], this.updateV13_(), this.setKey(this.getKeyForParams_());
        }
        getFeatureInfoUrl(t2, e2, i2, n2) {
          const r2 = Ui(i2), s2 = this.getProjection();
          let o2 = this.getTileGrid();
          o2 || (o2 = this.getTileGridForProjection(r2));
          const a2 = o2.getZForResolution(e2, this.zDirection), l2 = o2.getTileCoordForCoordAndZ(t2, a2);
          if (o2.getResolutions().length <= l2[0])
            return;
          let h2 = o2.getResolution(l2[0]), c2 = o2.getTileCoordExtent(l2, this.tmpExtent_), u2 = Va(o2.getTileSize(l2[0]), this.tmpSize);
          const d2 = this.gutter_;
          0 !== d2 && (u2 = Ua(u2, d2, this.tmpSize), c2 = Xt(c2, h2 * d2, c2)), s2 && s2 !== r2 && (h2 = Gl(s2, r2, t2, h2), c2 = Ji(c2, r2, s2), t2 = $i(t2, r2, s2));
          const g2 = { SERVICE: "WMS", VERSION: Sc, REQUEST: "GetFeatureInfo", FORMAT: "image/png", TRANSPARENT: true, QUERY_LAYERS: this.params_.LAYERS };
          Object.assign(g2, this.params_, n2);
          const f2 = Math.floor((t2[0] - c2[0]) / h2), p2 = Math.floor((c2[3] - t2[1]) / h2);
          return g2[this.v13_ ? "I" : "X"] = f2, g2[this.v13_ ? "J" : "Y"] = p2, this.getRequestUrl_(l2, u2, c2, 1, s2 || r2, g2);
        }
        getLegendUrl(t2, e2) {
          if (void 0 === this.urls[0])
            return;
          const i2 = { SERVICE: "WMS", VERSION: Sc, REQUEST: "GetLegendGraphic", FORMAT: "image/png" };
          if (void 0 === e2 || void 0 === e2.LAYER) {
            const t3 = this.params_.LAYERS;
            if (!(!Array.isArray(t3) || 1 === t3.length))
              return;
            i2.LAYER = t3;
          }
          if (void 0 !== t2) {
            const e3 = this.getProjection() ? this.getProjection().getMetersPerUnit() : 1, n2 = 28e-5;
            i2.SCALE = t2 * e3 / n2;
          }
          return Object.assign(i2, e2), vc(this.urls[0], i2);
        }
        getGutter() {
          return this.gutter_;
        }
        getParams() {
          return this.params_;
        }
        getRequestUrl_(t2, e2, i2, n2, r2, s2) {
          const o2 = this.urls;
          if (!o2)
            return;
          if (s2.WIDTH = e2[0], s2.HEIGHT = e2[1], s2[this.v13_ ? "CRS" : "SRS"] = r2.getCode(), "STYLES" in this.params_ || (s2.STYLES = ""), 1 != n2)
            switch (this.serverType_) {
              case "geoserver":
                const t3 = 90 * n2 + 0.5 | 0;
                "FORMAT_OPTIONS" in s2 ? s2.FORMAT_OPTIONS += ";dpi:" + t3 : s2.FORMAT_OPTIONS = "dpi:" + t3;
                break;
              case "mapserver":
                s2.MAP_RESOLUTION = 90 * n2;
                break;
              case "carmentaserver":
              case "qgis":
                s2.DPI = 90 * n2;
                break;
              default:
                at(false, 52);
            }
          const a2 = r2.getAxisOrientation(), l2 = i2;
          if (this.v13_ && "ne" == a2.substr(0, 2)) {
            let t3;
            t3 = i2[0], l2[0] = i2[1], l2[1] = t3, t3 = i2[2], l2[2] = i2[3], l2[3] = t3;
          }
          let h2;
          if (s2.BBOX = l2.join(","), 1 == o2.length)
            h2 = o2[0];
          else {
            h2 = o2[li(ol2(t2), o2.length)];
          }
          return vc(h2, s2);
        }
        getTilePixelRatio(t2) {
          return this.hidpi_ && void 0 !== this.serverType_ ? t2 : 1;
        }
        getKeyForParams_() {
          let t2 = 0;
          const e2 = [];
          for (const i2 in this.params_)
            e2[t2++] = i2 + "-" + this.params_[i2];
          return e2.join("/");
        }
        updateParams(t2) {
          Object.assign(this.params_, t2), this.updateV13_(), this.setKey(this.getKeyForParams_());
        }
        updateV13_() {
          const t2 = this.params_.VERSION || Sc;
          this.v13_ = pi(t2, "1.3") >= 0;
        }
        tileUrlFunction(t2, e2, i2) {
          let n2 = this.getTileGrid();
          if (n2 || (n2 = this.getTileGridForProjection(i2)), n2.getResolutions().length <= t2[0])
            return;
          1 == e2 || this.hidpi_ && void 0 !== this.serverType_ || (e2 = 1);
          const r2 = n2.getResolution(t2[0]);
          let s2 = n2.getTileCoordExtent(t2, this.tmpExtent_), o2 = Va(n2.getTileSize(t2[0]), this.tmpSize);
          const a2 = this.gutter_;
          0 !== a2 && (o2 = Ua(o2, a2, this.tmpSize), s2 = Xt(s2, r2 * a2, s2)), 1 != e2 && (o2 = Xa(o2, e2, this.tmpSize));
          const l2 = { SERVICE: "WMS", VERSION: Sc, REQUEST: "GetMap", FORMAT: "image/png", TRANSPARENT: true };
          return Object.assign(l2, this.params_), this.getRequestUrl_(t2, o2, s2, e2, i2, l2);
        }
      }, _T.source.UTFGrid = class extends nh {
        constructor(t2) {
          if (super({ projection: Ui("EPSG:3857"), state: "loading", zDirection: t2.zDirection }), this.preemptive_ = void 0 === t2.preemptive || t2.preemptive, this.tileUrlFunction_ = lh, this.template_ = void 0, this.jsonp_ = t2.jsonp || false, t2.url)
            if (this.jsonp_)
              vl(t2.url, this.handleTileJSONResponse.bind(this), this.handleTileJSONError.bind(this));
            else {
              const e2 = new XMLHttpRequest();
              e2.addEventListener("load", this.onXHRLoad_.bind(this)), e2.addEventListener("error", this.onXHRError_.bind(this)), e2.open("GET", t2.url), e2.send();
            }
          else
            t2.tileJSON ? this.handleTileJSONResponse(t2.tileJSON) : at(false, 51);
        }
        onXHRLoad_(t2) {
          const e2 = t2.target;
          if (!e2.status || e2.status >= 200 && e2.status < 300) {
            let t3;
            try {
              t3 = JSON.parse(e2.responseText);
            } catch (t4) {
              return void this.handleTileJSONError();
            }
            this.handleTileJSONResponse(t3);
          } else
            this.handleTileJSONError();
        }
        onXHRError_(t2) {
          this.handleTileJSONError();
        }
        getTemplate() {
          return this.template_;
        }
        forDataAtCoordinateAndResolution(t2, e2, i2, n2) {
          if (this.tileGrid) {
            const r2 = this.tileGrid.getZForResolution(e2, this.zDirection), s2 = this.tileGrid.getTileCoordForCoordAndZ(t2, r2);
            this.getTile(s2[0], s2[1], s2[2], 1, this.getProjection()).forDataAtCoordinate(t2, i2, n2);
          } else
            true === n2 ? setTimeout(function() {
              i2(null);
            }, 0) : i2(null);
        }
        handleTileJSONError() {
          this.setState("error");
        }
        handleTileJSONResponse(t2) {
          const e2 = Ui("EPSG:4326"), i2 = this.getProjection();
          let n2;
          if (void 0 !== t2.bounds) {
            const r3 = qi(e2, i2);
            n2 = Re(t2.bounds, r3);
          }
          const r2 = ih(i2), s2 = t2.minzoom || 0, o2 = Ql({ extent: r2, maxZoom: t2.maxzoom || 22, minZoom: s2 });
          this.tileGrid = o2, this.template_ = t2.template;
          const a2 = t2.grids;
          if (a2) {
            if (this.tileUrlFunction_ = oh(a2, o2), void 0 !== t2.attribution) {
              const e3 = void 0 !== n2 ? n2 : r2;
              this.setAttributions(function(i3) {
                return we(e3, i3.extent) ? [t2.attribution] : null;
              });
            }
            this.setState("ready");
          } else
            this.setState("error");
        }
        getTile(t2, e2, i2, n2, r2) {
          const s2 = il(t2, e2, i2);
          if (this.tileCache.containsKey(s2))
            return this.tileCache.get(s2);
          {
            const o2 = [t2, e2, i2], a2 = this.getTileCoordForTileUrlFunction(o2, r2), l2 = this.tileUrlFunction_(a2, n2, r2), h2 = new Jc(o2, void 0 !== l2 ? H : tt, void 0 !== l2 ? l2 : "", this.tileGrid.getTileCoordExtent(o2), this.preemptive_, this.jsonp_);
            return this.tileCache.set(s2, h2), h2;
          }
        }
        useTile(t2, e2, i2) {
          const n2 = il(t2, e2, i2);
          this.tileCache.containsKey(n2) && this.tileCache.get(n2);
        }
      }, _T.source.UTFGrid.CustomTile = Jc, _T.source.UrlTile = ch, _T.source.Vector = zh, _T.source.Vector.VectorSourceEvent = Uh, _T.source.VectorTile = Qc, _T.source.VectorTile.defaultLoadFunction = tu, _T.source.WMTS = class extends uh {
        constructor(t2) {
          const e2 = void 0 !== t2.requestEncoding ? t2.requestEncoding : "KVP", i2 = t2.tileGrid;
          let n2 = t2.urls;
          void 0 === n2 && void 0 !== t2.url && (n2 = hh(t2.url)), super({ attributions: t2.attributions, attributionsCollapsible: t2.attributionsCollapsible, cacheSize: t2.cacheSize, crossOrigin: t2.crossOrigin, interpolate: t2.interpolate, projection: t2.projection, reprojectionErrorThreshold: t2.reprojectionErrorThreshold, tileClass: t2.tileClass, tileGrid: i2, tileLoadFunction: t2.tileLoadFunction, tilePixelRatio: t2.tilePixelRatio, urls: n2, wrapX: void 0 !== t2.wrapX && t2.wrapX, transition: t2.transition, zDirection: t2.zDirection }), this.version_ = void 0 !== t2.version ? t2.version : "1.0.0", this.format_ = void 0 !== t2.format ? t2.format : "image/jpeg", this.dimensions_ = void 0 !== t2.dimensions ? t2.dimensions : {}, this.layer_ = t2.layer, this.matrixSet_ = t2.matrixSet, this.style_ = t2.style, this.requestEncoding_ = e2, this.setKey(this.getKeyForDimensions_()), n2 && n2.length > 0 && (this.tileUrlFunction = ah(n2.map(this.createFromWMTSTemplate.bind(this))));
        }
        setUrls(t2) {
          this.urls = t2;
          const e2 = t2.join("\n");
          this.setTileUrlFunction(ah(t2.map(this.createFromWMTSTemplate.bind(this))), e2);
        }
        getDimensions() {
          return this.dimensions_;
        }
        getFormat() {
          return this.format_;
        }
        getLayer() {
          return this.layer_;
        }
        getMatrixSet() {
          return this.matrixSet_;
        }
        getRequestEncoding() {
          return this.requestEncoding_;
        }
        getStyle() {
          return this.style_;
        }
        getVersion() {
          return this.version_;
        }
        getKeyForDimensions_() {
          let t2 = 0;
          const e2 = [];
          for (const i2 in this.dimensions_)
            e2[t2++] = i2 + "-" + this.dimensions_[i2];
          return e2.join("/");
        }
        updateDimensions(t2) {
          Object.assign(this.dimensions_, t2), this.setKey(this.getKeyForDimensions_());
        }
        createFromWMTSTemplate(t2) {
          const e2 = this.requestEncoding_, i2 = { layer: this.layer_, style: this.style_, tilematrixset: this.matrixSet_ };
          "KVP" == e2 && Object.assign(i2, { Service: "WMTS", Request: "GetTile", Version: this.version_, Format: this.format_ }), t2 = "KVP" == e2 ? vc(t2, i2) : t2.replace(/\{(\w+?)\}/g, function(t3, e3) {
            return e3.toLowerCase() in i2 ? i2[e3.toLowerCase()] : t3;
          });
          const n2 = this.tileGrid, r2 = this.dimensions_;
          return function(i3, s2, o2) {
            if (i3) {
              const s3 = { TileMatrix: n2.getMatrixId(i3[0]), TileCol: i3[1], TileRow: i3[2] };
              Object.assign(s3, r2);
              let o3 = t2;
              return o3 = "KVP" == e2 ? vc(o3, s3) : o3.replace(/\{(\w+?)\}/g, function(t3, e3) {
                return s3[e3];
              }), o3;
            }
          };
        }
      }, _T.source.WMTS.optionsFromCapabilities = function(t2, e2) {
        const i2 = t2.Contents.Layer.find(function(t3) {
          return t3.Identifier == e2.layer;
        });
        if (!i2)
          return null;
        const n2 = t2.Contents.TileMatrixSet;
        let r2;
        r2 = i2.TileMatrixSetLink.length > 1 ? "projection" in e2 ? i2.TileMatrixSetLink.findIndex(function(t3) {
          const i3 = n2.find(function(e3) {
            return e3.Identifier == t3.TileMatrixSet;
          }).SupportedCRS, r3 = Ui(i3), s3 = Ui(e2.projection);
          return r3 && s3 ? Ki(r3, s3) : i3 == e2.projection;
        }) : i2.TileMatrixSetLink.findIndex(function(t3) {
          return t3.TileMatrixSet == e2.matrixSet;
        }) : 0, r2 < 0 && (r2 = 0);
        const s2 = i2.TileMatrixSetLink[r2].TileMatrixSet, o2 = i2.TileMatrixSetLink[r2].TileMatrixSetLimits;
        let a2 = i2.Format[0];
        "format" in e2 && (a2 = e2.format), r2 = i2.Style.findIndex(function(t3) {
          return "style" in e2 ? t3.Title == e2.style : t3.isDefault;
        }), r2 < 0 && (r2 = 0);
        const l2 = i2.Style[r2].Identifier, h2 = {};
        "Dimension" in i2 && i2.Dimension.forEach(function(t3, e3, i3) {
          const n3 = t3.Identifier;
          let r3 = t3.Default;
          void 0 === r3 && (r3 = t3.Value[0]), h2[n3] = r3;
        });
        const c2 = t2.Contents.TileMatrixSet.find(function(t3) {
          return t3.Identifier == s2;
        });
        let u2;
        const d2 = c2.SupportedCRS;
        if (d2 && (u2 = Ui(d2)), "projection" in e2) {
          const t3 = Ui(e2.projection);
          t3 && (u2 && !Ki(t3, u2) || (u2 = t3));
        }
        let g2 = false;
        const f2 = "ne" == u2.getAxisOrientation().substr(0, 2);
        let p2 = c2.TileMatrix[0], m2 = { MinTileCol: 0, MinTileRow: 0, MaxTileCol: p2.MatrixWidth - 1, MaxTileRow: p2.MatrixHeight - 1 };
        if (o2) {
          m2 = o2[o2.length - 1];
          const t3 = c2.TileMatrix.find((t4) => t4.Identifier === m2.TileMatrix || c2.Identifier + ":" + t4.Identifier === m2.TileMatrix);
          t3 && (p2 = t3);
        }
        const _2 = 28e-5 * p2.ScaleDenominator / u2.getMetersPerUnit(), y2 = f2 ? [p2.TopLeftCorner[1], p2.TopLeftCorner[0]] : p2.TopLeftCorner, x2 = p2.TileWidth * _2, v2 = p2.TileHeight * _2;
        let S2 = c2.BoundingBox;
        S2 && f2 && (S2 = [S2[1], S2[0], S2[3], S2[2]]);
        let w2 = [y2[0] + x2 * m2.MinTileCol, y2[1] - v2 * (1 + m2.MaxTileRow), y2[0] + x2 * (1 + m2.MaxTileCol), y2[1] - v2 * m2.MinTileRow];
        if (void 0 !== S2 && !Yt(S2, w2)) {
          const t3 = i2.WGS84BoundingBox, e3 = Ui("EPSG:4326").getExtent();
          if (w2 = S2, t3)
            g2 = t3[0] === e3[0] && t3[2] === e3[2];
          else {
            const t4 = Ji(S2, c2.SupportedCRS, "EPSG:4326");
            g2 = t4[0] - 1e-10 <= e3[0] && t4[2] + 1e-10 >= e3[2];
          }
        }
        const E2 = iu(c2, w2, o2), T2 = [];
        let C2 = e2.requestEncoding;
        if (C2 = void 0 !== C2 ? C2 : "", "OperationsMetadata" in t2 && "GetTile" in t2.OperationsMetadata) {
          const e3 = t2.OperationsMetadata.GetTile.DCP.HTTP.Get;
          for (let t3 = 0, i3 = e3.length; t3 < i3; ++t3)
            if (e3[t3].Constraint) {
              const i4 = e3[t3].Constraint.find(function(t4) {
                return "GetEncoding" == t4.name;
              }).AllowedValues.Value;
              if ("" === C2 && (C2 = i4[0]), "KVP" !== C2)
                break;
              i4.includes("KVP") && T2.push(e3[t3].href);
            } else
              e3[t3].href && (C2 = "KVP", T2.push(e3[t3].href));
        }
        return 0 === T2.length && (C2 = "REST", i2.ResourceURL.forEach(function(t3) {
          "tile" === t3.resourceType && (a2 = t3.format, T2.push(t3.template));
        })), { urls: T2, layer: e2.layer, matrixSet: s2, format: a2, projection: u2, requestEncoding: C2, tileGrid: E2, style: l2, dimensions: h2, wrapX: g2, crossOrigin: e2.crossOrigin };
      }, _T.source.XYZ = fh, _T.source.Zoomify = class extends uh {
        constructor(t2) {
          const e2 = t2.size, i2 = void 0 !== t2.tierSizeCalculation ? t2.tierSizeCalculation : "default", n2 = t2.tilePixelRatio || 1, r2 = e2[0], s2 = e2[1], o2 = [], a2 = t2.tileSize || Lo;
          let l2 = a2 * n2;
          switch (i2) {
            case "default":
              for (; r2 > l2 || s2 > l2; )
                o2.push([Math.ceil(r2 / l2), Math.ceil(s2 / l2)]), l2 += l2;
              break;
            case "truncated":
              let t3 = r2, e3 = s2;
              for (; t3 > l2 || e3 > l2; )
                o2.push([Math.ceil(t3 / l2), Math.ceil(e3 / l2)]), t3 >>= 1, e3 >>= 1;
              break;
            default:
              at(false, 53);
          }
          o2.push([1, 1]), o2.reverse();
          const h2 = [n2], c2 = [0];
          for (let t3 = 1, e3 = o2.length; t3 < e3; t3++)
            h2.push(n2 << t3), c2.push(o2[t3 - 1][0] * o2[t3 - 1][1] + c2[t3 - 1]);
          h2.reverse();
          const u2 = new ql({ tileSize: a2, extent: t2.extent || [0, -s2, r2, 0], resolutions: h2 });
          let d2 = t2.url;
          !d2 || d2.includes("{TileGroup}") || d2.includes("{tileIndex}") || (d2 += "{TileGroup}/{z}-{x}-{y}.jpg");
          const g2 = hh(d2);
          let f2 = a2 * n2;
          const p2 = ah(g2.map(function(t3) {
            return function(e3, i3, n3) {
              if (e3) {
                const i4 = e3[0], n4 = e3[1], r3 = e3[2], s3 = n4 + r3 * o2[i4][0], a3 = { z: i4, x: n4, y: r3, tileIndex: s3, TileGroup: "TileGroup" + ((s3 + c2[i4]) / f2 | 0) };
                return t3.replace(/\{(\w+?)\}/g, function(t4, e4) {
                  return a3[e4];
                });
              }
            };
          })), m2 = nc.bind(null, Va(a2 * n2));
          super({ attributions: t2.attributions, cacheSize: t2.cacheSize, crossOrigin: t2.crossOrigin, interpolate: t2.interpolate, projection: t2.projection, tilePixelRatio: n2, reprojectionErrorThreshold: t2.reprojectionErrorThreshold, tileClass: m2, tileGrid: u2, tileUrlFunction: p2, transition: t2.transition }), this.zDirection = t2.zDirection;
          const _2 = p2(u2.getTileCoordForCoordAndResolution(ge(u2.getExtent()), h2[h2.length - 1]), 1, null), y2 = new Image();
          y2.addEventListener("error", function() {
            f2 = a2, this.changed();
          }.bind(this)), y2.src = _2;
        }
      }, _T.source.Zoomify.CustomTile = nc, _T.source.common = {}, _T.source.common.DEFAULT_WMS_VERSION = "1.3.0", _T.source.ogcTileUtil = {}, _T.source.ogcTileUtil.getMapTileUrlTemplate = Tg, _T.source.ogcTileUtil.getTileSetInfo = Rg, _T.source.ogcTileUtil.getVectorTileUrlTemplate = Cg, _T.source.sourcesFromTileGrid = function(t2, e2) {
        const i2 = new tl(32), n2 = t2.getExtent();
        return function(r2, s2) {
          i2.expireCache(), n2 && (r2 = ye(n2, r2));
          const o2 = t2.getZForResolution(s2), a2 = [];
          return t2.forEachTileCoord(r2, o2, (t3) => {
            const n3 = t3.toString();
            if (!i2.containsKey(n3)) {
              const r3 = e2(t3);
              i2.set(n3, r3);
            }
            a2.push(i2.get(n3));
          }), a2;
        };
      }, _T.source.wms = {}, _T.source.wms.DEFAULT_VERSION = Sc, _T.sphere = {}, _T.sphere.DEFAULT_RADIUS = Li, _T.sphere.getArea = function t2(e2, i2) {
        const n2 = (i2 = i2 || {}).radius || Li, r2 = i2.projection || "EPSG:3857", s2 = e2.getType();
        "GeometryCollection" !== s2 && (e2 = e2.clone().transform(r2, "EPSG:4326"));
        let o2, a2, l2, h2, c2, u2, d2 = 0;
        switch (s2) {
          case "Point":
          case "MultiPoint":
          case "LineString":
          case "MultiLineString":
          case "LinearRing":
            break;
          case "Polygon":
            for (o2 = e2.getCoordinates(), d2 = Math.abs(Ai(o2[0], n2)), l2 = 1, h2 = o2.length; l2 < h2; ++l2)
              d2 -= Math.abs(Ai(o2[l2], n2));
            break;
          case "MultiPolygon":
            for (o2 = e2.getCoordinates(), l2 = 0, h2 = o2.length; l2 < h2; ++l2)
              for (a2 = o2[l2], d2 += Math.abs(Ai(a2[0], n2)), c2 = 1, u2 = a2.length; c2 < u2; ++c2)
                d2 -= Math.abs(Ai(a2[c2], n2));
            break;
          case "GeometryCollection": {
            const n3 = e2.getGeometries();
            for (l2 = 0, h2 = n3.length; l2 < h2; ++l2)
              d2 += t2(n3[l2], i2);
            break;
          }
          default:
            throw new Error("Unsupported geometry type: " + s2);
        }
        return d2;
      }, _T.sphere.getDistance = Mi, _T.sphere.getLength = function t2(e2, i2) {
        const n2 = (i2 = i2 || {}).radius || Li, r2 = i2.projection || "EPSG:3857", s2 = e2.getType();
        "GeometryCollection" !== s2 && (e2 = e2.clone().transform(r2, "EPSG:4326"));
        let o2, a2, l2, h2, c2, u2, d2 = 0;
        switch (s2) {
          case "Point":
          case "MultiPoint":
            break;
          case "LineString":
          case "LinearRing":
            o2 = e2.getCoordinates(), d2 = Fi(o2, n2);
            break;
          case "MultiLineString":
          case "Polygon":
            for (o2 = e2.getCoordinates(), l2 = 0, h2 = o2.length; l2 < h2; ++l2)
              d2 += Fi(o2[l2], n2);
            break;
          case "MultiPolygon":
            for (o2 = e2.getCoordinates(), l2 = 0, h2 = o2.length; l2 < h2; ++l2)
              for (a2 = o2[l2], c2 = 0, u2 = a2.length; c2 < u2; ++c2)
                d2 += Fi(a2[c2], n2);
            break;
          case "GeometryCollection": {
            const n3 = e2.getGeometries();
            for (l2 = 0, h2 = n3.length; l2 < h2; ++l2)
              d2 += t2(n3[l2], i2);
            break;
          }
          default:
            throw new Error("Unsupported geometry type: " + s2);
        }
        return d2;
      }, _T.sphere.offset = Oi, _T.string = {}, _T.string.compareVersions = pi, _T.string.padNumber = fi, _T.structs = {}, _T.structs.LRUCache = tl, _T.structs.LinkedList = class {
        constructor(t2) {
          this.first_, this.last_, this.head_, this.circular_ = void 0 === t2 || t2, this.length_ = 0;
        }
        insertItem(t2) {
          const e2 = { prev: void 0, next: void 0, data: t2 }, i2 = this.head_;
          if (i2) {
            const t3 = i2.next;
            e2.prev = i2, e2.next = t3, i2.next = e2, t3 && (t3.prev = e2), i2 === this.last_ && (this.last_ = e2);
          } else
            this.first_ = e2, this.last_ = e2, this.circular_ && (e2.next = e2, e2.prev = e2);
          this.head_ = e2, this.length_++;
        }
        removeItem() {
          const t2 = this.head_;
          if (t2) {
            const e2 = t2.next, i2 = t2.prev;
            e2 && (e2.prev = i2), i2 && (i2.next = e2), this.head_ = e2 || i2, this.first_ === this.last_ ? (this.head_ = void 0, this.first_ = void 0, this.last_ = void 0) : this.first_ === t2 ? this.first_ = this.head_ : this.last_ === t2 && (this.last_ = i2 ? this.head_.prev : this.head_), this.length_--;
          }
        }
        firstItem() {
          if (this.head_ = this.first_, this.head_)
            return this.head_.data;
        }
        lastItem() {
          if (this.head_ = this.last_, this.head_)
            return this.head_.data;
        }
        nextItem() {
          if (this.head_ && this.head_.next)
            return this.head_ = this.head_.next, this.head_.data;
        }
        getNextItem() {
          if (this.head_ && this.head_.next)
            return this.head_.next.data;
        }
        prevItem() {
          if (this.head_ && this.head_.prev)
            return this.head_ = this.head_.prev, this.head_.data;
        }
        getPrevItem() {
          if (this.head_ && this.head_.prev)
            return this.head_.prev.data;
        }
        getCurrItem() {
          if (this.head_)
            return this.head_.data;
        }
        setFirstItem() {
          this.circular_ && this.head_ && (this.first_ = this.head_, this.last_ = this.head_.prev);
        }
        concat(t2) {
          if (t2.head_) {
            if (this.head_) {
              const e2 = this.head_.next;
              this.head_.next = t2.first_, t2.first_.prev = this.head_, e2.prev = t2.last_, t2.last_.next = e2, this.length_ += t2.length_;
            } else
              this.head_ = t2.head_, this.first_ = t2.first_, this.last_ = t2.last_, this.length_ = t2.length_;
            t2.head_ = void 0, t2.first_ = void 0, t2.last_ = void 0, t2.length_ = 0;
          }
        }
        getLength() {
          return this.length_;
        }
      }, _T.structs.PriorityQueue = To, _T.structs.PriorityQueue.DROP = Eo, _T.structs.RBush = Ah, _T.style = {}, _T.style.Circle = ng, _T.style.Fill = rg, _T.style.Icon = lg, _T.style.IconImage = og, _T.style.IconImage.get = ag, _T.style.IconImageCache = es, _T.style.IconImageCache.shared = ns, _T.style.Image = eg, _T.style.RegularShape = ig, _T.style.Stroke = hg, _T.style.Style = cg, _T.style.Style.createDefaultStyle = gg, _T.style.Style.createEditingStyle = fg, _T.style.Style.toFunction = ug, _T.style.Text = mg, _T.style.expressions = {}, _T.style.expressions.Operators = Ld, _T.style.expressions.PALETTE_TEXTURE_ARRAY = qd, _T.style.expressions.arrayToGlsl = Od, _T.style.expressions.colorToGlsl = Nd, _T.style.expressions.expressionToGlsl = Gd, _T.style.expressions.getStringNumberEquivalent = Dd, _T.style.expressions.getValueType = Md, _T.style.expressions.isTypeUnique = Fd, _T.style.expressions.numberToGlsl = Ad, _T.style.expressions.stringToGlsl = kd, _T.style.expressions.uniformNameForVariable = Kd, _T.style.flat = {}, _T.style.flat.toStyle = _g, _T.tilecoord = {}, _T.tilecoord.createOrUpdate = el, _T.tilecoord.fromKey = sl, _T.tilecoord.getCacheKeyForTileKey = rl, _T.tilecoord.getKey = nl, _T.tilecoord.getKeyZXY = il, _T.tilecoord.hash = ol2, _T.tilecoord.withinExtentAndZ = al, _T.tilegrid = {}, _T.tilegrid.TileGrid = ql, _T.tilegrid.WMTS = eu, _T.tilegrid.WMTS.createFromCapabilitiesMatrixSet = iu, _T.tilegrid.common = {}, _T.tilegrid.common.DEFAULT_MAX_ZOOM = 42, _T.tilegrid.common.DEFAULT_TILE_SIZE = Lo, _T.tilegrid.createForExtent = Jl, _T.tilegrid.createForProjection = eh, _T.tilegrid.createXYZ = Ql, _T.tilegrid.extentFromProjection = ih, _T.tilegrid.getForProjection = Hl, _T.tilegrid.wrapX = $l, _T.tileurlfunction = {}, _T.tileurlfunction.createFromTemplate = sh, _T.tileurlfunction.createFromTemplates = oh, _T.tileurlfunction.createFromTileUrlFunctions = ah, _T.tileurlfunction.expandUrl = hh, _T.tileurlfunction.nullTileUrlFunction = lh, _T.transform = {}, _T.transform.apply = bt, _T.transform.compose = Mt, _T.transform.composeCssTransform = function(t2, e2, i2, n2, r2, s2, o2) {
        return Nt(Mt([1, 0, 0, 1, 0, 0], t2, e2, i2, n2, r2, s2, o2));
      }, _T.transform.create = St, _T.transform.determinant = At, _T.transform.invert = function(t2) {
        return Ft(t2, t2);
      }, _T.transform.makeInverse = Ft, _T.transform.makeScale = It, _T.transform.multiply = Et, _T.transform.reset = wt, _T.transform.rotate = Rt, _T.transform.scale = Pt, _T.transform.set = Tt, _T.transform.setFromArray = Ct, _T.transform.toString = Nt, _T.transform.translate = Lt, _T.uri = {}, _T.uri.appendParams = vc, _T.util = {}, _T.util.VERSION = "latest", _T.util.abstract = B, _T.util.getUid = z, _T.vec = {}, _T.vec.mat4 = {}, _T.vec.mat4.create = Xu, _T.vec.mat4.fromTransform = Vu, _T.webgl = {}, _T.webgl.ARRAY_BUFFER = nu, _T.webgl.Buffer = Gu, _T.webgl.Buffer.getArrayClassForType = ju, _T.webgl.DYNAMIC_DRAW = ou, _T.webgl.ELEMENT_ARRAY_BUFFER = ru, _T.webgl.FLOAT = au, _T.webgl.Helper = nd, _T.webgl.Helper.computeAttributesStride = rd, _T.webgl.PaletteTexture = od, _T.webgl.PostProcessingPass = zu, _T.webgl.RenderTarget = ld, _T.webgl.STATIC_DRAW = su, _T.webgl.STREAM_DRAW = 35040, _T.webgl.ShaderBuilder = {}, _T.webgl.ShaderBuilder.ShaderBuilder = Qd, _T.webgl.ShaderBuilder.parseLiteralStyle = tg, _T.webgl.TileTexture = dd, _T.webgl.UNSIGNED_BYTE = 5121, _T.webgl.UNSIGNED_INT = 5125, _T.webgl.UNSIGNED_SHORT = 5123, _T.webgl.getContext = hu, _T.webgl.getSupportedExtensions = function() {
        if (!cu) {
          const t2 = hu(document.createElement("canvas"));
          t2 && (cu = t2.getSupportedExtensions());
        }
        return cu;
      }, _T.xml = {}, _T.xml.OBJECT_PROPERTY_NODE_FACTORY = bu, _T.xml.XML_SCHEMA_INSTANCE_URI = uu, _T.xml.createElementNS = du, _T.xml.getAllTextContent = gu, _T.xml.getAllTextContent_ = fu, _T.xml.getAttributeNS = mu, _T.xml.getDocument = Du, _T.xml.getXMLSerializer = Nu, _T.xml.isDocument = pu, _T.xml.makeArrayExtender = yu, _T.xml.makeArrayPusher = xu, _T.xml.makeArraySerializer = Tu, _T.xml.makeChildAppender = Eu, _T.xml.makeObjectPropertyPusher = Su, _T.xml.makeObjectPropertySetter = wu, _T.xml.makeReplacer = vu, _T.xml.makeSequence = Ru, _T.xml.makeSimpleNodeFactory = Cu, _T.xml.makeStructureNS = Pu, _T.xml.parse = _u, _T.xml.parseNode = Iu, _T.xml.pushParseAndPop = Lu, _T.xml.pushSerializeAndPop = Fu, _T.xml.registerDocument = function(t2) {
        Ou = t2;
      }, _T.xml.registerXMLSerializer = function(t2) {
        Au = t2;
      }, _T.xml.serialize = Mu, _T;
    }();
  }
});

export {
  ol_exports,
  init_ol
};
//# sourceMappingURL=chunk-AFWBFAGS.js.map
