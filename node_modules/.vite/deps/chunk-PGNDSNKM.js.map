{
  "version": 3,
  "sources": ["../../ol/net.js", "../../ol/source/TileJSON.js"],
  "sourcesContent": ["/**\n * @module ol/net\n */\nimport {getUid} from './util.js';\n\n/**\n * Simple JSONP helper. Supports error callbacks and a custom callback param.\n * The error callback will be called when no JSONP is executed after 10 seconds.\n *\n * @param {string} url Request url. A 'callback' query parameter will be\n *     appended.\n * @param {Function} callback Callback on success.\n * @param {Function} [errback] Callback on error.\n * @param {string} [callbackParam] Custom query parameter for the JSONP\n *     callback. Default is 'callback'.\n */\nexport function jsonp(url, callback, errback, callbackParam) {\n  const script = document.createElement('script');\n  const key = 'olc_' + getUid(callback);\n  function cleanup() {\n    delete window[key];\n    script.parentNode.removeChild(script);\n  }\n  script.async = true;\n  script.src =\n    url +\n    (url.includes('?') ? '&' : '?') +\n    (callbackParam || 'callback') +\n    '=' +\n    key;\n  const timer = setTimeout(function () {\n    cleanup();\n    if (errback) {\n      errback();\n    }\n  }, 10000);\n  window[key] = function (data) {\n    clearTimeout(timer);\n    cleanup();\n    callback(data);\n  };\n  document.head.appendChild(script);\n}\n\nexport class ResponseError extends Error {\n  /**\n   * @param {XMLHttpRequest} response The XHR object.\n   */\n  constructor(response) {\n    const message = 'Unexpected response status: ' + response.status;\n    super(message);\n\n    /**\n     * @type {string}\n     */\n    this.name = 'ResponseError';\n\n    /**\n     * @type {XMLHttpRequest}\n     */\n    this.response = response;\n  }\n}\n\nexport class ClientError extends Error {\n  /**\n   * @param {XMLHttpRequest} client The XHR object.\n   */\n  constructor(client) {\n    super('Failed to issue request');\n\n    /**\n     * @type {string}\n     */\n    this.name = 'ClientError';\n\n    /**\n     * @type {XMLHttpRequest}\n     */\n    this.client = client;\n  }\n}\n\n/**\n * @param {string} url The URL.\n * @return {Promise<Object>} A promise that resolves to the JSON response.\n */\nexport function getJSON(url) {\n  return new Promise(function (resolve, reject) {\n    /**\n     * @param {ProgressEvent<XMLHttpRequest>} event The load event.\n     */\n    function onLoad(event) {\n      const client = event.target;\n      // status will be 0 for file:// urls\n      if (!client.status || (client.status >= 200 && client.status < 300)) {\n        let data;\n        try {\n          data = JSON.parse(client.responseText);\n        } catch (err) {\n          const message = 'Error parsing response text as JSON: ' + err.message;\n          reject(new Error(message));\n          return;\n        }\n        resolve(data);\n        return;\n      }\n\n      reject(new ResponseError(client));\n    }\n\n    /**\n     * @param {ProgressEvent<XMLHttpRequest>} event The error event.\n     */\n    function onError(event) {\n      reject(new ClientError(event.target));\n    }\n\n    const client = new XMLHttpRequest();\n    client.addEventListener('load', onLoad);\n    client.addEventListener('error', onError);\n    client.open('GET', url);\n    client.setRequestHeader('Accept', 'application/json');\n    client.send();\n  });\n}\n\n/**\n * @param {string} base The base URL.\n * @param {string} url The potentially relative URL.\n * @return {string} The full URL.\n */\nexport function resolveUrl(base, url) {\n  if (url.includes('://')) {\n    return url;\n  }\n  return new URL(url, base).href;\n}\n\nlet originalXHR;\nexport function overrideXHR(xhr) {\n  if (typeof XMLHttpRequest !== 'undefined') {\n    originalXHR = XMLHttpRequest;\n  }\n  global.XMLHttpRequest = xhr;\n}\n\nexport function restoreXHR() {\n  global.XMLHttpRequest = originalXHR;\n}\n", "/**\n * @module ol/source/TileJSON\n */\n// FIXME check order of async callbacks\n\n/**\n * See https://mapbox.com/developers/api/.\n */\n\nimport TileImage from './TileImage.js';\nimport {applyTransform, intersects} from '../extent.js';\nimport {assert} from '../asserts.js';\nimport {createFromTemplates} from '../tileurlfunction.js';\nimport {createXYZ, extentFromProjection} from '../tilegrid.js';\nimport {get as getProjection, getTransformFromProjections} from '../proj.js';\nimport {jsonp as requestJSONP} from '../net.js';\n\n/**\n * @typedef {Object} Config\n * @property {string} [name] The name.\n * @property {string} [description] The description.\n * @property {string} [version] The version.\n * @property {string} [attribution] The attribution.\n * @property {string} [template] The template.\n * @property {string} [legend] The legend.\n * @property {string} [scheme] The scheme.\n * @property {Array<string>} tiles The tile URL templates.\n * @property {Array<string>} [grids] Optional grids.\n * @property {number} [minzoom] Minimum zoom level.\n * @property {number} [maxzoom] Maximum zoom level.\n * @property {Array<number>} [bounds] Optional bounds.\n * @property {Array<number>} [center] Optional center.\n */\n\n/**\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {number} [cacheSize] Initial tile cache size. Will auto-grow to hold at least the number of tiles in the viewport.\n * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that\n * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.\n * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.\n * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,\n * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.\n * @property {boolean} [jsonp=false] Use JSONP with callback to load the TileJSON.\n * Useful when the server does not support CORS..\n * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).\n * Higher values can increase reprojection performance, but decrease precision.\n * @property {Config} [tileJSON] TileJSON configuration for this source.\n * If not provided, `url` must be configured.\n * @property {import(\"../Tile.js\").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is\n * ```js\n * function(imageTile, src) {\n *   imageTile.getImage().src = src;\n * };\n * ```\n * @property {number|import(\"../size.js\").Size} [tileSize=[256, 256]] The tile size used by the tile service.\n * Note: `tileSize` and other non-standard TileJSON properties are currently ignored.\n * @property {string} [url] URL to the TileJSON file. If not provided, `tileJSON` must be configured.\n * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.\n * @property {number} [transition] Duration of the opacity transition for rendering.\n * To disable the opacity transition, pass `transition: 0`.\n * @property {number|import(\"../array.js\").NearestDirectionFunction} [zDirection=0]\n * Choose whether to use tiles with a higher or lower zoom level when between integer\n * zoom levels. See {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution}.\n */\n\n/**\n * @classdesc\n * Layer source for tile data in TileJSON format.\n * @api\n */\nclass TileJSON extends TileImage {\n  /**\n   * @param {Options} options TileJSON options.\n   */\n  constructor(options) {\n    super({\n      attributions: options.attributions,\n      cacheSize: options.cacheSize,\n      crossOrigin: options.crossOrigin,\n      interpolate: options.interpolate,\n      projection: getProjection('EPSG:3857'),\n      reprojectionErrorThreshold: options.reprojectionErrorThreshold,\n      state: 'loading',\n      tileLoadFunction: options.tileLoadFunction,\n      wrapX: options.wrapX !== undefined ? options.wrapX : true,\n      transition: options.transition,\n      zDirection: options.zDirection,\n    });\n\n    /**\n     * @type {Config}\n     * @private\n     */\n    this.tileJSON_ = null;\n\n    /**\n     * @type {number|import(\"../size.js\").Size}\n     * @private\n     */\n    this.tileSize_ = options.tileSize;\n\n    if (options.url) {\n      if (options.jsonp) {\n        requestJSONP(\n          options.url,\n          this.handleTileJSONResponse.bind(this),\n          this.handleTileJSONError.bind(this)\n        );\n      } else {\n        const client = new XMLHttpRequest();\n        client.addEventListener('load', this.onXHRLoad_.bind(this));\n        client.addEventListener('error', this.onXHRError_.bind(this));\n        client.open('GET', options.url);\n        client.send();\n      }\n    } else if (options.tileJSON) {\n      this.handleTileJSONResponse(options.tileJSON);\n    } else {\n      assert(false, 51); // Either `url` or `tileJSON` options must be provided\n    }\n  }\n\n  /**\n   * @private\n   * @param {Event} event The load event.\n   */\n  onXHRLoad_(event) {\n    const client = /** @type {XMLHttpRequest} */ (event.target);\n    // status will be 0 for file:// urls\n    if (!client.status || (client.status >= 200 && client.status < 300)) {\n      let response;\n      try {\n        response = /** @type {Config} */ (JSON.parse(client.responseText));\n      } catch (err) {\n        this.handleTileJSONError();\n        return;\n      }\n      this.handleTileJSONResponse(response);\n    } else {\n      this.handleTileJSONError();\n    }\n  }\n\n  /**\n   * @private\n   * @param {Event} event The error event.\n   */\n  onXHRError_(event) {\n    this.handleTileJSONError();\n  }\n\n  /**\n   * @return {Config} The tilejson object.\n   * @api\n   */\n  getTileJSON() {\n    return this.tileJSON_;\n  }\n\n  /**\n   * @protected\n   * @param {Config} tileJSON Tile JSON.\n   */\n  handleTileJSONResponse(tileJSON) {\n    const epsg4326Projection = getProjection('EPSG:4326');\n\n    const sourceProjection = this.getProjection();\n    let extent;\n    if (tileJSON['bounds'] !== undefined) {\n      const transform = getTransformFromProjections(\n        epsg4326Projection,\n        sourceProjection\n      );\n      extent = applyTransform(tileJSON['bounds'], transform);\n    }\n\n    const gridExtent = extentFromProjection(sourceProjection);\n    const minZoom = tileJSON['minzoom'] || 0;\n    const maxZoom = tileJSON['maxzoom'] || 22;\n    const tileGrid = createXYZ({\n      extent: gridExtent,\n      maxZoom: maxZoom,\n      minZoom: minZoom,\n      tileSize: this.tileSize_,\n    });\n    this.tileGrid = tileGrid;\n\n    this.tileUrlFunction = createFromTemplates(tileJSON['tiles'], tileGrid);\n\n    if (tileJSON['attribution'] && !this.getAttributions()) {\n      const attributionExtent = extent !== undefined ? extent : gridExtent;\n      this.setAttributions(function (frameState) {\n        if (intersects(attributionExtent, frameState.extent)) {\n          return [tileJSON['attribution']];\n        }\n        return null;\n      });\n    }\n    this.tileJSON_ = tileJSON;\n    this.setState('ready');\n  }\n\n  /**\n   * @protected\n   */\n  handleTileJSONError() {\n    this.setState('error');\n  }\n}\n\nexport default TileJSON;\n"],
  "mappings": "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",
  "names": []
}
