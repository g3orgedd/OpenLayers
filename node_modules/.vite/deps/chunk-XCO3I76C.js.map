{
  "version": 3,
  "sources": ["../../ol/string.js", "../../ol/coordinate.js"],
  "sourcesContent": ["/**\r\n * @module ol/string\r\n */\r\n\r\n/**\r\n * @param {number} number Number to be formatted\r\n * @param {number} width The desired width\r\n * @param {number} [precision] Precision of the output string (i.e. number of decimal places)\r\n * @return {string} Formatted string\r\n */\r\nexport function padNumber(number, width, precision) {\r\n  const numberString =\r\n    precision !== undefined ? number.toFixed(precision) : '' + number;\r\n  let decimal = numberString.indexOf('.');\r\n  decimal = decimal === -1 ? numberString.length : decimal;\r\n  return decimal > width\r\n    ? numberString\r\n    : new Array(1 + width - decimal).join('0') + numberString;\r\n}\r\n\r\n/**\r\n * Adapted from https://github.com/omichelsen/compare-versions/blob/master/index.js\r\n * @param {string|number} v1 First version\r\n * @param {string|number} v2 Second version\r\n * @return {number} Value\r\n */\r\nexport function compareVersions(v1, v2) {\r\n  const s1 = ('' + v1).split('.');\r\n  const s2 = ('' + v2).split('.');\r\n\r\n  for (let i = 0; i < Math.max(s1.length, s2.length); i++) {\r\n    const n1 = parseInt(s1[i] || '0', 10);\r\n    const n2 = parseInt(s2[i] || '0', 10);\r\n\r\n    if (n1 > n2) {\r\n      return 1;\r\n    }\r\n    if (n2 > n1) {\r\n      return -1;\r\n    }\r\n  }\r\n\r\n  return 0;\r\n}\r\n", "/**\r\n * @module ol/coordinate\r\n */\r\nimport {getWidth} from './extent.js';\r\nimport {modulo, toFixed} from './math.js';\r\nimport {padNumber} from './string.js';\r\n\r\n/**\r\n * An array of numbers representing an xy coordinate. Example: `[16, 48]`.\r\n * @typedef {Array<number>} Coordinate\r\n * @api\r\n */\r\n\r\n/**\r\n * A function that takes a {@link module:ol/coordinate~Coordinate} and\r\n * transforms it into a `{string}`.\r\n *\r\n * @typedef {function((Coordinate|undefined)): string} CoordinateFormat\r\n * @api\r\n */\r\n\r\n/**\r\n * Add `delta` to `coordinate`. `coordinate` is modified in place and returned\r\n * by the function.\r\n *\r\n * Example:\r\n *\r\n *     import {add} from 'ol/coordinate';\r\n *\r\n *     const coord = [7.85, 47.983333];\r\n *     add(coord, [-2, 4]);\r\n *     // coord is now [5.85, 51.983333]\r\n *\r\n * @param {Coordinate} coordinate Coordinate.\r\n * @param {Coordinate} delta Delta.\r\n * @return {Coordinate} The input coordinate adjusted by\r\n * the given delta.\r\n * @api\r\n */\r\nexport function add(coordinate, delta) {\r\n  coordinate[0] += +delta[0];\r\n  coordinate[1] += +delta[1];\r\n  return coordinate;\r\n}\r\n\r\n/**\r\n * Calculates the point closest to the passed coordinate on the passed circle.\r\n *\r\n * @param {Coordinate} coordinate The coordinate.\r\n * @param {import(\"./geom/Circle.js\").default} circle The circle.\r\n * @return {Coordinate} Closest point on the circumference.\r\n */\r\nexport function closestOnCircle(coordinate, circle) {\r\n  const r = circle.getRadius();\r\n  const center = circle.getCenter();\r\n  const x0 = center[0];\r\n  const y0 = center[1];\r\n  const x1 = coordinate[0];\r\n  const y1 = coordinate[1];\r\n\r\n  let dx = x1 - x0;\r\n  const dy = y1 - y0;\r\n  if (dx === 0 && dy === 0) {\r\n    dx = 1;\r\n  }\r\n  const d = Math.sqrt(dx * dx + dy * dy);\r\n\r\n  const x = x0 + (r * dx) / d;\r\n  const y = y0 + (r * dy) / d;\r\n\r\n  return [x, y];\r\n}\r\n\r\n/**\r\n * Calculates the point closest to the passed coordinate on the passed segment.\r\n * This is the foot of the perpendicular of the coordinate to the segment when\r\n * the foot is on the segment, or the closest segment coordinate when the foot\r\n * is outside the segment.\r\n *\r\n * @param {Coordinate} coordinate The coordinate.\r\n * @param {Array<Coordinate>} segment The two coordinates\r\n * of the segment.\r\n * @return {Coordinate} The foot of the perpendicular of\r\n * the coordinate to the segment.\r\n */\r\nexport function closestOnSegment(coordinate, segment) {\r\n  const x0 = coordinate[0];\r\n  const y0 = coordinate[1];\r\n  const start = segment[0];\r\n  const end = segment[1];\r\n  const x1 = start[0];\r\n  const y1 = start[1];\r\n  const x2 = end[0];\r\n  const y2 = end[1];\r\n  const dx = x2 - x1;\r\n  const dy = y2 - y1;\r\n  const along =\r\n    dx === 0 && dy === 0\r\n      ? 0\r\n      : (dx * (x0 - x1) + dy * (y0 - y1)) / (dx * dx + dy * dy || 0);\r\n  let x, y;\r\n  if (along <= 0) {\r\n    x = x1;\r\n    y = y1;\r\n  } else if (along >= 1) {\r\n    x = x2;\r\n    y = y2;\r\n  } else {\r\n    x = x1 + along * dx;\r\n    y = y1 + along * dy;\r\n  }\r\n  return [x, y];\r\n}\r\n\r\n/**\r\n * Returns a {@link module:ol/coordinate~CoordinateFormat} function that can be\r\n * used to format\r\n * a {Coordinate} to a string.\r\n *\r\n * Example without specifying the fractional digits:\r\n *\r\n *     import {createStringXY} from 'ol/coordinate';\r\n *\r\n *     const coord = [7.85, 47.983333];\r\n *     const stringifyFunc = createStringXY();\r\n *     const out = stringifyFunc(coord);\r\n *     // out is now '8, 48'\r\n *\r\n * Example with explicitly specifying 2 fractional digits:\r\n *\r\n *     import {createStringXY} from 'ol/coordinate';\r\n *\r\n *     const coord = [7.85, 47.983333];\r\n *     const stringifyFunc = createStringXY(2);\r\n *     const out = stringifyFunc(coord);\r\n *     // out is now '7.85, 47.98'\r\n *\r\n * @param {number} [fractionDigits] The number of digits to include\r\n *    after the decimal point. Default is `0`.\r\n * @return {CoordinateFormat} Coordinate format.\r\n * @api\r\n */\r\nexport function createStringXY(fractionDigits) {\r\n  return (\r\n    /**\r\n     * @param {Coordinate} coordinate Coordinate.\r\n     * @return {string} String XY.\r\n     */\r\n    function (coordinate) {\r\n      return toStringXY(coordinate, fractionDigits);\r\n    }\r\n  );\r\n}\r\n\r\n/**\r\n * @param {string} hemispheres Hemispheres.\r\n * @param {number} degrees Degrees.\r\n * @param {number} [fractionDigits] The number of digits to include\r\n *    after the decimal point. Default is `0`.\r\n * @return {string} String.\r\n */\r\nexport function degreesToStringHDMS(hemispheres, degrees, fractionDigits) {\r\n  const normalizedDegrees = modulo(degrees + 180, 360) - 180;\r\n  const x = Math.abs(3600 * normalizedDegrees);\r\n  const decimals = fractionDigits || 0;\r\n\r\n  let deg = Math.floor(x / 3600);\r\n  let min = Math.floor((x - deg * 3600) / 60);\r\n  let sec = toFixed(x - deg * 3600 - min * 60, decimals);\r\n\r\n  if (sec >= 60) {\r\n    sec = 0;\r\n    min += 1;\r\n  }\r\n\r\n  if (min >= 60) {\r\n    min = 0;\r\n    deg += 1;\r\n  }\r\n\r\n  let hdms = deg + '\\u00b0';\r\n  if (min !== 0 || sec !== 0) {\r\n    hdms += ' ' + padNumber(min, 2) + '\\u2032';\r\n  }\r\n  if (sec !== 0) {\r\n    hdms += ' ' + padNumber(sec, 2, decimals) + '\\u2033';\r\n  }\r\n  if (normalizedDegrees !== 0) {\r\n    hdms += ' ' + hemispheres.charAt(normalizedDegrees < 0 ? 1 : 0);\r\n  }\r\n\r\n  return hdms;\r\n}\r\n\r\n/**\r\n * Transforms the given {@link module:ol/coordinate~Coordinate} to a string\r\n * using the given string template. The strings `{x}` and `{y}` in the template\r\n * will be replaced with the first and second coordinate values respectively.\r\n *\r\n * Example without specifying the fractional digits:\r\n *\r\n *     import {format} from 'ol/coordinate';\r\n *\r\n *     const coord = [7.85, 47.983333];\r\n *     const template = 'Coordinate is ({x}|{y}).';\r\n *     const out = format(coord, template);\r\n *     // out is now 'Coordinate is (8|48).'\r\n *\r\n * Example explicitly specifying the fractional digits:\r\n *\r\n *     import {format} from 'ol/coordinate';\r\n *\r\n *     const coord = [7.85, 47.983333];\r\n *     const template = 'Coordinate is ({x}|{y}).';\r\n *     const out = format(coord, template, 2);\r\n *     // out is now 'Coordinate is (7.85|47.98).'\r\n *\r\n * @param {Coordinate} coordinate Coordinate.\r\n * @param {string} template A template string with `{x}` and `{y}` placeholders\r\n *     that will be replaced by first and second coordinate values.\r\n * @param {number} [fractionDigits] The number of digits to include\r\n *    after the decimal point. Default is `0`.\r\n * @return {string} Formatted coordinate.\r\n * @api\r\n */\r\nexport function format(coordinate, template, fractionDigits) {\r\n  if (coordinate) {\r\n    return template\r\n      .replace('{x}', coordinate[0].toFixed(fractionDigits))\r\n      .replace('{y}', coordinate[1].toFixed(fractionDigits));\r\n  } else {\r\n    return '';\r\n  }\r\n}\r\n\r\n/**\r\n * @param {Coordinate} coordinate1 First coordinate.\r\n * @param {Coordinate} coordinate2 Second coordinate.\r\n * @return {boolean} The two coordinates are equal.\r\n */\r\nexport function equals(coordinate1, coordinate2) {\r\n  let equals = true;\r\n  for (let i = coordinate1.length - 1; i >= 0; --i) {\r\n    if (coordinate1[i] != coordinate2[i]) {\r\n      equals = false;\r\n      break;\r\n    }\r\n  }\r\n  return equals;\r\n}\r\n\r\n/**\r\n * Rotate `coordinate` by `angle`. `coordinate` is modified in place and\r\n * returned by the function.\r\n *\r\n * Example:\r\n *\r\n *     import {rotate} from 'ol/coordinate';\r\n *\r\n *     const coord = [7.85, 47.983333];\r\n *     const rotateRadians = Math.PI / 2; // 90 degrees\r\n *     rotate(coord, rotateRadians);\r\n *     // coord is now [-47.983333, 7.85]\r\n *\r\n * @param {Coordinate} coordinate Coordinate.\r\n * @param {number} angle Angle in radian.\r\n * @return {Coordinate} Coordinate.\r\n * @api\r\n */\r\nexport function rotate(coordinate, angle) {\r\n  const cosAngle = Math.cos(angle);\r\n  const sinAngle = Math.sin(angle);\r\n  const x = coordinate[0] * cosAngle - coordinate[1] * sinAngle;\r\n  const y = coordinate[1] * cosAngle + coordinate[0] * sinAngle;\r\n  coordinate[0] = x;\r\n  coordinate[1] = y;\r\n  return coordinate;\r\n}\r\n\r\n/**\r\n * Scale `coordinate` by `scale`. `coordinate` is modified in place and returned\r\n * by the function.\r\n *\r\n * Example:\r\n *\r\n *     import {scale as scaleCoordinate} from 'ol/coordinate';\r\n *\r\n *     const coord = [7.85, 47.983333];\r\n *     const scale = 1.2;\r\n *     scaleCoordinate(coord, scale);\r\n *     // coord is now [9.42, 57.5799996]\r\n *\r\n * @param {Coordinate} coordinate Coordinate.\r\n * @param {number} scale Scale factor.\r\n * @return {Coordinate} Coordinate.\r\n */\r\nexport function scale(coordinate, scale) {\r\n  coordinate[0] *= scale;\r\n  coordinate[1] *= scale;\r\n  return coordinate;\r\n}\r\n\r\n/**\r\n * @param {Coordinate} coord1 First coordinate.\r\n * @param {Coordinate} coord2 Second coordinate.\r\n * @return {number} Squared distance between coord1 and coord2.\r\n */\r\nexport function squaredDistance(coord1, coord2) {\r\n  const dx = coord1[0] - coord2[0];\r\n  const dy = coord1[1] - coord2[1];\r\n  return dx * dx + dy * dy;\r\n}\r\n\r\n/**\r\n * @param {Coordinate} coord1 First coordinate.\r\n * @param {Coordinate} coord2 Second coordinate.\r\n * @return {number} Distance between coord1 and coord2.\r\n */\r\nexport function distance(coord1, coord2) {\r\n  return Math.sqrt(squaredDistance(coord1, coord2));\r\n}\r\n\r\n/**\r\n * Calculate the squared distance from a coordinate to a line segment.\r\n *\r\n * @param {Coordinate} coordinate Coordinate of the point.\r\n * @param {Array<Coordinate>} segment Line segment (2\r\n * coordinates).\r\n * @return {number} Squared distance from the point to the line segment.\r\n */\r\nexport function squaredDistanceToSegment(coordinate, segment) {\r\n  return squaredDistance(coordinate, closestOnSegment(coordinate, segment));\r\n}\r\n\r\n/**\r\n * Format a geographic coordinate with the hemisphere, degrees, minutes, and\r\n * seconds.\r\n *\r\n * Example without specifying fractional digits:\r\n *\r\n *     import {toStringHDMS} from 'ol/coordinate';\r\n *\r\n *     const coord = [7.85, 47.983333];\r\n *     const out = toStringHDMS(coord);\r\n *     // out is now '47\u00B0 58\u2032 60\u2033 N 7\u00B0 50\u2032 60\u2033 E'\r\n *\r\n * Example explicitly specifying 1 fractional digit:\r\n *\r\n *     import {toStringHDMS} from 'ol/coordinate';\r\n *\r\n *     const coord = [7.85, 47.983333];\r\n *     const out = toStringHDMS(coord, 1);\r\n *     // out is now '47\u00B0 58\u2032 60.0\u2033 N 7\u00B0 50\u2032 60.0\u2033 E'\r\n *\r\n * @param {Coordinate} coordinate Coordinate.\r\n * @param {number} [fractionDigits] The number of digits to include\r\n *    after the decimal point. Default is `0`.\r\n * @return {string} Hemisphere, degrees, minutes and seconds.\r\n * @api\r\n */\r\nexport function toStringHDMS(coordinate, fractionDigits) {\r\n  if (coordinate) {\r\n    return (\r\n      degreesToStringHDMS('NS', coordinate[1], fractionDigits) +\r\n      ' ' +\r\n      degreesToStringHDMS('EW', coordinate[0], fractionDigits)\r\n    );\r\n  } else {\r\n    return '';\r\n  }\r\n}\r\n\r\n/**\r\n * Format a coordinate as a comma delimited string.\r\n *\r\n * Example without specifying fractional digits:\r\n *\r\n *     import {toStringXY} from 'ol/coordinate';\r\n *\r\n *     const coord = [7.85, 47.983333];\r\n *     const out = toStringXY(coord);\r\n *     // out is now '8, 48'\r\n *\r\n * Example explicitly specifying 1 fractional digit:\r\n *\r\n *     import {toStringXY} from 'ol/coordinate';\r\n *\r\n *     const coord = [7.85, 47.983333];\r\n *     const out = toStringXY(coord, 1);\r\n *     // out is now '7.8, 48.0'\r\n *\r\n * @param {Coordinate} coordinate Coordinate.\r\n * @param {number} [fractionDigits] The number of digits to include\r\n *    after the decimal point. Default is `0`.\r\n * @return {string} XY.\r\n * @api\r\n */\r\nexport function toStringXY(coordinate, fractionDigits) {\r\n  return format(coordinate, '{x}, {y}', fractionDigits);\r\n}\r\n\r\n/**\r\n * Modifies the provided coordinate in-place to be within the real world\r\n * extent. The lower projection extent boundary is inclusive, the upper one\r\n * exclusive.\r\n *\r\n * @param {Coordinate} coordinate Coordinate.\r\n * @param {import(\"./proj/Projection.js\").default} projection Projection.\r\n * @return {Coordinate} The coordinate within the real world extent.\r\n */\r\nexport function wrapX(coordinate, projection) {\r\n  if (projection.canWrapX()) {\r\n    const worldWidth = getWidth(projection.getExtent());\r\n    const worldsAway = getWorldsAway(coordinate, projection, worldWidth);\r\n    if (worldsAway) {\r\n      coordinate[0] -= worldsAway * worldWidth;\r\n    }\r\n  }\r\n  return coordinate;\r\n}\r\n/**\r\n * @param {Coordinate} coordinate Coordinate.\r\n * @param {import(\"./proj/Projection.js\").default} projection Projection.\r\n * @param {number} [sourceExtentWidth] Width of the source extent.\r\n * @return {number} Offset in world widths.\r\n */\r\nexport function getWorldsAway(coordinate, projection, sourceExtentWidth) {\r\n  const projectionExtent = projection.getExtent();\r\n  let worldsAway = 0;\r\n  if (\r\n    projection.canWrapX() &&\r\n    (coordinate[0] < projectionExtent[0] || coordinate[0] > projectionExtent[2])\r\n  ) {\r\n    sourceExtentWidth = sourceExtentWidth || getWidth(projectionExtent);\r\n    worldsAway = Math.floor(\r\n      (coordinate[0] - projectionExtent[0]) / sourceExtentWidth\r\n    );\r\n  }\r\n  return worldsAway;\r\n}\r\n"],
  "mappings": "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",
  "names": ["equals", "scale"]
}
