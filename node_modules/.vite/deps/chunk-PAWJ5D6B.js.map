{
  "version": 3,
  "sources": ["../../ol/layer/BaseImage.js", "../../ol/renderer/canvas/ImageLayer.js", "../../ol/layer/Image.js", "../../ol/VectorTile.js", "../../ol/VectorRenderTile.js", "../../ol/source/VectorTile.js", "../../ol/source/TileJSON.js", "../../ol/layer/TileProperty.js", "../../ol/layer/BaseTile.js", "../../ol/renderer/canvas/TileLayer.js", "../../ol/layer/Tile.js", "../../ol/ImageCanvas.js", "../../ol/DataTile.js"],
  "sourcesContent": ["/**\r\n * @module ol/layer/BaseImage\r\n */\r\nimport Layer from './Layer.js';\r\n\r\n/**\r\n * @template {import(\"../source/Image.js\").default} ImageSourceType\r\n * @typedef {Object} Options\r\n * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.\r\n * @property {number} [opacity=1] Opacity (0, 1).\r\n * @property {boolean} [visible=true] Visibility.\r\n * @property {import(\"../extent.js\").Extent} [extent] The bounding extent for layer rendering.  The layer will not be\r\n * rendered outside of this extent.\r\n * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers\r\n * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed\r\n * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`\r\n * method was used.\r\n * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\r\n * visible.\r\n * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\r\n * be visible.\r\n * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be\r\n * visible.\r\n * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will\r\n * be visible.\r\n * @property {import(\"../Map.js\").default} [map] Sets the layer as overlay on a map. The map will not manage\r\n * this layer in its layers collection, and the layer will be rendered on top. This is useful for\r\n * temporary layers. The standard way to add a layer to a map and have it managed by the map is to\r\n * use {@link import(\"../Map.js\").default#addLayer map.addLayer()}.\r\n * @property {ImageSourceType} [source] Source for this layer.\r\n * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * Server-rendered images that are available for arbitrary extents and\r\n * resolutions.\r\n * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}\r\n * property on the layer object; for example, setting `title: 'My Title'` in the\r\n * options means that `title` is observable, and has get/set accessors.\r\n *\r\n * @template {import(\"../source/Image.js\").default} ImageSourceType\r\n * @template {import(\"../renderer/Layer.js\").default} RendererType\r\n * @extends {Layer<ImageSourceType, RendererType>}\r\n * @api\r\n */\r\nclass BaseImageLayer extends Layer {\r\n  /**\r\n   * @param {Options<ImageSourceType>} [options] Layer options.\r\n   */\r\n  constructor(options) {\r\n    options = options ? options : {};\r\n    super(options);\r\n  }\r\n}\r\n\r\nexport default BaseImageLayer;\r\n", "/**\r\n * @module ol/renderer/canvas/ImageLayer\r\n */\r\nimport CanvasLayerRenderer from './Layer.js';\r\nimport ImageState from '../../ImageState.js';\r\nimport ViewHint from '../../ViewHint.js';\r\nimport {\r\n  apply as applyTransform,\r\n  compose as composeTransform,\r\n  makeInverse,\r\n  toString as toTransformString,\r\n} from '../../transform.js';\r\nimport {\r\n  containsCoordinate,\r\n  containsExtent,\r\n  getHeight,\r\n  getIntersection,\r\n  getWidth,\r\n  intersects as intersectsExtent,\r\n  isEmpty,\r\n} from '../../extent.js';\r\nimport {fromUserExtent} from '../../proj.js';\r\n\r\n/**\r\n * @classdesc\r\n * Canvas renderer for image layers.\r\n * @api\r\n */\r\nclass CanvasImageLayerRenderer extends CanvasLayerRenderer {\r\n  /**\r\n   * @param {import(\"../../layer/Image.js\").default} imageLayer Image layer.\r\n   */\r\n  constructor(imageLayer) {\r\n    super(imageLayer);\r\n\r\n    /**\r\n     * @protected\r\n     * @type {?import(\"../../ImageBase.js\").default}\r\n     */\r\n    this.image_ = null;\r\n  }\r\n\r\n  /**\r\n   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.\r\n   */\r\n  getImage() {\r\n    return !this.image_ ? null : this.image_.getImage();\r\n  }\r\n\r\n  /**\r\n   * Determine whether render should be called.\r\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\r\n   * @return {boolean} Layer is ready to be rendered.\r\n   */\r\n  prepareFrame(frameState) {\r\n    const layerState = frameState.layerStatesArray[frameState.layerIndex];\r\n    const pixelRatio = frameState.pixelRatio;\r\n    const viewState = frameState.viewState;\r\n    const viewResolution = viewState.resolution;\r\n\r\n    const imageSource = this.getLayer().getSource();\r\n\r\n    const hints = frameState.viewHints;\r\n\r\n    let renderedExtent = frameState.extent;\r\n    if (layerState.extent !== undefined) {\r\n      renderedExtent = getIntersection(\r\n        renderedExtent,\r\n        fromUserExtent(layerState.extent, viewState.projection)\r\n      );\r\n    }\r\n\r\n    if (\r\n      !hints[ViewHint.ANIMATING] &&\r\n      !hints[ViewHint.INTERACTING] &&\r\n      !isEmpty(renderedExtent)\r\n    ) {\r\n      if (imageSource) {\r\n        const projection = viewState.projection;\r\n        const image = imageSource.getImage(\r\n          renderedExtent,\r\n          viewResolution,\r\n          pixelRatio,\r\n          projection\r\n        );\r\n        if (image) {\r\n          if (this.loadImage(image)) {\r\n            this.image_ = image;\r\n          } else if (image.getState() === ImageState.EMPTY) {\r\n            this.image_ = null;\r\n          }\r\n        }\r\n      } else {\r\n        this.image_ = null;\r\n      }\r\n    }\r\n\r\n    return !!this.image_;\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../../pixel.js\").Pixel} pixel Pixel.\r\n   * @return {Uint8ClampedArray} Data at the pixel location.\r\n   */\r\n  getData(pixel) {\r\n    const frameState = this.frameState;\r\n    if (!frameState) {\r\n      return null;\r\n    }\r\n\r\n    const layer = this.getLayer();\r\n    const coordinate = applyTransform(\r\n      frameState.pixelToCoordinateTransform,\r\n      pixel.slice()\r\n    );\r\n\r\n    const layerExtent = layer.getExtent();\r\n    if (layerExtent) {\r\n      if (!containsCoordinate(layerExtent, coordinate)) {\r\n        return null;\r\n      }\r\n    }\r\n\r\n    const imageExtent = this.image_.getExtent();\r\n    const img = this.image_.getImage();\r\n\r\n    const imageMapWidth = getWidth(imageExtent);\r\n    const col = Math.floor(\r\n      img.width * ((coordinate[0] - imageExtent[0]) / imageMapWidth)\r\n    );\r\n    if (col < 0 || col >= img.width) {\r\n      return null;\r\n    }\r\n\r\n    const imageMapHeight = getHeight(imageExtent);\r\n    const row = Math.floor(\r\n      img.height * ((imageExtent[3] - coordinate[1]) / imageMapHeight)\r\n    );\r\n    if (row < 0 || row >= img.height) {\r\n      return null;\r\n    }\r\n\r\n    return this.getImageData(img, col, row);\r\n  }\r\n\r\n  /**\r\n   * Render the layer.\r\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\r\n   * @param {HTMLElement} target Target that may be used to render content to.\r\n   * @return {HTMLElement} The rendered element.\r\n   */\r\n  renderFrame(frameState, target) {\r\n    const image = this.image_;\r\n    const imageExtent = image.getExtent();\r\n    const imageResolution = image.getResolution();\r\n    const imagePixelRatio = image.getPixelRatio();\r\n    const layerState = frameState.layerStatesArray[frameState.layerIndex];\r\n    const pixelRatio = frameState.pixelRatio;\r\n    const viewState = frameState.viewState;\r\n    const viewCenter = viewState.center;\r\n    const viewResolution = viewState.resolution;\r\n    const scale =\r\n      (pixelRatio * imageResolution) / (viewResolution * imagePixelRatio);\r\n\r\n    const extent = frameState.extent;\r\n    const resolution = viewState.resolution;\r\n    const rotation = viewState.rotation;\r\n    // desired dimensions of the canvas in pixels\r\n    const width = Math.round((getWidth(extent) / resolution) * pixelRatio);\r\n    const height = Math.round((getHeight(extent) / resolution) * pixelRatio);\r\n\r\n    // set forward and inverse pixel transforms\r\n    composeTransform(\r\n      this.pixelTransform,\r\n      frameState.size[0] / 2,\r\n      frameState.size[1] / 2,\r\n      1 / pixelRatio,\r\n      1 / pixelRatio,\r\n      rotation,\r\n      -width / 2,\r\n      -height / 2\r\n    );\r\n    makeInverse(this.inversePixelTransform, this.pixelTransform);\r\n\r\n    const canvasTransform = toTransformString(this.pixelTransform);\r\n\r\n    this.useContainer(target, canvasTransform, this.getBackground(frameState));\r\n\r\n    const context = this.context;\r\n    const canvas = context.canvas;\r\n\r\n    if (canvas.width != width || canvas.height != height) {\r\n      canvas.width = width;\r\n      canvas.height = height;\r\n    } else if (!this.containerReused) {\r\n      context.clearRect(0, 0, width, height);\r\n    }\r\n\r\n    // clipped rendering if layer extent is set\r\n    let clipped = false;\r\n    let render = true;\r\n    if (layerState.extent) {\r\n      const layerExtent = fromUserExtent(\r\n        layerState.extent,\r\n        viewState.projection\r\n      );\r\n      render = intersectsExtent(layerExtent, frameState.extent);\r\n      clipped = render && !containsExtent(layerExtent, frameState.extent);\r\n      if (clipped) {\r\n        this.clipUnrotated(context, frameState, layerExtent);\r\n      }\r\n    }\r\n\r\n    const img = image.getImage();\r\n\r\n    const transform = composeTransform(\r\n      this.tempTransform,\r\n      width / 2,\r\n      height / 2,\r\n      scale,\r\n      scale,\r\n      0,\r\n      (imagePixelRatio * (imageExtent[0] - viewCenter[0])) / imageResolution,\r\n      (imagePixelRatio * (viewCenter[1] - imageExtent[3])) / imageResolution\r\n    );\r\n\r\n    this.renderedResolution = (imageResolution * pixelRatio) / imagePixelRatio;\r\n\r\n    const dw = img.width * transform[0];\r\n    const dh = img.height * transform[3];\r\n\r\n    if (!this.getLayer().getSource().getInterpolate()) {\r\n      context.imageSmoothingEnabled = false;\r\n    }\r\n\r\n    this.preRender(context, frameState);\r\n    if (render && dw >= 0.5 && dh >= 0.5) {\r\n      const dx = transform[4];\r\n      const dy = transform[5];\r\n      const opacity = layerState.opacity;\r\n      let previousAlpha;\r\n      if (opacity !== 1) {\r\n        previousAlpha = context.globalAlpha;\r\n        context.globalAlpha = opacity;\r\n      }\r\n      context.drawImage(img, 0, 0, +img.width, +img.height, dx, dy, dw, dh);\r\n      if (opacity !== 1) {\r\n        context.globalAlpha = previousAlpha;\r\n      }\r\n    }\r\n    this.postRender(context, frameState);\r\n\r\n    if (clipped) {\r\n      context.restore();\r\n    }\r\n    context.imageSmoothingEnabled = true;\r\n\r\n    if (canvasTransform !== canvas.style.transform) {\r\n      canvas.style.transform = canvasTransform;\r\n    }\r\n\r\n    return this.container;\r\n  }\r\n}\r\n\r\nexport default CanvasImageLayerRenderer;\r\n", "/**\r\n * @module ol/layer/Image\r\n */\r\nimport BaseImageLayer from './BaseImage.js';\r\nimport CanvasImageLayerRenderer from '../renderer/canvas/ImageLayer.js';\r\n\r\n/**\r\n * @classdesc\r\n * Server-rendered images that are available for arbitrary extents and\r\n * resolutions.\r\n * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}\r\n * property on the layer object; for example, setting `title: 'My Title'` in the\r\n * options means that `title` is observable, and has get/set accessors.\r\n *\r\n * @template {import(\"../source/Image.js\").default} ImageSourceType\r\n * @extends {BaseImageLayer<ImageSourceType, CanvasImageLayerRenderer>}\r\n * @api\r\n */\r\nclass ImageLayer extends BaseImageLayer {\r\n  /**\r\n   * @param {import(\"./BaseImage.js\").Options<ImageSourceType>} [options] Layer options.\r\n   */\r\n  constructor(options) {\r\n    super(options);\r\n  }\r\n\r\n  createRenderer() {\r\n    return new CanvasImageLayerRenderer(this);\r\n  }\r\n\r\n  /**\r\n   * Get data for a pixel location.  A four element RGBA array will be returned.  For requests outside the\r\n   * layer extent, `null` will be returned.  Data for an image can only be retrieved if the\r\n   * source's `crossOrigin` property is set.\r\n   *\r\n   * ```js\r\n   * // display layer data on every pointer move\r\n   * map.on('pointermove', (event) => {\r\n   *   console.log(layer.getData(event.pixel));\r\n   * });\r\n   * ```\r\n   * @param {import(\"../pixel\").Pixel} pixel Pixel.\r\n   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.\r\n   * @api\r\n   */\r\n  getData(pixel) {\r\n    return super.getData(pixel);\r\n  }\r\n}\r\n\r\nexport default ImageLayer;\r\n", "/**\r\n * @module ol/VectorTile\r\n */\r\nimport Tile from './Tile.js';\r\nimport TileState from './TileState.js';\r\n\r\nclass VectorTile extends Tile {\r\n  /**\r\n   * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\r\n   * @param {import(\"./TileState.js\").default} state State.\r\n   * @param {string} src Data source url.\r\n   * @param {import(\"./format/Feature.js\").default} format Feature format.\r\n   * @param {import(\"./Tile.js\").LoadFunction} tileLoadFunction Tile load function.\r\n   * @param {import(\"./Tile.js\").Options} [options] Tile options.\r\n   */\r\n  constructor(tileCoord, state, src, format, tileLoadFunction, options) {\r\n    super(tileCoord, state, options);\r\n\r\n    /**\r\n     * Extent of this tile; set by the source.\r\n     * @type {import(\"./extent.js\").Extent}\r\n     */\r\n    this.extent = null;\r\n\r\n    /**\r\n     * @private\r\n     * @type {import(\"./format/Feature.js\").default}\r\n     */\r\n    this.format_ = format;\r\n\r\n    /**\r\n     * @private\r\n     * @type {Array<import(\"./Feature.js\").default>}\r\n     */\r\n    this.features_ = null;\r\n\r\n    /**\r\n     * @private\r\n     * @type {import(\"./featureloader.js\").FeatureLoader}\r\n     */\r\n    this.loader_;\r\n\r\n    /**\r\n     * Feature projection of this tile; set by the source.\r\n     * @type {import(\"./proj/Projection.js\").default}\r\n     */\r\n    this.projection = null;\r\n\r\n    /**\r\n     * Resolution of this tile; set by the source.\r\n     * @type {number}\r\n     */\r\n    this.resolution;\r\n\r\n    /**\r\n     * @private\r\n     * @type {import(\"./Tile.js\").LoadFunction}\r\n     */\r\n    this.tileLoadFunction_ = tileLoadFunction;\r\n\r\n    /**\r\n     * @private\r\n     * @type {string}\r\n     */\r\n    this.url_ = src;\r\n\r\n    this.key = src;\r\n  }\r\n\r\n  /**\r\n   * Get the feature format assigned for reading this tile's features.\r\n   * @return {import(\"./format/Feature.js\").default} Feature format.\r\n   * @api\r\n   */\r\n  getFormat() {\r\n    return this.format_;\r\n  }\r\n\r\n  /**\r\n   * Get the features for this tile. Geometries will be in the view projection.\r\n   * @return {Array<import(\"./Feature.js\").FeatureLike>} Features.\r\n   * @api\r\n   */\r\n  getFeatures() {\r\n    return this.features_;\r\n  }\r\n\r\n  /**\r\n   * Load not yet loaded URI.\r\n   */\r\n  load() {\r\n    if (this.state == TileState.IDLE) {\r\n      this.setState(TileState.LOADING);\r\n      this.tileLoadFunction_(this, this.url_);\r\n      if (this.loader_) {\r\n        this.loader_(this.extent, this.resolution, this.projection);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Handler for successful tile load.\r\n   * @param {Array<import(\"./Feature.js\").default>} features The loaded features.\r\n   * @param {import(\"./proj/Projection.js\").default} dataProjection Data projection.\r\n   */\r\n  onLoad(features, dataProjection) {\r\n    this.setFeatures(features);\r\n  }\r\n\r\n  /**\r\n   * Handler for tile load errors.\r\n   */\r\n  onError() {\r\n    this.setState(TileState.ERROR);\r\n  }\r\n\r\n  /**\r\n   * Function for use in an {@link module:ol/source/VectorTile~VectorTile}'s `tileLoadFunction`.\r\n   * Sets the features for the tile.\r\n   * @param {Array<import(\"./Feature.js\").default>} features Features.\r\n   * @api\r\n   */\r\n  setFeatures(features) {\r\n    this.features_ = features;\r\n    this.setState(TileState.LOADED);\r\n  }\r\n\r\n  /**\r\n   * Set the feature loader for reading this tile's features.\r\n   * @param {import(\"./featureloader.js\").FeatureLoader} loader Feature loader.\r\n   * @api\r\n   */\r\n  setLoader(loader) {\r\n    this.loader_ = loader;\r\n  }\r\n}\r\n\r\nexport default VectorTile;\r\n", "/**\r\n * @module ol/VectorRenderTile\r\n */\r\nimport Tile from './Tile.js';\r\nimport {createCanvasContext2D, releaseCanvas} from './dom.js';\r\nimport {getUid} from './util.js';\r\n\r\n/**\r\n * @typedef {Object} ReplayState\r\n * @property {boolean} dirty Dirty.\r\n * @property {null|import(\"./render.js\").OrderFunction} renderedRenderOrder RenderedRenderOrder.\r\n * @property {number} renderedTileRevision RenderedTileRevision.\r\n * @property {number} renderedResolution RenderedResolution.\r\n * @property {number} renderedRevision RenderedRevision.\r\n * @property {number} renderedTileResolution RenderedTileResolution.\r\n * @property {number} renderedTileZ RenderedTileZ.\r\n */\r\n\r\n/**\r\n * @type {Array<HTMLCanvasElement>}\r\n */\r\nconst canvasPool = [];\r\n\r\nclass VectorRenderTile extends Tile {\r\n  /**\r\n   * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\r\n   * @param {import(\"./TileState.js\").default} state State.\r\n   * @param {import(\"./tilecoord.js\").TileCoord} urlTileCoord Wrapped tile coordinate for source urls.\r\n   * @param {function(VectorRenderTile):Array<import(\"./VectorTile\").default>} getSourceTiles Function\r\n   * to get source tiles for this tile.\r\n   */\r\n  constructor(tileCoord, state, urlTileCoord, getSourceTiles) {\r\n    super(tileCoord, state, {transition: 0});\r\n\r\n    /**\r\n     * @private\r\n     * @type {!Object<string, CanvasRenderingContext2D>}\r\n     */\r\n    this.context_ = {};\r\n\r\n    /**\r\n     * Executor groups by layer uid. Entries are read/written by the renderer.\r\n     * @type {Object<string, Array<import(\"./render/canvas/ExecutorGroup.js\").default>>}\r\n     */\r\n    this.executorGroups = {};\r\n\r\n    /**\r\n     * Executor groups for decluttering, by layer uid. Entries are read/written by the renderer.\r\n     * @type {Object<string, Array<import(\"./render/canvas/ExecutorGroup.js\").default>>}\r\n     */\r\n    this.declutterExecutorGroups = {};\r\n\r\n    /**\r\n     * Number of loading source tiles. Read/written by the source.\r\n     * @type {number}\r\n     */\r\n    this.loadingSourceTiles = 0;\r\n\r\n    /**\r\n     * @type {Object<number, ImageData>}\r\n     */\r\n    this.hitDetectionImageData = {};\r\n\r\n    /**\r\n     * @private\r\n     * @type {!Object<string, ReplayState>}\r\n     */\r\n    this.replayState_ = {};\r\n\r\n    /**\r\n     * @type {Array<import(\"./VectorTile.js\").default>}\r\n     */\r\n    this.sourceTiles = [];\r\n\r\n    /**\r\n     * @type {Object<string, boolean>}\r\n     */\r\n    this.errorTileKeys = {};\r\n\r\n    /**\r\n     * @type {number}\r\n     */\r\n    this.wantedResolution;\r\n\r\n    /**\r\n     * @type {!function():Array<import(\"./VectorTile.js\").default>}\r\n     */\r\n    this.getSourceTiles = getSourceTiles.bind(undefined, this);\r\n\r\n    /**\r\n     * @type {import(\"./tilecoord.js\").TileCoord}\r\n     */\r\n    this.wrappedTileCoord = urlTileCoord;\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"./layer/Layer.js\").default} layer Layer.\r\n   * @return {CanvasRenderingContext2D} The rendering context.\r\n   */\r\n  getContext(layer) {\r\n    const key = getUid(layer);\r\n    if (!(key in this.context_)) {\r\n      this.context_[key] = createCanvasContext2D(1, 1, canvasPool);\r\n    }\r\n    return this.context_[key];\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"./layer/Layer.js\").default} layer Layer.\r\n   * @return {boolean} Tile has a rendering context for the given layer.\r\n   */\r\n  hasContext(layer) {\r\n    return getUid(layer) in this.context_;\r\n  }\r\n\r\n  /**\r\n   * Get the Canvas for this tile.\r\n   * @param {import(\"./layer/Layer.js\").default} layer Layer.\r\n   * @return {HTMLCanvasElement} Canvas.\r\n   */\r\n  getImage(layer) {\r\n    return this.hasContext(layer) ? this.getContext(layer).canvas : null;\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"./layer/Layer.js\").default} layer Layer.\r\n   * @return {ReplayState} The replay state.\r\n   */\r\n  getReplayState(layer) {\r\n    const key = getUid(layer);\r\n    if (!(key in this.replayState_)) {\r\n      this.replayState_[key] = {\r\n        dirty: false,\r\n        renderedRenderOrder: null,\r\n        renderedResolution: NaN,\r\n        renderedRevision: -1,\r\n        renderedTileResolution: NaN,\r\n        renderedTileRevision: -1,\r\n        renderedTileZ: -1,\r\n      };\r\n    }\r\n    return this.replayState_[key];\r\n  }\r\n\r\n  /**\r\n   * Load the tile.\r\n   */\r\n  load() {\r\n    this.getSourceTiles();\r\n  }\r\n\r\n  /**\r\n   * Remove from the cache due to expiry\r\n   */\r\n  release() {\r\n    for (const key in this.context_) {\r\n      const context = this.context_[key];\r\n      releaseCanvas(context);\r\n      canvasPool.push(context.canvas);\r\n      delete this.context_[key];\r\n    }\r\n    super.release();\r\n  }\r\n}\r\n\r\nexport default VectorRenderTile;\r\n", "/**\r\n * @module ol/source/VectorTile\r\n */\r\n\r\nimport EventType from '../events/EventType.js';\r\nimport Tile from '../VectorTile.js';\r\nimport TileCache from '../TileCache.js';\r\nimport TileGrid from '../tilegrid/TileGrid.js';\r\nimport TileState from '../TileState.js';\r\nimport UrlTile from './UrlTile.js';\r\nimport VectorRenderTile from '../VectorRenderTile.js';\r\nimport {DEFAULT_MAX_ZOOM} from '../tilegrid/common.js';\r\nimport {\r\n  buffer as bufferExtent,\r\n  getIntersection,\r\n  intersects,\r\n} from '../extent.js';\r\nimport {createXYZ, extentFromProjection} from '../tilegrid.js';\r\nimport {fromKey, getCacheKeyForTileKey, getKeyZXY} from '../tilecoord.js';\r\nimport {isEmpty} from '../obj.js';\r\nimport {loadFeaturesXhr} from '../featureloader.js';\r\nimport {toSize} from '../size.js';\r\n\r\n/**\r\n * @typedef {Object} Options\r\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\r\n * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.\r\n * @property {number} [cacheSize] Initial tile cache size. Will auto-grow to hold at least twice the number of tiles in the viewport.\r\n * @property {import(\"../extent.js\").Extent} [extent] Extent.\r\n * @property {import(\"../format/Feature.js\").default} [format] Feature format for tiles. Used and required by the default.\r\n * @property {boolean} [overlaps=true] This source may have overlapping geometries. Setting this\r\n * to `false` (e.g. for sources with polygons that represent administrative\r\n * boundaries or TopoJSON sources) allows the renderer to optimise fill and\r\n * stroke operations.\r\n * @property {import(\"../proj.js\").ProjectionLike} [projection='EPSG:3857'] Projection of the tile grid.\r\n * @property {import(\"./Source.js\").State} [state] Source state.\r\n * @property {typeof import(\"../VectorTile.js\").default} [tileClass] Class used to instantiate image tiles.\r\n * Default is {@link module:ol/VectorTile~VectorTile}.\r\n * @property {number} [maxZoom=22] Optional max zoom level. Not used if `tileGrid` is provided.\r\n * @property {number} [minZoom] Optional min zoom level. Not used if `tileGrid` is provided.\r\n * @property {number|import(\"../size.js\").Size} [tileSize=512] Optional tile size. Not used if `tileGrid` is provided.\r\n * @property {number} [maxResolution] Optional tile grid resolution at level zero. Not used if `tileGrid` is provided.\r\n * @property {import(\"../tilegrid/TileGrid.js\").default} [tileGrid] Tile grid.\r\n * @property {import(\"../Tile.js\").LoadFunction} [tileLoadFunction]\r\n * Optional function to load a tile given a URL. Could look like this for pbf tiles:\r\n * ```js\r\n * function(tile, url) {\r\n *   tile.setLoader(function(extent, resolution, projection) {\r\n *     fetch(url).then(function(response) {\r\n *       response.arrayBuffer().then(function(data) {\r\n *         const format = tile.getFormat() // ol/format/MVT configured as source format\r\n *         const features = format.readFeatures(data, {\r\n *           extent: extent,\r\n *           featureProjection: projection\r\n *         });\r\n *         tile.setFeatures(features);\r\n *       });\r\n *     });\r\n *   });\r\n * }\r\n * ```\r\n * If you do not need extent, resolution and projection to get the features for a tile (e.g.\r\n * for GeoJSON tiles), your `tileLoadFunction` does not need a `setLoader()` call. Only make sure\r\n * to call `setFeatures()` on the tile:\r\n * ```js\r\n * const format = new GeoJSON({featureProjection: map.getView().getProjection()});\r\n * async function tileLoadFunction(tile, url) {\r\n *   const response = await fetch(url);\r\n *   const data = await response.json();\r\n *   tile.setFeatures(format.readFeatures(data));\r\n * }\r\n * ```\r\n * @property {import(\"../Tile.js\").UrlFunction} [tileUrlFunction] Optional function to get tile URL given a tile coordinate and the projection.\r\n * @property {string} [url] URL template. Must include `{x}`, `{y}` or `{-y}`, and `{z}` placeholders.\r\n * A `{?-?}` template pattern, for example `subdomain{a-f}.domain.com`, may be\r\n * used instead of defining each one separately in the `urls` option.\r\n * @property {number} [transition] A duration for tile opacity\r\n * transitions in milliseconds. A duration of 0 disables the opacity transition.\r\n * @property {Array<string>} [urls] An array of URL templates.\r\n * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.\r\n * When set to `false`, only one world\r\n * will be rendered. When set to `true`, tiles will be wrapped horizontally to\r\n * render multiple worlds.\r\n * @property {number|import(\"../array.js\").NearestDirectionFunction} [zDirection=1]\r\n * Choose whether to use tiles with a higher or lower zoom level when between integer\r\n * zoom levels. See {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution}.\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * Class for layer sources providing vector data divided into a tile grid, to be\r\n * used with {@link module:ol/layer/VectorTile~VectorTileLayer}. Although this source receives tiles\r\n * with vector features from the server, it is not meant for feature editing.\r\n * Features are optimized for rendering, their geometries are clipped at or near\r\n * tile boundaries and simplified for a view resolution. See\r\n * {@link module:ol/source/Vector~VectorSource} for vector sources that are suitable for feature\r\n * editing.\r\n *\r\n * @fires import(\"./Tile.js\").TileSourceEvent\r\n * @api\r\n */\r\nclass VectorTile extends UrlTile {\r\n  /**\r\n   * @param {!Options} options Vector tile options.\r\n   */\r\n  constructor(options) {\r\n    const projection = options.projection || 'EPSG:3857';\r\n\r\n    const extent = options.extent || extentFromProjection(projection);\r\n\r\n    const tileGrid =\r\n      options.tileGrid ||\r\n      createXYZ({\r\n        extent: extent,\r\n        maxResolution: options.maxResolution,\r\n        maxZoom: options.maxZoom !== undefined ? options.maxZoom : 22,\r\n        minZoom: options.minZoom,\r\n        tileSize: options.tileSize || 512,\r\n      });\r\n\r\n    super({\r\n      attributions: options.attributions,\r\n      attributionsCollapsible: options.attributionsCollapsible,\r\n      cacheSize: options.cacheSize,\r\n      interpolate: true,\r\n      opaque: false,\r\n      projection: projection,\r\n      state: options.state,\r\n      tileGrid: tileGrid,\r\n      tileLoadFunction: options.tileLoadFunction\r\n        ? options.tileLoadFunction\r\n        : defaultLoadFunction,\r\n      tileUrlFunction: options.tileUrlFunction,\r\n      url: options.url,\r\n      urls: options.urls,\r\n      wrapX: options.wrapX === undefined ? true : options.wrapX,\r\n      transition: options.transition,\r\n      zDirection: options.zDirection === undefined ? 1 : options.zDirection,\r\n    });\r\n\r\n    /**\r\n     * @private\r\n     * @type {import(\"../format/Feature.js\").default|null}\r\n     */\r\n    this.format_ = options.format ? options.format : null;\r\n\r\n    /**\r\n     * @private\r\n     * @type {TileCache}\r\n     */\r\n    this.sourceTileCache = new TileCache(this.tileCache.highWaterMark);\r\n\r\n    /**\r\n     * @private\r\n     * @type {boolean}\r\n     */\r\n    this.overlaps_ = options.overlaps == undefined ? true : options.overlaps;\r\n\r\n    /**\r\n     * @protected\r\n     * @type {typeof import(\"../VectorTile.js\").default}\r\n     */\r\n    this.tileClass = options.tileClass ? options.tileClass : Tile;\r\n\r\n    /**\r\n     * @private\r\n     * @type {Object<string, import(\"../tilegrid/TileGrid.js\").default>}\r\n     */\r\n    this.tileGrids_ = {};\r\n  }\r\n\r\n  /**\r\n   * Get features whose bounding box intersects the provided extent. Only features for cached\r\n   * tiles for the last rendered zoom level are available in the source. So this method is only\r\n   * suitable for requesting tiles for extents that are currently rendered.\r\n   *\r\n   * Features are returned in random tile order and as they are included in the tiles. This means\r\n   * they can be clipped, duplicated across tiles, and simplified to the render resolution.\r\n   *\r\n   * @param {import(\"../extent.js\").Extent} extent Extent.\r\n   * @return {Array<import(\"../Feature.js\").FeatureLike>} Features.\r\n   * @api\r\n   */\r\n  getFeaturesInExtent(extent) {\r\n    const features = [];\r\n    const tileCache = this.tileCache;\r\n    if (tileCache.getCount() === 0) {\r\n      return features;\r\n    }\r\n    const z = fromKey(tileCache.peekFirstKey())[0];\r\n    const tileGrid = this.tileGrid;\r\n    tileCache.forEach(function (tile) {\r\n      if (tile.tileCoord[0] !== z || tile.getState() !== TileState.LOADED) {\r\n        return;\r\n      }\r\n      const sourceTiles = tile.getSourceTiles();\r\n      for (let i = 0, ii = sourceTiles.length; i < ii; ++i) {\r\n        const sourceTile = sourceTiles[i];\r\n        const tileCoord = sourceTile.tileCoord;\r\n        if (intersects(extent, tileGrid.getTileCoordExtent(tileCoord))) {\r\n          const tileFeatures = sourceTile.getFeatures();\r\n          if (tileFeatures) {\r\n            for (let j = 0, jj = tileFeatures.length; j < jj; ++j) {\r\n              const candidate = tileFeatures[j];\r\n              const geometry = candidate.getGeometry();\r\n              if (intersects(extent, geometry.getExtent())) {\r\n                features.push(candidate);\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    });\r\n    return features;\r\n  }\r\n\r\n  /**\r\n   * @return {boolean} The source can have overlapping geometries.\r\n   */\r\n  getOverlaps() {\r\n    return this.overlaps_;\r\n  }\r\n\r\n  /**\r\n   * clear {@link module:ol/TileCache~TileCache} and delete all source tiles\r\n   * @api\r\n   */\r\n  clear() {\r\n    this.tileCache.clear();\r\n    this.sourceTileCache.clear();\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\r\n   * @param {!Object<string, boolean>} usedTiles Used tiles.\r\n   */\r\n  expireCache(projection, usedTiles) {\r\n    const tileCache = this.getTileCacheForProjection(projection);\r\n    const usedSourceTiles = Object.keys(usedTiles).reduce((acc, key) => {\r\n      const cacheKey = getCacheKeyForTileKey(key);\r\n      const tile = tileCache.peek(cacheKey);\r\n      if (tile) {\r\n        const sourceTiles = tile.sourceTiles;\r\n        for (let i = 0, ii = sourceTiles.length; i < ii; ++i) {\r\n          acc[sourceTiles[i].getKey()] = true;\r\n        }\r\n      }\r\n      return acc;\r\n    }, {});\r\n    super.expireCache(projection, usedTiles);\r\n    this.sourceTileCache.expireCache(usedSourceTiles);\r\n  }\r\n\r\n  /**\r\n   * @param {number} pixelRatio Pixel ratio.\r\n   * @param {import(\"../proj/Projection\").default} projection Projection.\r\n   * @param {VectorRenderTile} tile Vector image tile.\r\n   * @return {Array<import(\"../VectorTile\").default>} Tile keys.\r\n   */\r\n  getSourceTiles(pixelRatio, projection, tile) {\r\n    if (tile.getState() === TileState.IDLE) {\r\n      tile.setState(TileState.LOADING);\r\n      const urlTileCoord = tile.wrappedTileCoord;\r\n      const tileGrid = this.getTileGridForProjection(projection);\r\n      const extent = tileGrid.getTileCoordExtent(urlTileCoord);\r\n      const z = urlTileCoord[0];\r\n      const resolution = tileGrid.getResolution(z);\r\n      // make extent 1 pixel smaller so we don't load tiles for < 0.5 pixel render space\r\n      bufferExtent(extent, -resolution, extent);\r\n      const sourceTileGrid = this.tileGrid;\r\n      const sourceExtent = sourceTileGrid.getExtent();\r\n      if (sourceExtent) {\r\n        getIntersection(extent, sourceExtent, extent);\r\n      }\r\n      const sourceZ = sourceTileGrid.getZForResolution(\r\n        resolution,\r\n        this.zDirection\r\n      );\r\n\r\n      sourceTileGrid.forEachTileCoord(extent, sourceZ, (sourceTileCoord) => {\r\n        const tileUrl = this.tileUrlFunction(\r\n          sourceTileCoord,\r\n          pixelRatio,\r\n          projection\r\n        );\r\n        const sourceTile = this.sourceTileCache.containsKey(tileUrl)\r\n          ? this.sourceTileCache.get(tileUrl)\r\n          : new this.tileClass(\r\n              sourceTileCoord,\r\n              tileUrl ? TileState.IDLE : TileState.EMPTY,\r\n              tileUrl,\r\n              this.format_,\r\n              this.tileLoadFunction\r\n            );\r\n        tile.sourceTiles.push(sourceTile);\r\n        const sourceTileState = sourceTile.getState();\r\n        if (sourceTileState < TileState.LOADED) {\r\n          const listenChange = (event) => {\r\n            this.handleTileChange(event);\r\n            const state = sourceTile.getState();\r\n            if (state === TileState.LOADED || state === TileState.ERROR) {\r\n              const sourceTileKey = sourceTile.getKey();\r\n              if (sourceTileKey in tile.errorTileKeys) {\r\n                if (sourceTile.getState() === TileState.LOADED) {\r\n                  delete tile.errorTileKeys[sourceTileKey];\r\n                }\r\n              } else {\r\n                tile.loadingSourceTiles--;\r\n              }\r\n              if (state === TileState.ERROR) {\r\n                tile.errorTileKeys[sourceTileKey] = true;\r\n              } else {\r\n                sourceTile.removeEventListener(EventType.CHANGE, listenChange);\r\n              }\r\n              if (tile.loadingSourceTiles === 0) {\r\n                tile.setState(\r\n                  isEmpty(tile.errorTileKeys)\r\n                    ? TileState.LOADED\r\n                    : TileState.ERROR\r\n                );\r\n              }\r\n            }\r\n          };\r\n          sourceTile.addEventListener(EventType.CHANGE, listenChange);\r\n          tile.loadingSourceTiles++;\r\n        }\r\n        if (sourceTileState === TileState.IDLE) {\r\n          sourceTile.extent =\r\n            sourceTileGrid.getTileCoordExtent(sourceTileCoord);\r\n          sourceTile.projection = projection;\r\n          sourceTile.resolution = sourceTileGrid.getResolution(\r\n            sourceTileCoord[0]\r\n          );\r\n          this.sourceTileCache.set(tileUrl, sourceTile);\r\n          sourceTile.load();\r\n        }\r\n      });\r\n      if (!tile.loadingSourceTiles) {\r\n        tile.setState(\r\n          tile.sourceTiles.some(\r\n            (sourceTile) => sourceTile.getState() === TileState.ERROR\r\n          )\r\n            ? TileState.ERROR\r\n            : TileState.LOADED\r\n        );\r\n      }\r\n    }\r\n\r\n    return tile.sourceTiles;\r\n  }\r\n\r\n  /**\r\n   * @param {number} z Tile coordinate z.\r\n   * @param {number} x Tile coordinate x.\r\n   * @param {number} y Tile coordinate y.\r\n   * @param {number} pixelRatio Pixel ratio.\r\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\r\n   * @return {!VectorRenderTile} Tile.\r\n   */\r\n  getTile(z, x, y, pixelRatio, projection) {\r\n    const coordKey = getKeyZXY(z, x, y);\r\n    const key = this.getKey();\r\n    let tile;\r\n    if (this.tileCache.containsKey(coordKey)) {\r\n      tile = this.tileCache.get(coordKey);\r\n      if (tile.key === key) {\r\n        return tile;\r\n      }\r\n    }\r\n    const tileCoord = [z, x, y];\r\n    let urlTileCoord = this.getTileCoordForTileUrlFunction(\r\n      tileCoord,\r\n      projection\r\n    );\r\n    const sourceExtent = this.getTileGrid().getExtent();\r\n    const tileGrid = this.getTileGridForProjection(projection);\r\n    if (urlTileCoord && sourceExtent) {\r\n      const tileExtent = tileGrid.getTileCoordExtent(urlTileCoord);\r\n      // make extent 1 pixel smaller so we don't load tiles for < 0.5 pixel render space\r\n      bufferExtent(tileExtent, -tileGrid.getResolution(z), tileExtent);\r\n      if (!intersects(sourceExtent, tileExtent)) {\r\n        urlTileCoord = null;\r\n      }\r\n    }\r\n    let empty = true;\r\n    if (urlTileCoord !== null) {\r\n      const sourceTileGrid = this.tileGrid;\r\n      const resolution = tileGrid.getResolution(z);\r\n      const sourceZ = sourceTileGrid.getZForResolution(resolution, 1);\r\n      // make extent 1 pixel smaller so we don't load tiles for < 0.5 pixel render space\r\n      const extent = tileGrid.getTileCoordExtent(urlTileCoord);\r\n      bufferExtent(extent, -resolution, extent);\r\n      sourceTileGrid.forEachTileCoord(\r\n        extent,\r\n        sourceZ,\r\n        function (sourceTileCoord) {\r\n          empty =\r\n            empty &&\r\n            !this.tileUrlFunction(sourceTileCoord, pixelRatio, projection);\r\n        }.bind(this)\r\n      );\r\n    }\r\n    const newTile = new VectorRenderTile(\r\n      tileCoord,\r\n      empty ? TileState.EMPTY : TileState.IDLE,\r\n      urlTileCoord,\r\n      this.getSourceTiles.bind(this, pixelRatio, projection)\r\n    );\r\n\r\n    newTile.key = key;\r\n    if (tile) {\r\n      newTile.interimTile = tile;\r\n      newTile.refreshInterimChain();\r\n      this.tileCache.replace(coordKey, newTile);\r\n    } else {\r\n      this.tileCache.set(coordKey, newTile);\r\n    }\r\n    return newTile;\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\r\n   * @return {!import(\"../tilegrid/TileGrid.js\").default} Tile grid.\r\n   */\r\n  getTileGridForProjection(projection) {\r\n    const code = projection.getCode();\r\n    let tileGrid = this.tileGrids_[code];\r\n    if (!tileGrid) {\r\n      // A tile grid that matches the tile size of the source tile grid is more\r\n      // likely to have 1:1 relationships between source tiles and rendered tiles.\r\n      const sourceTileGrid = this.tileGrid;\r\n      const resolutions = sourceTileGrid.getResolutions().slice();\r\n      const origins = resolutions.map(function (resolution, z) {\r\n        return sourceTileGrid.getOrigin(z);\r\n      });\r\n      const tileSizes = resolutions.map(function (resolution, z) {\r\n        return sourceTileGrid.getTileSize(z);\r\n      });\r\n      const length = DEFAULT_MAX_ZOOM + 1;\r\n      for (let z = resolutions.length; z < length; ++z) {\r\n        resolutions.push(resolutions[z - 1] / 2);\r\n        origins.push(origins[z - 1]);\r\n        tileSizes.push(tileSizes[z - 1]);\r\n      }\r\n      tileGrid = new TileGrid({\r\n        extent: sourceTileGrid.getExtent(),\r\n        origins: origins,\r\n        resolutions: resolutions,\r\n        tileSizes: tileSizes,\r\n      });\r\n      this.tileGrids_[code] = tileGrid;\r\n    }\r\n    return tileGrid;\r\n  }\r\n\r\n  /**\r\n   * Get the tile pixel ratio for this source.\r\n   * @param {number} pixelRatio Pixel ratio.\r\n   * @return {number} Tile pixel ratio.\r\n   */\r\n  getTilePixelRatio(pixelRatio) {\r\n    return pixelRatio;\r\n  }\r\n\r\n  /**\r\n   * @param {number} z Z.\r\n   * @param {number} pixelRatio Pixel ratio.\r\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\r\n   * @return {import(\"../size.js\").Size} Tile size.\r\n   */\r\n  getTilePixelSize(z, pixelRatio, projection) {\r\n    const tileGrid = this.getTileGridForProjection(projection);\r\n    const tileSize = toSize(tileGrid.getTileSize(z), this.tmpSize);\r\n    return [\r\n      Math.round(tileSize[0] * pixelRatio),\r\n      Math.round(tileSize[1] * pixelRatio),\r\n    ];\r\n  }\r\n\r\n  /**\r\n   * Increases the cache size if needed\r\n   * @param {number} tileCount Minimum number of tiles needed.\r\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\r\n   */\r\n  updateCacheSize(tileCount, projection) {\r\n    super.updateCacheSize(tileCount * 2, projection);\r\n    this.sourceTileCache.highWaterMark =\r\n      this.getTileCacheForProjection(projection).highWaterMark;\r\n  }\r\n}\r\n\r\nexport default VectorTile;\r\n\r\n/**\r\n * Sets the loader for a tile.\r\n * @param {import(\"../VectorTile.js\").default} tile Vector tile.\r\n * @param {string} url URL.\r\n */\r\nexport function defaultLoadFunction(tile, url) {\r\n  tile.setLoader(\r\n    /**\r\n     * @param {import(\"../extent.js\").Extent} extent Extent.\r\n     * @param {number} resolution Resolution.\r\n     * @param {import(\"../proj/Projection.js\").default} projection Projection.\r\n     */\r\n    function (extent, resolution, projection) {\r\n      loadFeaturesXhr(\r\n        url,\r\n        tile.getFormat(),\r\n        extent,\r\n        resolution,\r\n        projection,\r\n        tile.onLoad.bind(tile),\r\n        tile.onError.bind(tile)\r\n      );\r\n    }\r\n  );\r\n}\r\n", "/**\r\n * @module ol/source/TileJSON\r\n */\r\n// FIXME check order of async callbacks\r\n\r\n/**\r\n * See https://mapbox.com/developers/api/.\r\n */\r\n\r\nimport TileImage from './TileImage.js';\r\nimport {applyTransform, intersects} from '../extent.js';\r\nimport {assert} from '../asserts.js';\r\nimport {createFromTemplates} from '../tileurlfunction.js';\r\nimport {createXYZ, extentFromProjection} from '../tilegrid.js';\r\nimport {get as getProjection, getTransformFromProjections} from '../proj.js';\r\nimport {jsonp as requestJSONP} from '../net.js';\r\n\r\n/**\r\n * @typedef {Object} Config\r\n * @property {string} [name] The name.\r\n * @property {string} [description] The description.\r\n * @property {string} [version] The version.\r\n * @property {string} [attribution] The attribution.\r\n * @property {string} [template] The template.\r\n * @property {string} [legend] The legend.\r\n * @property {string} [scheme] The scheme.\r\n * @property {Array<string>} tiles The tile URL templates.\r\n * @property {Array<string>} [grids] Optional grids.\r\n * @property {number} [minzoom] Minimum zoom level.\r\n * @property {number} [maxzoom] Maximum zoom level.\r\n * @property {Array<number>} [bounds] Optional bounds.\r\n * @property {Array<number>} [center] Optional center.\r\n */\r\n\r\n/**\r\n * @typedef {Object} Options\r\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\r\n * @property {number} [cacheSize] Initial tile cache size. Will auto-grow to hold at least the number of tiles in the viewport.\r\n * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that\r\n * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.\r\n * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.\r\n * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,\r\n * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.\r\n * @property {boolean} [jsonp=false] Use JSONP with callback to load the TileJSON.\r\n * Useful when the server does not support CORS..\r\n * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).\r\n * Higher values can increase reprojection performance, but decrease precision.\r\n * @property {Config} [tileJSON] TileJSON configuration for this source.\r\n * If not provided, `url` must be configured.\r\n * @property {import(\"../Tile.js\").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is\r\n * ```js\r\n * function(imageTile, src) {\r\n *   imageTile.getImage().src = src;\r\n * };\r\n * ```\r\n * @property {number|import(\"../size.js\").Size} [tileSize=[256, 256]] The tile size used by the tile service.\r\n * Note: `tileSize` and other non-standard TileJSON properties are currently ignored.\r\n * @property {string} [url] URL to the TileJSON file. If not provided, `tileJSON` must be configured.\r\n * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.\r\n * @property {number} [transition] Duration of the opacity transition for rendering.\r\n * To disable the opacity transition, pass `transition: 0`.\r\n * @property {number|import(\"../array.js\").NearestDirectionFunction} [zDirection=0]\r\n * Choose whether to use tiles with a higher or lower zoom level when between integer\r\n * zoom levels. See {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution}.\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * Layer source for tile data in TileJSON format.\r\n * @api\r\n */\r\nclass TileJSON extends TileImage {\r\n  /**\r\n   * @param {Options} options TileJSON options.\r\n   */\r\n  constructor(options) {\r\n    super({\r\n      attributions: options.attributions,\r\n      cacheSize: options.cacheSize,\r\n      crossOrigin: options.crossOrigin,\r\n      interpolate: options.interpolate,\r\n      projection: getProjection('EPSG:3857'),\r\n      reprojectionErrorThreshold: options.reprojectionErrorThreshold,\r\n      state: 'loading',\r\n      tileLoadFunction: options.tileLoadFunction,\r\n      wrapX: options.wrapX !== undefined ? options.wrapX : true,\r\n      transition: options.transition,\r\n      zDirection: options.zDirection,\r\n    });\r\n\r\n    /**\r\n     * @type {Config}\r\n     * @private\r\n     */\r\n    this.tileJSON_ = null;\r\n\r\n    /**\r\n     * @type {number|import(\"../size.js\").Size}\r\n     * @private\r\n     */\r\n    this.tileSize_ = options.tileSize;\r\n\r\n    if (options.url) {\r\n      if (options.jsonp) {\r\n        requestJSONP(\r\n          options.url,\r\n          this.handleTileJSONResponse.bind(this),\r\n          this.handleTileJSONError.bind(this)\r\n        );\r\n      } else {\r\n        const client = new XMLHttpRequest();\r\n        client.addEventListener('load', this.onXHRLoad_.bind(this));\r\n        client.addEventListener('error', this.onXHRError_.bind(this));\r\n        client.open('GET', options.url);\r\n        client.send();\r\n      }\r\n    } else if (options.tileJSON) {\r\n      this.handleTileJSONResponse(options.tileJSON);\r\n    } else {\r\n      assert(false, 51); // Either `url` or `tileJSON` options must be provided\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   * @param {Event} event The load event.\r\n   */\r\n  onXHRLoad_(event) {\r\n    const client = /** @type {XMLHttpRequest} */ (event.target);\r\n    // status will be 0 for file:// urls\r\n    if (!client.status || (client.status >= 200 && client.status < 300)) {\r\n      let response;\r\n      try {\r\n        response = /** @type {Config} */ (JSON.parse(client.responseText));\r\n      } catch (err) {\r\n        this.handleTileJSONError();\r\n        return;\r\n      }\r\n      this.handleTileJSONResponse(response);\r\n    } else {\r\n      this.handleTileJSONError();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   * @param {Event} event The error event.\r\n   */\r\n  onXHRError_(event) {\r\n    this.handleTileJSONError();\r\n  }\r\n\r\n  /**\r\n   * @return {Config} The tilejson object.\r\n   * @api\r\n   */\r\n  getTileJSON() {\r\n    return this.tileJSON_;\r\n  }\r\n\r\n  /**\r\n   * @protected\r\n   * @param {Config} tileJSON Tile JSON.\r\n   */\r\n  handleTileJSONResponse(tileJSON) {\r\n    const epsg4326Projection = getProjection('EPSG:4326');\r\n\r\n    const sourceProjection = this.getProjection();\r\n    let extent;\r\n    if (tileJSON['bounds'] !== undefined) {\r\n      const transform = getTransformFromProjections(\r\n        epsg4326Projection,\r\n        sourceProjection\r\n      );\r\n      extent = applyTransform(tileJSON['bounds'], transform);\r\n    }\r\n\r\n    const gridExtent = extentFromProjection(sourceProjection);\r\n    const minZoom = tileJSON['minzoom'] || 0;\r\n    const maxZoom = tileJSON['maxzoom'] || 22;\r\n    const tileGrid = createXYZ({\r\n      extent: gridExtent,\r\n      maxZoom: maxZoom,\r\n      minZoom: minZoom,\r\n      tileSize: this.tileSize_,\r\n    });\r\n    this.tileGrid = tileGrid;\r\n\r\n    this.tileUrlFunction = createFromTemplates(tileJSON['tiles'], tileGrid);\r\n\r\n    if (tileJSON['attribution'] && !this.getAttributions()) {\r\n      const attributionExtent = extent !== undefined ? extent : gridExtent;\r\n      this.setAttributions(function (frameState) {\r\n        if (intersects(attributionExtent, frameState.extent)) {\r\n          return [tileJSON['attribution']];\r\n        }\r\n        return null;\r\n      });\r\n    }\r\n    this.tileJSON_ = tileJSON;\r\n    this.setState('ready');\r\n  }\r\n\r\n  /**\r\n   * @protected\r\n   */\r\n  handleTileJSONError() {\r\n    this.setState('error');\r\n  }\r\n}\r\n\r\nexport default TileJSON;\r\n", "/**\r\n * @module ol/layer/TileProperty\r\n */\r\n\r\n/**\r\n * @enum {string}\r\n */\r\nexport default {\r\n  PRELOAD: 'preload',\r\n  USE_INTERIM_TILES_ON_ERROR: 'useInterimTilesOnError',\r\n};\r\n", "/**\r\n * @module ol/layer/BaseTile\r\n */\r\nimport Layer from './Layer.js';\r\nimport TileProperty from './TileProperty.js';\r\n\r\n/***\r\n * @template Return\r\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\r\n *   import(\"../Observable\").OnSignature<import(\"./Base\").BaseLayerObjectEventTypes|\r\n *     'change:source'|'change:preload'|'change:useInterimTilesOnError', import(\"../Object\").ObjectEvent, Return> &\r\n *   import(\"../Observable\").OnSignature<import(\"../render/EventType\").LayerRenderEventTypes, import(\"../render/Event\").default, Return> &\r\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"./Base\").BaseLayerObjectEventTypes|\r\n *   'change:source'|'change:preload'|'change:useInterimTilesOnError'|import(\"../render/EventType\").LayerRenderEventTypes, Return>} BaseTileLayerOnSignature\r\n */\r\n\r\n/**\r\n * @template {import(\"../source/Tile.js\").default} TileSourceType\r\n * @typedef {Object} Options\r\n * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.\r\n * @property {number} [opacity=1] Opacity (0, 1).\r\n * @property {boolean} [visible=true] Visibility.\r\n * @property {import(\"../extent.js\").Extent} [extent] The bounding extent for layer rendering.  The layer will not be\r\n * rendered outside of this extent.\r\n * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers\r\n * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed\r\n * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`\r\n * method was used.\r\n * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\r\n * visible.\r\n * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\r\n * be visible.\r\n * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be\r\n * visible.\r\n * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will\r\n * be visible.\r\n * @property {number} [preload=0] Preload. Load low-resolution tiles up to `preload` levels. `0`\r\n * means no preloading.\r\n * @property {TileSourceType} [source] Source for this layer.\r\n * @property {import(\"../Map.js\").default} [map] Sets the layer as overlay on a map. The map will not manage\r\n * this layer in its layers collection, and the layer will be rendered on top. This is useful for\r\n * temporary layers. The standard way to add a layer to a map and have it managed by the map is to\r\n * use {@link import(\"../Map.js\").default#addLayer map.addLayer()}.\r\n * @property {boolean} [useInterimTilesOnError=true] Use interim tiles on error.\r\n * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * For layer sources that provide pre-rendered, tiled images in grids that are\r\n * organized by zoom levels for specific resolutions.\r\n * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}\r\n * property on the layer object; for example, setting `title: 'My Title'` in the\r\n * options means that `title` is observable, and has get/set accessors.\r\n *\r\n * @template {import(\"../source/Tile.js\").default} TileSourceType\r\n * @template {import(\"../renderer/Layer.js\").default} RendererType\r\n * @extends {Layer<TileSourceType, RendererType>}\r\n * @api\r\n */\r\nclass BaseTileLayer extends Layer {\r\n  /**\r\n   * @param {Options<TileSourceType>} [options] Tile layer options.\r\n   */\r\n  constructor(options) {\r\n    options = options ? options : {};\r\n\r\n    const baseOptions = Object.assign({}, options);\r\n\r\n    delete baseOptions.preload;\r\n    delete baseOptions.useInterimTilesOnError;\r\n    super(baseOptions);\r\n\r\n    /***\r\n     * @type {BaseTileLayerOnSignature<import(\"../events\").EventsKey>}\r\n     */\r\n    this.on;\r\n\r\n    /***\r\n     * @type {BaseTileLayerOnSignature<import(\"../events\").EventsKey>}\r\n     */\r\n    this.once;\r\n\r\n    /***\r\n     * @type {BaseTileLayerOnSignature<void>}\r\n     */\r\n    this.un;\r\n\r\n    this.setPreload(options.preload !== undefined ? options.preload : 0);\r\n    this.setUseInterimTilesOnError(\r\n      options.useInterimTilesOnError !== undefined\r\n        ? options.useInterimTilesOnError\r\n        : true\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Return the level as number to which we will preload tiles up to.\r\n   * @return {number} The level to preload tiles up to.\r\n   * @observable\r\n   * @api\r\n   */\r\n  getPreload() {\r\n    return /** @type {number} */ (this.get(TileProperty.PRELOAD));\r\n  }\r\n\r\n  /**\r\n   * Set the level as number to which we will preload tiles up to.\r\n   * @param {number} preload The level to preload tiles up to.\r\n   * @observable\r\n   * @api\r\n   */\r\n  setPreload(preload) {\r\n    this.set(TileProperty.PRELOAD, preload);\r\n  }\r\n\r\n  /**\r\n   * Whether we use interim tiles on error.\r\n   * @return {boolean} Use interim tiles on error.\r\n   * @observable\r\n   * @api\r\n   */\r\n  getUseInterimTilesOnError() {\r\n    return /** @type {boolean} */ (\r\n      this.get(TileProperty.USE_INTERIM_TILES_ON_ERROR)\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Set whether we use interim tiles on error.\r\n   * @param {boolean} useInterimTilesOnError Use interim tiles on error.\r\n   * @observable\r\n   * @api\r\n   */\r\n  setUseInterimTilesOnError(useInterimTilesOnError) {\r\n    this.set(TileProperty.USE_INTERIM_TILES_ON_ERROR, useInterimTilesOnError);\r\n  }\r\n\r\n  /**\r\n   * Get data for a pixel location.  The return type depends on the source data.  For image tiles,\r\n   * a four element RGBA array will be returned.  For data tiles, the array length will match the\r\n   * number of bands in the dataset.  For requests outside the layer extent, `null` will be returned.\r\n   * Data for a image tiles can only be retrieved if the source's `crossOrigin` property is set.\r\n   *\r\n   * ```js\r\n   * // display layer data on every pointer move\r\n   * map.on('pointermove', (event) => {\r\n   *   console.log(layer.getData(event.pixel));\r\n   * });\r\n   * ```\r\n   * @param {import(\"../pixel\").Pixel} pixel Pixel.\r\n   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.\r\n   * @api\r\n   */\r\n  getData(pixel) {\r\n    return super.getData(pixel);\r\n  }\r\n}\r\n\r\nexport default BaseTileLayer;\r\n", "/**\r\n * @module ol/renderer/canvas/TileLayer\r\n */\r\nimport CanvasLayerRenderer from './Layer.js';\r\nimport ImageTile from '../../ImageTile.js';\r\nimport ReprojTile from '../../reproj/Tile.js';\r\nimport TileRange from '../../TileRange.js';\r\nimport TileState from '../../TileState.js';\r\nimport {\r\n  apply as applyTransform,\r\n  compose as composeTransform,\r\n  makeInverse,\r\n  toString as toTransformString,\r\n} from '../../transform.js';\r\nimport {\r\n  containsCoordinate,\r\n  createEmpty,\r\n  equals,\r\n  getHeight,\r\n  getIntersection,\r\n  getRotatedViewport,\r\n  getTopLeft,\r\n  getWidth,\r\n  intersects,\r\n} from '../../extent.js';\r\nimport {fromUserExtent} from '../../proj.js';\r\nimport {getUid} from '../../util.js';\r\nimport {numberSafeCompareFunction} from '../../array.js';\r\nimport {toSize} from '../../size.js';\r\n\r\n/**\r\n * @classdesc\r\n * Canvas renderer for tile layers.\r\n * @api\r\n * @template {import(\"../../layer/Tile.js\").default<import(\"../../source/Tile.js\").default>|import(\"../../layer/VectorTile.js\").default} [LayerType=import(\"../../layer/Tile.js\").default<import(\"../../source/Tile.js\").default>|import(\"../../layer/VectorTile.js\").default]\r\n * @extends {CanvasLayerRenderer<LayerType>}\r\n */\r\nclass CanvasTileLayerRenderer extends CanvasLayerRenderer {\r\n  /**\r\n   * @param {LayerType} tileLayer Tile layer.\r\n   */\r\n  constructor(tileLayer) {\r\n    super(tileLayer);\r\n\r\n    /**\r\n     * Rendered extent has changed since the previous `renderFrame()` call\r\n     * @type {boolean}\r\n     */\r\n    this.extentChanged = true;\r\n\r\n    /**\r\n     * @private\r\n     * @type {?import(\"../../extent.js\").Extent}\r\n     */\r\n    this.renderedExtent_ = null;\r\n\r\n    /**\r\n     * @protected\r\n     * @type {number}\r\n     */\r\n    this.renderedPixelRatio;\r\n\r\n    /**\r\n     * @protected\r\n     * @type {import(\"../../proj/Projection.js\").default}\r\n     */\r\n    this.renderedProjection = null;\r\n\r\n    /**\r\n     * @protected\r\n     * @type {number}\r\n     */\r\n    this.renderedRevision;\r\n\r\n    /**\r\n     * @protected\r\n     * @type {!Array<import(\"../../Tile.js\").default>}\r\n     */\r\n    this.renderedTiles = [];\r\n\r\n    /**\r\n     * @private\r\n     * @type {boolean}\r\n     */\r\n    this.newTiles_ = false;\r\n\r\n    /**\r\n     * @protected\r\n     * @type {import(\"../../extent.js\").Extent}\r\n     */\r\n    this.tmpExtent = createEmpty();\r\n\r\n    /**\r\n     * @private\r\n     * @type {import(\"../../TileRange.js\").default}\r\n     */\r\n    this.tmpTileRange_ = new TileRange(0, 0, 0, 0);\r\n  }\r\n\r\n  /**\r\n   * @protected\r\n   * @param {import(\"../../Tile.js\").default} tile Tile.\r\n   * @return {boolean} Tile is drawable.\r\n   */\r\n  isDrawableTile(tile) {\r\n    const tileLayer = this.getLayer();\r\n    const tileState = tile.getState();\r\n    const useInterimTilesOnError = tileLayer.getUseInterimTilesOnError();\r\n    return (\r\n      tileState == TileState.LOADED ||\r\n      tileState == TileState.EMPTY ||\r\n      (tileState == TileState.ERROR && !useInterimTilesOnError)\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @param {number} z Tile coordinate z.\r\n   * @param {number} x Tile coordinate x.\r\n   * @param {number} y Tile coordinate y.\r\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\r\n   * @return {!import(\"../../Tile.js\").default} Tile.\r\n   */\r\n  getTile(z, x, y, frameState) {\r\n    const pixelRatio = frameState.pixelRatio;\r\n    const projection = frameState.viewState.projection;\r\n    const tileLayer = this.getLayer();\r\n    const tileSource = tileLayer.getSource();\r\n    let tile = tileSource.getTile(z, x, y, pixelRatio, projection);\r\n    if (tile.getState() == TileState.ERROR) {\r\n      if (tileLayer.getUseInterimTilesOnError() && tileLayer.getPreload() > 0) {\r\n        // Preloaded tiles for lower resolutions might have finished loading.\r\n        this.newTiles_ = true;\r\n      }\r\n    }\r\n    if (!this.isDrawableTile(tile)) {\r\n      tile = tile.getInterimTile();\r\n    }\r\n    return tile;\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../../pixel.js\").Pixel} pixel Pixel.\r\n   * @return {Uint8ClampedArray} Data at the pixel location.\r\n   */\r\n  getData(pixel) {\r\n    const frameState = this.frameState;\r\n    if (!frameState) {\r\n      return null;\r\n    }\r\n\r\n    const layer = this.getLayer();\r\n    const coordinate = applyTransform(\r\n      frameState.pixelToCoordinateTransform,\r\n      pixel.slice()\r\n    );\r\n\r\n    const layerExtent = layer.getExtent();\r\n    if (layerExtent) {\r\n      if (!containsCoordinate(layerExtent, coordinate)) {\r\n        return null;\r\n      }\r\n    }\r\n\r\n    const pixelRatio = frameState.pixelRatio;\r\n    const projection = frameState.viewState.projection;\r\n    const viewState = frameState.viewState;\r\n    const source = layer.getRenderSource();\r\n    const tileGrid = source.getTileGridForProjection(viewState.projection);\r\n    const tilePixelRatio = source.getTilePixelRatio(frameState.pixelRatio);\r\n\r\n    for (\r\n      let z = tileGrid.getZForResolution(viewState.resolution);\r\n      z >= tileGrid.getMinZoom();\r\n      --z\r\n    ) {\r\n      const tileCoord = tileGrid.getTileCoordForCoordAndZ(coordinate, z);\r\n      const tile = source.getTile(\r\n        z,\r\n        tileCoord[1],\r\n        tileCoord[2],\r\n        pixelRatio,\r\n        projection\r\n      );\r\n      if (\r\n        !(tile instanceof ImageTile || tile instanceof ReprojTile) ||\r\n        (tile instanceof ReprojTile && tile.getState() === TileState.EMPTY)\r\n      ) {\r\n        return null;\r\n      }\r\n\r\n      if (tile.getState() !== TileState.LOADED) {\r\n        continue;\r\n      }\r\n\r\n      const tileOrigin = tileGrid.getOrigin(z);\r\n      const tileSize = toSize(tileGrid.getTileSize(z));\r\n      const tileResolution = tileGrid.getResolution(z);\r\n\r\n      const col = Math.floor(\r\n        tilePixelRatio *\r\n          ((coordinate[0] - tileOrigin[0]) / tileResolution -\r\n            tileCoord[1] * tileSize[0])\r\n      );\r\n\r\n      const row = Math.floor(\r\n        tilePixelRatio *\r\n          ((tileOrigin[1] - coordinate[1]) / tileResolution -\r\n            tileCoord[2] * tileSize[1])\r\n      );\r\n\r\n      const gutter = Math.round(\r\n        tilePixelRatio * source.getGutterForProjection(viewState.projection)\r\n      );\r\n\r\n      return this.getImageData(tile.getImage(), col + gutter, row + gutter);\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * @param {Object<number, Object<string, import(\"../../Tile.js\").default>>} tiles Lookup of loaded tiles by zoom level.\r\n   * @param {number} zoom Zoom level.\r\n   * @param {import(\"../../Tile.js\").default} tile Tile.\r\n   * @return {boolean|void} If `false`, the tile will not be considered loaded.\r\n   */\r\n  loadedTileCallback(tiles, zoom, tile) {\r\n    if (this.isDrawableTile(tile)) {\r\n      return super.loadedTileCallback(tiles, zoom, tile);\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Determine whether render should be called.\r\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\r\n   * @return {boolean} Layer is ready to be rendered.\r\n   */\r\n  prepareFrame(frameState) {\r\n    return !!this.getLayer().getSource();\r\n  }\r\n\r\n  /**\r\n   * Render the layer.\r\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\r\n   * @param {HTMLElement} target Target that may be used to render content to.\r\n   * @return {HTMLElement} The rendered element.\r\n   */\r\n  renderFrame(frameState, target) {\r\n    const layerState = frameState.layerStatesArray[frameState.layerIndex];\r\n    const viewState = frameState.viewState;\r\n    const projection = viewState.projection;\r\n    const viewResolution = viewState.resolution;\r\n    const viewCenter = viewState.center;\r\n    const rotation = viewState.rotation;\r\n    const pixelRatio = frameState.pixelRatio;\r\n\r\n    const tileLayer = this.getLayer();\r\n    const tileSource = tileLayer.getSource();\r\n    const sourceRevision = tileSource.getRevision();\r\n    const tileGrid = tileSource.getTileGridForProjection(projection);\r\n    const z = tileGrid.getZForResolution(viewResolution, tileSource.zDirection);\r\n    const tileResolution = tileGrid.getResolution(z);\r\n\r\n    let extent = frameState.extent;\r\n    const resolution = frameState.viewState.resolution;\r\n    const tilePixelRatio = tileSource.getTilePixelRatio(pixelRatio);\r\n    // desired dimensions of the canvas in pixels\r\n    const width = Math.round((getWidth(extent) / resolution) * pixelRatio);\r\n    const height = Math.round((getHeight(extent) / resolution) * pixelRatio);\r\n\r\n    const layerExtent =\r\n      layerState.extent && fromUserExtent(layerState.extent, projection);\r\n    if (layerExtent) {\r\n      extent = getIntersection(\r\n        extent,\r\n        fromUserExtent(layerState.extent, projection)\r\n      );\r\n    }\r\n\r\n    const dx = (tileResolution * width) / 2 / tilePixelRatio;\r\n    const dy = (tileResolution * height) / 2 / tilePixelRatio;\r\n    const canvasExtent = [\r\n      viewCenter[0] - dx,\r\n      viewCenter[1] - dy,\r\n      viewCenter[0] + dx,\r\n      viewCenter[1] + dy,\r\n    ];\r\n\r\n    const tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z);\r\n\r\n    /**\r\n     * @type {Object<number, Object<string, import(\"../../Tile.js\").default>>}\r\n     */\r\n    const tilesToDrawByZ = {};\r\n    tilesToDrawByZ[z] = {};\r\n\r\n    const findLoadedTiles = this.createLoadedTileFinder(\r\n      tileSource,\r\n      projection,\r\n      tilesToDrawByZ\r\n    );\r\n\r\n    const tmpExtent = this.tmpExtent;\r\n    const tmpTileRange = this.tmpTileRange_;\r\n    this.newTiles_ = false;\r\n    const viewport = rotation\r\n      ? getRotatedViewport(\r\n          viewState.center,\r\n          resolution,\r\n          rotation,\r\n          frameState.size\r\n        )\r\n      : undefined;\r\n    for (let x = tileRange.minX; x <= tileRange.maxX; ++x) {\r\n      for (let y = tileRange.minY; y <= tileRange.maxY; ++y) {\r\n        if (\r\n          rotation &&\r\n          !tileGrid.tileCoordIntersectsViewport([z, x, y], viewport)\r\n        ) {\r\n          continue;\r\n        }\r\n        const tile = this.getTile(z, x, y, frameState);\r\n        if (this.isDrawableTile(tile)) {\r\n          const uid = getUid(this);\r\n          if (tile.getState() == TileState.LOADED) {\r\n            tilesToDrawByZ[z][tile.tileCoord.toString()] = tile;\r\n            let inTransition = tile.inTransition(uid);\r\n            if (inTransition && layerState.opacity !== 1) {\r\n              // Skipping transition when layer is not fully opaque avoids visual artifacts.\r\n              tile.endTransition(uid);\r\n              inTransition = false;\r\n            }\r\n            if (\r\n              !this.newTiles_ &&\r\n              (inTransition || !this.renderedTiles.includes(tile))\r\n            ) {\r\n              this.newTiles_ = true;\r\n            }\r\n          }\r\n          if (tile.getAlpha(uid, frameState.time) === 1) {\r\n            // don't look for alt tiles if alpha is 1\r\n            continue;\r\n          }\r\n        }\r\n\r\n        const childTileRange = tileGrid.getTileCoordChildTileRange(\r\n          tile.tileCoord,\r\n          tmpTileRange,\r\n          tmpExtent\r\n        );\r\n\r\n        let covered = false;\r\n        if (childTileRange) {\r\n          covered = findLoadedTiles(z + 1, childTileRange);\r\n        }\r\n        if (!covered) {\r\n          tileGrid.forEachTileCoordParentTileRange(\r\n            tile.tileCoord,\r\n            findLoadedTiles,\r\n            tmpTileRange,\r\n            tmpExtent\r\n          );\r\n        }\r\n      }\r\n    }\r\n\r\n    const canvasScale =\r\n      ((tileResolution / viewResolution) * pixelRatio) / tilePixelRatio;\r\n\r\n    // set forward and inverse pixel transforms\r\n    composeTransform(\r\n      this.pixelTransform,\r\n      frameState.size[0] / 2,\r\n      frameState.size[1] / 2,\r\n      1 / pixelRatio,\r\n      1 / pixelRatio,\r\n      rotation,\r\n      -width / 2,\r\n      -height / 2\r\n    );\r\n\r\n    const canvasTransform = toTransformString(this.pixelTransform);\r\n\r\n    this.useContainer(target, canvasTransform, this.getBackground(frameState));\r\n    const context = this.context;\r\n    const canvas = context.canvas;\r\n\r\n    makeInverse(this.inversePixelTransform, this.pixelTransform);\r\n\r\n    // set scale transform for calculating tile positions on the canvas\r\n    composeTransform(\r\n      this.tempTransform,\r\n      width / 2,\r\n      height / 2,\r\n      canvasScale,\r\n      canvasScale,\r\n      0,\r\n      -width / 2,\r\n      -height / 2\r\n    );\r\n\r\n    if (canvas.width != width || canvas.height != height) {\r\n      canvas.width = width;\r\n      canvas.height = height;\r\n    } else if (!this.containerReused) {\r\n      context.clearRect(0, 0, width, height);\r\n    }\r\n\r\n    if (layerExtent) {\r\n      this.clipUnrotated(context, frameState, layerExtent);\r\n    }\r\n\r\n    if (!tileSource.getInterpolate()) {\r\n      context.imageSmoothingEnabled = false;\r\n    }\r\n\r\n    this.preRender(context, frameState);\r\n\r\n    this.renderedTiles.length = 0;\r\n    /** @type {Array<number>} */\r\n    let zs = Object.keys(tilesToDrawByZ).map(Number);\r\n    zs.sort(numberSafeCompareFunction);\r\n\r\n    let clips, clipZs, currentClip;\r\n    if (\r\n      layerState.opacity === 1 &&\r\n      (!this.containerReused ||\r\n        tileSource.getOpaque(frameState.viewState.projection))\r\n    ) {\r\n      zs = zs.reverse();\r\n    } else {\r\n      clips = [];\r\n      clipZs = [];\r\n    }\r\n    for (let i = zs.length - 1; i >= 0; --i) {\r\n      const currentZ = zs[i];\r\n      const currentTilePixelSize = tileSource.getTilePixelSize(\r\n        currentZ,\r\n        pixelRatio,\r\n        projection\r\n      );\r\n      const currentResolution = tileGrid.getResolution(currentZ);\r\n      const currentScale = currentResolution / tileResolution;\r\n      const dx = currentTilePixelSize[0] * currentScale * canvasScale;\r\n      const dy = currentTilePixelSize[1] * currentScale * canvasScale;\r\n      const originTileCoord = tileGrid.getTileCoordForCoordAndZ(\r\n        getTopLeft(canvasExtent),\r\n        currentZ\r\n      );\r\n      const originTileExtent = tileGrid.getTileCoordExtent(originTileCoord);\r\n      const origin = applyTransform(this.tempTransform, [\r\n        (tilePixelRatio * (originTileExtent[0] - canvasExtent[0])) /\r\n          tileResolution,\r\n        (tilePixelRatio * (canvasExtent[3] - originTileExtent[3])) /\r\n          tileResolution,\r\n      ]);\r\n      const tileGutter =\r\n        tilePixelRatio * tileSource.getGutterForProjection(projection);\r\n      const tilesToDraw = tilesToDrawByZ[currentZ];\r\n      for (const tileCoordKey in tilesToDraw) {\r\n        const tile = /** @type {import(\"../../ImageTile.js\").default} */ (\r\n          tilesToDraw[tileCoordKey]\r\n        );\r\n        const tileCoord = tile.tileCoord;\r\n\r\n        // Calculate integer positions and sizes so that tiles align\r\n        const xIndex = originTileCoord[1] - tileCoord[1];\r\n        const nextX = Math.round(origin[0] - (xIndex - 1) * dx);\r\n        const yIndex = originTileCoord[2] - tileCoord[2];\r\n        const nextY = Math.round(origin[1] - (yIndex - 1) * dy);\r\n        const x = Math.round(origin[0] - xIndex * dx);\r\n        const y = Math.round(origin[1] - yIndex * dy);\r\n        const w = nextX - x;\r\n        const h = nextY - y;\r\n        const transition = z === currentZ;\r\n\r\n        const inTransition =\r\n          transition && tile.getAlpha(getUid(this), frameState.time) !== 1;\r\n        let contextSaved = false;\r\n        if (!inTransition) {\r\n          if (clips) {\r\n            // Clip mask for regions in this tile that already filled by a higher z tile\r\n            currentClip = [x, y, x + w, y, x + w, y + h, x, y + h];\r\n            for (let i = 0, ii = clips.length; i < ii; ++i) {\r\n              if (z !== currentZ && currentZ < clipZs[i]) {\r\n                const clip = clips[i];\r\n                if (\r\n                  intersects(\r\n                    [x, y, x + w, y + h],\r\n                    [clip[0], clip[3], clip[4], clip[7]]\r\n                  )\r\n                ) {\r\n                  if (!contextSaved) {\r\n                    context.save();\r\n                    contextSaved = true;\r\n                  }\r\n                  context.beginPath();\r\n                  // counter-clockwise (outer ring) for current tile\r\n                  context.moveTo(currentClip[0], currentClip[1]);\r\n                  context.lineTo(currentClip[2], currentClip[3]);\r\n                  context.lineTo(currentClip[4], currentClip[5]);\r\n                  context.lineTo(currentClip[6], currentClip[7]);\r\n                  // clockwise (inner ring) for higher z tile\r\n                  context.moveTo(clip[6], clip[7]);\r\n                  context.lineTo(clip[4], clip[5]);\r\n                  context.lineTo(clip[2], clip[3]);\r\n                  context.lineTo(clip[0], clip[1]);\r\n                  context.clip();\r\n                }\r\n              }\r\n            }\r\n            clips.push(currentClip);\r\n            clipZs.push(currentZ);\r\n          } else {\r\n            context.clearRect(x, y, w, h);\r\n          }\r\n        }\r\n        this.drawTileImage(\r\n          tile,\r\n          frameState,\r\n          x,\r\n          y,\r\n          w,\r\n          h,\r\n          tileGutter,\r\n          transition\r\n        );\r\n        if (clips && !inTransition) {\r\n          if (contextSaved) {\r\n            context.restore();\r\n          }\r\n          this.renderedTiles.unshift(tile);\r\n        } else {\r\n          this.renderedTiles.push(tile);\r\n        }\r\n        this.updateUsedTiles(frameState.usedTiles, tileSource, tile);\r\n      }\r\n    }\r\n\r\n    this.renderedRevision = sourceRevision;\r\n    this.renderedResolution = tileResolution;\r\n    this.extentChanged =\r\n      !this.renderedExtent_ || !equals(this.renderedExtent_, canvasExtent);\r\n    this.renderedExtent_ = canvasExtent;\r\n    this.renderedPixelRatio = pixelRatio;\r\n    this.renderedProjection = projection;\r\n\r\n    this.manageTilePyramid(\r\n      frameState,\r\n      tileSource,\r\n      tileGrid,\r\n      pixelRatio,\r\n      projection,\r\n      extent,\r\n      z,\r\n      tileLayer.getPreload()\r\n    );\r\n    this.scheduleExpireCache(frameState, tileSource);\r\n\r\n    this.postRender(context, frameState);\r\n\r\n    if (layerState.extent) {\r\n      context.restore();\r\n    }\r\n    context.imageSmoothingEnabled = true;\r\n\r\n    if (canvasTransform !== canvas.style.transform) {\r\n      canvas.style.transform = canvasTransform;\r\n    }\r\n\r\n    return this.container;\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../../ImageTile.js\").default} tile Tile.\r\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\r\n   * @param {number} x Left of the tile.\r\n   * @param {number} y Top of the tile.\r\n   * @param {number} w Width of the tile.\r\n   * @param {number} h Height of the tile.\r\n   * @param {number} gutter Tile gutter.\r\n   * @param {boolean} transition Apply an alpha transition.\r\n   */\r\n  drawTileImage(tile, frameState, x, y, w, h, gutter, transition) {\r\n    const image = this.getTileImage(tile);\r\n    if (!image) {\r\n      return;\r\n    }\r\n    const uid = getUid(this);\r\n    const layerState = frameState.layerStatesArray[frameState.layerIndex];\r\n    const alpha =\r\n      layerState.opacity *\r\n      (transition ? tile.getAlpha(uid, frameState.time) : 1);\r\n    const alphaChanged = alpha !== this.context.globalAlpha;\r\n    if (alphaChanged) {\r\n      this.context.save();\r\n      this.context.globalAlpha = alpha;\r\n    }\r\n    this.context.drawImage(\r\n      image,\r\n      gutter,\r\n      gutter,\r\n      image.width - 2 * gutter,\r\n      image.height - 2 * gutter,\r\n      x,\r\n      y,\r\n      w,\r\n      h\r\n    );\r\n\r\n    if (alphaChanged) {\r\n      this.context.restore();\r\n    }\r\n    if (alpha !== layerState.opacity) {\r\n      frameState.animate = true;\r\n    } else if (transition) {\r\n      tile.endTransition(uid);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @return {HTMLCanvasElement} Image\r\n   */\r\n  getImage() {\r\n    const context = this.context;\r\n    return context ? context.canvas : null;\r\n  }\r\n\r\n  /**\r\n   * Get the image from a tile.\r\n   * @param {import(\"../../ImageTile.js\").default} tile Tile.\r\n   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.\r\n   * @protected\r\n   */\r\n  getTileImage(tile) {\r\n    return tile.getImage();\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\r\n   * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\r\n   * @protected\r\n   */\r\n  scheduleExpireCache(frameState, tileSource) {\r\n    if (tileSource.canExpireCache()) {\r\n      /**\r\n       * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\r\n       * @param {import(\"../../Map.js\").default} map Map.\r\n       * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\r\n       */\r\n      const postRenderFunction = function (tileSource, map, frameState) {\r\n        const tileSourceKey = getUid(tileSource);\r\n        if (tileSourceKey in frameState.usedTiles) {\r\n          tileSource.expireCache(\r\n            frameState.viewState.projection,\r\n            frameState.usedTiles[tileSourceKey]\r\n          );\r\n        }\r\n      }.bind(null, tileSource);\r\n\r\n      frameState.postRenderFunctions.push(\r\n        /** @type {import(\"../../Map.js\").PostRenderFunction} */ (\r\n          postRenderFunction\r\n        )\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {!Object<string, !Object<string, boolean>>} usedTiles Used tiles.\r\n   * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\r\n   * @param {import('../../Tile.js').default} tile Tile.\r\n   * @protected\r\n   */\r\n  updateUsedTiles(usedTiles, tileSource, tile) {\r\n    // FIXME should we use tilesToDrawByZ instead?\r\n    const tileSourceKey = getUid(tileSource);\r\n    if (!(tileSourceKey in usedTiles)) {\r\n      usedTiles[tileSourceKey] = {};\r\n    }\r\n    usedTiles[tileSourceKey][tile.getKey()] = true;\r\n  }\r\n\r\n  /**\r\n   * Manage tile pyramid.\r\n   * This function performs a number of functions related to the tiles at the\r\n   * current zoom and lower zoom levels:\r\n   * - registers idle tiles in frameState.wantedTiles so that they are not\r\n   *   discarded by the tile queue\r\n   * - enqueues missing tiles\r\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\r\n   * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\r\n   * @param {import(\"../../tilegrid/TileGrid.js\").default} tileGrid Tile grid.\r\n   * @param {number} pixelRatio Pixel ratio.\r\n   * @param {import(\"../../proj/Projection.js\").default} projection Projection.\r\n   * @param {import(\"../../extent.js\").Extent} extent Extent.\r\n   * @param {number} currentZ Current Z.\r\n   * @param {number} preload Load low resolution tiles up to `preload` levels.\r\n   * @param {function(import(\"../../Tile.js\").default):void} [tileCallback] Tile callback.\r\n   * @protected\r\n   */\r\n  manageTilePyramid(\r\n    frameState,\r\n    tileSource,\r\n    tileGrid,\r\n    pixelRatio,\r\n    projection,\r\n    extent,\r\n    currentZ,\r\n    preload,\r\n    tileCallback\r\n  ) {\r\n    const tileSourceKey = getUid(tileSource);\r\n    if (!(tileSourceKey in frameState.wantedTiles)) {\r\n      frameState.wantedTiles[tileSourceKey] = {};\r\n    }\r\n    const wantedTiles = frameState.wantedTiles[tileSourceKey];\r\n    const tileQueue = frameState.tileQueue;\r\n    const minZoom = tileGrid.getMinZoom();\r\n    const rotation = frameState.viewState.rotation;\r\n    const viewport = rotation\r\n      ? getRotatedViewport(\r\n          frameState.viewState.center,\r\n          frameState.viewState.resolution,\r\n          rotation,\r\n          frameState.size\r\n        )\r\n      : undefined;\r\n    let tileCount = 0;\r\n    let tile, tileRange, tileResolution, x, y, z;\r\n    for (z = minZoom; z <= currentZ; ++z) {\r\n      tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z, tileRange);\r\n      tileResolution = tileGrid.getResolution(z);\r\n      for (x = tileRange.minX; x <= tileRange.maxX; ++x) {\r\n        for (y = tileRange.minY; y <= tileRange.maxY; ++y) {\r\n          if (\r\n            rotation &&\r\n            !tileGrid.tileCoordIntersectsViewport([z, x, y], viewport)\r\n          ) {\r\n            continue;\r\n          }\r\n          if (currentZ - z <= preload) {\r\n            ++tileCount;\r\n            tile = tileSource.getTile(z, x, y, pixelRatio, projection);\r\n            if (tile.getState() == TileState.IDLE) {\r\n              wantedTiles[tile.getKey()] = true;\r\n              if (!tileQueue.isKeyQueued(tile.getKey())) {\r\n                tileQueue.enqueue([\r\n                  tile,\r\n                  tileSourceKey,\r\n                  tileGrid.getTileCoordCenter(tile.tileCoord),\r\n                  tileResolution,\r\n                ]);\r\n              }\r\n            }\r\n            if (tileCallback !== undefined) {\r\n              tileCallback(tile);\r\n            }\r\n          } else {\r\n            tileSource.useTile(z, x, y, projection);\r\n          }\r\n        }\r\n      }\r\n    }\r\n    tileSource.updateCacheSize(tileCount, projection);\r\n  }\r\n}\r\n\r\nexport default CanvasTileLayerRenderer;\r\n", "/**\r\n * @module ol/layer/Tile\r\n */\r\nimport BaseTileLayer from './BaseTile.js';\r\nimport CanvasTileLayerRenderer from '../renderer/canvas/TileLayer.js';\r\n\r\n/**\r\n * @classdesc\r\n * For layer sources that provide pre-rendered, tiled images in grids that are\r\n * organized by zoom levels for specific resolutions.\r\n * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}\r\n * property on the layer object; for example, setting `title: 'My Title'` in the\r\n * options means that `title` is observable, and has get/set accessors.\r\n *\r\n * @template {import(\"../source/Tile.js\").default} TileSourceType\r\n * @extends BaseTileLayer<TileSourceType, CanvasTileLayerRenderer>\r\n * @api\r\n */\r\nclass TileLayer extends BaseTileLayer {\r\n  /**\r\n   * @param {import(\"./BaseTile.js\").Options<TileSourceType>} [options] Tile layer options.\r\n   */\r\n  constructor(options) {\r\n    super(options);\r\n  }\r\n\r\n  createRenderer() {\r\n    return new CanvasTileLayerRenderer(this);\r\n  }\r\n}\r\n\r\nexport default TileLayer;\r\n", "/**\r\n * @module ol/ImageCanvas\r\n */\r\nimport ImageBase from './ImageBase.js';\r\nimport ImageState from './ImageState.js';\r\n\r\n/**\r\n * A function that is called to trigger asynchronous canvas drawing.  It is\r\n * called with a \"done\" callback that should be called when drawing is done.\r\n * If any error occurs during drawing, the \"done\" callback should be called with\r\n * that error.\r\n *\r\n * @typedef {function(function(Error=): void): void} Loader\r\n */\r\n\r\nclass ImageCanvas extends ImageBase {\r\n  /**\r\n   * @param {import(\"./extent.js\").Extent} extent Extent.\r\n   * @param {number} resolution Resolution.\r\n   * @param {number} pixelRatio Pixel ratio.\r\n   * @param {HTMLCanvasElement} canvas Canvas.\r\n   * @param {Loader} [loader] Optional loader function to\r\n   *     support asynchronous canvas drawing.\r\n   */\r\n  constructor(extent, resolution, pixelRatio, canvas, loader) {\r\n    const state = loader !== undefined ? ImageState.IDLE : ImageState.LOADED;\r\n\r\n    super(extent, resolution, pixelRatio, state);\r\n\r\n    /**\r\n     * Optional canvas loader function.\r\n     * @type {?Loader}\r\n     * @private\r\n     */\r\n    this.loader_ = loader !== undefined ? loader : null;\r\n\r\n    /**\r\n     * @private\r\n     * @type {HTMLCanvasElement}\r\n     */\r\n    this.canvas_ = canvas;\r\n\r\n    /**\r\n     * @private\r\n     * @type {?Error}\r\n     */\r\n    this.error_ = null;\r\n  }\r\n\r\n  /**\r\n   * Get any error associated with asynchronous rendering.\r\n   * @return {?Error} Any error that occurred during rendering.\r\n   */\r\n  getError() {\r\n    return this.error_;\r\n  }\r\n\r\n  /**\r\n   * Handle async drawing complete.\r\n   * @param {Error} [err] Any error during drawing.\r\n   * @private\r\n   */\r\n  handleLoad_(err) {\r\n    if (err) {\r\n      this.error_ = err;\r\n      this.state = ImageState.ERROR;\r\n    } else {\r\n      this.state = ImageState.LOADED;\r\n    }\r\n    this.changed();\r\n  }\r\n\r\n  /**\r\n   * Load not yet loaded URI.\r\n   */\r\n  load() {\r\n    if (this.state == ImageState.IDLE) {\r\n      this.state = ImageState.LOADING;\r\n      this.changed();\r\n      this.loader_(this.handleLoad_.bind(this));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @return {HTMLCanvasElement} Canvas element.\r\n   */\r\n  getImage() {\r\n    return this.canvas_;\r\n  }\r\n}\r\n\r\nexport default ImageCanvas;\r\n", "/**\r\n * @module ol/DataTile\r\n */\r\nimport Tile from './Tile.js';\r\nimport TileState from './TileState.js';\r\n\r\n/**\r\n * Data that can be used with a DataTile.  For increased browser compatibility, use\r\n * Uint8Array instead of Uint8ClampedArray where possible.\r\n * @typedef {Uint8Array|Uint8ClampedArray|Float32Array|DataView} Data\r\n */\r\n\r\n/**\r\n * @typedef {Object} Options\r\n * @property {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\r\n * @property {function(): Promise<Data>} loader Data loader.\r\n * @property {number} [transition=250] A duration for tile opacity\r\n * transitions in milliseconds. A duration of 0 disables the opacity transition.\r\n * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,\r\n * the nearest neighbor is used when resampling.\r\n * @property {import('./size.js').Size} [size=[256, 256]] Tile size.\r\n * @api\r\n */\r\n\r\nclass DataTile extends Tile {\r\n  /**\r\n   * @param {Options} options Tile options.\r\n   */\r\n  constructor(options) {\r\n    const state = TileState.IDLE;\r\n\r\n    super(options.tileCoord, state, {\r\n      transition: options.transition,\r\n      interpolate: options.interpolate,\r\n    });\r\n\r\n    /**\r\n     * @type {function(): Promise<Data>}\r\n     * @private\r\n     */\r\n    this.loader_ = options.loader;\r\n\r\n    /**\r\n     * @type {Data}\r\n     * @private\r\n     */\r\n    this.data_ = null;\r\n\r\n    /**\r\n     * @type {Error}\r\n     * @private\r\n     */\r\n    this.error_ = null;\r\n\r\n    /**\r\n     * @type {import('./size.js').Size}\r\n     * @private\r\n     */\r\n    this.size_ = options.size || [256, 256];\r\n  }\r\n\r\n  /**\r\n   * Get the tile size.\r\n   * @return {import('./size.js').Size} Tile size.\r\n   */\r\n  getSize() {\r\n    return this.size_;\r\n  }\r\n\r\n  /**\r\n   * Get the data for the tile.\r\n   * @return {Data} Tile data.\r\n   * @api\r\n   */\r\n  getData() {\r\n    return this.data_;\r\n  }\r\n\r\n  /**\r\n   * Get any loading error.\r\n   * @return {Error} Loading error.\r\n   * @api\r\n   */\r\n  getError() {\r\n    return this.error_;\r\n  }\r\n\r\n  /**\r\n   * Load not yet loaded URI.\r\n   * @api\r\n   */\r\n  load() {\r\n    if (this.state !== TileState.IDLE && this.state !== TileState.ERROR) {\r\n      return;\r\n    }\r\n    this.state = TileState.LOADING;\r\n    this.changed();\r\n\r\n    const self = this;\r\n    this.loader_()\r\n      .then(function (data) {\r\n        self.data_ = data;\r\n        self.state = TileState.LOADED;\r\n        self.changed();\r\n      })\r\n      .catch(function (error) {\r\n        self.error_ = error;\r\n        self.state = TileState.ERROR;\r\n        self.changed();\r\n      });\r\n  }\r\n}\r\n\r\nexport default DataTile;\r\n"],
  "mappings": "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",
  "names": ["Layer_default", "isEmpty", "VectorTile", "VectorTile_default", "Layer_default", "Tile_default", "dx", "dy", "i", "tileSource", "frameState", "Tile_default"]
}
