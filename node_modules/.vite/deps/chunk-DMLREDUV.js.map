{
  "version": 3,
  "sources": ["../../ol/sphere.js"],
  "sourcesContent": ["/**\r\n * @module ol/sphere\r\n */\r\nimport {toDegrees, toRadians} from './math.js';\r\n\r\n/**\r\n * Object literal with options for the {@link getLength} or {@link getArea}\r\n * functions.\r\n * @typedef {Object} SphereMetricOptions\r\n * @property {import(\"./proj.js\").ProjectionLike} [projection='EPSG:3857']\r\n * Projection of the  geometry.  By default, the geometry is assumed to be in\r\n * Web Mercator.\r\n * @property {number} [radius=6371008.8] Sphere radius.  By default, the\r\n * [mean Earth radius](https://en.wikipedia.org/wiki/Earth_radius#Mean_radius)\r\n * for the WGS84 ellipsoid is used.\r\n */\r\n\r\n/**\r\n * The mean Earth radius (1/3 * (2a + b)) for the WGS84 ellipsoid.\r\n * https://en.wikipedia.org/wiki/Earth_radius#Mean_radius\r\n * @type {number}\r\n */\r\nexport const DEFAULT_RADIUS = 6371008.8;\r\n\r\n/**\r\n * Get the great circle distance (in meters) between two geographic coordinates.\r\n * @param {Array} c1 Starting coordinate.\r\n * @param {Array} c2 Ending coordinate.\r\n * @param {number} [radius] The sphere radius to use.  Defaults to the Earth's\r\n *     mean radius using the WGS84 ellipsoid.\r\n * @return {number} The great circle distance between the points (in meters).\r\n * @api\r\n */\r\nexport function getDistance(c1, c2, radius) {\r\n  radius = radius || DEFAULT_RADIUS;\r\n  const lat1 = toRadians(c1[1]);\r\n  const lat2 = toRadians(c2[1]);\r\n  const deltaLatBy2 = (lat2 - lat1) / 2;\r\n  const deltaLonBy2 = toRadians(c2[0] - c1[0]) / 2;\r\n  const a =\r\n    Math.sin(deltaLatBy2) * Math.sin(deltaLatBy2) +\r\n    Math.sin(deltaLonBy2) *\r\n      Math.sin(deltaLonBy2) *\r\n      Math.cos(lat1) *\r\n      Math.cos(lat2);\r\n  return 2 * radius * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\r\n}\r\n\r\n/**\r\n * Get the cumulative great circle length of linestring coordinates (geographic).\r\n * @param {Array} coordinates Linestring coordinates.\r\n * @param {number} radius The sphere radius to use.\r\n * @return {number} The length (in meters).\r\n */\r\nfunction getLengthInternal(coordinates, radius) {\r\n  let length = 0;\r\n  for (let i = 0, ii = coordinates.length; i < ii - 1; ++i) {\r\n    length += getDistance(coordinates[i], coordinates[i + 1], radius);\r\n  }\r\n  return length;\r\n}\r\n\r\n/**\r\n * Get the spherical length of a geometry.  This length is the sum of the\r\n * great circle distances between coordinates.  For polygons, the length is\r\n * the sum of all rings.  For points, the length is zero.  For multi-part\r\n * geometries, the length is the sum of the length of each part.\r\n * @param {import(\"./geom/Geometry.js\").default} geometry A geometry.\r\n * @param {SphereMetricOptions} [options] Options for the\r\n * length calculation.  By default, geometries are assumed to be in 'EPSG:3857'.\r\n * You can change this by providing a `projection` option.\r\n * @return {number} The spherical length (in meters).\r\n * @api\r\n */\r\nexport function getLength(geometry, options) {\r\n  options = options || {};\r\n  const radius = options.radius || DEFAULT_RADIUS;\r\n  const projection = options.projection || 'EPSG:3857';\r\n  const type = geometry.getType();\r\n  if (type !== 'GeometryCollection') {\r\n    geometry = geometry.clone().transform(projection, 'EPSG:4326');\r\n  }\r\n  let length = 0;\r\n  let coordinates, coords, i, ii, j, jj;\r\n  switch (type) {\r\n    case 'Point':\r\n    case 'MultiPoint': {\r\n      break;\r\n    }\r\n    case 'LineString':\r\n    case 'LinearRing': {\r\n      coordinates = /** @type {import(\"./geom/SimpleGeometry.js\").default} */ (\r\n        geometry\r\n      ).getCoordinates();\r\n      length = getLengthInternal(coordinates, radius);\r\n      break;\r\n    }\r\n    case 'MultiLineString':\r\n    case 'Polygon': {\r\n      coordinates = /** @type {import(\"./geom/SimpleGeometry.js\").default} */ (\r\n        geometry\r\n      ).getCoordinates();\r\n      for (i = 0, ii = coordinates.length; i < ii; ++i) {\r\n        length += getLengthInternal(coordinates[i], radius);\r\n      }\r\n      break;\r\n    }\r\n    case 'MultiPolygon': {\r\n      coordinates = /** @type {import(\"./geom/SimpleGeometry.js\").default} */ (\r\n        geometry\r\n      ).getCoordinates();\r\n      for (i = 0, ii = coordinates.length; i < ii; ++i) {\r\n        coords = coordinates[i];\r\n        for (j = 0, jj = coords.length; j < jj; ++j) {\r\n          length += getLengthInternal(coords[j], radius);\r\n        }\r\n      }\r\n      break;\r\n    }\r\n    case 'GeometryCollection': {\r\n      const geometries =\r\n        /** @type {import(\"./geom/GeometryCollection.js\").default} */ (\r\n          geometry\r\n        ).getGeometries();\r\n      for (i = 0, ii = geometries.length; i < ii; ++i) {\r\n        length += getLength(geometries[i], options);\r\n      }\r\n      break;\r\n    }\r\n    default: {\r\n      throw new Error('Unsupported geometry type: ' + type);\r\n    }\r\n  }\r\n  return length;\r\n}\r\n\r\n/**\r\n * Returns the spherical area for a list of coordinates.\r\n *\r\n * [Reference](https://trs.jpl.nasa.gov/handle/2014/40409)\r\n * Robert. G. Chamberlain and William H. Duquette, \"Some Algorithms for\r\n * Polygons on a Sphere\", JPL Publication 07-03, Jet Propulsion\r\n * Laboratory, Pasadena, CA, June 2007\r\n *\r\n * @param {Array<import(\"./coordinate.js\").Coordinate>} coordinates List of coordinates of a linear\r\n * ring. If the ring is oriented clockwise, the area will be positive,\r\n * otherwise it will be negative.\r\n * @param {number} radius The sphere radius.\r\n * @return {number} Area (in square meters).\r\n */\r\nfunction getAreaInternal(coordinates, radius) {\r\n  let area = 0;\r\n  const len = coordinates.length;\r\n  let x1 = coordinates[len - 1][0];\r\n  let y1 = coordinates[len - 1][1];\r\n  for (let i = 0; i < len; i++) {\r\n    const x2 = coordinates[i][0];\r\n    const y2 = coordinates[i][1];\r\n    area +=\r\n      toRadians(x2 - x1) *\r\n      (2 + Math.sin(toRadians(y1)) + Math.sin(toRadians(y2)));\r\n    x1 = x2;\r\n    y1 = y2;\r\n  }\r\n  return (area * radius * radius) / 2.0;\r\n}\r\n\r\n/**\r\n * Get the spherical area of a geometry.  This is the area (in meters) assuming\r\n * that polygon edges are segments of great circles on a sphere.\r\n * @param {import(\"./geom/Geometry.js\").default} geometry A geometry.\r\n * @param {SphereMetricOptions} [options] Options for the area\r\n *     calculation.  By default, geometries are assumed to be in 'EPSG:3857'.\r\n *     You can change this by providing a `projection` option.\r\n * @return {number} The spherical area (in square meters).\r\n * @api\r\n */\r\nexport function getArea(geometry, options) {\r\n  options = options || {};\r\n  const radius = options.radius || DEFAULT_RADIUS;\r\n  const projection = options.projection || 'EPSG:3857';\r\n  const type = geometry.getType();\r\n  if (type !== 'GeometryCollection') {\r\n    geometry = geometry.clone().transform(projection, 'EPSG:4326');\r\n  }\r\n  let area = 0;\r\n  let coordinates, coords, i, ii, j, jj;\r\n  switch (type) {\r\n    case 'Point':\r\n    case 'MultiPoint':\r\n    case 'LineString':\r\n    case 'MultiLineString':\r\n    case 'LinearRing': {\r\n      break;\r\n    }\r\n    case 'Polygon': {\r\n      coordinates = /** @type {import(\"./geom/Polygon.js\").default} */ (\r\n        geometry\r\n      ).getCoordinates();\r\n      area = Math.abs(getAreaInternal(coordinates[0], radius));\r\n      for (i = 1, ii = coordinates.length; i < ii; ++i) {\r\n        area -= Math.abs(getAreaInternal(coordinates[i], radius));\r\n      }\r\n      break;\r\n    }\r\n    case 'MultiPolygon': {\r\n      coordinates = /** @type {import(\"./geom/SimpleGeometry.js\").default} */ (\r\n        geometry\r\n      ).getCoordinates();\r\n      for (i = 0, ii = coordinates.length; i < ii; ++i) {\r\n        coords = coordinates[i];\r\n        area += Math.abs(getAreaInternal(coords[0], radius));\r\n        for (j = 1, jj = coords.length; j < jj; ++j) {\r\n          area -= Math.abs(getAreaInternal(coords[j], radius));\r\n        }\r\n      }\r\n      break;\r\n    }\r\n    case 'GeometryCollection': {\r\n      const geometries =\r\n        /** @type {import(\"./geom/GeometryCollection.js\").default} */ (\r\n          geometry\r\n        ).getGeometries();\r\n      for (i = 0, ii = geometries.length; i < ii; ++i) {\r\n        area += getArea(geometries[i], options);\r\n      }\r\n      break;\r\n    }\r\n    default: {\r\n      throw new Error('Unsupported geometry type: ' + type);\r\n    }\r\n  }\r\n  return area;\r\n}\r\n\r\n/**\r\n * Returns the coordinate at the given distance and bearing from `c1`.\r\n *\r\n * @param {import(\"./coordinate.js\").Coordinate} c1 The origin point (`[lon, lat]` in degrees).\r\n * @param {number} distance The great-circle distance between the origin\r\n *     point and the target point.\r\n * @param {number} bearing The bearing (in radians).\r\n * @param {number} [radius] The sphere radius to use.  Defaults to the Earth's\r\n *     mean radius using the WGS84 ellipsoid.\r\n * @return {import(\"./coordinate.js\").Coordinate} The target point.\r\n */\r\nexport function offset(c1, distance, bearing, radius) {\r\n  radius = radius || DEFAULT_RADIUS;\r\n  const lat1 = toRadians(c1[1]);\r\n  const lon1 = toRadians(c1[0]);\r\n  const dByR = distance / radius;\r\n  const lat = Math.asin(\r\n    Math.sin(lat1) * Math.cos(dByR) +\r\n      Math.cos(lat1) * Math.sin(dByR) * Math.cos(bearing)\r\n  );\r\n  const lon =\r\n    lon1 +\r\n    Math.atan2(\r\n      Math.sin(bearing) * Math.sin(dByR) * Math.cos(lat1),\r\n      Math.cos(dByR) - Math.sin(lat1) * Math.sin(lat)\r\n    );\r\n  return [toDegrees(lon), toDegrees(lat)];\r\n}\r\n"],
  "mappings": "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",
  "names": []
}
