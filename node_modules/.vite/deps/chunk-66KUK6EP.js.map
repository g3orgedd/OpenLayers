{
  "version": 3,
  "sources": ["../../ol/geom/flat/closest.js", "../../ol/geom/flat/simplify.js", "../../ol/geom/flat/inflate.js"],
  "sourcesContent": ["/**\r\n * @module ol/geom/flat/closest\r\n */\r\nimport {lerp, squaredDistance as squaredDx} from '../../math.js';\r\n\r\n/**\r\n * Returns the point on the 2D line segment flatCoordinates[offset1] to\r\n * flatCoordinates[offset2] that is closest to the point (x, y).  Extra\r\n * dimensions are linearly interpolated.\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset1 Offset 1.\r\n * @param {number} offset2 Offset 2.\r\n * @param {number} stride Stride.\r\n * @param {number} x X.\r\n * @param {number} y Y.\r\n * @param {Array<number>} closestPoint Closest point.\r\n */\r\nfunction assignClosest(\r\n  flatCoordinates,\r\n  offset1,\r\n  offset2,\r\n  stride,\r\n  x,\r\n  y,\r\n  closestPoint\r\n) {\r\n  const x1 = flatCoordinates[offset1];\r\n  const y1 = flatCoordinates[offset1 + 1];\r\n  const dx = flatCoordinates[offset2] - x1;\r\n  const dy = flatCoordinates[offset2 + 1] - y1;\r\n  let offset;\r\n  if (dx === 0 && dy === 0) {\r\n    offset = offset1;\r\n  } else {\r\n    const t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);\r\n    if (t > 1) {\r\n      offset = offset2;\r\n    } else if (t > 0) {\r\n      for (let i = 0; i < stride; ++i) {\r\n        closestPoint[i] = lerp(\r\n          flatCoordinates[offset1 + i],\r\n          flatCoordinates[offset2 + i],\r\n          t\r\n        );\r\n      }\r\n      closestPoint.length = stride;\r\n      return;\r\n    } else {\r\n      offset = offset1;\r\n    }\r\n  }\r\n  for (let i = 0; i < stride; ++i) {\r\n    closestPoint[i] = flatCoordinates[offset + i];\r\n  }\r\n  closestPoint.length = stride;\r\n}\r\n\r\n/**\r\n * Return the squared of the largest distance between any pair of consecutive\r\n * coordinates.\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {number} end End.\r\n * @param {number} stride Stride.\r\n * @param {number} max Max squared delta.\r\n * @return {number} Max squared delta.\r\n */\r\nexport function maxSquaredDelta(flatCoordinates, offset, end, stride, max) {\r\n  let x1 = flatCoordinates[offset];\r\n  let y1 = flatCoordinates[offset + 1];\r\n  for (offset += stride; offset < end; offset += stride) {\r\n    const x2 = flatCoordinates[offset];\r\n    const y2 = flatCoordinates[offset + 1];\r\n    const squaredDelta = squaredDx(x1, y1, x2, y2);\r\n    if (squaredDelta > max) {\r\n      max = squaredDelta;\r\n    }\r\n    x1 = x2;\r\n    y1 = y2;\r\n  }\r\n  return max;\r\n}\r\n\r\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {Array<number>} ends Ends.\r\n * @param {number} stride Stride.\r\n * @param {number} max Max squared delta.\r\n * @return {number} Max squared delta.\r\n */\r\nexport function arrayMaxSquaredDelta(\r\n  flatCoordinates,\r\n  offset,\r\n  ends,\r\n  stride,\r\n  max\r\n) {\r\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\r\n    const end = ends[i];\r\n    max = maxSquaredDelta(flatCoordinates, offset, end, stride, max);\r\n    offset = end;\r\n  }\r\n  return max;\r\n}\r\n\r\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {Array<Array<number>>} endss Endss.\r\n * @param {number} stride Stride.\r\n * @param {number} max Max squared delta.\r\n * @return {number} Max squared delta.\r\n */\r\nexport function multiArrayMaxSquaredDelta(\r\n  flatCoordinates,\r\n  offset,\r\n  endss,\r\n  stride,\r\n  max\r\n) {\r\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\r\n    const ends = endss[i];\r\n    max = arrayMaxSquaredDelta(flatCoordinates, offset, ends, stride, max);\r\n    offset = ends[ends.length - 1];\r\n  }\r\n  return max;\r\n}\r\n\r\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {number} end End.\r\n * @param {number} stride Stride.\r\n * @param {number} maxDelta Max delta.\r\n * @param {boolean} isRing Is ring.\r\n * @param {number} x X.\r\n * @param {number} y Y.\r\n * @param {Array<number>} closestPoint Closest point.\r\n * @param {number} minSquaredDistance Minimum squared distance.\r\n * @param {Array<number>} [tmpPoint] Temporary point object.\r\n * @return {number} Minimum squared distance.\r\n */\r\nexport function assignClosestPoint(\r\n  flatCoordinates,\r\n  offset,\r\n  end,\r\n  stride,\r\n  maxDelta,\r\n  isRing,\r\n  x,\r\n  y,\r\n  closestPoint,\r\n  minSquaredDistance,\r\n  tmpPoint\r\n) {\r\n  if (offset == end) {\r\n    return minSquaredDistance;\r\n  }\r\n  let i, squaredDistance;\r\n  if (maxDelta === 0) {\r\n    // All points are identical, so just test the first point.\r\n    squaredDistance = squaredDx(\r\n      x,\r\n      y,\r\n      flatCoordinates[offset],\r\n      flatCoordinates[offset + 1]\r\n    );\r\n    if (squaredDistance < minSquaredDistance) {\r\n      for (i = 0; i < stride; ++i) {\r\n        closestPoint[i] = flatCoordinates[offset + i];\r\n      }\r\n      closestPoint.length = stride;\r\n      return squaredDistance;\r\n    } else {\r\n      return minSquaredDistance;\r\n    }\r\n  }\r\n  tmpPoint = tmpPoint ? tmpPoint : [NaN, NaN];\r\n  let index = offset + stride;\r\n  while (index < end) {\r\n    assignClosest(\r\n      flatCoordinates,\r\n      index - stride,\r\n      index,\r\n      stride,\r\n      x,\r\n      y,\r\n      tmpPoint\r\n    );\r\n    squaredDistance = squaredDx(x, y, tmpPoint[0], tmpPoint[1]);\r\n    if (squaredDistance < minSquaredDistance) {\r\n      minSquaredDistance = squaredDistance;\r\n      for (i = 0; i < stride; ++i) {\r\n        closestPoint[i] = tmpPoint[i];\r\n      }\r\n      closestPoint.length = stride;\r\n      index += stride;\r\n    } else {\r\n      // Skip ahead multiple points, because we know that all the skipped\r\n      // points cannot be any closer than the closest point we have found so\r\n      // far.  We know this because we know how close the current point is, how\r\n      // close the closest point we have found so far is, and the maximum\r\n      // distance between consecutive points.  For example, if we're currently\r\n      // at distance 10, the best we've found so far is 3, and that the maximum\r\n      // distance between consecutive points is 2, then we'll need to skip at\r\n      // least (10 - 3) / 2 == 3 (rounded down) points to have any chance of\r\n      // finding a closer point.  We use Math.max(..., 1) to ensure that we\r\n      // always advance at least one point, to avoid an infinite loop.\r\n      index +=\r\n        stride *\r\n        Math.max(\r\n          ((Math.sqrt(squaredDistance) - Math.sqrt(minSquaredDistance)) /\r\n            maxDelta) |\r\n            0,\r\n          1\r\n        );\r\n    }\r\n  }\r\n  if (isRing) {\r\n    // Check the closing segment.\r\n    assignClosest(\r\n      flatCoordinates,\r\n      end - stride,\r\n      offset,\r\n      stride,\r\n      x,\r\n      y,\r\n      tmpPoint\r\n    );\r\n    squaredDistance = squaredDx(x, y, tmpPoint[0], tmpPoint[1]);\r\n    if (squaredDistance < minSquaredDistance) {\r\n      minSquaredDistance = squaredDistance;\r\n      for (i = 0; i < stride; ++i) {\r\n        closestPoint[i] = tmpPoint[i];\r\n      }\r\n      closestPoint.length = stride;\r\n    }\r\n  }\r\n  return minSquaredDistance;\r\n}\r\n\r\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {Array<number>} ends Ends.\r\n * @param {number} stride Stride.\r\n * @param {number} maxDelta Max delta.\r\n * @param {boolean} isRing Is ring.\r\n * @param {number} x X.\r\n * @param {number} y Y.\r\n * @param {Array<number>} closestPoint Closest point.\r\n * @param {number} minSquaredDistance Minimum squared distance.\r\n * @param {Array<number>} [tmpPoint] Temporary point object.\r\n * @return {number} Minimum squared distance.\r\n */\r\nexport function assignClosestArrayPoint(\r\n  flatCoordinates,\r\n  offset,\r\n  ends,\r\n  stride,\r\n  maxDelta,\r\n  isRing,\r\n  x,\r\n  y,\r\n  closestPoint,\r\n  minSquaredDistance,\r\n  tmpPoint\r\n) {\r\n  tmpPoint = tmpPoint ? tmpPoint : [NaN, NaN];\r\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\r\n    const end = ends[i];\r\n    minSquaredDistance = assignClosestPoint(\r\n      flatCoordinates,\r\n      offset,\r\n      end,\r\n      stride,\r\n      maxDelta,\r\n      isRing,\r\n      x,\r\n      y,\r\n      closestPoint,\r\n      minSquaredDistance,\r\n      tmpPoint\r\n    );\r\n    offset = end;\r\n  }\r\n  return minSquaredDistance;\r\n}\r\n\r\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {Array<Array<number>>} endss Endss.\r\n * @param {number} stride Stride.\r\n * @param {number} maxDelta Max delta.\r\n * @param {boolean} isRing Is ring.\r\n * @param {number} x X.\r\n * @param {number} y Y.\r\n * @param {Array<number>} closestPoint Closest point.\r\n * @param {number} minSquaredDistance Minimum squared distance.\r\n * @param {Array<number>} [tmpPoint] Temporary point object.\r\n * @return {number} Minimum squared distance.\r\n */\r\nexport function assignClosestMultiArrayPoint(\r\n  flatCoordinates,\r\n  offset,\r\n  endss,\r\n  stride,\r\n  maxDelta,\r\n  isRing,\r\n  x,\r\n  y,\r\n  closestPoint,\r\n  minSquaredDistance,\r\n  tmpPoint\r\n) {\r\n  tmpPoint = tmpPoint ? tmpPoint : [NaN, NaN];\r\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\r\n    const ends = endss[i];\r\n    minSquaredDistance = assignClosestArrayPoint(\r\n      flatCoordinates,\r\n      offset,\r\n      ends,\r\n      stride,\r\n      maxDelta,\r\n      isRing,\r\n      x,\r\n      y,\r\n      closestPoint,\r\n      minSquaredDistance,\r\n      tmpPoint\r\n    );\r\n    offset = ends[ends.length - 1];\r\n  }\r\n  return minSquaredDistance;\r\n}\r\n", "/**\r\n * @module ol/geom/flat/simplify\r\n */\r\n// Based on simplify-js https://github.com/mourner/simplify-js\r\n// Copyright (c) 2012, Vladimir Agafonkin\r\n// All rights reserved.\r\n//\r\n// Redistribution and use in source and binary forms, with or without\r\n// modification, are permitted provided that the following conditions are met:\r\n//\r\n//    1. Redistributions of source code must retain the above copyright notice,\r\n//       this list of conditions and the following disclaimer.\r\n//\r\n//    2. Redistributions in binary form must reproduce the above copyright\r\n//       notice, this list of conditions and the following disclaimer in the\r\n//       documentation and/or other materials provided with the distribution.\r\n//\r\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\r\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\r\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\r\n// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\r\n// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\r\n// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\r\n// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\r\n// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\r\n// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n// POSSIBILITY OF SUCH DAMAGE.\r\n\r\nimport {squaredDistance, squaredSegmentDistance} from '../../math.js';\r\n\r\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {number} end End.\r\n * @param {number} stride Stride.\r\n * @param {number} squaredTolerance Squared tolerance.\r\n * @param {boolean} highQuality Highest quality.\r\n * @param {Array<number>} [simplifiedFlatCoordinates] Simplified flat\r\n *     coordinates.\r\n * @return {Array<number>} Simplified line string.\r\n */\r\nexport function simplifyLineString(\r\n  flatCoordinates,\r\n  offset,\r\n  end,\r\n  stride,\r\n  squaredTolerance,\r\n  highQuality,\r\n  simplifiedFlatCoordinates\r\n) {\r\n  simplifiedFlatCoordinates =\r\n    simplifiedFlatCoordinates !== undefined ? simplifiedFlatCoordinates : [];\r\n  if (!highQuality) {\r\n    end = radialDistance(\r\n      flatCoordinates,\r\n      offset,\r\n      end,\r\n      stride,\r\n      squaredTolerance,\r\n      simplifiedFlatCoordinates,\r\n      0\r\n    );\r\n    flatCoordinates = simplifiedFlatCoordinates;\r\n    offset = 0;\r\n    stride = 2;\r\n  }\r\n  simplifiedFlatCoordinates.length = douglasPeucker(\r\n    flatCoordinates,\r\n    offset,\r\n    end,\r\n    stride,\r\n    squaredTolerance,\r\n    simplifiedFlatCoordinates,\r\n    0\r\n  );\r\n  return simplifiedFlatCoordinates;\r\n}\r\n\r\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {number} end End.\r\n * @param {number} stride Stride.\r\n * @param {number} squaredTolerance Squared tolerance.\r\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\r\n *     coordinates.\r\n * @param {number} simplifiedOffset Simplified offset.\r\n * @return {number} Simplified offset.\r\n */\r\nexport function douglasPeucker(\r\n  flatCoordinates,\r\n  offset,\r\n  end,\r\n  stride,\r\n  squaredTolerance,\r\n  simplifiedFlatCoordinates,\r\n  simplifiedOffset\r\n) {\r\n  const n = (end - offset) / stride;\r\n  if (n < 3) {\r\n    for (; offset < end; offset += stride) {\r\n      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset];\r\n      simplifiedFlatCoordinates[simplifiedOffset++] =\r\n        flatCoordinates[offset + 1];\r\n    }\r\n    return simplifiedOffset;\r\n  }\r\n  /** @type {Array<number>} */\r\n  const markers = new Array(n);\r\n  markers[0] = 1;\r\n  markers[n - 1] = 1;\r\n  /** @type {Array<number>} */\r\n  const stack = [offset, end - stride];\r\n  let index = 0;\r\n  while (stack.length > 0) {\r\n    const last = stack.pop();\r\n    const first = stack.pop();\r\n    let maxSquaredDistance = 0;\r\n    const x1 = flatCoordinates[first];\r\n    const y1 = flatCoordinates[first + 1];\r\n    const x2 = flatCoordinates[last];\r\n    const y2 = flatCoordinates[last + 1];\r\n    for (let i = first + stride; i < last; i += stride) {\r\n      const x = flatCoordinates[i];\r\n      const y = flatCoordinates[i + 1];\r\n      const squaredDistance = squaredSegmentDistance(x, y, x1, y1, x2, y2);\r\n      if (squaredDistance > maxSquaredDistance) {\r\n        index = i;\r\n        maxSquaredDistance = squaredDistance;\r\n      }\r\n    }\r\n    if (maxSquaredDistance > squaredTolerance) {\r\n      markers[(index - offset) / stride] = 1;\r\n      if (first + stride < index) {\r\n        stack.push(first, index);\r\n      }\r\n      if (index + stride < last) {\r\n        stack.push(index, last);\r\n      }\r\n    }\r\n  }\r\n  for (let i = 0; i < n; ++i) {\r\n    if (markers[i]) {\r\n      simplifiedFlatCoordinates[simplifiedOffset++] =\r\n        flatCoordinates[offset + i * stride];\r\n      simplifiedFlatCoordinates[simplifiedOffset++] =\r\n        flatCoordinates[offset + i * stride + 1];\r\n    }\r\n  }\r\n  return simplifiedOffset;\r\n}\r\n\r\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {Array<number>} ends Ends.\r\n * @param {number} stride Stride.\r\n * @param {number} squaredTolerance Squared tolerance.\r\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\r\n *     coordinates.\r\n * @param {number} simplifiedOffset Simplified offset.\r\n * @param {Array<number>} simplifiedEnds Simplified ends.\r\n * @return {number} Simplified offset.\r\n */\r\nexport function douglasPeuckerArray(\r\n  flatCoordinates,\r\n  offset,\r\n  ends,\r\n  stride,\r\n  squaredTolerance,\r\n  simplifiedFlatCoordinates,\r\n  simplifiedOffset,\r\n  simplifiedEnds\r\n) {\r\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\r\n    const end = ends[i];\r\n    simplifiedOffset = douglasPeucker(\r\n      flatCoordinates,\r\n      offset,\r\n      end,\r\n      stride,\r\n      squaredTolerance,\r\n      simplifiedFlatCoordinates,\r\n      simplifiedOffset\r\n    );\r\n    simplifiedEnds.push(simplifiedOffset);\r\n    offset = end;\r\n  }\r\n  return simplifiedOffset;\r\n}\r\n\r\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {Array<Array<number>>} endss Endss.\r\n * @param {number} stride Stride.\r\n * @param {number} squaredTolerance Squared tolerance.\r\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\r\n *     coordinates.\r\n * @param {number} simplifiedOffset Simplified offset.\r\n * @param {Array<Array<number>>} simplifiedEndss Simplified endss.\r\n * @return {number} Simplified offset.\r\n */\r\nexport function douglasPeuckerMultiArray(\r\n  flatCoordinates,\r\n  offset,\r\n  endss,\r\n  stride,\r\n  squaredTolerance,\r\n  simplifiedFlatCoordinates,\r\n  simplifiedOffset,\r\n  simplifiedEndss\r\n) {\r\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\r\n    const ends = endss[i];\r\n    const simplifiedEnds = [];\r\n    simplifiedOffset = douglasPeuckerArray(\r\n      flatCoordinates,\r\n      offset,\r\n      ends,\r\n      stride,\r\n      squaredTolerance,\r\n      simplifiedFlatCoordinates,\r\n      simplifiedOffset,\r\n      simplifiedEnds\r\n    );\r\n    simplifiedEndss.push(simplifiedEnds);\r\n    offset = ends[ends.length - 1];\r\n  }\r\n  return simplifiedOffset;\r\n}\r\n\r\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {number} end End.\r\n * @param {number} stride Stride.\r\n * @param {number} squaredTolerance Squared tolerance.\r\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\r\n *     coordinates.\r\n * @param {number} simplifiedOffset Simplified offset.\r\n * @return {number} Simplified offset.\r\n */\r\nexport function radialDistance(\r\n  flatCoordinates,\r\n  offset,\r\n  end,\r\n  stride,\r\n  squaredTolerance,\r\n  simplifiedFlatCoordinates,\r\n  simplifiedOffset\r\n) {\r\n  if (end <= offset + stride) {\r\n    // zero or one point, no simplification possible, so copy and return\r\n    for (; offset < end; offset += stride) {\r\n      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset];\r\n      simplifiedFlatCoordinates[simplifiedOffset++] =\r\n        flatCoordinates[offset + 1];\r\n    }\r\n    return simplifiedOffset;\r\n  }\r\n  let x1 = flatCoordinates[offset];\r\n  let y1 = flatCoordinates[offset + 1];\r\n  // copy first point\r\n  simplifiedFlatCoordinates[simplifiedOffset++] = x1;\r\n  simplifiedFlatCoordinates[simplifiedOffset++] = y1;\r\n  let x2 = x1;\r\n  let y2 = y1;\r\n  for (offset += stride; offset < end; offset += stride) {\r\n    x2 = flatCoordinates[offset];\r\n    y2 = flatCoordinates[offset + 1];\r\n    if (squaredDistance(x1, y1, x2, y2) > squaredTolerance) {\r\n      // copy point at offset\r\n      simplifiedFlatCoordinates[simplifiedOffset++] = x2;\r\n      simplifiedFlatCoordinates[simplifiedOffset++] = y2;\r\n      x1 = x2;\r\n      y1 = y2;\r\n    }\r\n  }\r\n  if (x2 != x1 || y2 != y1) {\r\n    // copy last point\r\n    simplifiedFlatCoordinates[simplifiedOffset++] = x2;\r\n    simplifiedFlatCoordinates[simplifiedOffset++] = y2;\r\n  }\r\n  return simplifiedOffset;\r\n}\r\n\r\n/**\r\n * @param {number} value Value.\r\n * @param {number} tolerance Tolerance.\r\n * @return {number} Rounded value.\r\n */\r\nexport function snap(value, tolerance) {\r\n  return tolerance * Math.round(value / tolerance);\r\n}\r\n\r\n/**\r\n * Simplifies a line string using an algorithm designed by Tim Schaub.\r\n * Coordinates are snapped to the nearest value in a virtual grid and\r\n * consecutive duplicate coordinates are discarded.  This effectively preserves\r\n * topology as the simplification of any subsection of a line string is\r\n * independent of the rest of the line string.  This means that, for examples,\r\n * the common edge between two polygons will be simplified to the same line\r\n * string independently in both polygons.  This implementation uses a single\r\n * pass over the coordinates and eliminates intermediate collinear points.\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {number} end End.\r\n * @param {number} stride Stride.\r\n * @param {number} tolerance Tolerance.\r\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\r\n *     coordinates.\r\n * @param {number} simplifiedOffset Simplified offset.\r\n * @return {number} Simplified offset.\r\n */\r\nexport function quantize(\r\n  flatCoordinates,\r\n  offset,\r\n  end,\r\n  stride,\r\n  tolerance,\r\n  simplifiedFlatCoordinates,\r\n  simplifiedOffset\r\n) {\r\n  // do nothing if the line is empty\r\n  if (offset == end) {\r\n    return simplifiedOffset;\r\n  }\r\n  // snap the first coordinate (P1)\r\n  let x1 = snap(flatCoordinates[offset], tolerance);\r\n  let y1 = snap(flatCoordinates[offset + 1], tolerance);\r\n  offset += stride;\r\n  // add the first coordinate to the output\r\n  simplifiedFlatCoordinates[simplifiedOffset++] = x1;\r\n  simplifiedFlatCoordinates[simplifiedOffset++] = y1;\r\n  // find the next coordinate that does not snap to the same value as the first\r\n  // coordinate (P2)\r\n  let x2, y2;\r\n  do {\r\n    x2 = snap(flatCoordinates[offset], tolerance);\r\n    y2 = snap(flatCoordinates[offset + 1], tolerance);\r\n    offset += stride;\r\n    if (offset == end) {\r\n      // all coordinates snap to the same value, the line collapses to a point\r\n      // push the last snapped value anyway to ensure that the output contains\r\n      // at least two points\r\n      // FIXME should we really return at least two points anyway?\r\n      simplifiedFlatCoordinates[simplifiedOffset++] = x2;\r\n      simplifiedFlatCoordinates[simplifiedOffset++] = y2;\r\n      return simplifiedOffset;\r\n    }\r\n  } while (x2 == x1 && y2 == y1);\r\n  while (offset < end) {\r\n    // snap the next coordinate (P3)\r\n    const x3 = snap(flatCoordinates[offset], tolerance);\r\n    const y3 = snap(flatCoordinates[offset + 1], tolerance);\r\n    offset += stride;\r\n    // skip P3 if it is equal to P2\r\n    if (x3 == x2 && y3 == y2) {\r\n      continue;\r\n    }\r\n    // calculate the delta between P1 and P2\r\n    const dx1 = x2 - x1;\r\n    const dy1 = y2 - y1;\r\n    // calculate the delta between P3 and P1\r\n    const dx2 = x3 - x1;\r\n    const dy2 = y3 - y1;\r\n    // if P1, P2, and P3 are colinear and P3 is further from P1 than P2 is from\r\n    // P1 in the same direction then P2 is on the straight line between P1 and\r\n    // P3\r\n    if (\r\n      dx1 * dy2 == dy1 * dx2 &&\r\n      ((dx1 < 0 && dx2 < dx1) || dx1 == dx2 || (dx1 > 0 && dx2 > dx1)) &&\r\n      ((dy1 < 0 && dy2 < dy1) || dy1 == dy2 || (dy1 > 0 && dy2 > dy1))\r\n    ) {\r\n      // discard P2 and set P2 = P3\r\n      x2 = x3;\r\n      y2 = y3;\r\n      continue;\r\n    }\r\n    // either P1, P2, and P3 are not colinear, or they are colinear but P3 is\r\n    // between P3 and P1 or on the opposite half of the line to P2.  add P2,\r\n    // and continue with P1 = P2 and P2 = P3\r\n    simplifiedFlatCoordinates[simplifiedOffset++] = x2;\r\n    simplifiedFlatCoordinates[simplifiedOffset++] = y2;\r\n    x1 = x2;\r\n    y1 = y2;\r\n    x2 = x3;\r\n    y2 = y3;\r\n  }\r\n  // add the last point (P2)\r\n  simplifiedFlatCoordinates[simplifiedOffset++] = x2;\r\n  simplifiedFlatCoordinates[simplifiedOffset++] = y2;\r\n  return simplifiedOffset;\r\n}\r\n\r\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {Array<number>} ends Ends.\r\n * @param {number} stride Stride.\r\n * @param {number} tolerance Tolerance.\r\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\r\n *     coordinates.\r\n * @param {number} simplifiedOffset Simplified offset.\r\n * @param {Array<number>} simplifiedEnds Simplified ends.\r\n * @return {number} Simplified offset.\r\n */\r\nexport function quantizeArray(\r\n  flatCoordinates,\r\n  offset,\r\n  ends,\r\n  stride,\r\n  tolerance,\r\n  simplifiedFlatCoordinates,\r\n  simplifiedOffset,\r\n  simplifiedEnds\r\n) {\r\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\r\n    const end = ends[i];\r\n    simplifiedOffset = quantize(\r\n      flatCoordinates,\r\n      offset,\r\n      end,\r\n      stride,\r\n      tolerance,\r\n      simplifiedFlatCoordinates,\r\n      simplifiedOffset\r\n    );\r\n    simplifiedEnds.push(simplifiedOffset);\r\n    offset = end;\r\n  }\r\n  return simplifiedOffset;\r\n}\r\n\r\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {Array<Array<number>>} endss Endss.\r\n * @param {number} stride Stride.\r\n * @param {number} tolerance Tolerance.\r\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\r\n *     coordinates.\r\n * @param {number} simplifiedOffset Simplified offset.\r\n * @param {Array<Array<number>>} simplifiedEndss Simplified endss.\r\n * @return {number} Simplified offset.\r\n */\r\nexport function quantizeMultiArray(\r\n  flatCoordinates,\r\n  offset,\r\n  endss,\r\n  stride,\r\n  tolerance,\r\n  simplifiedFlatCoordinates,\r\n  simplifiedOffset,\r\n  simplifiedEndss\r\n) {\r\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\r\n    const ends = endss[i];\r\n    const simplifiedEnds = [];\r\n    simplifiedOffset = quantizeArray(\r\n      flatCoordinates,\r\n      offset,\r\n      ends,\r\n      stride,\r\n      tolerance,\r\n      simplifiedFlatCoordinates,\r\n      simplifiedOffset,\r\n      simplifiedEnds\r\n    );\r\n    simplifiedEndss.push(simplifiedEnds);\r\n    offset = ends[ends.length - 1];\r\n  }\r\n  return simplifiedOffset;\r\n}\r\n", "/**\r\n * @module ol/geom/flat/inflate\r\n */\r\n\r\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {number} end End.\r\n * @param {number} stride Stride.\r\n * @param {Array<import(\"../../coordinate.js\").Coordinate>} [coordinates] Coordinates.\r\n * @return {Array<import(\"../../coordinate.js\").Coordinate>} Coordinates.\r\n */\r\nexport function inflateCoordinates(\r\n  flatCoordinates,\r\n  offset,\r\n  end,\r\n  stride,\r\n  coordinates\r\n) {\r\n  coordinates = coordinates !== undefined ? coordinates : [];\r\n  let i = 0;\r\n  for (let j = offset; j < end; j += stride) {\r\n    coordinates[i++] = flatCoordinates.slice(j, j + stride);\r\n  }\r\n  coordinates.length = i;\r\n  return coordinates;\r\n}\r\n\r\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {Array<number>} ends Ends.\r\n * @param {number} stride Stride.\r\n * @param {Array<Array<import(\"../../coordinate.js\").Coordinate>>} [coordinatess] Coordinatess.\r\n * @return {Array<Array<import(\"../../coordinate.js\").Coordinate>>} Coordinatess.\r\n */\r\nexport function inflateCoordinatesArray(\r\n  flatCoordinates,\r\n  offset,\r\n  ends,\r\n  stride,\r\n  coordinatess\r\n) {\r\n  coordinatess = coordinatess !== undefined ? coordinatess : [];\r\n  let i = 0;\r\n  for (let j = 0, jj = ends.length; j < jj; ++j) {\r\n    const end = ends[j];\r\n    coordinatess[i++] = inflateCoordinates(\r\n      flatCoordinates,\r\n      offset,\r\n      end,\r\n      stride,\r\n      coordinatess[i]\r\n    );\r\n    offset = end;\r\n  }\r\n  coordinatess.length = i;\r\n  return coordinatess;\r\n}\r\n\r\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {Array<Array<number>>} endss Endss.\r\n * @param {number} stride Stride.\r\n * @param {Array<Array<Array<import(\"../../coordinate.js\").Coordinate>>>} [coordinatesss]\r\n *     Coordinatesss.\r\n * @return {Array<Array<Array<import(\"../../coordinate.js\").Coordinate>>>} Coordinatesss.\r\n */\r\nexport function inflateMultiCoordinatesArray(\r\n  flatCoordinates,\r\n  offset,\r\n  endss,\r\n  stride,\r\n  coordinatesss\r\n) {\r\n  coordinatesss = coordinatesss !== undefined ? coordinatesss : [];\r\n  let i = 0;\r\n  for (let j = 0, jj = endss.length; j < jj; ++j) {\r\n    const ends = endss[j];\r\n    coordinatesss[i++] =\r\n      ends.length === 1 && ends[0] === offset\r\n        ? []\r\n        : inflateCoordinatesArray(\r\n            flatCoordinates,\r\n            offset,\r\n            ends,\r\n            stride,\r\n            coordinatesss[i]\r\n          );\r\n    offset = ends[ends.length - 1];\r\n  }\r\n  coordinatesss.length = i;\r\n  return coordinatesss;\r\n}\r\n"],
  "mappings": ";;;;;;;AAiBA,SAAS,cACP,iBACA,SACA,SACA,QACA,GACA,GACA,cACA;AACA,QAAM,KAAK,gBAAgB;AAC3B,QAAM,KAAK,gBAAgB,UAAU;AACrC,QAAM,KAAK,gBAAgB,WAAW;AACtC,QAAM,KAAK,gBAAgB,UAAU,KAAK;AAC1C,MAAI;AACJ,MAAI,OAAO,KAAK,OAAO,GAAG;AACxB,aAAS;AAAA,EACX,OAAO;AACL,UAAM,MAAM,IAAI,MAAM,MAAM,IAAI,MAAM,OAAO,KAAK,KAAK,KAAK;AAC5D,QAAI,IAAI,GAAG;AACT,eAAS;AAAA,IACX,WAAW,IAAI,GAAG;AAChB,eAAS,IAAI,GAAG,IAAI,QAAQ,EAAE,GAAG;AAC/B,qBAAa,KAAK;AAAA,UAChB,gBAAgB,UAAU;AAAA,UAC1B,gBAAgB,UAAU;AAAA,UAC1B;AAAA,QACF;AAAA,MACF;AACA,mBAAa,SAAS;AACtB;AAAA,IACF,OAAO;AACL,eAAS;AAAA,IACX;AAAA,EACF;AACA,WAAS,IAAI,GAAG,IAAI,QAAQ,EAAE,GAAG;AAC/B,iBAAa,KAAK,gBAAgB,SAAS;AAAA,EAC7C;AACA,eAAa,SAAS;AACxB;AAYO,SAAS,gBAAgB,iBAAiB,QAAQ,KAAK,QAAQ,KAAK;AACzE,MAAI,KAAK,gBAAgB;AACzB,MAAI,KAAK,gBAAgB,SAAS;AAClC,OAAK,UAAU,QAAQ,SAAS,KAAK,UAAU,QAAQ;AACrD,UAAM,KAAK,gBAAgB;AAC3B,UAAM,KAAK,gBAAgB,SAAS;AACpC,UAAM,eAAe,gBAAU,IAAI,IAAI,IAAI,EAAE;AAC7C,QAAI,eAAe,KAAK;AACtB,YAAM;AAAA,IACR;AACA,SAAK;AACL,SAAK;AAAA,EACP;AACA,SAAO;AACT;AAUO,SAAS,qBACd,iBACA,QACA,MACA,QACA,KACA;AACA,WAAS,IAAI,GAAG,KAAK,KAAK,QAAQ,IAAI,IAAI,EAAE,GAAG;AAC7C,UAAM,MAAM,KAAK;AACjB,UAAM,gBAAgB,iBAAiB,QAAQ,KAAK,QAAQ,GAAG;AAC/D,aAAS;AAAA,EACX;AACA,SAAO;AACT;AAUO,SAAS,0BACd,iBACA,QACA,OACA,QACA,KACA;AACA,WAAS,IAAI,GAAG,KAAK,MAAM,QAAQ,IAAI,IAAI,EAAE,GAAG;AAC9C,UAAM,OAAO,MAAM;AACnB,UAAM,qBAAqB,iBAAiB,QAAQ,MAAM,QAAQ,GAAG;AACrE,aAAS,KAAK,KAAK,SAAS;AAAA,EAC9B;AACA,SAAO;AACT;AAgBO,SAAS,mBACd,iBACA,QACA,KACA,QACA,UACA,QACA,GACA,GACA,cACA,oBACA,UACA;AACA,MAAI,UAAU,KAAK;AACjB,WAAO;AAAA,EACT;AACA,MAAI,GAAGA;AACP,MAAI,aAAa,GAAG;AAElB,IAAAA,mBAAkB;AAAA,MAChB;AAAA,MACA;AAAA,MACA,gBAAgB;AAAA,MAChB,gBAAgB,SAAS;AAAA,IAC3B;AACA,QAAIA,mBAAkB,oBAAoB;AACxC,WAAK,IAAI,GAAG,IAAI,QAAQ,EAAE,GAAG;AAC3B,qBAAa,KAAK,gBAAgB,SAAS;AAAA,MAC7C;AACA,mBAAa,SAAS;AACtB,aAAOA;AAAA,IACT,OAAO;AACL,aAAO;AAAA,IACT;AAAA,EACF;AACA,aAAW,WAAW,WAAW,CAAC,KAAK,GAAG;AAC1C,MAAI,QAAQ,SAAS;AACrB,SAAO,QAAQ,KAAK;AAClB;AAAA,MACE;AAAA,MACA,QAAQ;AAAA,MACR;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AACA,IAAAA,mBAAkB,gBAAU,GAAG,GAAG,SAAS,IAAI,SAAS,EAAE;AAC1D,QAAIA,mBAAkB,oBAAoB;AACxC,2BAAqBA;AACrB,WAAK,IAAI,GAAG,IAAI,QAAQ,EAAE,GAAG;AAC3B,qBAAa,KAAK,SAAS;AAAA,MAC7B;AACA,mBAAa,SAAS;AACtB,eAAS;AAAA,IACX,OAAO;AAWL,eACE,SACA,KAAK;AAAA,SACD,KAAK,KAAKA,gBAAe,IAAI,KAAK,KAAK,kBAAkB,KACzD,WACA;AAAA,QACF;AAAA,MACF;AAAA,IACJ;AAAA,EACF;AACA,MAAI,QAAQ;AAEV;AAAA,MACE;AAAA,MACA,MAAM;AAAA,MACN;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AACA,IAAAA,mBAAkB,gBAAU,GAAG,GAAG,SAAS,IAAI,SAAS,EAAE;AAC1D,QAAIA,mBAAkB,oBAAoB;AACxC,2BAAqBA;AACrB,WAAK,IAAI,GAAG,IAAI,QAAQ,EAAE,GAAG;AAC3B,qBAAa,KAAK,SAAS;AAAA,MAC7B;AACA,mBAAa,SAAS;AAAA,IACxB;AAAA,EACF;AACA,SAAO;AACT;AAgBO,SAAS,wBACd,iBACA,QACA,MACA,QACA,UACA,QACA,GACA,GACA,cACA,oBACA,UACA;AACA,aAAW,WAAW,WAAW,CAAC,KAAK,GAAG;AAC1C,WAAS,IAAI,GAAG,KAAK,KAAK,QAAQ,IAAI,IAAI,EAAE,GAAG;AAC7C,UAAM,MAAM,KAAK;AACjB,yBAAqB;AAAA,MACnB;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AACA,aAAS;AAAA,EACX;AACA,SAAO;AACT;AAgBO,SAAS,6BACd,iBACA,QACA,OACA,QACA,UACA,QACA,GACA,GACA,cACA,oBACA,UACA;AACA,aAAW,WAAW,WAAW,CAAC,KAAK,GAAG;AAC1C,WAAS,IAAI,GAAG,KAAK,MAAM,QAAQ,IAAI,IAAI,EAAE,GAAG;AAC9C,UAAM,OAAO,MAAM;AACnB,yBAAqB;AAAA,MACnB;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AACA,aAAS,KAAK,KAAK,SAAS;AAAA,EAC9B;AACA,SAAO;AACT;;;ACtPO,SAAS,eACd,iBACA,QACA,KACA,QACA,kBACA,2BACA,kBACA;AACA,QAAM,KAAK,MAAM,UAAU;AAC3B,MAAI,IAAI,GAAG;AACT,WAAO,SAAS,KAAK,UAAU,QAAQ;AACrC,gCAA0B,sBAAsB,gBAAgB;AAChE,gCAA0B,sBACxB,gBAAgB,SAAS;AAAA,IAC7B;AACA,WAAO;AAAA,EACT;AAEA,QAAM,UAAU,IAAI,MAAM,CAAC;AAC3B,UAAQ,KAAK;AACb,UAAQ,IAAI,KAAK;AAEjB,QAAM,QAAQ,CAAC,QAAQ,MAAM,MAAM;AACnC,MAAI,QAAQ;AACZ,SAAO,MAAM,SAAS,GAAG;AACvB,UAAM,OAAO,MAAM,IAAI;AACvB,UAAM,QAAQ,MAAM,IAAI;AACxB,QAAI,qBAAqB;AACzB,UAAM,KAAK,gBAAgB;AAC3B,UAAM,KAAK,gBAAgB,QAAQ;AACnC,UAAM,KAAK,gBAAgB;AAC3B,UAAM,KAAK,gBAAgB,OAAO;AAClC,aAAS,IAAI,QAAQ,QAAQ,IAAI,MAAM,KAAK,QAAQ;AAClD,YAAM,IAAI,gBAAgB;AAC1B,YAAM,IAAI,gBAAgB,IAAI;AAC9B,YAAMC,mBAAkB,uBAAuB,GAAG,GAAG,IAAI,IAAI,IAAI,EAAE;AACnE,UAAIA,mBAAkB,oBAAoB;AACxC,gBAAQ;AACR,6BAAqBA;AAAA,MACvB;AAAA,IACF;AACA,QAAI,qBAAqB,kBAAkB;AACzC,eAAS,QAAQ,UAAU,UAAU;AACrC,UAAI,QAAQ,SAAS,OAAO;AAC1B,cAAM,KAAK,OAAO,KAAK;AAAA,MACzB;AACA,UAAI,QAAQ,SAAS,MAAM;AACzB,cAAM,KAAK,OAAO,IAAI;AAAA,MACxB;AAAA,IACF;AAAA,EACF;AACA,WAAS,IAAI,GAAG,IAAI,GAAG,EAAE,GAAG;AAC1B,QAAI,QAAQ,IAAI;AACd,gCAA0B,sBACxB,gBAAgB,SAAS,IAAI;AAC/B,gCAA0B,sBACxB,gBAAgB,SAAS,IAAI,SAAS;AAAA,IAC1C;AAAA,EACF;AACA,SAAO;AACT;AAcO,SAAS,oBACd,iBACA,QACA,MACA,QACA,kBACA,2BACA,kBACA,gBACA;AACA,WAAS,IAAI,GAAG,KAAK,KAAK,QAAQ,IAAI,IAAI,EAAE,GAAG;AAC7C,UAAM,MAAM,KAAK;AACjB,uBAAmB;AAAA,MACjB;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AACA,mBAAe,KAAK,gBAAgB;AACpC,aAAS;AAAA,EACX;AACA,SAAO;AACT;AAuGO,SAAS,KAAK,OAAO,WAAW;AACrC,SAAO,YAAY,KAAK,MAAM,QAAQ,SAAS;AACjD;AAqBO,SAAS,SACd,iBACA,QACA,KACA,QACA,WACA,2BACA,kBACA;AAEA,MAAI,UAAU,KAAK;AACjB,WAAO;AAAA,EACT;AAEA,MAAI,KAAK,KAAK,gBAAgB,SAAS,SAAS;AAChD,MAAI,KAAK,KAAK,gBAAgB,SAAS,IAAI,SAAS;AACpD,YAAU;AAEV,4BAA0B,sBAAsB;AAChD,4BAA0B,sBAAsB;AAGhD,MAAI,IAAI;AACR,KAAG;AACD,SAAK,KAAK,gBAAgB,SAAS,SAAS;AAC5C,SAAK,KAAK,gBAAgB,SAAS,IAAI,SAAS;AAChD,cAAU;AACV,QAAI,UAAU,KAAK;AAKjB,gCAA0B,sBAAsB;AAChD,gCAA0B,sBAAsB;AAChD,aAAO;AAAA,IACT;AAAA,EACF,SAAS,MAAM,MAAM,MAAM;AAC3B,SAAO,SAAS,KAAK;AAEnB,UAAM,KAAK,KAAK,gBAAgB,SAAS,SAAS;AAClD,UAAM,KAAK,KAAK,gBAAgB,SAAS,IAAI,SAAS;AACtD,cAAU;AAEV,QAAI,MAAM,MAAM,MAAM,IAAI;AACxB;AAAA,IACF;AAEA,UAAM,MAAM,KAAK;AACjB,UAAM,MAAM,KAAK;AAEjB,UAAM,MAAM,KAAK;AACjB,UAAM,MAAM,KAAK;AAIjB,QACE,MAAM,OAAO,MAAM,QACjB,MAAM,KAAK,MAAM,OAAQ,OAAO,OAAQ,MAAM,KAAK,MAAM,SACzD,MAAM,KAAK,MAAM,OAAQ,OAAO,OAAQ,MAAM,KAAK,MAAM,MAC3D;AAEA,WAAK;AACL,WAAK;AACL;AAAA,IACF;AAIA,8BAA0B,sBAAsB;AAChD,8BAA0B,sBAAsB;AAChD,SAAK;AACL,SAAK;AACL,SAAK;AACL,SAAK;AAAA,EACP;AAEA,4BAA0B,sBAAsB;AAChD,4BAA0B,sBAAsB;AAChD,SAAO;AACT;AAcO,SAAS,cACd,iBACA,QACA,MACA,QACA,WACA,2BACA,kBACA,gBACA;AACA,WAAS,IAAI,GAAG,KAAK,KAAK,QAAQ,IAAI,IAAI,EAAE,GAAG;AAC7C,UAAM,MAAM,KAAK;AACjB,uBAAmB;AAAA,MACjB;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AACA,mBAAe,KAAK,gBAAgB;AACpC,aAAS;AAAA,EACX;AACA,SAAO;AACT;AAcO,SAAS,mBACd,iBACA,QACA,OACA,QACA,WACA,2BACA,kBACA,iBACA;AACA,WAAS,IAAI,GAAG,KAAK,MAAM,QAAQ,IAAI,IAAI,EAAE,GAAG;AAC9C,UAAM,OAAO,MAAM;AACnB,UAAM,iBAAiB,CAAC;AACxB,uBAAmB;AAAA,MACjB;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AACA,oBAAgB,KAAK,cAAc;AACnC,aAAS,KAAK,KAAK,SAAS;AAAA,EAC9B;AACA,SAAO;AACT;;;AC/cO,SAAS,mBACd,iBACA,QACA,KACA,QACA,aACA;AACA,gBAAc,gBAAgB,SAAY,cAAc,CAAC;AACzD,MAAI,IAAI;AACR,WAAS,IAAI,QAAQ,IAAI,KAAK,KAAK,QAAQ;AACzC,gBAAY,OAAO,gBAAgB,MAAM,GAAG,IAAI,MAAM;AAAA,EACxD;AACA,cAAY,SAAS;AACrB,SAAO;AACT;AAUO,SAAS,wBACd,iBACA,QACA,MACA,QACA,cACA;AACA,iBAAe,iBAAiB,SAAY,eAAe,CAAC;AAC5D,MAAI,IAAI;AACR,WAAS,IAAI,GAAG,KAAK,KAAK,QAAQ,IAAI,IAAI,EAAE,GAAG;AAC7C,UAAM,MAAM,KAAK;AACjB,iBAAa,OAAO;AAAA,MAClB;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA,aAAa;AAAA,IACf;AACA,aAAS;AAAA,EACX;AACA,eAAa,SAAS;AACtB,SAAO;AACT;AAWO,SAAS,6BACd,iBACA,QACA,OACA,QACA,eACA;AACA,kBAAgB,kBAAkB,SAAY,gBAAgB,CAAC;AAC/D,MAAI,IAAI;AACR,WAAS,IAAI,GAAG,KAAK,MAAM,QAAQ,IAAI,IAAI,EAAE,GAAG;AAC9C,UAAM,OAAO,MAAM;AACnB,kBAAc,OACZ,KAAK,WAAW,KAAK,KAAK,OAAO,SAC7B,CAAC,IACD;AAAA,MACE;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA,cAAc;AAAA,IAChB;AACN,aAAS,KAAK,KAAK,SAAS;AAAA,EAC9B;AACA,gBAAc,SAAS;AACvB,SAAO;AACT;",
  "names": ["squaredDistance", "squaredDistance"]
}
