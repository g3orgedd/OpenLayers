{
  "version": 3,
  "sources": ["../../ol/render.js", "../../ol/geom/flat/geodesic.js", "../../ol/layer/Graticule.js"],
  "sourcesContent": ["/**\r\n * @module ol/render\r\n */\r\nimport CanvasImmediateRenderer from './render/canvas/Immediate.js';\r\nimport {DEVICE_PIXEL_RATIO} from './has.js';\r\nimport {\r\n  apply as applyTransform,\r\n  create as createTransform,\r\n  multiply as multiplyTransform,\r\n  scale as scaleTransform,\r\n} from './transform.js';\r\nimport {getSquaredTolerance} from './renderer/vector.js';\r\nimport {getTransformFromProjections, getUserProjection} from './proj.js';\r\n\r\n/**\r\n * @typedef {Object} State\r\n * @property {CanvasRenderingContext2D} context Canvas context that the layer is being rendered to.\r\n * @property {import(\"./Feature.js\").FeatureLike} feature Feature.\r\n * @property {import(\"./geom/SimpleGeometry.js\").default} geometry Geometry.\r\n * @property {number} pixelRatio Pixel ratio used by the layer renderer.\r\n * @property {number} resolution Resolution that the render batch was created and optimized for.\r\n * This is not the view's resolution that is being rendered.\r\n * @property {number} rotation Rotation of the rendered layer in radians.\r\n */\r\n\r\n/**\r\n * A function to be used when sorting features before rendering.\r\n * It takes two instances of {@link module:ol/Feature~Feature} or\r\n * {@link module:ol/render/Feature~RenderFeature} and returns a `{number}`.\r\n *\r\n * @typedef {function(import(\"./Feature.js\").FeatureLike, import(\"./Feature.js\").FeatureLike):number} OrderFunction\r\n */\r\n\r\n/**\r\n * @typedef {Object} ToContextOptions\r\n * @property {import(\"./size.js\").Size} [size] Desired size of the canvas in css\r\n * pixels. When provided, both canvas and css size will be set according to the\r\n * `pixelRatio`. If not provided, the current canvas and css sizes will not be\r\n * altered.\r\n * @property {number} [pixelRatio=window.devicePixelRatio] Pixel ratio (canvas\r\n * pixel to css pixel ratio) for the canvas.\r\n */\r\n\r\n/**\r\n * Binds a Canvas Immediate API to a canvas context, to allow drawing geometries\r\n * to the context's canvas.\r\n *\r\n * The units for geometry coordinates are css pixels relative to the top left\r\n * corner of the canvas element.\r\n * ```js\r\n * import {toContext} from 'ol/render';\r\n * import Fill from 'ol/style/Fill';\r\n * import Polygon from 'ol/geom/Polygon';\r\n *\r\n * const canvas = document.createElement('canvas');\r\n * const render = toContext(\r\n *     canvas.getContext('2d'),\r\n *     {size: [100, 100]}\r\n * );\r\n * render.setFillStrokeStyle(new Fill({ color: blue }));\r\n * render.drawPolygon(\r\n *     new Polygon([[[0, 0], [100, 100], [100, 0], [0, 0]]])\r\n * );\r\n * ```\r\n *\r\n * @param {CanvasRenderingContext2D} context Canvas context.\r\n * @param {ToContextOptions} [options] Options.\r\n * @return {CanvasImmediateRenderer} Canvas Immediate.\r\n * @api\r\n */\r\nexport function toContext(context, options) {\r\n  const canvas = context.canvas;\r\n  options = options ? options : {};\r\n  const pixelRatio = options.pixelRatio || DEVICE_PIXEL_RATIO;\r\n  const size = options.size;\r\n  if (size) {\r\n    canvas.width = size[0] * pixelRatio;\r\n    canvas.height = size[1] * pixelRatio;\r\n    canvas.style.width = size[0] + 'px';\r\n    canvas.style.height = size[1] + 'px';\r\n  }\r\n  const extent = [0, 0, canvas.width, canvas.height];\r\n  const transform = scaleTransform(createTransform(), pixelRatio, pixelRatio);\r\n  return new CanvasImmediateRenderer(context, pixelRatio, extent, transform, 0);\r\n}\r\n\r\n/**\r\n * Gets a vector context for drawing to the event's canvas.\r\n * @param {import(\"./render/Event.js\").default} event Render event.\r\n * @return {CanvasImmediateRenderer} Vector context.\r\n * @api\r\n */\r\nexport function getVectorContext(event) {\r\n  if (!(event.context instanceof CanvasRenderingContext2D)) {\r\n    throw new Error('Only works for render events from Canvas 2D layers');\r\n  }\r\n\r\n  // canvas may be at a different pixel ratio than frameState.pixelRatio\r\n  const canvasPixelRatio = event.inversePixelTransform[0];\r\n  const frameState = event.frameState;\r\n  const transform = multiplyTransform(\r\n    event.inversePixelTransform.slice(),\r\n    frameState.coordinateToPixelTransform\r\n  );\r\n  const squaredTolerance = getSquaredTolerance(\r\n    frameState.viewState.resolution,\r\n    canvasPixelRatio\r\n  );\r\n  let userTransform;\r\n  const userProjection = getUserProjection();\r\n  if (userProjection) {\r\n    userTransform = getTransformFromProjections(\r\n      userProjection,\r\n      frameState.viewState.projection\r\n    );\r\n  }\r\n\r\n  return new CanvasImmediateRenderer(\r\n    event.context,\r\n    canvasPixelRatio,\r\n    frameState.extent,\r\n    transform,\r\n    frameState.viewState.rotation,\r\n    squaredTolerance,\r\n    userTransform\r\n  );\r\n}\r\n\r\n/**\r\n * Gets the pixel of the event's canvas context from the map viewport's CSS pixel.\r\n * @param {import(\"./render/Event.js\").default} event Render event.\r\n * @param {import(\"./pixel.js\").Pixel} pixel CSS pixel relative to the top-left\r\n * corner of the map viewport.\r\n * @return {import(\"./pixel.js\").Pixel} Pixel on the event's canvas context.\r\n * @api\r\n */\r\nexport function getRenderPixel(event, pixel) {\r\n  return applyTransform(event.inversePixelTransform, pixel.slice(0));\r\n}\r\n", "/**\r\n * @module ol/geom/flat/geodesic\r\n */\r\nimport {get as getProjection, getTransform} from '../../proj.js';\r\nimport {squaredSegmentDistance, toDegrees, toRadians} from '../../math.js';\r\n\r\n/**\r\n * @param {function(number): import(\"../../coordinate.js\").Coordinate} interpolate Interpolate function.\r\n * @param {import(\"../../proj.js\").TransformFunction} transform Transform from longitude/latitude to\r\n *     projected coordinates.\r\n * @param {number} squaredTolerance Squared tolerance.\r\n * @return {Array<number>} Flat coordinates.\r\n */\r\nfunction line(interpolate, transform, squaredTolerance) {\r\n  // FIXME reduce garbage generation\r\n  // FIXME optimize stack operations\r\n\r\n  /** @type {Array<number>} */\r\n  const flatCoordinates = [];\r\n\r\n  let geoA = interpolate(0);\r\n  let geoB = interpolate(1);\r\n\r\n  let a = transform(geoA);\r\n  let b = transform(geoB);\r\n\r\n  /** @type {Array<import(\"../../coordinate.js\").Coordinate>} */\r\n  const geoStack = [geoB, geoA];\r\n  /** @type {Array<import(\"../../coordinate.js\").Coordinate>} */\r\n  const stack = [b, a];\r\n  /** @type {Array<number>} */\r\n  const fractionStack = [1, 0];\r\n\r\n  /** @type {!Object<string, boolean>} */\r\n  const fractions = {};\r\n\r\n  let maxIterations = 1e5;\r\n  let geoM, m, fracA, fracB, fracM, key;\r\n\r\n  while (--maxIterations > 0 && fractionStack.length > 0) {\r\n    // Pop the a coordinate off the stack\r\n    fracA = fractionStack.pop();\r\n    geoA = geoStack.pop();\r\n    a = stack.pop();\r\n    // Add the a coordinate if it has not been added yet\r\n    key = fracA.toString();\r\n    if (!(key in fractions)) {\r\n      flatCoordinates.push(a[0], a[1]);\r\n      fractions[key] = true;\r\n    }\r\n    // Pop the b coordinate off the stack\r\n    fracB = fractionStack.pop();\r\n    geoB = geoStack.pop();\r\n    b = stack.pop();\r\n    // Find the m point between the a and b coordinates\r\n    fracM = (fracA + fracB) / 2;\r\n    geoM = interpolate(fracM);\r\n    m = transform(geoM);\r\n    if (\r\n      squaredSegmentDistance(m[0], m[1], a[0], a[1], b[0], b[1]) <\r\n      squaredTolerance\r\n    ) {\r\n      // If the m point is sufficiently close to the straight line, then we\r\n      // discard it.  Just use the b coordinate and move on to the next line\r\n      // segment.\r\n      flatCoordinates.push(b[0], b[1]);\r\n      key = fracB.toString();\r\n      fractions[key] = true;\r\n    } else {\r\n      // Otherwise, we need to subdivide the current line segment.  Split it\r\n      // into two and push the two line segments onto the stack.\r\n      fractionStack.push(fracB, fracM, fracM, fracA);\r\n      stack.push(b, m, m, a);\r\n      geoStack.push(geoB, geoM, geoM, geoA);\r\n    }\r\n  }\r\n\r\n  return flatCoordinates;\r\n}\r\n\r\n/**\r\n * Generate a great-circle arcs between two lat/lon points.\r\n * @param {number} lon1 Longitude 1 in degrees.\r\n * @param {number} lat1 Latitude 1 in degrees.\r\n * @param {number} lon2 Longitude 2 in degrees.\r\n * @param {number} lat2 Latitude 2 in degrees.\r\n * @param {import(\"../../proj/Projection.js\").default} projection Projection.\r\n * @param {number} squaredTolerance Squared tolerance.\r\n * @return {Array<number>} Flat coordinates.\r\n */\r\nexport function greatCircleArc(\r\n  lon1,\r\n  lat1,\r\n  lon2,\r\n  lat2,\r\n  projection,\r\n  squaredTolerance\r\n) {\r\n  const geoProjection = getProjection('EPSG:4326');\r\n\r\n  const cosLat1 = Math.cos(toRadians(lat1));\r\n  const sinLat1 = Math.sin(toRadians(lat1));\r\n  const cosLat2 = Math.cos(toRadians(lat2));\r\n  const sinLat2 = Math.sin(toRadians(lat2));\r\n  const cosDeltaLon = Math.cos(toRadians(lon2 - lon1));\r\n  const sinDeltaLon = Math.sin(toRadians(lon2 - lon1));\r\n  const d = sinLat1 * sinLat2 + cosLat1 * cosLat2 * cosDeltaLon;\r\n\r\n  return line(\r\n    /**\r\n     * @param {number} frac Fraction.\r\n     * @return {import(\"../../coordinate.js\").Coordinate} Coordinate.\r\n     */\r\n    function (frac) {\r\n      if (1 <= d) {\r\n        return [lon2, lat2];\r\n      }\r\n      const D = frac * Math.acos(d);\r\n      const cosD = Math.cos(D);\r\n      const sinD = Math.sin(D);\r\n      const y = sinDeltaLon * cosLat2;\r\n      const x = cosLat1 * sinLat2 - sinLat1 * cosLat2 * cosDeltaLon;\r\n      const theta = Math.atan2(y, x);\r\n      const lat = Math.asin(sinLat1 * cosD + cosLat1 * sinD * Math.cos(theta));\r\n      const lon =\r\n        toRadians(lon1) +\r\n        Math.atan2(\r\n          Math.sin(theta) * sinD * cosLat1,\r\n          cosD - sinLat1 * Math.sin(lat)\r\n        );\r\n      return [toDegrees(lon), toDegrees(lat)];\r\n    },\r\n    getTransform(geoProjection, projection),\r\n    squaredTolerance\r\n  );\r\n}\r\n\r\n/**\r\n * Generate a meridian (line at constant longitude).\r\n * @param {number} lon Longitude.\r\n * @param {number} lat1 Latitude 1.\r\n * @param {number} lat2 Latitude 2.\r\n * @param {import(\"../../proj/Projection.js\").default} projection Projection.\r\n * @param {number} squaredTolerance Squared tolerance.\r\n * @return {Array<number>} Flat coordinates.\r\n */\r\nexport function meridian(lon, lat1, lat2, projection, squaredTolerance) {\r\n  const epsg4326Projection = getProjection('EPSG:4326');\r\n  return line(\r\n    /**\r\n     * @param {number} frac Fraction.\r\n     * @return {import(\"../../coordinate.js\").Coordinate} Coordinate.\r\n     */\r\n    function (frac) {\r\n      return [lon, lat1 + (lat2 - lat1) * frac];\r\n    },\r\n    getTransform(epsg4326Projection, projection),\r\n    squaredTolerance\r\n  );\r\n}\r\n\r\n/**\r\n * Generate a parallel (line at constant latitude).\r\n * @param {number} lat Latitude.\r\n * @param {number} lon1 Longitude 1.\r\n * @param {number} lon2 Longitude 2.\r\n * @param {import(\"../../proj/Projection.js\").default} projection Projection.\r\n * @param {number} squaredTolerance Squared tolerance.\r\n * @return {Array<number>} Flat coordinates.\r\n */\r\nexport function parallel(lat, lon1, lon2, projection, squaredTolerance) {\r\n  const epsg4326Projection = getProjection('EPSG:4326');\r\n  return line(\r\n    /**\r\n     * @param {number} frac Fraction.\r\n     * @return {import(\"../../coordinate.js\").Coordinate} Coordinate.\r\n     */\r\n    function (frac) {\r\n      return [lon1 + (lon2 - lon1) * frac, lat];\r\n    },\r\n    getTransform(epsg4326Projection, projection),\r\n    squaredTolerance\r\n  );\r\n}\r\n", "/**\r\n * @module ol/layer/Graticule\r\n */\r\nimport Collection from '../Collection.js';\r\nimport EventType from '../render/EventType.js';\r\nimport Feature from '../Feature.js';\r\nimport Fill from '../style/Fill.js';\r\nimport LineString from '../geom/LineString.js';\r\nimport Point from '../geom/Point.js';\r\nimport Stroke from '../style/Stroke.js';\r\nimport Style from '../style/Style.js';\r\nimport Text from '../style/Text.js';\r\nimport VectorLayer from './Vector.js';\r\nimport VectorSource from '../source/Vector.js';\r\nimport {\r\n  applyTransform,\r\n  approximatelyEquals,\r\n  containsCoordinate,\r\n  containsExtent,\r\n  equals,\r\n  getCenter,\r\n  getIntersection,\r\n  getWidth,\r\n  intersects,\r\n  isEmpty,\r\n  wrapX as wrapExtentX,\r\n} from '../extent.js';\r\nimport {clamp} from '../math.js';\r\nimport {degreesToStringHDMS} from '../coordinate.js';\r\nimport {\r\n  equivalent as equivalentProjection,\r\n  get as getProjection,\r\n  getTransform,\r\n} from '../proj.js';\r\nimport {getVectorContext} from '../render.js';\r\nimport {meridian, parallel} from '../geom/flat/geodesic.js';\r\n\r\n/**\r\n * @type {Stroke}\r\n * @private\r\n * @const\r\n */\r\nconst DEFAULT_STROKE_STYLE = new Stroke({\r\n  color: 'rgba(0,0,0,0.2)',\r\n});\r\n\r\n/**\r\n * @type {Array<number>}\r\n * @private\r\n */\r\nconst INTERVALS = [\r\n  90,\r\n  45,\r\n  30,\r\n  20,\r\n  10,\r\n  5,\r\n  2,\r\n  1,\r\n  30 / 60,\r\n  20 / 60,\r\n  10 / 60,\r\n  5 / 60,\r\n  2 / 60,\r\n  1 / 60,\r\n  30 / 3600,\r\n  20 / 3600,\r\n  10 / 3600,\r\n  5 / 3600,\r\n  2 / 3600,\r\n  1 / 3600,\r\n];\r\n\r\n/**\r\n * @typedef {Object} GraticuleLabelDataType\r\n * @property {Point} geom Geometry.\r\n * @property {string} text Text.\r\n */\r\n\r\n/**\r\n * @typedef {Object} Options\r\n * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.\r\n * @property {number} [opacity=1] Opacity (0, 1).\r\n * @property {boolean} [visible=true] Visibility.\r\n * @property {import(\"../extent.js\").Extent} [extent] The bounding extent for layer rendering.  The layer will not be\r\n * rendered outside of this extent.\r\n * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers\r\n * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed\r\n * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`\r\n * method was used.\r\n * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\r\n * visible.\r\n * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\r\n * be visible.\r\n * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be\r\n * visible.\r\n * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will\r\n * be visible.\r\n * @property {number} [maxLines=100] The maximum number of meridians and\r\n * parallels from the center of the map. The default value of 100 means that at\r\n * most 200 meridians and 200 parallels will be displayed. The default value is\r\n * appropriate for conformal projections like Spherical Mercator. If you\r\n * increase the value, more lines will be drawn and the drawing performance will\r\n * decrease.\r\n * @property {Stroke} [strokeStyle] The\r\n * stroke style to use for drawing the graticule. If not provided, the following stroke will be used:\r\n * ```js\r\n * new Stroke({\r\n *   color: 'rgba(0, 0, 0, 0.2)' // a not fully opaque black\r\n * });\r\n * ```\r\n * @property {number} [targetSize=100] The target size of the graticule cells,\r\n * in pixels.\r\n * @property {boolean} [showLabels=false] Render a label with the respective\r\n * latitude/longitude for each graticule line.\r\n * @property {function(number):string} [lonLabelFormatter] Label formatter for\r\n * longitudes. This function is called with the longitude as argument, and\r\n * should return a formatted string representing the longitude. By default,\r\n * labels are formatted as degrees, minutes, seconds and hemisphere.\r\n * @property {function(number):string} [latLabelFormatter] Label formatter for\r\n * latitudes. This function is called with the latitude as argument, and\r\n * should return a formatted string representing the latitude. By default,\r\n * labels are formatted as degrees, minutes, seconds and hemisphere.\r\n * @property {number} [lonLabelPosition=0] Longitude label position in fractions\r\n * (0..1) of view extent. 0 means at the bottom of the viewport, 1 means at the\r\n * top.\r\n * @property {number} [latLabelPosition=1] Latitude label position in fractions\r\n * (0..1) of view extent. 0 means at the left of the viewport, 1 means at the\r\n * right.\r\n * @property {Text} [lonLabelStyle] Longitude label text\r\n * style. If not provided, the following style will be used:\r\n * ```js\r\n * new Text({\r\n *   font: '12px Calibri,sans-serif',\r\n *   textBaseline: 'bottom',\r\n *   fill: new Fill({\r\n *     color: 'rgba(0,0,0,1)'\r\n *   }),\r\n *   stroke: new Stroke({\r\n *     color: 'rgba(255,255,255,1)',\r\n *     width: 3\r\n *   })\r\n * });\r\n * ```\r\n * Note that the default's `textBaseline` configuration will not work well for\r\n * `lonLabelPosition` configurations that position labels close to the top of\r\n * the viewport.\r\n * @property {Text} [latLabelStyle] Latitude label text style.\r\n * If not provided, the following style will be used:\r\n * ```js\r\n * new Text({\r\n *   font: '12px Calibri,sans-serif',\r\n *   textAlign: 'end',\r\n *   fill: new Fill({\r\n *     color: 'rgba(0,0,0,1)'\r\n *   }),\r\n *   stroke: Stroke({\r\n *     color: 'rgba(255,255,255,1)',\r\n *     width: 3\r\n *   })\r\n * });\r\n * ```\r\n * Note that the default's `textAlign` configuration will not work well for\r\n * `latLabelPosition` configurations that position labels close to the left of\r\n * the viewport.\r\n * @property {Array<number>} [intervals=[90, 45, 30, 20, 10, 5, 2, 1, 30/60, 20/60, 10/60, 5/60, 2/60, 1/60, 30/3600, 20/3600, 10/3600, 5/3600, 2/3600, 1/3600]]\r\n * Intervals (in degrees) for the graticule. Example to limit graticules to 30 and 10 degrees intervals:\r\n * ```js\r\n * [30, 10]\r\n * ```\r\n * @property {boolean} [wrapX=true] Whether to repeat the graticule horizontally.\r\n * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * Layer that renders a grid for a coordinate system (currently only EPSG:4326 is supported).\r\n * Note that the view projection must define both extent and worldExtent.\r\n *\r\n * @fires import(\"../render/Event.js\").RenderEvent\r\n * @extends {VectorLayer<import(\"../source/Vector.js\").default>}\r\n * @api\r\n */\r\nclass Graticule extends VectorLayer {\r\n  /**\r\n   * @param {Options} [options] Options.\r\n   */\r\n  constructor(options) {\r\n    options = options ? options : {};\r\n\r\n    const baseOptions = Object.assign(\r\n      {\r\n        updateWhileAnimating: true,\r\n        updateWhileInteracting: true,\r\n        renderBuffer: 0,\r\n      },\r\n      options\r\n    );\r\n\r\n    delete baseOptions.maxLines;\r\n    delete baseOptions.strokeStyle;\r\n    delete baseOptions.targetSize;\r\n    delete baseOptions.showLabels;\r\n    delete baseOptions.lonLabelFormatter;\r\n    delete baseOptions.latLabelFormatter;\r\n    delete baseOptions.lonLabelPosition;\r\n    delete baseOptions.latLabelPosition;\r\n    delete baseOptions.lonLabelStyle;\r\n    delete baseOptions.latLabelStyle;\r\n    delete baseOptions.intervals;\r\n    super(baseOptions);\r\n\r\n    /**\r\n     * @type {import(\"../proj/Projection.js\").default}\r\n     */\r\n    this.projection_ = null;\r\n\r\n    /**\r\n     * @type {number}\r\n     * @private\r\n     */\r\n    this.maxLat_ = Infinity;\r\n\r\n    /**\r\n     * @type {number}\r\n     * @private\r\n     */\r\n    this.maxLon_ = Infinity;\r\n\r\n    /**\r\n     * @type {number}\r\n     * @private\r\n     */\r\n    this.minLat_ = -Infinity;\r\n\r\n    /**\r\n     * @type {number}\r\n     * @private\r\n     */\r\n    this.minLon_ = -Infinity;\r\n\r\n    /**\r\n     * @type {number}\r\n     * @private\r\n     */\r\n    this.maxX_ = Infinity;\r\n\r\n    /**\r\n     * @type {number}\r\n     * @private\r\n     */\r\n    this.maxY_ = Infinity;\r\n\r\n    /**\r\n     * @type {number}\r\n     * @private\r\n     */\r\n    this.minX_ = -Infinity;\r\n\r\n    /**\r\n     * @type {number}\r\n     * @private\r\n     */\r\n    this.minY_ = -Infinity;\r\n\r\n    /**\r\n     * @type {number}\r\n     * @private\r\n     */\r\n    this.targetSize_ =\r\n      options.targetSize !== undefined ? options.targetSize : 100;\r\n\r\n    /**\r\n     * @type {number}\r\n     * @private\r\n     */\r\n    this.maxLines_ = options.maxLines !== undefined ? options.maxLines : 100;\r\n\r\n    /**\r\n     * @type {Array<LineString>}\r\n     * @private\r\n     */\r\n    this.meridians_ = [];\r\n\r\n    /**\r\n     * @type {Array<LineString>}\r\n     * @private\r\n     */\r\n    this.parallels_ = [];\r\n\r\n    /**\r\n     * @type {Stroke}\r\n     * @private\r\n     */\r\n    this.strokeStyle_ =\r\n      options.strokeStyle !== undefined\r\n        ? options.strokeStyle\r\n        : DEFAULT_STROKE_STYLE;\r\n\r\n    /**\r\n     * @type {import(\"../proj.js\").TransformFunction|undefined}\r\n     * @private\r\n     */\r\n    this.fromLonLatTransform_ = undefined;\r\n\r\n    /**\r\n     * @type {import(\"../proj.js\").TransformFunction|undefined}\r\n     * @private\r\n     */\r\n    this.toLonLatTransform_ = undefined;\r\n\r\n    /**\r\n     * @type {import(\"../coordinate.js\").Coordinate}\r\n     * @private\r\n     */\r\n    this.projectionCenterLonLat_ = null;\r\n\r\n    /**\r\n     * @type {import(\"../coordinate.js\").Coordinate}\r\n     * @private\r\n     */\r\n    this.bottomLeft_ = null;\r\n\r\n    /**\r\n     * @type {import(\"../coordinate.js\").Coordinate}\r\n     * @private\r\n     */\r\n    this.bottomRight_ = null;\r\n\r\n    /**\r\n     * @type {import(\"../coordinate.js\").Coordinate}\r\n     * @private\r\n     */\r\n    this.topLeft_ = null;\r\n\r\n    /**\r\n     * @type {import(\"../coordinate.js\").Coordinate}\r\n     * @private\r\n     */\r\n    this.topRight_ = null;\r\n\r\n    /**\r\n     * @type {Array<GraticuleLabelDataType>}\r\n     * @private\r\n     */\r\n    this.meridiansLabels_ = null;\r\n\r\n    /**\r\n     * @type {Array<GraticuleLabelDataType>}\r\n     * @private\r\n     */\r\n    this.parallelsLabels_ = null;\r\n\r\n    if (options.showLabels) {\r\n      /**\r\n       * @type {null|function(number):string}\r\n       * @private\r\n       */\r\n      this.lonLabelFormatter_ =\r\n        options.lonLabelFormatter == undefined\r\n          ? degreesToStringHDMS.bind(this, 'EW')\r\n          : options.lonLabelFormatter;\r\n\r\n      /**\r\n       * @type {function(number):string}\r\n       * @private\r\n       */\r\n      this.latLabelFormatter_ =\r\n        options.latLabelFormatter == undefined\r\n          ? degreesToStringHDMS.bind(this, 'NS')\r\n          : options.latLabelFormatter;\r\n\r\n      /**\r\n       * Longitude label position in fractions (0..1) of view extent. 0 means\r\n       * bottom, 1 means top.\r\n       * @type {number}\r\n       * @private\r\n       */\r\n      this.lonLabelPosition_ =\r\n        options.lonLabelPosition == undefined ? 0 : options.lonLabelPosition;\r\n\r\n      /**\r\n       * Latitude Label position in fractions (0..1) of view extent. 0 means left, 1\r\n       * means right.\r\n       * @type {number}\r\n       * @private\r\n       */\r\n      this.latLabelPosition_ =\r\n        options.latLabelPosition == undefined ? 1 : options.latLabelPosition;\r\n\r\n      /**\r\n       * @type {Style}\r\n       * @private\r\n       */\r\n      this.lonLabelStyleBase_ = new Style({\r\n        text:\r\n          options.lonLabelStyle !== undefined\r\n            ? options.lonLabelStyle.clone()\r\n            : new Text({\r\n                font: '12px Calibri,sans-serif',\r\n                textBaseline: 'bottom',\r\n                fill: new Fill({\r\n                  color: 'rgba(0,0,0,1)',\r\n                }),\r\n                stroke: new Stroke({\r\n                  color: 'rgba(255,255,255,1)',\r\n                  width: 3,\r\n                }),\r\n              }),\r\n      });\r\n\r\n      /**\r\n       * @private\r\n       * @param {import(\"../Feature\").default} feature Feature\r\n       * @return {Style} style\r\n       */\r\n      this.lonLabelStyle_ = function (feature) {\r\n        const label = feature.get('graticule_label');\r\n        this.lonLabelStyleBase_.getText().setText(label);\r\n        return this.lonLabelStyleBase_;\r\n      }.bind(this);\r\n\r\n      /**\r\n       * @type {Style}\r\n       * @private\r\n       */\r\n      this.latLabelStyleBase_ = new Style({\r\n        text:\r\n          options.latLabelStyle !== undefined\r\n            ? options.latLabelStyle.clone()\r\n            : new Text({\r\n                font: '12px Calibri,sans-serif',\r\n                textAlign: 'right',\r\n                fill: new Fill({\r\n                  color: 'rgba(0,0,0,1)',\r\n                }),\r\n                stroke: new Stroke({\r\n                  color: 'rgba(255,255,255,1)',\r\n                  width: 3,\r\n                }),\r\n              }),\r\n      });\r\n\r\n      /**\r\n       * @private\r\n       * @param {import(\"../Feature\").default} feature Feature\r\n       * @return {Style} style\r\n       */\r\n      this.latLabelStyle_ = function (feature) {\r\n        const label = feature.get('graticule_label');\r\n        this.latLabelStyleBase_.getText().setText(label);\r\n        return this.latLabelStyleBase_;\r\n      }.bind(this);\r\n\r\n      this.meridiansLabels_ = [];\r\n      this.parallelsLabels_ = [];\r\n\r\n      this.addEventListener(EventType.POSTRENDER, this.drawLabels_.bind(this));\r\n    }\r\n\r\n    /**\r\n     * @type {Array<number>}\r\n     * @private\r\n     */\r\n    this.intervals_ =\r\n      options.intervals !== undefined ? options.intervals : INTERVALS;\r\n\r\n    // use a source with a custom loader for lines & text\r\n    this.setSource(\r\n      new VectorSource({\r\n        loader: this.loaderFunction.bind(this),\r\n        strategy: this.strategyFunction.bind(this),\r\n        features: new Collection(),\r\n        overlaps: false,\r\n        useSpatialIndex: false,\r\n        wrapX: options.wrapX,\r\n      })\r\n    );\r\n\r\n    /**\r\n     * feature pool to use when updating graticule\r\n     * @type {Array<Feature>}\r\n     * @private\r\n     */\r\n    this.featurePool_ = [];\r\n\r\n    /**\r\n     * @type {Style}\r\n     * @private\r\n     */\r\n    this.lineStyle_ = new Style({\r\n      stroke: this.strokeStyle_,\r\n    });\r\n\r\n    /**\r\n     * @type {?import(\"../extent.js\").Extent}\r\n     * @private\r\n     */\r\n    this.loadedExtent_ = null;\r\n\r\n    /**\r\n     * @type {?import(\"../extent.js\").Extent}\r\n     * @private\r\n     */\r\n    this.renderedExtent_ = null;\r\n\r\n    /**\r\n     * @type {?number}\r\n     * @private\r\n     */\r\n    this.renderedResolution_ = null;\r\n\r\n    this.setRenderOrder(null);\r\n  }\r\n\r\n  /**\r\n   * Strategy function for loading features based on the view's extent and\r\n   * resolution.\r\n   * @param {import(\"../extent.js\").Extent} extent Extent.\r\n   * @param {number} resolution Resolution.\r\n   * @return {Array<import(\"../extent.js\").Extent>} Extents.\r\n   */\r\n  strategyFunction(extent, resolution) {\r\n    // extents may be passed in different worlds, to avoid endless loop we use only one\r\n    let realWorldExtent = extent.slice();\r\n    if (this.projection_ && this.getSource().getWrapX()) {\r\n      wrapExtentX(realWorldExtent, this.projection_);\r\n    }\r\n    if (this.loadedExtent_) {\r\n      if (\r\n        approximatelyEquals(this.loadedExtent_, realWorldExtent, resolution)\r\n      ) {\r\n        // make sure result is exactly equal to previous extent\r\n        realWorldExtent = this.loadedExtent_.slice();\r\n      } else {\r\n        // we should not keep track of loaded extents\r\n        this.getSource().removeLoadedExtent(this.loadedExtent_);\r\n      }\r\n    }\r\n    return [realWorldExtent];\r\n  }\r\n\r\n  /**\r\n   * Update geometries in the source based on current view\r\n   * @param {import(\"../extent\").Extent} extent Extent\r\n   * @param {number} resolution Resolution\r\n   * @param {import(\"../proj/Projection.js\").default} projection Projection\r\n   */\r\n  loaderFunction(extent, resolution, projection) {\r\n    this.loadedExtent_ = extent;\r\n    const source = this.getSource();\r\n\r\n    // only consider the intersection between our own extent & the requested one\r\n    const layerExtent = this.getExtent() || [\r\n      -Infinity,\r\n      -Infinity,\r\n      Infinity,\r\n      Infinity,\r\n    ];\r\n    const renderExtent = getIntersection(layerExtent, extent);\r\n\r\n    if (\r\n      this.renderedExtent_ &&\r\n      equals(this.renderedExtent_, renderExtent) &&\r\n      this.renderedResolution_ === resolution\r\n    ) {\r\n      return;\r\n    }\r\n    this.renderedExtent_ = renderExtent;\r\n    this.renderedResolution_ = resolution;\r\n\r\n    // bail out if nothing to render\r\n    if (isEmpty(renderExtent)) {\r\n      return;\r\n    }\r\n\r\n    // update projection info\r\n    const center = getCenter(renderExtent);\r\n    const squaredTolerance = (resolution * resolution) / 4;\r\n\r\n    const updateProjectionInfo =\r\n      !this.projection_ || !equivalentProjection(this.projection_, projection);\r\n\r\n    if (updateProjectionInfo) {\r\n      this.updateProjectionInfo_(projection);\r\n    }\r\n\r\n    this.createGraticule_(renderExtent, center, resolution, squaredTolerance);\r\n\r\n    // first make sure we have enough features in the pool\r\n    let featureCount = this.meridians_.length + this.parallels_.length;\r\n    if (this.meridiansLabels_) {\r\n      featureCount += this.meridians_.length;\r\n    }\r\n    if (this.parallelsLabels_) {\r\n      featureCount += this.parallels_.length;\r\n    }\r\n\r\n    let feature;\r\n    while (featureCount > this.featurePool_.length) {\r\n      feature = new Feature();\r\n      this.featurePool_.push(feature);\r\n    }\r\n\r\n    const featuresColl = source.getFeaturesCollection();\r\n    featuresColl.clear();\r\n    let poolIndex = 0;\r\n\r\n    // add features for the lines & labels\r\n    let i, l;\r\n    for (i = 0, l = this.meridians_.length; i < l; ++i) {\r\n      feature = this.featurePool_[poolIndex++];\r\n      feature.setGeometry(this.meridians_[i]);\r\n      feature.setStyle(this.lineStyle_);\r\n      featuresColl.push(feature);\r\n    }\r\n    for (i = 0, l = this.parallels_.length; i < l; ++i) {\r\n      feature = this.featurePool_[poolIndex++];\r\n      feature.setGeometry(this.parallels_[i]);\r\n      feature.setStyle(this.lineStyle_);\r\n      featuresColl.push(feature);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {number} lon Longitude.\r\n   * @param {number} minLat Minimal latitude.\r\n   * @param {number} maxLat Maximal latitude.\r\n   * @param {number} squaredTolerance Squared tolerance.\r\n   * @param {import(\"../extent.js\").Extent} extent Extent.\r\n   * @param {number} index Index.\r\n   * @return {number} Index.\r\n   * @private\r\n   */\r\n  addMeridian_(lon, minLat, maxLat, squaredTolerance, extent, index) {\r\n    const lineString = this.getMeridian_(\r\n      lon,\r\n      minLat,\r\n      maxLat,\r\n      squaredTolerance,\r\n      index\r\n    );\r\n    if (intersects(lineString.getExtent(), extent)) {\r\n      if (this.meridiansLabels_) {\r\n        const text = this.lonLabelFormatter_(lon);\r\n        if (index in this.meridiansLabels_) {\r\n          this.meridiansLabels_[index].text = text;\r\n        } else {\r\n          this.meridiansLabels_[index] = {\r\n            geom: new Point([]),\r\n            text: text,\r\n          };\r\n        }\r\n      }\r\n      this.meridians_[index++] = lineString;\r\n    }\r\n    return index;\r\n  }\r\n\r\n  /**\r\n   * @param {number} lat Latitude.\r\n   * @param {number} minLon Minimal longitude.\r\n   * @param {number} maxLon Maximal longitude.\r\n   * @param {number} squaredTolerance Squared tolerance.\r\n   * @param {import(\"../extent.js\").Extent} extent Extent.\r\n   * @param {number} index Index.\r\n   * @return {number} Index.\r\n   * @private\r\n   */\r\n  addParallel_(lat, minLon, maxLon, squaredTolerance, extent, index) {\r\n    const lineString = this.getParallel_(\r\n      lat,\r\n      minLon,\r\n      maxLon,\r\n      squaredTolerance,\r\n      index\r\n    );\r\n    if (intersects(lineString.getExtent(), extent)) {\r\n      if (this.parallelsLabels_) {\r\n        const text = this.latLabelFormatter_(lat);\r\n        if (index in this.parallelsLabels_) {\r\n          this.parallelsLabels_[index].text = text;\r\n        } else {\r\n          this.parallelsLabels_[index] = {\r\n            geom: new Point([]),\r\n            text: text,\r\n          };\r\n        }\r\n      }\r\n      this.parallels_[index++] = lineString;\r\n    }\r\n    return index;\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../render/Event.js\").default} event Render event.\r\n   * @private\r\n   */\r\n  drawLabels_(event) {\r\n    const rotation = event.frameState.viewState.rotation;\r\n    const resolution = event.frameState.viewState.resolution;\r\n    const size = event.frameState.size;\r\n    const extent = event.frameState.extent;\r\n    const rotationCenter = getCenter(extent);\r\n    let rotationExtent = extent;\r\n    if (rotation) {\r\n      const unrotatedWidth = size[0] * resolution;\r\n      const unrotatedHeight = size[1] * resolution;\r\n      rotationExtent = [\r\n        rotationCenter[0] - unrotatedWidth / 2,\r\n        rotationCenter[1] - unrotatedHeight / 2,\r\n        rotationCenter[0] + unrotatedWidth / 2,\r\n        rotationCenter[1] + unrotatedHeight / 2,\r\n      ];\r\n    }\r\n\r\n    let startWorld = 0;\r\n    let endWorld = 0;\r\n    let labelsAtStart = this.latLabelPosition_ < 0.5;\r\n    const projectionExtent = this.projection_.getExtent();\r\n    const worldWidth = getWidth(projectionExtent);\r\n    if (\r\n      this.getSource().getWrapX() &&\r\n      this.projection_.canWrapX() &&\r\n      !containsExtent(projectionExtent, extent)\r\n    ) {\r\n      startWorld = Math.floor((extent[0] - projectionExtent[0]) / worldWidth);\r\n      endWorld = Math.ceil((extent[2] - projectionExtent[2]) / worldWidth);\r\n      const inverted = Math.abs(rotation) > Math.PI / 2;\r\n      labelsAtStart = labelsAtStart !== inverted;\r\n    }\r\n    const vectorContext = getVectorContext(event);\r\n\r\n    for (let world = startWorld; world <= endWorld; ++world) {\r\n      let poolIndex = this.meridians_.length + this.parallels_.length;\r\n      let feature, index, l, textPoint;\r\n\r\n      if (this.meridiansLabels_) {\r\n        for (index = 0, l = this.meridiansLabels_.length; index < l; ++index) {\r\n          const lineString = this.meridians_[index];\r\n          if (!rotation && world === 0) {\r\n            textPoint = this.getMeridianPoint_(lineString, extent, index);\r\n          } else {\r\n            const clone = lineString.clone();\r\n            clone.translate(world * worldWidth, 0);\r\n            clone.rotate(-rotation, rotationCenter);\r\n            textPoint = this.getMeridianPoint_(clone, rotationExtent, index);\r\n            textPoint.rotate(rotation, rotationCenter);\r\n          }\r\n          feature = this.featurePool_[poolIndex++];\r\n          feature.setGeometry(textPoint);\r\n          feature.set('graticule_label', this.meridiansLabels_[index].text);\r\n          vectorContext.drawFeature(feature, this.lonLabelStyle_(feature));\r\n        }\r\n      }\r\n      if (this.parallelsLabels_) {\r\n        if (\r\n          (world === startWorld && labelsAtStart) ||\r\n          (world === endWorld && !labelsAtStart)\r\n        ) {\r\n          for (index = 0, l = this.parallels_.length; index < l; ++index) {\r\n            const lineString = this.parallels_[index];\r\n            if (!rotation && world === 0) {\r\n              textPoint = this.getParallelPoint_(lineString, extent, index);\r\n            } else {\r\n              const clone = lineString.clone();\r\n              clone.translate(world * worldWidth, 0);\r\n              clone.rotate(-rotation, rotationCenter);\r\n              textPoint = this.getParallelPoint_(clone, rotationExtent, index);\r\n              textPoint.rotate(rotation, rotationCenter);\r\n            }\r\n            feature = this.featurePool_[poolIndex++];\r\n            feature.setGeometry(textPoint);\r\n            feature.set('graticule_label', this.parallelsLabels_[index].text);\r\n            vectorContext.drawFeature(feature, this.latLabelStyle_(feature));\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../extent.js\").Extent} extent Extent.\r\n   * @param {import(\"../coordinate.js\").Coordinate} center Center.\r\n   * @param {number} resolution Resolution.\r\n   * @param {number} squaredTolerance Squared tolerance.\r\n   * @private\r\n   */\r\n  createGraticule_(extent, center, resolution, squaredTolerance) {\r\n    const interval = this.getInterval_(resolution);\r\n    if (interval == -1) {\r\n      this.meridians_.length = 0;\r\n      this.parallels_.length = 0;\r\n      if (this.meridiansLabels_) {\r\n        this.meridiansLabels_.length = 0;\r\n      }\r\n      if (this.parallelsLabels_) {\r\n        this.parallelsLabels_.length = 0;\r\n      }\r\n      return;\r\n    }\r\n\r\n    let wrapX = false;\r\n    const projectionExtent = this.projection_.getExtent();\r\n    const worldWidth = getWidth(projectionExtent);\r\n    if (\r\n      this.getSource().getWrapX() &&\r\n      this.projection_.canWrapX() &&\r\n      !containsExtent(projectionExtent, extent)\r\n    ) {\r\n      if (getWidth(extent) >= worldWidth) {\r\n        extent[0] = projectionExtent[0];\r\n        extent[2] = projectionExtent[2];\r\n      } else {\r\n        wrapX = true;\r\n      }\r\n    }\r\n\r\n    // Constrain the center to fit into the extent available to the graticule\r\n\r\n    const validCenterP = [\r\n      clamp(center[0], this.minX_, this.maxX_),\r\n      clamp(center[1], this.minY_, this.maxY_),\r\n    ];\r\n\r\n    // Transform the center to lon lat\r\n    // Some projections may have a void area at the poles\r\n    // so replace any NaN latitudes with the min or max value closest to a pole\r\n\r\n    const centerLonLat = this.toLonLatTransform_(validCenterP);\r\n    if (isNaN(centerLonLat[1])) {\r\n      centerLonLat[1] =\r\n        Math.abs(this.maxLat_) >= Math.abs(this.minLat_)\r\n          ? this.maxLat_\r\n          : this.minLat_;\r\n    }\r\n    let centerLon = clamp(centerLonLat[0], this.minLon_, this.maxLon_);\r\n    let centerLat = clamp(centerLonLat[1], this.minLat_, this.maxLat_);\r\n    const maxLines = this.maxLines_;\r\n    let cnt, idx, lat, lon;\r\n\r\n    // Limit the extent to fit into the extent available to the graticule\r\n\r\n    let validExtentP = extent;\r\n    if (!wrapX) {\r\n      validExtentP = [\r\n        clamp(extent[0], this.minX_, this.maxX_),\r\n        clamp(extent[1], this.minY_, this.maxY_),\r\n        clamp(extent[2], this.minX_, this.maxX_),\r\n        clamp(extent[3], this.minY_, this.maxY_),\r\n      ];\r\n    }\r\n\r\n    // Transform the extent to get the lon lat ranges for the edges of the extent\r\n\r\n    const validExtent = applyTransform(\r\n      validExtentP,\r\n      this.toLonLatTransform_,\r\n      undefined,\r\n      8\r\n    );\r\n\r\n    let maxLat = validExtent[3];\r\n    let maxLon = validExtent[2];\r\n    let minLat = validExtent[1];\r\n    let minLon = validExtent[0];\r\n\r\n    if (!wrapX) {\r\n      // Check if extremities of the world extent lie inside the extent\r\n      // (for example the pole in a polar projection)\r\n      // and extend the extent as appropriate\r\n\r\n      if (containsCoordinate(validExtentP, this.bottomLeft_)) {\r\n        minLon = this.minLon_;\r\n        minLat = this.minLat_;\r\n      }\r\n      if (containsCoordinate(validExtentP, this.bottomRight_)) {\r\n        maxLon = this.maxLon_;\r\n        minLat = this.minLat_;\r\n      }\r\n      if (containsCoordinate(validExtentP, this.topLeft_)) {\r\n        minLon = this.minLon_;\r\n        maxLat = this.maxLat_;\r\n      }\r\n      if (containsCoordinate(validExtentP, this.topRight_)) {\r\n        maxLon = this.maxLon_;\r\n        maxLat = this.maxLat_;\r\n      }\r\n\r\n      // The transformed center may also extend the lon lat ranges used for rendering\r\n\r\n      maxLat = clamp(maxLat, centerLat, this.maxLat_);\r\n      maxLon = clamp(maxLon, centerLon, this.maxLon_);\r\n      minLat = clamp(minLat, this.minLat_, centerLat);\r\n      minLon = clamp(minLon, this.minLon_, centerLon);\r\n    }\r\n\r\n    // Create meridians\r\n\r\n    centerLon = Math.floor(centerLon / interval) * interval;\r\n    lon = clamp(centerLon, this.minLon_, this.maxLon_);\r\n\r\n    idx = this.addMeridian_(lon, minLat, maxLat, squaredTolerance, extent, 0);\r\n\r\n    cnt = 0;\r\n    if (wrapX) {\r\n      while ((lon -= interval) >= minLon && cnt++ < maxLines) {\r\n        idx = this.addMeridian_(\r\n          lon,\r\n          minLat,\r\n          maxLat,\r\n          squaredTolerance,\r\n          extent,\r\n          idx\r\n        );\r\n      }\r\n    } else {\r\n      while (lon != this.minLon_ && cnt++ < maxLines) {\r\n        lon = Math.max(lon - interval, this.minLon_);\r\n        idx = this.addMeridian_(\r\n          lon,\r\n          minLat,\r\n          maxLat,\r\n          squaredTolerance,\r\n          extent,\r\n          idx\r\n        );\r\n      }\r\n    }\r\n\r\n    lon = clamp(centerLon, this.minLon_, this.maxLon_);\r\n\r\n    cnt = 0;\r\n    if (wrapX) {\r\n      while ((lon += interval) <= maxLon && cnt++ < maxLines) {\r\n        idx = this.addMeridian_(\r\n          lon,\r\n          minLat,\r\n          maxLat,\r\n          squaredTolerance,\r\n          extent,\r\n          idx\r\n        );\r\n      }\r\n    } else {\r\n      while (lon != this.maxLon_ && cnt++ < maxLines) {\r\n        lon = Math.min(lon + interval, this.maxLon_);\r\n        idx = this.addMeridian_(\r\n          lon,\r\n          minLat,\r\n          maxLat,\r\n          squaredTolerance,\r\n          extent,\r\n          idx\r\n        );\r\n      }\r\n    }\r\n\r\n    this.meridians_.length = idx;\r\n    if (this.meridiansLabels_) {\r\n      this.meridiansLabels_.length = idx;\r\n    }\r\n\r\n    // Create parallels\r\n\r\n    centerLat = Math.floor(centerLat / interval) * interval;\r\n    lat = clamp(centerLat, this.minLat_, this.maxLat_);\r\n\r\n    idx = this.addParallel_(lat, minLon, maxLon, squaredTolerance, extent, 0);\r\n\r\n    cnt = 0;\r\n    while (lat != this.minLat_ && cnt++ < maxLines) {\r\n      lat = Math.max(lat - interval, this.minLat_);\r\n      idx = this.addParallel_(\r\n        lat,\r\n        minLon,\r\n        maxLon,\r\n        squaredTolerance,\r\n        extent,\r\n        idx\r\n      );\r\n    }\r\n\r\n    lat = clamp(centerLat, this.minLat_, this.maxLat_);\r\n\r\n    cnt = 0;\r\n    while (lat != this.maxLat_ && cnt++ < maxLines) {\r\n      lat = Math.min(lat + interval, this.maxLat_);\r\n      idx = this.addParallel_(\r\n        lat,\r\n        minLon,\r\n        maxLon,\r\n        squaredTolerance,\r\n        extent,\r\n        idx\r\n      );\r\n    }\r\n\r\n    this.parallels_.length = idx;\r\n    if (this.parallelsLabels_) {\r\n      this.parallelsLabels_.length = idx;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {number} resolution Resolution.\r\n   * @return {number} The interval in degrees.\r\n   * @private\r\n   */\r\n  getInterval_(resolution) {\r\n    const centerLon = this.projectionCenterLonLat_[0];\r\n    const centerLat = this.projectionCenterLonLat_[1];\r\n    let interval = -1;\r\n    const target = Math.pow(this.targetSize_ * resolution, 2);\r\n    /** @type {Array<number>} **/\r\n    const p1 = [];\r\n    /** @type {Array<number>} **/\r\n    const p2 = [];\r\n    for (let i = 0, ii = this.intervals_.length; i < ii; ++i) {\r\n      const delta = clamp(this.intervals_[i] / 2, 0, 90);\r\n      // Don't attempt to transform latitudes beyond the poles!\r\n      const clampedLat = clamp(centerLat, -90 + delta, 90 - delta);\r\n      p1[0] = centerLon - delta;\r\n      p1[1] = clampedLat - delta;\r\n      p2[0] = centerLon + delta;\r\n      p2[1] = clampedLat + delta;\r\n      this.fromLonLatTransform_(p1, p1);\r\n      this.fromLonLatTransform_(p2, p2);\r\n      const dist = Math.pow(p2[0] - p1[0], 2) + Math.pow(p2[1] - p1[1], 2);\r\n      if (dist <= target) {\r\n        break;\r\n      }\r\n      interval = this.intervals_[i];\r\n    }\r\n    return interval;\r\n  }\r\n\r\n  /**\r\n   * @param {number} lon Longitude.\r\n   * @param {number} minLat Minimal latitude.\r\n   * @param {number} maxLat Maximal latitude.\r\n   * @param {number} squaredTolerance Squared tolerance.\r\n   * @return {LineString} The meridian line string.\r\n   * @param {number} index Index.\r\n   * @private\r\n   */\r\n  getMeridian_(lon, minLat, maxLat, squaredTolerance, index) {\r\n    const flatCoordinates = meridian(\r\n      lon,\r\n      minLat,\r\n      maxLat,\r\n      this.projection_,\r\n      squaredTolerance\r\n    );\r\n    let lineString = this.meridians_[index];\r\n    if (!lineString) {\r\n      lineString = new LineString(flatCoordinates, 'XY');\r\n      this.meridians_[index] = lineString;\r\n    } else {\r\n      lineString.setFlatCoordinates('XY', flatCoordinates);\r\n      lineString.changed();\r\n    }\r\n    return lineString;\r\n  }\r\n\r\n  /**\r\n   * @param {LineString} lineString Meridian\r\n   * @param {import(\"../extent.js\").Extent} extent Extent.\r\n   * @param {number} index Index.\r\n   * @return {Point} Meridian point.\r\n   * @private\r\n   */\r\n  getMeridianPoint_(lineString, extent, index) {\r\n    const flatCoordinates = lineString.getFlatCoordinates();\r\n    let bottom = 1;\r\n    let top = flatCoordinates.length - 1;\r\n    if (flatCoordinates[bottom] > flatCoordinates[top]) {\r\n      bottom = top;\r\n      top = 1;\r\n    }\r\n    const clampedBottom = Math.max(extent[1], flatCoordinates[bottom]);\r\n    const clampedTop = Math.min(extent[3], flatCoordinates[top]);\r\n    const lat = clamp(\r\n      extent[1] + Math.abs(extent[1] - extent[3]) * this.lonLabelPosition_,\r\n      clampedBottom,\r\n      clampedTop\r\n    );\r\n    const coordinate0 =\r\n      flatCoordinates[bottom - 1] +\r\n      ((flatCoordinates[top - 1] - flatCoordinates[bottom - 1]) *\r\n        (lat - flatCoordinates[bottom])) /\r\n        (flatCoordinates[top] - flatCoordinates[bottom]);\r\n    const coordinate = [coordinate0, lat];\r\n    const point = this.meridiansLabels_[index].geom;\r\n    point.setCoordinates(coordinate);\r\n    return point;\r\n  }\r\n\r\n  /**\r\n   * Get the list of meridians.  Meridians are lines of equal longitude.\r\n   * @return {Array<LineString>} The meridians.\r\n   * @api\r\n   */\r\n  getMeridians() {\r\n    return this.meridians_;\r\n  }\r\n\r\n  /**\r\n   * @param {number} lat Latitude.\r\n   * @param {number} minLon Minimal longitude.\r\n   * @param {number} maxLon Maximal longitude.\r\n   * @param {number} squaredTolerance Squared tolerance.\r\n   * @return {LineString} The parallel line string.\r\n   * @param {number} index Index.\r\n   * @private\r\n   */\r\n  getParallel_(lat, minLon, maxLon, squaredTolerance, index) {\r\n    const flatCoordinates = parallel(\r\n      lat,\r\n      minLon,\r\n      maxLon,\r\n      this.projection_,\r\n      squaredTolerance\r\n    );\r\n    let lineString = this.parallels_[index];\r\n    if (!lineString) {\r\n      lineString = new LineString(flatCoordinates, 'XY');\r\n    } else {\r\n      lineString.setFlatCoordinates('XY', flatCoordinates);\r\n      lineString.changed();\r\n    }\r\n    return lineString;\r\n  }\r\n\r\n  /**\r\n   * @param {LineString} lineString Parallels.\r\n   * @param {import(\"../extent.js\").Extent} extent Extent.\r\n   * @param {number} index Index.\r\n   * @return {Point} Parallel point.\r\n   * @private\r\n   */\r\n  getParallelPoint_(lineString, extent, index) {\r\n    const flatCoordinates = lineString.getFlatCoordinates();\r\n    let left = 0;\r\n    let right = flatCoordinates.length - 2;\r\n    if (flatCoordinates[left] > flatCoordinates[right]) {\r\n      left = right;\r\n      right = 0;\r\n    }\r\n    const clampedLeft = Math.max(extent[0], flatCoordinates[left]);\r\n    const clampedRight = Math.min(extent[2], flatCoordinates[right]);\r\n    const lon = clamp(\r\n      extent[0] + Math.abs(extent[0] - extent[2]) * this.latLabelPosition_,\r\n      clampedLeft,\r\n      clampedRight\r\n    );\r\n    const coordinate1 =\r\n      flatCoordinates[left + 1] +\r\n      ((flatCoordinates[right + 1] - flatCoordinates[left + 1]) *\r\n        (lon - flatCoordinates[left])) /\r\n        (flatCoordinates[right] - flatCoordinates[left]);\r\n    const coordinate = [lon, coordinate1];\r\n    const point = this.parallelsLabels_[index].geom;\r\n    point.setCoordinates(coordinate);\r\n    return point;\r\n  }\r\n\r\n  /**\r\n   * Get the list of parallels.  Parallels are lines of equal latitude.\r\n   * @return {Array<LineString>} The parallels.\r\n   * @api\r\n   */\r\n  getParallels() {\r\n    return this.parallels_;\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\r\n   * @private\r\n   */\r\n  updateProjectionInfo_(projection) {\r\n    const epsg4326Projection = getProjection('EPSG:4326');\r\n\r\n    const worldExtent = projection.getWorldExtent();\r\n\r\n    this.maxLat_ = worldExtent[3];\r\n    this.maxLon_ = worldExtent[2];\r\n    this.minLat_ = worldExtent[1];\r\n    this.minLon_ = worldExtent[0];\r\n\r\n    // If the world extent crosses the dateline define a custom transform to\r\n    // return longitudes which wrap the dateline\r\n\r\n    const toLonLatTransform = getTransform(projection, epsg4326Projection);\r\n    if (this.minLon_ < this.maxLon_) {\r\n      this.toLonLatTransform_ = toLonLatTransform;\r\n    } else {\r\n      const split = this.minLon_ + this.maxLon_ / 2;\r\n      this.maxLon_ += 360;\r\n      this.toLonLatTransform_ = function (coordinates, output, dimension) {\r\n        dimension = dimension || 2;\r\n        const lonLatCoordinates = toLonLatTransform(\r\n          coordinates,\r\n          output,\r\n          dimension\r\n        );\r\n        for (let i = 0, l = lonLatCoordinates.length; i < l; i += dimension) {\r\n          if (lonLatCoordinates[i] < split) {\r\n            lonLatCoordinates[i] += 360;\r\n          }\r\n        }\r\n        return lonLatCoordinates;\r\n      };\r\n    }\r\n\r\n    // Transform the extent to get the limits of the view projection extent\r\n    // which should be available to the graticule\r\n\r\n    this.fromLonLatTransform_ = getTransform(epsg4326Projection, projection);\r\n    const worldExtentP = applyTransform(\r\n      [this.minLon_, this.minLat_, this.maxLon_, this.maxLat_],\r\n      this.fromLonLatTransform_,\r\n      undefined,\r\n      8\r\n    );\r\n\r\n    this.minX_ = worldExtentP[0];\r\n    this.maxX_ = worldExtentP[2];\r\n    this.minY_ = worldExtentP[1];\r\n    this.maxY_ = worldExtentP[3];\r\n\r\n    // Determine the view projection coordinates of the extremities of the world extent\r\n    // as these may lie inside a view extent (for example the pole in a polar projection)\r\n\r\n    this.bottomLeft_ = this.fromLonLatTransform_([this.minLon_, this.minLat_]);\r\n    this.bottomRight_ = this.fromLonLatTransform_([this.maxLon_, this.minLat_]);\r\n    this.topLeft_ = this.fromLonLatTransform_([this.minLon_, this.maxLat_]);\r\n    this.topRight_ = this.fromLonLatTransform_([this.maxLon_, this.maxLat_]);\r\n\r\n    // Transform the projection center to lon lat\r\n    // Some projections may have a void area at the poles\r\n    // so replace any NaN latitudes with the min or max value closest to a pole\r\n\r\n    this.projectionCenterLonLat_ = this.toLonLatTransform_(\r\n      getCenter(projection.getExtent())\r\n    );\r\n    if (isNaN(this.projectionCenterLonLat_[1])) {\r\n      this.projectionCenterLonLat_[1] =\r\n        Math.abs(this.maxLat_) >= Math.abs(this.minLat_)\r\n          ? this.maxLat_\r\n          : this.minLat_;\r\n    }\r\n\r\n    this.projection_ = projection;\r\n  }\r\n}\r\n\r\nexport default Graticule;\r\n"],
  "mappings": "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",
  "names": ["Vector_default", "wrapX"]
}
